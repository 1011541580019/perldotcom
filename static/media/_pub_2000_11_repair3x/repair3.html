<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.13-en" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>
<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="/pub/2000/11/repair3.html">
<dc:title>Program Repair Shop and Red Flags</dc:title>
<dc:description> What&apos;s wrong with this picture? The Interface The Code open_info_file start_info_file start_next_part read_next_node Looking for the menu Putting It All Together Red Flags Don&apos;t Repeat Code eof() return 0 and return undef Brief Confession What&apos;s wrong with this picture?...</dc:description>
<dc:creator>Mark-Jason Dominus</dc:creator>
<dc:date>2000-11-14T00:00:00-08:00</dc:date>
<license rdf:resource="http://creativecommons.org/licenses/by-nc-nd/3.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-nc-nd/3.0/">
</License>
</rdf:RDF>
-->

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
<script type='text/javascript' src='http://partner.googleadservices.com/gampad/google_service.js'></script>
<script type='text/javascript'>
GS_googleAddAdSenseService("ca-pub-4136420132070439");
GS_googleEnableAllServices();
</script>
<script type='text/javascript'>
GA_googleAddSlot("ca-pub-4136420132070439", "Perl_728x90");
</script>
<script type='text/javascript'>GA_googleFetchAds();</script>
    
    <link rel="prev bookmark" href="/pub/2000/11/p5pdigest/THISWEEK-20001107.html" title="This Week on p5p 2000/11/07" />
    <link rel="next bookmark" href="/pub/2000/11/p5pdigest/THISWEEK-20001114.html" title="This Week on p5p 2000/11/14" />
    
    
    <title>Program Repair Shop and Red Flags - Perl.com</title>
</head>
<body id="perl-com" class="mt-entry-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <span id="top_advert"> 
<!-- Put any landscape advert in here -->
<!-- Perl_728x90 -->
<script type='text/javascript'>
GA_googleFillSlot("Perl_728x90");
</script>
        </span> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description">news and views of the Perl programming language</div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <div id="entry-1750" class="entry-asset asset hentry">
                                <div class="asset-header">
                                    <h1 id="page-title" class="asset-name entry-title">Program Repair Shop and Red Flags</h1>
                                    <div class="asset-meta">
                                        <span class="byline">

                                            By <span class="vcard author">Mark-Jason Dominus</span> on <abbr class="published" title="2000-11-14T00:00:00-08:00">November 14, 2000 12:00 AM</abbr>

                                        </span>


                                    </div>
                                </div>
                                <div class="asset-content entry-content">

                                    <div class="asset-body">
                                        
<!-- Program Repair Shop and Red Flags: Parsing Info Files -->

<br />
<br /><a name="__index__"></a>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#what's wrong with this picture">What's wrong with this picture?</a></li>
	<li><a href="#the interface">The Interface</a></li>
	<li><a href="#the code">The Code</a></li>
	<ul>

		<li><a href="#open_info_file"><code>open_info_file</code></a></li>
		<li><a href="#start_info_file"><code>start_info_file</code></a></li>
		<li><a href="#start_next_part"><code>start_next_part</code></a></li>
		<li><a href="#read_next_node"><code>read_next_node</code></a></li>
		<li><a href="#looking for the menu">Looking for the menu</a></li>
	</ul>

	<li><a href="#putting it all together">Putting It All Together</a></li>
	<li><a href="#red flags">Red Flags</a></li>
	<ul>

		<li><a href="#don't repeat code">Don't Repeat Code</a></li>
		<li><a href="#eof()"><code>eof()</code></a></li>
		<li><a href="#return 0 and return undef"><code>return 0</code> and <code>return undef</code></a></li>
	</ul>

	<li><a href="#brief confession">Brief Confession</a></li>
</ul>
<!-- INDEX END -->

<hr>
<p>
<h3><a name="what's wrong with this picture">What's wrong with this picture?</a></h3>
<p>Once again I'm going to have a look at a program written by a Perl
beginner and see what I can do to improve it.</p>
<p>This month's program comes from a very old Usenet post.  It was posted
seven years ago - on Nov. 12, 1993, to be exact - on the
<code>comp.lang.perl</code> newsgroup.  (At that time <code>comp.lang.perl.misc</code> had
not yet been created.)</p>
<p>The program is a library of code for reading GNU ``info'' files.
Info files are a form of structured documentation used by the GNU
project.  If you use the emacs editor, you can browse info files by
using the <code>C-h i</code> command, for example.  An info file is made up of
many <em>nodes</em>, each containing information about a certain
topic.  The nodes are arranged in a tree structure.  Each node has a
header with some meta-information; one item recorded in the header of
each node is the name of that node's parent in the documentation tree.
Most nodes also have a menu of their child nodes.  Each node also has
pointers to the following and preceding nodes so that you can read
through all the nodes in order.</p>
<p>
<hr>
<h3><a name="the interface">The Interface</a></h3>
<p>The code we'll see has functions for opening info files and for reading
in nodes and parsing the information in their headers and menus.  
But before I start discussing the code, I'll show the documentation.
Here it is, copied directly from that 7-year-old Usenet posting,
typos and all:</p>
<pre>
    To use the functions:  Call



            &amp;open_info_file(INFO_FILENAME);


    to open the filehandle `INFO' to the named info file.
    Then call


            &amp;get_next_node;


    repeatedly to read the next node in the info file; variables
            $info_file
            $info_node
            $info_prev
            $info_next
            $info_up


    are set if the corresponding fields appear in the node's
    header, and if the node has a menu, it is loaded into
    %info_menu.  When `get_next-node' returns false, you have
    reached end-of-file or there has been an error.</pre>
<p>Right away, we can see a major problem.  The code is supposed to be a
library of utility functions.  But the only communication between the
library and the main program is through a series of global variables
with names like <code>$info_up</code>.  This, of course, is terrible
style.  The functions cannot be used in any program that happens to
have a variable named <code>$info_up</code>, and if you do use it in such a
program, you can introduce bizarre, hard-to-find bugs that result from
the way the library smashes whatever value that variable had before.
The library might even interfere with itself!  If you had something
like this:</p>
<pre>
        &amp;get_next_node;
        foo();
        print $info_node;</pre>
<p>then you might not get the results you expect.  If <code>foo()</code> happens to
<em>also</em> call <code>get_next_node</code>, it will discard the value of
<code>$info_node</code> that the main code was planning to print.</p>
<p>These are the types of problems that functions and local
variables were intended to solve.   In this case, it's easy to solve
the problems:  Just have <code>get_next_node</code> return a list of the node
information, instead of setting a bunch of hardwired global variables.
If the caller of the function wants to set the variables itself, it is
still free to do that:</p>
<pre>
        %next_node = &amp;get_next_node;
        ($info_file, $info_node, $info_prev, $info_next, $info_up)
            = @next_node{qw(File Node Prev Next Up)};
        %info_menu = %{$next_node{Menu}}
</pre>
<p>Or not:</p>
<pre>
        my (%node) = &amp;get_next_node;
        my ($next) = $node{Next};
</pre>
<p>If for some reason the caller of <code>get_next_node</code> <em>likes</em> the global
variables, they can still have the original interface:</p>
<pre>
        sub get_next_node_orig {
          my %next_node = &amp;get_next_node;
          ($info_file, $info_node, $info_prev, $info_next, $info_up)
              = @next_node{qw(File Node Prev Next Up)};
          %info_menu = %{$next_node{Menu}}
        }</pre>
<p>This shows that no functionality has been lost; it is just as powerful
to return a list of values as it is to set the global variables
directly.</p>
<p>
<hr>
<h3><a name="the code">The Code</a></h3>
<p>Now we'll see the code itself.  
<a href="/2000/11/info.pl">The entire program is available here</a>.
We will be looking at one part at a time.</p>
<p>
<h4><a name="open_info_file"><code>open_info_file</code></a></h4>
<p>The first function that the
user calls is the <code>open_info_file</code> function:</p>
<pre>
    83  sub open_info_file {
    84      ($info_filename) = @_;
    85      (open(INFO, &quot;$info_filename&quot;)) 
	      || die &quot;Couldn't open $info_filename: $!&quot;;
    86      return &amp;start_info_file;
    87  }</pre>
<p>Before I discuss the design problems here, there's a minor syntactic
issue: The quotation marks around <code>&quot;$info_filename&quot;</code> are useless.
Perl uses the <code>&quot;...&quot;</code> notation to say ``Construct a string.''  But
<code>$info_filename</code> is <em>already</em> a string, so making it into a string
is at best a waste of time.  Moreover, the extra quotation marks can
sometimes cause subtle bugs.  Consider this innocuous-looking code:</p>
<pre>
        my ($x) = @_;
        do_something(&quot;$x&quot;);</pre>
<p>If <code>$x</code> was a string, this still works.  But if <code>$x</code> was a
<em>reference</em>, it probably fails.  Why?  Because <code>&quot;$x&quot;</code> constructs a
string that looks like a reference but isn't, and if <code>do_something</code>
is expecting a reference, it will be disappointed.  Such errors can be
hard to debug, because the string that <code>do_something</code> gets looks 
like a reference when you print it out.  The <code>use strict 'refs'</code>
pragma was designed to catch exactly this error.  With <code>use strict
'refs'</code> in scope, <code>do_something</code> will probably raise an error like</p>
<pre>
    Can't use string (&quot;SCALAR(0x8149bbc)&quot;) as an ARRAY ref...
</pre>
<p>Without <code>use strict 'refs'</code>, you get a subtle and silent bug.</p>
<p>But back to the code.  <code>open_info_file</code> calls <code>die</code> if it can't open
the specified file for any reason.  It would probably be more
convenient and consistent to have it simply return a failure code in
this case; this is what it does if the <code>open</code> succeeds, but then
<code>start_next_part</code> fails.  It's usually easier for the calling code to
deal with a simple error return than with an exception, all the more
so in 1993, when Perl didn't have exception handling.  I would rewrite
the function like this:</p>
<pre>
        sub open_info_file {
            ($info_filename) = @_;
            open(INFO, $info_filename) || return;
            return start_info_file();
        }</pre>
<p>I also got rid of some superfluous parentheses and changed the 1993
<code>&amp;function</code> syntax to a more modern <code>function()</code> syntax.
It's tempting to try to make <code>$info_filename</code> into a private
variable, but it turns out that other functions need to see it later,
so the best we can do is make it a file-scoped lexical, private to the
library, but shared among all the functions in the library.</p>
<p>Finally, a design issue:  The filehandle name <code>INFO</code> is hard-wired
into the function.  Since filehandle names are global variables, this
is best avoided for the same reason that we wanted to get rid of the
<code>$info_node</code> variable earlier:  If some other part of the program
happens to have a filehandle named <code>INFO</code>, it's going to be very
surprised to find it suddenly attached to a new file.</p>
<p>There are a number of ways to solve this.  The best one available in
Perl 4 is to have the caller pass in the filehandle it wants to use,
as an argument to <code>open_info_file</code>.  Then the call is effectively
using the filehandle as an object.  In this case, however, this
doesn't work as well as we'd like, because, as we'll see later, the
library needs to be able to associate the name of the file with the
filehandle.  In the original library, this was easy, because the
filename was always stored in the global variable <code>$info_filename</code>
and the filehandle was always <code>INFO</code>.  The downside of this simple
solution is the library couldn't have two info files open at
once.  There are solutions to this in Perl 4, but they're only of
interest to Perl 4 programmers, so I won't go into detail.</p>
<p>The solution in Perl 5 is to use an <em>object</em> to represent an open
info file.  Whenever the caller wants to operate on the file, it
passes the object into the library as an argument.  The object can
carry around the open filehandle and the filename.  Since the data
inside the object is private, it doesn't interfere with any other data
in the program.  The caller can have several files open at once, and
distinguish between them because each file is represented by its own
object.</p>
<p>To make this library into an object-oriented class only requires a few
small changes.  We add</p>
<pre>
        package Info_File;</pre>
<p>at the top, and rewrite <code>open_info_file</code> like this:</p>
<pre>
    sub open_info_file {
        my ($class, $info_filename) = @_;
        my $fh = new FileHandle;        
        open($fh, $info_filename) || return;
        my $object = { FH =&gt; $fh, NAME =&gt; $info_filename };
        bless $object =&gt; $class;
        return unless $object-&gt;start_info_file;            
        return $object;
    }
</pre>
<p>We now invoke the function like this:</p>
<pre>
     $object = Info_File-&gt;new('camel.info');</pre>
<p>The <code>new FileHandle</code> line constructs a fresh new filehandle.  The
next line opens the filehandle, as usual.  The line</p>
<pre>
     my $object = { FH =&gt; $fh, NAME =&gt; $info_filename };</pre>
<p>constructs the object, which is simply a hash.  The object contains
all the information that the library will need to use in order to deal
with the info file - in this case, the open filehandle and the
original filename.  The <code>bless</code> function converts the hash into a
full-fledged object of the <code>Info_File</code> class.  Finally, the</p>
<pre>
        $object-&gt;start_info_file;</pre>
<p>invokes the <code>start_info_file</code> function with <code>$object</code> as its
argument, just like calling <code>start_info_file($object)</code>.  The special
``arrow'' syntax for objects is enabled by the <code>bless</code> on the previous
line.  This notation indicates a <em>method call</em> on the object;
<code>start_info_file</code> is the <em>method</em>.  A method is just an ordinary
subroutine.  A method call on an object is like any other subroutine
call, except that the object itself is passed as an argument to the
subroutine.</p>
<p>That was a lot of space to spend on one three-line function, but many
of the same issues are going to pop up over and over, and it's good to
see them in a simple context.</p>
<p>
<h3><a name="start_info_file"><code>start_info_file</code></a></h3>
<pre>

    47  # Discard commentary before first node of info file
    48  sub start_info_file {
    49      $_ = &lt;INFO&gt; until (/^\037/ || eof(INFO));
    50      return &amp;start_next_part if (eof(INFO)) ;
    51      return 1;
    52  }</pre>
<p>An info file typically has a preamble before the first node, usually
containing a copyright notice and a license.  When the user opens an
info file, the library needs to skip this preamble to get to the
nodes, which are the parts of interest.  That is what
<code>start_info_file</code> does.  The preamble is separated from the first
node by a line that begins with the obscure <code>\037</code> character, which
is control-underscore.  The function will read through the file line
by line, looking for the first line that begins with the obscure
character.  If it finds such a line, it immediately returns success.  
Otherwise, it moves on to the next ``part,'' which I'll explain later.</p>
<p>As I explained in earlier articles, a ``red flag'' is an immediate
warning sign that you have done something wrong.  Use of the <code>eof()</code>
function is one of the clearest and brightest red flags in Perl.  It
is almost always a mistake to use <code>eof()</code>.</p>
<p>The problem with <code>eof()</code> is that it tries to see into the future,
whether the <em>next</em> read from the filehandle will return an
end-of-file condition.  It's impossible to actually see the future, so
what it really does is try to read some data.  If there isn't any, it
reports that the next read will also report end-of-file.  If not, it
has to put back the data that it just read.  This can cause weird
problems, because <code>eof()</code> is reading extra data that you might not
have meant to read.</p>
<p><code>eof()</code> is one of those functions like <code>goto</code> that looks useful at
first, but then it turns out that there is almost always a better way
to accomplish the same thing.  In this case, the code is more
straightforward and idiomatic like this:</p>
<pre>
    sub start_info_file {
        while (&lt;INFO&gt;) {
          return 1  if /^\037/;
        }
        &amp;start_next_part;
    }</pre>
<p>Perl will automatically exit the <code>while</code> loop when it reaches the end
of the file, and in that case we can unconditionally call
<code>start_next_part</code>.  Inside the loop, we examine the current line to
see whether it is the separator, and return success if it is.  The
assignment to <code>$_</code> and the check for end-of-file are now all
implicit.</p>
<p>In the object-oriented style, <code>start_info_file</code> expects to get an
object, originally constructed by <code>open_info_file</code>, as its argument.
This object will contain the filehandle that the function will read
from in place of <code>INFO</code>.  The rewriting into OO style is
straightforward:</p>
<pre>
    sub start_info_file {
        my ($object) = @_;
        my $fh = $object-&gt;{FH};
        while (&lt;$fh&gt;) {
          return 1 if /^\037/;
        }
        $object-&gt;start_next_part;
    }</pre>
<p>Here we extract the filehandle from the object by asking for
<code>$object-&gt;{$fh}</code>, and then use the filehandle <code>$fh</code> in place of
<code>INFO</code>.  The call to <code>start_next_part</code> changes into a method call on
the object, which means that the object is implicitly passed to the
<code>start_next_part</code> function so that <code>start_next_part</code> <em>also</em> has
access to the object, including the filehandle buried inside it.</p>
<p>
<h3><a name="start_next_part"><code>start_next_part</code></a></h3>
<p>I promised to explain what <code>start_next_part</code> does, and now we're
there.  An info file is not a single file; it might be split into
several separate files, each containing some of the nodes.  If the
main info file is named <code>camel.info</code>, there might be additional
nodes in the files <code>camel.info-1</code>, <code>camel.info-2</code> and so on.  This
means that when we get to the end of an info file we are not finished;
we have to check to see whether it continues in a different file.
<code>start_next_part</code> does this.</p>
<pre>
    54  # Look for next part of multi-part info file.  Return 0
    55  # (normal failure) if it isn't there---that just means
    56  # we ran out of parts.  die on some other kind of failure.
    57  sub start_next_part {
    58      local($path, $basename, $ext);
    59      if ($info_filename =~ /\//) {
    60          ($path, $basename) 
		    = ( $info_filename =~ /^(.*)\/(.*)$/ );
    61      } else {
    62          $basename = $info_filename;
    63          $path = &quot;&quot;;
    64      }
    65      if ($basename =~ /-\d*$/) {
    66          ($basename, $ext) 
		    = ($basename =~ /^([^-]*)-(\d*)$/);
    67      } else {
    68          $ext = 0;
    69      }
    70      $ext++;
    71      $info_filename = &quot;$path/$basename-$ext&quot;;
    72      close(INFO);
    73      if (! (open(INFO, &quot;$info_filename&quot;)) ) {
    74          if ($! eq &quot;No such file or directory&quot;) {
    75              return 0;
    76          } else {
    77              die &quot;Couldn't open $info_filename: $!&quot;;
    78          }
    79      }
    80      return &amp;start_info_file;
    81  }</pre>
<p>The main point of this code is to take a filename like
<code>/usr/info/camel.info-3</code> and change it into
<code>/usr/info/camel.info-4</code>.  It has to handle a special case:
<code>/usr/info/camel.info</code> must become <code>/usr/info/camel.info-1</code>.  After
computing the new filename, it tries to open the next part of the info
file.  If successful, it calls <code>start_info_file</code> to skip the preamble
in the new part.</p>
<p>The first thing to notice here is that the function is performing more work than it needs to.  It carefully separates the filename into
a directory name and a base name, typically <code>/usr/info</code> and
<code>camel.info-3</code>.  But this step is unnecessary, so let's
eliminate it.</p>
<pre>
    sub start_next_part {
        local($name, $ext);
        if ($info_filename =~ /-\d*$/) {
            ($name, $ext) 
                = ($info_filename =~ /^([^-]*)-(\d*)$/);
        } else {
            $ext = 0;
        }
        $ext++;
        $info_filename = &quot;$name-$ext&quot;;
        # ... no more changes ...
    }</pre>
<p>This immediately reduces the size of the function by 25 percent.
Now we notice that the two pattern matches that remain are almost the
same.  This is the red flag of all red flags:  Any time a program
does something twice, look to see whether you can get away with doing it
only once.  Sometimes you can't.  This time, we can:
</p>
<pre>
    sub start_next_part {
        local($name, $ext);
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            ($name, $ext) = ($1, $2);
        } else {
            $name = $info_filename; $ext = 0;
        }
        $ext++;
        $info_filename = &quot;$name-$ext&quot;;
        # ... no more changes ...
    }</pre>
<p>This is somewhat simpler, and it paves the way for a big improvement:
The <code>$name</code> variable is superfluous, because its only purpose is to
hold an intermediate result.  The real variable of interest is
<code>$info_filename</code>.  <code>$name</code> is what I call a <em>synthetic variable</em>:
It's an artifact of the way we solve the problem, and is inessential
to the problem itself.   In this case, it's easy to eliminate:</p>
<pre>
    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . '-' . ($2 + 1);
        } else {
            $info_filename .= '-1';
        }
        # ... no more changes ...
    }</pre>
<p>If the pattern matches, then <code>$1</code> contains the base name, typically
<code>/usr/info/camel.info</code>, and <code>$2</code> contains the numeric suffix,
typically <code>3</code>.  There is no need to copy these into named variables
before using them; we can construct the new filename,
<code>/usr/info/camel.info-4</code> directly from <code>$1</code> and <code>$2</code>.  If the
pattern doesn't match, we construct the new file name by appending
<code>-1</code> to the old file name; this turns <code>/usr/info/camel.info</code> into
<code>/usr/info/camel.info-1</code>.</p>
<p>That takes care of the top half of the function; now let's look at the
bottom half:</p>
<pre>
    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . '-' . ($2 + 1);
        } else {
            $info_filename .= '-1';
        }
        close(INFO);
        if (! (open(INFO, &quot;$info_filename&quot;)) ) {
            if ($! eq &quot;No such file or directory&quot;) {
                return 0;
            } else {
                die &quot;Couldn't open $info_filename: $!&quot;;
            }
        }
        return &amp;start_info_file;
    }</pre>
<p>The <code>close(INFO)</code> is unnecessary, because the <code>open</code> on the
following line will perform an implicit close.  If the file can't be
opened the function looks to find out why.  If the reason is that the next
part doesn't exist, then we're really at the end, and it quietly
returns failure, but if there was some other sort of error, it
aborts.  In keeping with our change to <code>open_info_file</code>, we will
eliminate the <code>die</code> and let the caller die itself, if that is desirable:</p>
<pre>
    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . '-' . ($2 + 1);
        } else {
            $info_filename .= '-1';
        }
        return unless open(INFO, $info_filename);
        return &amp;start_info_file;
    }</pre>
<p>I made a few other minor changes here: Superfluous quotation marks
around <code>$info_filename</code> are gone, and <code>if !</code> has turned into
<code>unless</code>.  Also, I replaced <code>return 0</code> with <code>return</code>.  <code>return 0</code>
and <code>return undef</code> are red flags: They are attempts to make a
function that returns a false value.  But if the function is invoked
in a list context, return values of <code>0</code> and <code>undef</code> are interpreted
as true, not false, because they are one-element lists, and the only
false lists are empty ones:</p>
<pre>
    sub false {
      return 0;
    }

    @a = false();
    if (@a) {          
      print &quot;ooops!\n&quot;;
    }</pre>
<p>The correct way for a function to return a boolean false value in Perl
is almost always a simple <code>return</code> as we have here.  In scalar
context, this returns an undefined value; in list context, it returns
an empty list.</p>
<p>The function has gone from 20 lines to 7.   Refitting it for
object-oriented style does not make it much bigger:</p>
<pre>
    sub start_next_part {
        my ($object) = @_;
        my $info_filename = $object-&gt;{NAME};
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . '-' . ($2 + 1);
        } else {
            $info_filename .= '-1';
        }
        my $fh = $object-&gt;{FH};
        return unless open($fh, $info_filename);
        $object-&gt;{NAME} = $info_filename;         # ***
        return $object-&gt;start_info_file;
    }</pre>
<p>Here we extract the info file's filename from the object using
<code>$object-&gt;{NAME}</code>, which we originally set up back in
<code>open_info_file</code>.  We also extract the filehandle from the object
using <code>$object-&gt;{FH}</code> as we did in <code>start_info_file</code>.  If we
successfully open the new file, we store the changed filename back
into the object, for next time; this occurs on the line marked <code>***</code>.</p>
<p>
<h3><a name="read_next_node"><code>read_next_node</code></a></h3>
<p>Finally, we get to the heart of the library.  <code>read_next_node</code>
actually reads a nodeful of information and returns it to the caller.
(The first thing to notice is that the documentation calls this
function <code>get_next_node</code>, which is wrong.  But that's an easy fix.)</p>
<p>As far as this function is concerned, the node has three parts.  The
first line is the header of the node, which contains the name of the
node; pointers to the previous and next nodes; and other
metainformation.  Then there's a long stretch of text, which is the
documentation that the node was intended to contain.  Somewhere near
the bottom of the text is a menu of pointers to other nodes.  
<code>read_next_node</code> is interested in the header line and the menu.  It
has three sections:  One section to handle the header line, one
section to skip the following text until it sees the menu and one
section to parse the menu.  We'll deal with these one at a time.</p>
<pre>
     1  # Read next node into global variables.  Assumes that file 
     2  # pointer is positioned at the header line that starts a 
     3  # node.  Leaves file pointer positioned at header line of 
     4  # next node. Programmer: note that nodes are separated by 
     5  # a &quot;\n\037\n&quot; sequence.  Reutrn true on 
	  success, false on failure
     6  sub read_next_node {
     7      undef %info_menu;
     8      $_ = &lt;INFO&gt;;                # Header line
     9      if (eof(INFO)) {
    10          return &amp;start_next_part &amp;&amp; &amp;read_next_node;
    11      }
    12  
    13      ($info_file) = /File:\s*([^,]*)/;
    14      ($info_node) = /Node:\s*([^,]*)/;
    15      ($info_prev) = /Prev:\s*([^,]*)/;
    16      ($info_next) = /Next:\s*([^,]*)/;
    17      ($info_up)   = /Up:\s*([^,]*)/;</pre>
<p>Not much needs to change here.  The <code>undef %info_menu</code> was an
appropriate initialization when <code>%info_menu</code> was a global variable,
but our function isn't going to use global variables; it's going to
return the menu information as part of its return list, so we replace
this line with <code>my %info_menu</code>.  The <code>eof()</code> test is a red flag
again; it's probably more straightforward to simply check whether <code>$_</code> is
defined.  If it's undefined, then the function has reached the
end of the file, and needs to try to open the next part.  If that
succeeds, then it calls itself recursively to read the first node from
the new part.  The <code>&amp;&amp;</code> used here to sequence those two operations is
concise, if a little peculiar.  Unfortunately, it won't work any more
now that <code>read_next_node</code> returns a list of data, because <code>&amp;&amp;</code>
always evaluates its arguments in scalar context.  This section of the
code needs to change to:</p>
<pre>
        $_ = &lt;INFO&gt;;                # Header line
        if (! defined $_) {
            return unless  &amp;start_next_part;      
            return &amp;read_next_node;
        }</pre>
<p>The recursive call might be considered a little strange, because it's
essentially performing a <code>goto</code> back up to the top of the function,
and some people might express that with a simple <code>while</code> loop.  But
it's not really obvious that that would be clearer, so I decided to
leave the recursive call in.</p>
<p>The subsequent lines extract parts of the header into the global
variables <code>$info_file</code>, <code>$info_node</code> and so on.   Since we need to
make these items into a data structure to be returned from the function, 
rather than a set of global variables, it's natural to try this:</p>
<pre>
        ($header{File}) = /File:\s*([^,]*)/;
        ($header{Node}) = /Node:\s*([^,]*)/;
        ($header{Prev}) = /Prev:\s*([^,]*)/;
        ($header{Next}) = /Next:\s*([^,]*)/;
        ($header{Up})   =   /Up:\s*([^,]*)/;
</pre>
This works, but as I mentioned before, repeated code is the biggest
red flag of all.   The similarity of these five lines  suggests that we
should try a loop instead:</p>
<pre>
        for my $label (qw(File Node Prev Next Up)) {
          ($header{$label}) = /$label:\s*([^,]*)/;
        }</pre>
<p>Here five lines have become two.  The downside, however, is that Perl has to recompile the pattern five
times for each node, because the value of <code>$label</code> keeps changing.
There are three things we can do to deal with this.  We can ignore it,
we can apply the <code>qr//</code> operator to precompile the patterns, or we
can try to make the five variable patterns into a single constant
pattern.  My vote here, as for most questions of micro-optimization,
is to ignore it unless it proves to be a real problem.
The <code>qr//</code> solution will be an adequate fallback in that case.</p>
<p>I did also consider combining them into one pattern, but that turns 
into a disaster:</p>
<pre>
    ($file, $node, $prev, $next, $up) = 
      /File:\s*([^,]*),\s*Node:\s*([^,]*),\s*
       Next:\s*([^,]*),\s*Prev:\s*([^,]*),\s*
       Up:\s*([^,]*)/x;</pre>
<p>Actually, it's worse than that, because some of the five items might be
missing from the header line, so we must make each part optional:</p>
<pre>
    ($file, $node, $prev, $next, $up) = 
      /(?:File:\s*([^,]*),)?\s*(?:Node:\s*([^,]*),)?\s*
       (?:Next:\s*([^,]*),)?\s*(?:Prev:\s*([^,]*),)?\s*
       (?:Up:\s*([^,]*))?/x;</pre>
<p>Actually, it's even worse, because the original author was programming
in Perl 4 and didn't have <code>(?:...)</code> or <code>/x</code>.  So that tactic really
didn't work out.</p>
<p>This brings up an important point that I don't always emphasize as
much as I should: It's not always obvious what tactics are best until
you have tried them.  When I write these articles, I make false
starts.  I rewrite the code one way, and discover that there are
unexpected problems and the gains aren't as big as I thought they
were.  Then, I try another way and see if it looks better.  Sometimes
it turns out I was wrong, and the original code wins, as it did in
this case.</p>
<p>When you're writing your own code, it won't always be clear how best
to proceed.  Try it both ways and see which looks better, then throw
away the one you don't like as much.</p>
<p>In this article, I had originally planned to rework the library into
something that would still have functioned under Perl 4.  I wrote a
lot of text explaining how to do this.  But it turned out that the only good solution was objects, so I did it over, and that's
what you see.</p>
<p>The moral:  Never be afraid to do it over.</p>

<h3><a name="looking for the menu">Looking for the menu</a></h3>
<p>OK, end of digression.  The function has processed the header line;
now it needs to skip the intervening text until it finds the menu part
of the node:</p>
<pre>
    19      $_ = &lt;INFO&gt; until /^(\* Menu:|\037)/ || eof(INFO);
    20      if (eof(INFO)) {
    21          return &amp;start_next_part;
    22      } elsif (/^\037/) { 
    23          return 1; # end of node, so return success.
    24      }</pre>
<p>The menu follows a line labeled <code>* Menu:</code>.  If the function sees
the end of the node or the end of the file before it sees <code>* Menu</code>,
then the node has no menu.  There's a bug here:  The function should
return immediately at the end of the node, regardless of whether it is
also the end of the file.  As originally written, it calls
<code>start_next_part</code> at the end of the file, which might fail (if the
current node was the last one) and reports the failure back to the
caller when it should have reported success.  Fixing the bug and
eliminating <code>eof()</code> yields this:</p>
<pre>
    $_ = &lt;INFO&gt; until !defined($_) || /^(\* Menu:|\037)/;
    return @header if !defined($_) || /^\037/;</pre>
<p>The repeated tests bothered me there, but the best alternative
formulation I could come up with was:</p>
<pre>
    while (&lt;INFO&gt;) {
      last if /^\* Menu:/;
      return %header if /^\037/;
    }
    return %header unless defined $_;</pre>
<p>I asked around, and Simon Cozens suggested</p>
<pre>
    do { 
      $_ = &lt;INFO&gt;; 
      return %header if /^\037/ || ! defined $_ 
    } until /^\* Menu:/ ;</pre>
<p>I think I like this best, because it makes the <code>/^\* Menu:/</code> into the
main termination condition, which is as it should be.  On the other
hand, <code>do...until</code> is unusual, and you don't get the implicit
read into <code>$_</code>.  But four versions of the same code is plenty, so
let's move on.</p>
<p>Finally our function is ready to read the menu.  A typical menu looks
like this:</p>
<pre>
        * Menu:

        * Numerical types::
        * Exactness::
        * Implementation restrictions::
        * Syntax of numerical constants::
        * Numerical operations::
        * Numerical input and output::</pre>
<p>Each item has a title (which is displayed to the user) and a node name
(which is the node that the user visits next if they select that menu
item).  If the title and node name are different, the menu item looks
like this:</p>
<pre>
        * The title:       The node name.</pre>
<p>If they're the same (as is often the case) the menu item ends in <code>::</code>
as in the examples above.  The menu-reading code has to handle both
cases:</p>
<pre>
    27      local($key, $ref);
    28      while (&lt;INFO&gt;) {    
    29          return 1 if /^\037/;    # end of node, success.
    30          next unless /^\* \S/;   # skip non-menu-items
    31          if (/^\* ([^:]*)::/) {  # menu item ends with ::
    32              $key = $ref = $1;
    33          } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
    34              ($key, $ref) = ($1, $2);
    35          } else {
    36              print STDERR &quot;Couldn't parse menu item\n\t$_&quot;;
    37              next;
    38          }
    39          $info_menu{$key} = $ref;
    40      }</pre>
<p>I think this code is lovely.  I would do only two things differently.
First, I would change the error message to include the filename and
line number of the malformed menu entry.  Perl's built-in <code>$.</code>
variable makes this easy, and the current behavior makes it too
difficult for the programmer to locate the source of the problem.  And
second, instead of <code>return</code>ing directly out of the loop, I would
use <code>last</code>, because the return value <code>(%header, Menu
=&gt; \%menu)</code> is rather
complicated and the code below the loop will have to return the same
thing anyway.</p>
<p>In the original prgram, that <code>return</code> line calls <code>start_info_file</code>
again if the function reads to the end of the current part while still
reading the menu.  This isn't correct; it should simply return
success and let the next call to <code>read_next_node</code> worry about
opening the new part.</p>
<p>The rewritten version of <code>read_next_node</code> looks like this:</p>
<pre>
    sub read_next_node {
        $_ = &lt;INFO&gt;;                # Header line
        if (! defined $_) {
            return unless  &amp;start_next_part;      
            return &amp;read_next_node;
        }

        my (%header, %menu);
        for my $label (qw(File Node Prev Next Up)) {
          ($header{$label}) = /$label:\s*([^,]*)/;
        }

        do { 
          $_ = &lt;INFO&gt;; 
          return %header if /^\037/ || ! defined $_ 
        } until /^\* Menu:/ ;



        while (&lt;INFO&gt;) {    
            my ($key, $ref);
            last if /^\037/;        # end of node
            next unless /^\* \S/;   # skip non-menu-items
            if (/^\* ([^:]*)::/) {  # menu item ends with ::
                $key = $ref = $1;
            } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
                ($key, $ref) = ($1, $2);
            } else {
                warn &quot;Couldn't parse menu item at line $. 
                      of file $info_file_name&quot;;
                next;
            }
            $menu{$key} = $ref;
        }

        return (%header, Menu =&gt; \%menu);
    }</pre>
<p>The code didn't get shorter this time, but that's because it was
pretty good to begin with.  After making a few straightforward changes
to convert it to object-oriented style, we get:</p>
<pre>
    sub read_next_node {
        my ($object) = @_;
        my ($fh) = $object-&gt;{FH};
        local $_ = &lt;$fh&gt;;           # Header line
        if (! defined $_) {
            return unless  $object-&gt;start_next_part;      
            return $object-&gt;read_next_node;
        }

        my (%header, %menu);
        for my $label (qw(File Node Prev Next Up)) {
          ($header{$label}) = /$label:\s*([^,]*)/;
        }

        do { 
          $_ = &lt;$fh&gt;; 
          return %header if /^\037/ || ! defined $_ 
        } until /^\* Menu:/ ;

        while (&lt;$fh&gt;) {    
            my ($key, $ref);
            last if /^\037/;        # end of node
            next unless /^\* \S/;   # skip non-menu-items
            if (/^\* ([^:]*)::/) {  # menu item ends with ::
                $key = $ref = $1;
            } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
                ($key, $ref) = ($1, $2);
            } else {
                warn &quot;Couldn't parse menu item at line $. 
                      of file $object-&gt;{NAME}&quot;;
                next;
            }
            $menu{$key} = $ref;
        }

        return (%header, Menu =&gt; \%menu);
    }
</pre>
<p><a href="/2000/11/Info_File.pm">The entire object-oriented module is
        available here</a>.
<p>
A simple example program that demonstrates the use of the library:

<pre>
    use Info_File;
    my $file = shift;
    my $info = Info_File-&gt;open_info_file($file)
      or die "Couldn't open $file: $!; aborting";
    while (my %node = $info-&gt;read_next_node) {
      print $node{Node},"\n";  # print the node name
    }
</pre>
<p>
<hr>
<h3><a name="putting it all together">Putting It All Together</a></h3>
<p>This time the code hasn't gotten any smaller; it's the same
size as it was before.  Some parts got smaller, but there was some
overhead associated with the conversion to object-oriented style that
made the code bigger again.</p>
<p>But the OO style got us several big wins.  The interface got better;
the library no longer communicates through global variables and no
longer smashes <code>INFO</code>.  It also gained the capability to process
two or more info files simultaneously, or the same info file more than
once, which is essential if it's to be useful in any large project.
Flexibility has increased also: It would require only a few extra
lines to provide the ability to search for any node or to seek back to
a node by name.</p>
<p>
<hr>
<h3><a name="red flags">Red Flags</a></h3>
<p>A summary of the red flags we saw this time:</p>
<p>
<!-- <a name="don't repeat code">Don't Repeat Code</a> -->
<p>The Cardinal Rule of Computer Programming is that if you wrote the
same code twice, you probably did something wrong.  At the very least,
you may be setting yourself up for a maintenance problem later on when
someone changes the code in one place and not in another.</p>
<p>Programming languages are chock-full of features designed to prevent
code duplication from the very lowest levels (features such as <code>$a[3]
+= $b</code> instead of <code>$a[3] = $a[3] + $b</code> to the very highest (features
such as DLLs and pipes.)  In between these levels are essential
features such as subroutines and modules.</p>
<p>Each time you see you have written the same code more than once, give
serious thought to how you might eliminate all but one instance.</p>
<p>
<h4><a name="eof()"><code>eof()</code></a></h4>
<p>The Perl <code>eof()</code> function is almost always a bad choice.  It's
typically overused by beginners and by people who have been
programming in Pascal for too long.</p>
<p>Perl returns an unambiguous end-of-file condition by yielding an
undefined value.  Perl's I/O operators are designed to make it
convenient to check for this.  The <code>while(&lt;FH&gt;)</code> construction
even does so automatically.  Explicit checking of <code>eof()</code> is almost
never required or desirable.</p>
<p>
<h4><a name="return 0 and return undef"><code>return 0</code> and <code>return undef</code></a></h4>
<p>This is often an attempt to return a value that will be perceived by
the caller as a Boolean false.  But in list context, it will test as
true, not false.  Unless the function <em>always</em> returns a single
scalar, even in list context, it is usually a better choice to use
plain <code>return;</code> to yield a false value.</p>
<p>Some programmers write <code>wantarray() ? () : undef</code>, which does the
same thing but is more verbose and confusing.</p>
<p>
<hr>
<h3><a name="brief confession">Brief Confession</a></h3>
<p>The program discussed in this article was indeed written by a Perl
beginner.  I wrote it in 1993 when I had only been programming in Perl
for a few months.  I must have been pleased with it, because it was
the first Perl program that I posted in a public forum.</p>



                                    </div>


                                </div>
                                <div class="asset-footer">


                                </div>
                            </div>


                    
                    


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2014/02/">February 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2014/01/">January 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/10/">October 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/01/">January 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/12/">December 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/11/">November 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/10/">October 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/08/">August 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/06/">June 2012 (11)</a></li>
        
    
        
            <li><a href="/pub/2012/05/">May 2012 (18)</a></li>
        
    
        
            <li><a href="/pub/2012/04/">April 2012 (17)</a></li>
        
    
        
            <li><a href="/pub/2012/02/">February 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/12/">December 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/09/">September 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/08/">August 2011 (2)</a></li>
        
    
        
            <li><a href="/pub/2011/06/">June 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/05/">May 2011 (3)</a></li>
        
    
        
            <li><a href="/pub/2011/04/">April 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/03/">March 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/02/">February 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/01/">January 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/11/">November 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/10/">October 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/09/">September 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/08/">August 2010 (3)</a></li>
        
    
        
            <li><a href="/pub/2010/07/">July 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/04/">April 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/03/">March 2010 (4)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.13-en" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

            <div class="widget-creative-commons widget">
                <div class="widget-content">
                    This blog is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons License</a>.
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
