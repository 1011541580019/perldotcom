<HTML>
<HEAD>
<TITLE>Speeding up method lookups</TITLE>
<LINK REV="made" HREF="mailto:mjd@plover.plover.com">
</HEAD>

<BODY>

<br />
<br /><A NAME="__index__"></A><!-- INDEX BEGIN -->

<UL>

 <LI><A HREF="#speeding up method lookups">Speeding up method lookups</A></LI>
 <UL>

  <LI><A HREF="#methods and subroutines">Methods and subroutines</A></LI>
  <LI><A HREF="#what entersub knows about methods">What entersub knows about methods</A></LI>
  <LI><A HREF="#when to convert methods">When to convert methods</A></LI>
  <LI><A HREF="#how to convert methods">How to convert methods</A></LI>
  <LI><A HREF="#finding the stash">Finding the stash</A></LI>
  <LI><A HREF="#extract the gv entry">Extract the GV entry</A></LI>
  <LI><A HREF="#rewrite entersub">Rewrite entersub</A></LI>
  <LI><A HREF="#conclusion">Conclusion</A></LI>
  <LI><A HREF="#exercises">Exercises</A></LI>
 </UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="speeding up method lookups">Speeding up method lookups</A></H1>
<P>Last week, Doug MacEachern provided an interesting and extremely
clever patch to speed up method calls. His benchmarks showed that it
completely reduced the overhead of using methods, and appeared to
suggest that method calls could actually be faster than subroutine
calls.  Let's have a look at the patch in detail, to see how it's
done.</P>
<P>
<!-- <A NAME="methods and subroutines">Methods and subroutines</A> -->
<P>Here's the original musing from Sarathy, which started it all off:</P>
<PRE>
    If @ISA isn't modified at run time, Foo::-&gt;bar() could be resolved
    at compile time to a subroutine call, as can this:</PRE>
<PRE>
    my Foo $obj = shift;
    $obj-&gt;bar();</PRE>
<P>As all the tutorials on Perl's object-oriented programming rightly
state, when you call a method, you're calling a subroutine. The
difference, however, is that a method call has to perform a lookup to
find out which package its subroutine lives in.</P>
<P>In the normal case without inheritance, <CODE>Foo-&gt;bar()</CODE> will be
subroutine <CODE>bar</CODE> in package <CODE>Foo</CODE>. However, because of inheritance,
you can't tell just by looking at <CODE>Foo-&gt;bar()</CODE> where <CODE>bar</CODE> is
going to be - <CODE>Foo</CODE> may inherit <CODE>bar</CODE> from <CODE>Frob</CODE>, from example.</P>
<P>To resolve this, when you call a method, Perl checks for a subroutine
<CODE>bar</CODE> in package <CODE>Foo</CODE>. If it doesn't find one, it checks <CODE>Foo</CODE>'s
parents: all the packages listed in <CODE>Foo</CODE>'s <CODE>@ISA</CODE> array. It then
checks the grandparents, and so on. This lookup has to be done at
run-time, instead of compile time, because <CODE>@ISA</CODE> is an ordinary
variable - someone may change the inheritance tree from under your feet.</P>
<P>Sarathy's thought was that if you know for sure what's going to be in
<CODE>@ISA</CODE> at the time you perform the compilation, you change an
expensive method call into a slightly less expensive subroutine call.
And that's what Doug's patch does.</P>
<P>We can divide the patch up into two parts: the function
<CODE>method_to_entersub</CODE> performs the conversion and tells us <STRONG>how</STRONG> it's
done, and the part of the code which calls <CODE>method_to_entersub</CODE>, telling us
<STRONG>when</STRONG> it's done. We'll look first at the when.</P>
<P>
<!-- <A NAME="what entersub knows about methods">What entersub knows about methods</A> -->
<P>Before we do that, though, a little detour about how subroutine calling
works internally.</P>
<P>Perl constructs the <CODE>entersub</CODE> op in a similar way for a method call
and an ordinary subroutine call.  The difference is that for a
subroutine call, the <CODE>entersub</CODE> op is preceded by an op that
fetches the GV that holds the subroutine code, and for a method call,
the <CODE>entersub</CODE> op is preceded by an op that looks up the method name
in the inheritance tree.  You can see this in the following
<CODE>B::Terse</CODE> output.</P>
<PRE>
        % perl -MO=Terse,exec -e 'bar()'
        ...
        SVOP (0xa043b00) gv  GV (0xa04ecf8) *bar              &lt;- cvop
        UNOP (0xa0b6a60) entersub [1]
        ...</PRE>
<P>For a method call, though, Perl also attaches an op representing the
class (let's call it <CODE>o2</CODE>, since that's as good a name as any) and
<CODE>svop</CODE>, instead of being a GV, becomes a special op to signify that a
method should be called in that class:</P>
<PRE>
    % perl -MO=Terse,exec -e 'Foo-&gt;bar()'
    ...
    SVOP (0xa043b00) const  PV (0xa0411f0) &quot;Foo&quot;          &lt;- o2
    SVOP (0xa043b40) method_named  PVIV (0xa04ecf8) &quot;bar&quot; &lt;- cvop
    UNOP (0xa0d0500) entersub [1]
    ...
</PRE>
<P>For class methods, <CODE>o</CODE> is a constant, while for object methods, <CODE>o2</CODE>
fetches the object, allowing us to work out the class at run time:</P>
<PRE>
    % perl -MO=Terse,exec -e '$foo-&gt;bar()'
    ...
    SVOP (0xa043b00) gvsv  GV (0xa04ecf8) *foo            &lt;- o2
    SVOP (0xa0d5720) method_named  PVIV (0xa0411f0) &quot;bar&quot; &lt;- cvop
    UNOP (0xa0d04d0) entersub [1]
    ...
</PRE>
<P><CODE>method_named</CODE> is the op representing, unsurprisingly, a named method.
You can also call methods on the fly, like this:</P>
<PRE>
                Foo-&gt;$methname()</PRE>
<P>and in this case, the <CODE>method</CODE> op is preceded by an op that fetches
the method name from <CODE>$methname</CODE>.  In this example, it's a simple
variable lookup:</P>
<PRE>
    % perl -MO=Terse,exec -e 'Foo-&gt;$x()'
    ...
    SVOP (0xa043b00) const  PV (0xa0411f0) &quot;Foo&quot;          &lt;- o2
    SVOP (0xa043b60) gvsv  GV (0xa04ed70) *x              &lt;- child of cvop
    UNOP (0xa043b40) method                               &lt;- cvop
    UNOP (0xa0d04d0) entersub [1]
    ...
</PRE>
<P>What we want to do is trap both these method-style <CODE>cvop</CODE>s,
<CODE>method_named</CODE> and <CODE>method</CODE>, and see if we can perform the method
lookup at compile time.  Once we know what subroutine will actually be
called, we can change the op tree so that it calls the subroutine
directly, so that at run time when the method is actually called, Perl
won't have to search the inheritance tree any more.</P>
<P>
<!-- <A NAME="when to convert methods">When to convert methods</A> -->
<PRE>
 --- ./op.c.orig Fri Jun  2 15:49:32 2000
 +++ ./op.c  Thu Jun 15 22:45:33 2000
 @@ -6243,6 +6309,12 @@
          } 
      }
      else if (   cvop-&gt;op_type == OP_METHOD 
               || cvop-&gt;op_type == OP_METHOD_NAMED) {
 +        if (o2-&gt;op_type == OP_CONST || o2-&gt;op_type == OP_PADSV) {
 +            OP *nop;
 +            if ((nop = method_to_entersub(aTHX_ o2, cvop))) {
 +                return nop;
 +            }
 +        }
          if (o2-&gt;op_type == OP_CONST) {
              o2-&gt;op_private &amp;= ~OPpCONST_STRICT;
          }</PRE>
<P>If you're not used to reading patches, the first three lines tell you
where we are: the seven lines from 6243 of <EM>op.c</EM>, which become
thirteen lines from 6309 when the patch is applied. The lines starting
with a plus are to be added.</P>
<P>Line 6243 is in the middle of the function <CODE>Perl_ck_subr</CODE>, which is
the check routine called when an <CODE>entersub</CODE> op is filed.  Check
routines are fed an op and produce a `cleaned up' version, performing
any optimization or elimination of redundancies. Perl replaces each op
in the op tree built during the compile phase with these optimized
versions.</P>
<P>As we learnt above, we're going to be in one of three situations at this
point: ordinary subroutine, which will have a GV op attached to our
<CODE>entersub</CODE> op; named method, which has <CODE>method_named</CODE> attached; or
unnamed method, which has <CODE>method</CODE> attached. We care about cases when
<CODE>cvop</CODE> is a <CODE>method</CODE> or <CODE>method_named</CODE> op:</P>
<PRE>
 else if (   cvop-&gt;op_type == OP_METHOD 
          || cvop-&gt;op_type == OP_METHOD_NAMED) {
</PRE>
<P>We're fixing class methods, which means we try the conversion when <CODE>o2</CODE>
is a constant. We also want to fix up <CODE>my Dog $sam; $sam-&gt;bark;</CODE>,
in which case <CODE>o2</CODE>, the object, is a lexical variable:
(In internal-speak, a pad sv.)</P>
<PRE>
 if (o2-&gt;op_type == OP_CONST || o2-&gt;op_type == OP_PADSV) {</PRE>
<P>In these cases, we try to convert the method to a subroutine, and return
the new method if we manage it:</P>
<PRE>
     OP *nop;
     if ((nop = method_to_entersub(aTHX_ o2, cvop))) {
         return nop;
     }</PRE>
<P>The final touch is a portion of the original source: in
<CODE>Foo-&gt;bar</CODE>, <CODE>Foo</CODE> is obviously a class name, and shouldn't fire
off a warning if <CODE>strict</CODE> is checking against barewords. Hence, we
remove the strict test from constants which are class names.</P>
<PRE>
 if (o2-&gt;op_type == OP_CONST) {
     o2-&gt;op_private &amp;= ~OPpCONST_STRICT;
 }</PRE>
<P>That's 'when'.  Now let's see 'how'.</P>
<P>
<H2><A NAME="how to convert methods">How to convert methods</A></H2>
<P>Inside the check routine, the variable <CODE>svop</CODE> holds the <CODE>method</CODE> or
<CODE>method_named</CODE> node that specifies how Perl should locate the
subroutine that is actually called; <CODE>o</CODE> is the node that is executed
just before this, that fetches the GV for the class name or the value
of the variable that contains the object on whose behalf the method
will be called.   For example:</P>
<PRE>
    Foo-&gt;bar():

    SVOP (0xa043b00) const  PV (0xa0411f0) &quot;Foo&quot;          &lt;- o
    SVOP (0xa043b40) method_named  PVIV (0xa04ecf8) &quot;bar&quot; &lt;- svop
    UNOP (0xa0d0500) entersub [1]
    ...

    $foo-&gt;bar():

    SVOP (0xa043b00) gvsv  GV (0xa04ecf8) *foo            &lt;- o
    SVOP (0xa0d5720) method_named  PVIV (0xa0411f0) &quot;bar&quot; &lt;- svop
    UNOP (0xa0d04d0) entersub [1]
</PRE>
<P>There is also a <CODE>method</CODE> variable that holds the SV that is contained
in <CODE>o</CODE>.  Our function opens by getting the method name out of there:</P>
<PRE>
 if (svop-&gt;op_type == OP_METHOD_NAMED) {
     methname = SvPV(method, methlen);
 }
 else {
     return Nullop;
 }</PRE>
<P>If it isn't a named method, (that is, if we've got something like
<CODE>$foo-&gt;$bar()</CODE>) we can't do anything with it. We return the false value
<CODE>Nullop</CODE>, which is a null pointer cast into an op, signalling to the calling
routine that we couldn't modify the program.</P>
<PRE>
 if (cvop-&gt;op_type == OP_METHOD_NAMED &amp;&amp;
     o2-&gt;op_type == OP_CONST || o2-&gt;op_type == OP_PADSV) {</PRE>
<P>Now, we're fixing up two things: class method calls where <CODE>o</CODE> is
constant, and <CODE>my Dog $sam</CODE> situations where <CODE>o</CODE> is a pad SV.</P>
<P>Inside this function, we have three tasks:</P>
<DL>
<DT><STRONG><A NAME="item_Find_the_stash">Find the stash</A></STRONG><BR>
<DD>
A stash is a package symbol table, such as <CODE>%Foo::</CODE> in Perl space. We
need to find the class to which our method belongs, and bring out the
symbol table from it.
<P></P>
<DT><STRONG><A NAME="item_Extract_the_GV_entry">Extract the GV entry</A></STRONG><BR>
<DD>
We're trying to create an <CODE>entersub</CODE> op which calls, for example
<CODE>&amp;Foo::bar</CODE>. We've got <CODE>%Foo::</CODE> from the above: the next task is to
find <CODE>*Foo::bar</CODE>. At this point, we want to take care of inheritance.
<P></P>
<DT><STRONG><A NAME="item_Rewrite_entersub">Rewrite entersub</A></STRONG><BR>
<DD>
Finally, we fiddle with the op tree to convert the method form of
<CODE>entersub</CODE> to a subroutine call which merely calls the GV we've just
found.
<P></P></DL>
<P>Along the way, we also need to take care of the fact that Perl caches
method lookups.</P>
<P>
<H2><A NAME="finding the stash">Finding the stash</A></H2>
<P>We're trying to find the GV <CODE>*Class::Method</CODE> so we can feed it to
<CODE>entersub</CODE>. The first thing we need to do, then, is to find the package
symbol table, or `stash', for the class. There are two possible situations
we're in now, and the situation determines how we find the stash: either we've
got a constant class, or the object is a lexical.</P>
<P>If we've got a constant class, finding the stash is simple: the PV of
the SV hidden in the SvOP <CODE>o</CODE> tells us the name of the package, and
<CODE>gv_stashpvn</CODE> returns the stash given a PV.</P>
<PRE>
 if (o-&gt;op_type == OP_CONST) {
     STRLEN len;
     char *package = SvPV(((SVOP*)o)-&gt;op_sv, len);
     stash = gv_stashpvn(package, len, FALSE);
 }</PRE>
<P>Don't be frightened of the scary casting in line 3: we're just getting
the string value from the <CODE>const</CODE> op.</P>
<P>If we've got a lexical (pad sv) object, <CODE>my Dog $sam</CODE>, life is slightly more
interesting.</P>
<PRE>
 else if (o-&gt;op_type == OP_PADSV) {</PRE>
<P>We fetch the actually SV itself from the current pad - the pad is where Perl
keeps the lexical variables belonging to the current block, and it's just
an ordinary array:</P>
<PRE>
     SV *sv = *av_fetch(PL_comppad_name, o-&gt;op_targ, FALSE);</PRE>
<P>We hope this SV exists, and is an object. If it is an object, <CODE>SvSTASH</CODE>
will give us the stash, since Perl stored a pointer to the stash when we
used <CODE>bless</CODE> to create the object.</P>
<PRE>
     if (sv &amp;&amp; SvOBJECT(sv)) {
         stash = SvSTASH(sv);
     }</PRE>
<P>Otherwise, we can't do much.</P>
<PRE>
     else {
         return Nullop;
     }
 }</PRE>
<P>Those are the only two cases - lexicals and constants - that can possibly
happen, but computer programming sometimes makes the impossible possible. Doug
stands firm against the demons of illogic:</P>
<PRE>
 else {
     return Nullop;
 }</PRE>
<P>
<H2><A NAME="extract the gv entry">Extract the GV entry</A></H2>
<P>If we've got a stash, we can now try and find the GV. Thankfully, there's
a function in <EM>gv.c</EM> which does this, and even takes care of inheritance
for us as well.</P>
<PRE>
 if (!(stash &amp;&amp; (gv = gv_fetchmeth(stash, methname, methlen, 0)) 
             &amp;&amp;  isGV(gv))) {
     return Nullop;
 }</PRE>
<P>If <CODE>gv_fetchmeth</CODE> fails, or if what it returns is not a gv for some
reason, then we couldn't find the package that actually contains the
method, so we give up and return <CODE>Nullop</CODE>.  Otherwise, <CODE>gv</CODE> points
to the GV that contains the subroutine we want <CODE>entersub</CODE> to call.
Or it will do the first time the method is looked up. If, however, our
method is inherited and provided by another stash, <CODE>gv_fetchmeth</CODE>
provides an alias to the real GV in the object's stash.</P>
<P>In order to get at the code for the real subroutine, we have to get
the original GV from this alias; we use the <CODE>GvCV</CODE> macro to do
this. If the GV we get from <CODE>GvCV</CODE> is in a different class to our
method, then we have an alias. We need <CODE>entersub</CODE> to point to the
original GV, and not this alias:</P>
<PRE>
 if (GvSTASH(CvGV(GvCV(gv))) != stash) {
     gv = CvGV(GvCV(gv)); /* point to the real gv */
 }</PRE>
<P>In his comments, which I've snipped, Doug notes that this cached lookup
will only be valid if inheritance doesn't change at run time. There's
currently no way to freeze <CODE>@ISA</CODE> at run time yet, (hey, there's a job
for someone!) so Doug suggests as an alternative a simple
<CODE>return Nullop</CODE> to abort if we have a cached lookup.</P>
<P>
<H2><A NAME="rewrite entersub">Rewrite entersub</A></H2>
<P>Finally, we have enough information to rewrite the <CODE>entersub</CODE> op: We
have a GV, which contains a CV, which we can now call directly. Let's
arrange things to do that.</P>
<P>First, remove the <CODE>strict</CODE> test from the method name as before.</P>
<PRE>
 o-&gt;op_private &amp;= ~(OPpCONST_BARE|OPpCONST_STRICT);</PRE>
<P>Now find the <CODE>op_method_named</CODE> op, and change it into the GV to create
a subroutine call.</P>
<PRE>
 for (mop = o; mop-&gt;op_sibling-&gt;op_sibling; mop = mop-&gt;op_sibling) ;
 op_free(mop-&gt;op_sibling); /* loose OP_METHOD{,_NAMED} */
 mop-&gt;op_sibling = scalar(newUNOP(OP_RV2CV, 0,
                             newGVOP(OP_GV, 0, gv)));
</PRE>
<P>Triumphantly, we return the converted op:</P>
<PRE>
 nop = convert(OP_ENTERSUB, OPf_STACKED, o);
 return nop;</PRE>
<P>
<H2><A NAME="conclusion">Conclusion</A></H2>
<P>We got a lot of mileage out of that patch; we've seen how Perl finds and
calls methods and subroutines, and shown how Doug's patch can turn
methods into subroutines. This should almost totally remove the overhead
in using object-oriented Perl, but for the following two points.</P>
<P>
<H2><A NAME="exercises">Exercises</A></H2>
<OL>
<LI>
Doug's patch needs a way of validating the inheritance tree at compile
time; the obvious way to do this is to freeze <CODE>@ISA</CODE>. Write a pragma
which does this.
<P>For bonus points <STRONG>and</STRONG> god-of-the-week status, find a way of validating
the method cache at compile time while keeping <CODE>@ISA</CODE> variable.</P>
<P></P>
<LI>
This only works for named methods; find a way to make it work for
methods that are fetched from variables or via other means. That is, make
<CODE>Class-&gt;$thing()</CODE> convertible to a sub.
<P></P></OL>

</BODY>

</HTML>
