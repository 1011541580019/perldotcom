<HTML>

<HEAD>
<TITLE> PDSC #0: General tips </TITLE>
</HEAD>

<BODY>

<CENTER>
<H1>
	    PDSC #0: General tips <BR>(abbreviated)
</H1>

<b><font size="+1"><I>by Tom Christiansen</I></b>
<BR>
<b>&lt; <A HREF="mailto:tchrist@perl.com">tchrist@perl.com</A> &gt;</b>
    <BR>
</font>
		    <P>
		    <b>release 0.2
		    <BR>
		    Sunday, 8 October 1995</b>
		   

</CENTER>
<HR>

<P>


The first thing you need to do is figure out how you want to access (such
as via an assignment) just <I>one individual element</I> of your data
structure just using lists and hashes.  Use an <b><code>@ARRAY</code></b> if you're
thinking of an array or linked list or stack or queue or deque, but use a
<b><code>%HASH</code></b> if you're thinking of a record or a structure or a lookup
table.

<P>

<DL>

<DT><LI><B>$coordinates[$row][$col] = "empty"</B>
<DD>
   This is a simple two-dimensional array indexed
   by integers.  
   Each first level numeric index itself produces a list (reference).
   See the <A HREF="pdsc-1.html">List of Lists document</a>.

<P>

<DT><P><LI><B>$flight_time{"denver"}[3] = "12:34"</B>
<DD>This is an (associative) array of lists.
   Each first level string index itself produces a list (reference).
    See the <A HREF="pdsc-3.html">Hash of Lists document</a>.

<P>
<DT><P><LI><B>$student[$i]{"age"} = 15</B>
<DD>This is an array of records that include named fields.
   Each first level numeric index itself produces a hash (reference).
   See the <A HREF="pdsc-2.html">List of Hashes document</a>.

<DT><P><LI><B>$tv_shows{"the simpsons"}{"start time"} = "Monday 20:00"</B>
<DD>This is an lookup table of records where you lookup the
    show by the name, and then you look up the record field by 
    the field name.  
   Each first level string index itself produces a hash (reference).
    See the <A HREF="pdsc-4.html">Hash of Hashes document</a>.
<P>


<DT><P><LI><B>$tv{"the simpsons"}{members}[0]{name} = "homer"</B>

<DD>This is an elaborate data structure involving a mix of 
    records that contain fields that are sometimes themselves 
    other arrays and records.  
    See the <A HREF="pdsc-5.html">More Elaborate Structures document</a>.

<DT><P><LI><B>$rec-&gt;{FH}-&gt;print( &amp;{ $rec-&gt;{FUNC} } ( $rec-&gt;{LIST}[0]))</B>
<DD>
This is a strange record that itself includes references to filehandles,
functions, and other strings, lists, and hashes.  We print to the filehandle
referenced in <B>$rec</B>'s FH 
the result of calling the function in its FUNC field
with an argument of the first element in the array which is its LIST field.
    See also the <A HREF="pdsc-5.html">More Elaborate Structures document</a>.

</DD>
</DL>

<HR>

<font size="+1">
<center>
<h1>Note</h1>
Please see the <A HREF="pdsc-0-verbose.html">expanded version</a> of this document
for a much more elaborate treatment of the following tips.
</center>
</font>

<HR>
<h2>General Tips</h2>

<P>

Here are some further tips of general interest:

<OL>

<P><LI>Always <B>use strict</B> and <b>-w</b>.  The strict can be a pain,
    but it will save you from saying <B>$a[$i]</B> when you 
    mean <B>$a-&gt;[$i]</B> and vice versa.

<P><LI>Things like <B>push()</B> require an <B>@</B> sign, as in
<DL><DD><CODE>push @{ $a[3] }, @new_list</CODE></DL>
You can't write
<DL><DD><CODE>push $a[3], @new_list</CODE></DL>


<P><LI>Things like <B>keys()</B> require a <B>%</B> sign, as in

<DL><CODE><DD>foreach $k (keys %{ $h{"key"} }) { ... }</CODE></DL>
   You can't write
	<DL><CODE><DD>foreach $k (keys $h{"key"}) { ... }</CODE></DL>

<P><LI>Don't store pointers to existing data in a structure.
   Always create a new structure, eg. to build a 2D array
   indexed by line and by word number:

<PRE>
       while ( &lt;&gt; ) {
	   @fields = split;
	   push @a, [ @fields ];
       }
</PRE>


    This generally means never using the backslash to take
    a reference, but rather using the <B>[]</B> or <B>{}</B> constructors.
    This, for examples, is <b>wrong</b>!

<PRE>
       while ( &lt;&gt; ) {
	   @fields = split;
	   push @a, \@fields;
       }
</PRE>

    It's the same problem as this in C:

<PRE>
	char a[100], *p[10], *somefunc();
	for (i = 0; i &lt; 10; i++) {
	    strcpy(a, somefunc(i));
	    p[i] = a;
	} 
</PRE>

    <P>
    An exception to this rule would be when you're writing a
    recursive data structure or are creating multiple key indices for the
    same set of records.
  

<P><LI>Never write <B>$$a[$i]</B> when you mean <B>${$a[$i]}</B> or
               <B>@$a[$i]</B> when you mean <B>@{$a[$i]}</B>.
    Those won't work at all.

<P><LI>Never write <B>$$a[$i]</B> even if you mean <B>$a-&gt;[$i]</B>.  While it'll work
    to do that, it will needlessly confuse C programmers, who will think
    that subscripting binds tighter than the prefix dereference operator.
    This is right in C but wrong in perl where it's the other way around!

<P><LI>Remember that <B>$a[$i]</B> is the <i>i'th</i> elt of <B>@a</B>, but <B>$a-&gt;[$i]</B>
   is the <i>i'th</i> elt of the anon array pointed to by <B>$a</B>.  Saying
   <code>use strict</code> will help here.

<P><LI>Never write 
	<DL><CODE><DD>@ { $a[$i] } = @list</CODE></DL>
   instead of 
<DL><CODE><DD>$a[$i] = [ @list ]</CODE></DL>
   It'll work, but will confuse people.  

<P><LI>Try to use pointer arrows and indirection bracketing whenever you 
   feel the reader might be confused.  
   Sometimes it'll clear
   things up in your mind as well.
   Here are the five kinds of prefix dereferencers with disambiguating 
   braces:
   <UL>
   <P>
    <DL><DT><LI><B>print ${ $a[$i] }</B>
	<DD>Dereference a SCALAR reference.</DL>
    <DL><DT><LI><B>pop @{ $a[$i] }</B>
	<DD>Dereference an ARRAY reference.</DL>
    <DL><DT><LI><B>@k = keys %{ $a[$i] }</B>
	<DD>Dereference a HASH reference.</DL>
    <DL><DT><LI><B>$retval = &{ $a[$i] }( )</B>
	<DD>Dereference a CODE reference.</DL>
    <DL><DT><LI><B>*{ $a[$i] } = \&func</B>
	<DD>Dereference a GLOB reference; this is deep magic best
	left to the wizards.</DL>
   </UL>

<P><LI>The new <A HREF="ftp://perl.com/pub/perl/ext/perl5db-kit-0.9.tar.gz">perl5db</A> (ftp to perl.com in <A HREF="ftp://perl.com/pub/perl/ext/">/pub/perl/ext/</a>) will help print out complex data
    structures using the <B>x</B> and <B>X</B> commands.

</DL>

</BODY>
</HTML>
