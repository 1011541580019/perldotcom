<TITLE>tchrist's tcl dirty laundry list</TITLE>
<CENTER><h1>tchrist's tcl dirty laundry list</h1></CENTER>
<blockquote><i>
This is more venting that discussion.  See the longer discussions listed on the
<a href="index.html">index page</a> for more exposition.
</i></blockquote>
<hr>
<small>TEE CEE ELL</small> is merely a string substitution language in a lot of ways.
Here are some of my rags on tcl.  I know their answers and I don't 
like them.

<p>
--tom
<p>

<ul>

<P><LI>There is no 1st-class citizen besides a string, and all else is a hack.

<P><LI>How do you pass things?  you have to use <i>pass by name</i> and even then maybe
play horrid scoping games.  this an evil that all users of algol68 have
long since repented of.

<P><LI>Why are associative arrays broken?
<PRE>
    set array("some string value") "another string value"
</pre>
because the idiot lexer passes the wrong thing to set.

<P><LI>Why is <i>everything</i> wrapped in catch/throw?  

<P><LI>Why is eval so dangerously prevalent?

<P><LI>Why can't you distinguish between strings and numbers? 

<P><LI>Why are numbers broken?  Why when i read in east
coast zip codes do the leading 0's screw me up? 

<P><LI>Why can't you say:
<PRE>
    func_taking_list [ func_returning_list ] 
</pre>
because things don't really return lists. they return strings.
you have to say
<PRE>
    eval func_taking_list [ func_returning_list ] 
</pre>
<P><LI>Why isn't it 8-bit clean?

<P><LI>Why don't you have proper namespace protection?  Why don't
you have closures and lexical variables and dynamic variables?

<P><LI>Why don't you have proper function pointers?

<P><LI>What's so horribly wrong with 
<PRE>
    set $$something "value"
</pre>
<P><LI>Why can't i comment out code intuitively:
<PRE>
    while { $old_test }  {
    #while { $new_test } {
	func
    }
</pre>
<P><LI>Why can't i put braces where i want to?
<PRE>
    if { [ condition 
		"that's very long"
		"with any args
	 ]
    } {

    } 
</pre>

<P><LI>Why can't you access arrays intuitively?  Why must you use
lappend?

<P><LI>Why is there order(n) access time on lists?  Why must all
O(<i>n</i>) algorithm thus turn into O(<i>n<sup>2</sup></i>) and O(<i>n<sup>2</sup></i>) thus
become O(<i>n<sup>3</sup></i>)?  

<P><LI>Why are you forced to pass strings instead of real functions?

<P><LI>Why do runtime errors popup so late rather than 
compile times errors much earlier?

</ul>
