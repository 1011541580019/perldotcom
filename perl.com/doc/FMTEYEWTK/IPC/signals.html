<title> Signals </title>

<CENTER>

<H1> <A NAME="perlipc_signals_0"> Signals</A></H1>
</CENTER>

Perl uses a simple signal handling model: the <STRONG>%SIG</STRONG> hash contains names or
references of user-installed signal handlers.  These handlers will be called
with an argument which is the name of the signal that triggered it.  A
signal may be generated intentionally from a particular keyboard sequence like
control-C or control-Z, sent to you from an another process, or
triggered automatically by the kernel when special events transpire, like
a child process exiting, your process running out of stack space, or 
hitting file size limit.
<p>For example, to trap an interrupt signal, set up a handler like this.
Notice how all we do is set with a global variable and then raise an
exception.  That's because on most systems libraries are not
re-entrant, so calling any <EM>print()</EM> functions (or even anything that needs to
malloc(3) more memory) could in theory trigger a memory fault
and subsequent core dump.
<p>
<XMP>
    sub catch_zap {
        my $signame = shift;
        $shucks++;
        die "Somebody sent me a SIG$signame";
    } 
    $SIG{INT} = 'catch_zap';  # could fail in modules
    $SIG{INT} = \&catch_zap;  # best strategy

</XMP>
<p>The names of the signals are the ones listed out by <CODE>kill -l</CODE> on your
system, or you can retrieve them from the Config module.  Set up an
<STRONG>@signame</STRONG> list indexed by number to get the name and a <STRONG>%signo</STRONG> table
indexed by name to get the number:
<p>
<XMP>
    use Config;
    defined $Config{sig_name} || die "No sigs?";
    foreach $name (split(' ', $Config{sig_name})) {
        $signo{$name} = $i;
        $signame[$i] = $name;
        $i++;
    }   

</XMP>
<p>So to check whether signal 17 and SIGALRM were the same, just do this:
<p>
<XMP>
    print "signal #17 = $signame[17]\n";
    if ($signo{ALRM}) { 
        print "SIGALRM is $signo{ALRM}\n";
    }   

</XMP>
<p>You may also choose to assign the strings <CODE>'IGNORE'</CODE> or <CODE>'DEFAULT'</CODE> as
the handler, in which case Perl will try to discard the signal or do the
default thing.  Some signals can be neither trapped nor ignored, such as
the KILL and STOP (but not the TSTP) signals.  One strategy for
temporarily ignoring signals is to use a <EM>local()</EM> statement, which will be
automatically restored once your block is exited.  (Remember that <EM>local()</EM>
values are "inherited" by functions called from within that block.)
<p>
<XMP>
    sub precious {
        local $SIG{INT} = 'IGNORE';
        &more_functions;
    } 
    sub more_functions {
        # interrupts still ignored, for now...
    } 

</XMP>
<p>Sending a signal to a negative process ID means that you send the signal
to the entire Unix process-group.  This code send a hang-up signal to all
processes in the current process group <EM>except for</EM> the current process
itself:
<p>
<XMP>
    {
        local $SIG{HUP} = 'IGNORE';
        kill HUP => -$$;
        # snazzy writing of: kill('HUP', -$$)
    }

</XMP>
<p>Another interesting signal to send is signal number zero.  This doesn't
actually affect another process, but instead checks whether it's alive
or has changed its UID.  
<p>
<XMP>
    unless (kill 0 => $kid_pid) {
        warn "something wicked happened to $kid_pid";
    } 

</XMP>
<p>You might also want to employ anonymous functions for simple signal
handlers:
<p>
<XMP>
    $SIG{INT} = sub { die "\nOutta here!\n" };

</XMP>
<p>But that will be problematic for the more complicated handlers that need
to re-install themselves.  Because Perl's signal mechanism is currently
based on the signal(3) function from the C library, you may somtimes be so
misfortunate as to run on systems where that function is "broken", that
is, it behaves in the old unreliable SysV way rather than the newer, more
reasonable BSD and POSIX fashion.  So you'll see defensive people writing
signal handlers like this:
<p>
<XMP>
    sub REAPER { 
        $SIG{CHLD} = \&REAPER;  # loathe sysV
        $waitedpid = wait;
    }
    $SIG{CHLD} = \&REAPER;
    # now do something that forks...

</XMP>
<p>or even the more elaborate:
<p>
<XMP>
    use POSIX "wait_h";
    sub REAPER { 
        my $child;
        $SIG{CHLD} = \&REAPER;  # loathe sysV
        while ($child = waitpid(-1,WNOHANG)) {
            $Kid_Status{$child} = $?;
        } 
    }
    $SIG{CHLD} = \&REAPER;
    # do something that forks...

</XMP>
<p>Signal handling is also used for timeouts in Unix,   While safely
protected within an <CODE>eval{}</CODE> block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your <CODE>eval{}</CODE> block.  If it
goes off, you'll use <EM>die()</EM> to jump out of the block, much as you might
using <EM>longjmp()</EM> or <EM>throw()</EM> in other languages.
<p>Here's an example:
<p>
<XMP>
    eval { 
        local $SIG{ALRM} = sub { die "alarm clock restart" };
        alarm 10; 
        flock(FH, 2);   # blocking write lock
        alarm 0; 
    };
    if ($@ and $@ !~ /alarm clock restart/) { die }

</XMP>
<p>For more complex signal handling, you might see the standard POSIX
module.  Lamentably, this is almost entirely undocumented, but
the <EM>t/lib/posix.t</EM> file from the Perl source distribution has some
examples in it.
<p><p><hr>

<P>
<CENTER>
<A HREF="perlipc.html"> overview </a> /
<A HREF="fifo.html"> fifos </a> /
<A HREF="popen.html">pipes</a> /
<A HREF="safepopen.html">safe-pipes</a> /
<A HREF="openplex.html">open2</a> /
<A HREF="sockets.html">sockets</a> /
<A HREF="inet.html">AF_INET</a> /
<A HREF="unix.html">AF_UNIX</a> /
<A HREF="udp.html">udp</a> /
<A HREF="sysv.html">sys5</a>
</CENTER>
<P>

</HTML>
