<title> 
Bidirectional Communication
</title>

<CENTER>
<H1> 
<A NAME="perlipc_bidirectional_0">
Bidirectional Communication</A>
</H1>

</CENTER>
<P>

While this works reasonably well for unidirectional communication, what
about bidirectional communication?  The obvious thing you'd like to do
doesn't actually work:
<p>
<XMP>
    open(KID, "| some program |")

</XMP>
<p>and if you forgot to use the <STRONG>-w</STRONG> flag, then you'll miss out 
entirely on the diagnostic message:
<p>
<XMP>
    Can't do bidirectional pipe at -e line 1.

</XMP>
<p>If you really want to, you can use the standard <EM>open2()</EM> library function
to catch both ends.  There's also an <EM>open3()</EM> for tridirectional I/O so you
can also catch your child's STDERR, but doing so would then require an
awkward <EM>select()</EM> loop and wouldn't allow you to use normal Perl input
operations.
<p>If you look at its source, you'll see that <EM>open2()</EM> uses low-level
primitives like Unix <EM>pipe()</EM> and <EM>exec()</EM> to create all the connections.
While it might have been slightly more efficient by using <EM>socketpair()</EM>, it
would have then been even less portable than it already is.  The <EM>open2()</EM>
and <EM>open3()</EM> functions are  unlikely to work anywhere except on a Unix
system or some other one purporting to be POSIX compliant.
<p>Here's an example of using <EM>open2()</EM>:
<p>
<XMP>
    use FileHandle;
    use IPC::Open2;
    $pid = open2( \*Reader, \*Writer, "cat -u -n" );
    Writer->autoflush(); # default here, actually
    print Writer "stuff\n";
    $got = <Reader>;

</XMP>
<p>The problem with this is that Unix buffering is going to really
ruin your day.  Even though your <CODE>Writer</CODE> filehandle is autoflushed,
and the process on the other end will get your data in a timely manner,
you can't usually do anything to force it to actually give it back to you
in a similarly quick fashion.  In this case, we could, because we 
gave <EM>cat</EM> a <STRONG>-u</STRONG> flag to make it unbuffered.  But very few Unix
commands are designed to operate over pipes, so this seldom works
unless you yourself wrote the program on the other end of the 
double-ended pipe.
<p>A solution to this is the non-standard <EM>Comm.pl</EM> library.  It uses
pseudo-ttys to make your program behave more reasonably:
<p>
<XMP>
    require 'Comm.pl';
    $ph = open_proc('cat -n');
    for (1..10) {
        print $ph "a line\n";
        print "got back ", scalar <$ph>;
    }

</XMP>
<p>This way you don't have to have control over the source code of the
program you're using.  The <EM>Comm</EM> library also has <EM>expect()</EM> 
and <EM>interact()</EM> functions.  Find the library (and hopefully its 
successor <EM>IPC::Chat</EM>) at your nearest CPAN archive as detailed
in the 
<A HREF="perlipc.html#perlipc_see_0"><EM>SEE ALSO</EM></A>
 section below.
<p><p><hr>

<P>
<CENTER>
<A HREF="perlipc.html"> overview </a> /
<A HREF="signals.html"> signals </a> /
<A HREF="fifo.html"> fifos </a> /
<A HREF="popen.html">pipes</a> /
<A HREF="safepopen.html">safe-pipes</a> /
<A HREF="sockets.html">sockets</a> /
<A HREF="inet.html">AF_INET</a> /
<A HREF="unix.html">AF_UNIX</a> /
<A HREF="udp.html">udp</a> /
<A HREF="sysv.html">sys5</a>
</CENTER>
<P>

</HTML>
