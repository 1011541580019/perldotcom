%!PS-Adobe-3.0
%%BoundingBox: 54 72 558 720
%%Creator: Mozilla (NetScape) HTML->PS
%%DocumentData: Clean7Bit
%%Orientation: Portrait
%%Pages: 3
%%PageOrder: Ascend
%%Title: Regexp Backtracking
%%EndComments
%%BeginProlog
[ /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
 /two /three /four /five /six /seven /eight /nine /colon /semicolon
 /less /equal /greater /question /at /A /B /C /D /E
 /F /G /H /I /J /K /L /M /N /O
 /P /Q /R /S /T /U /V /W /X /Y
 /Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c
 /d /e /f /g /h /i /j /k /l /m
 /n /o /p /q /r /s /t /u /v /w
 /x /y /z /braceleft /bar /braceright /asciitilde /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright
 /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf
 /threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde
 /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring
 /ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
 /eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave
 /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis] /isolatin1encoding exch def
/c { matrix currentmatrix currentpoint translate
     3 1 roll scale newpath 0 0 1 0 360 arc setmatrix } bind def
/F0
    /Times-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f0 { /F0 findfont exch scalefont setfont } bind def
/F1
    /Times-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f1 { /F1 findfont exch scalefont setfont } bind def
/F2
    /Times-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f2 { /F2 findfont exch scalefont setfont } bind def
/F3
    /Times-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f3 { /F3 findfont exch scalefont setfont } bind def
/F4
    /Courier findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f4 { /F4 findfont exch scalefont setfont } bind def
/F5
    /Courier-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f5 { /F5 findfont exch scalefont setfont } bind def
/F6
    /Courier-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f6 { /F6 findfont exch scalefont setfont } bind def
/F7
    /Courier-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/f7 { /F7 findfont exch scalefont setfont } bind def
/rhc {
    {
        currentfile read {
	    dup 97 ge
		{ 87 sub true exit }
		{ dup 48 ge { 48 sub true exit } { pop } ifelse }
	    ifelse
	} {
	    false
	    exit
	} ifelse
    } loop
} bind def

/cvgray { % xtra_char npix cvgray - (string npix long)
    dup string
    0
    {
	rhc { cvr 4.784 mul } { exit } ifelse
	rhc { cvr 9.392 mul } { exit } ifelse
	rhc { cvr 1.824 mul } { exit } ifelse
	add add cvi 3 copy put pop
	1 add
	dup 3 index ge { exit } if
    } loop
    pop
    3 -1 roll 0 ne { rhc { pop } if } if
    exch pop
} bind def

/smartimage12rgb { % w h b [matrix] smartimage12rgb -
    /colorimage where {
	pop
	{ currentfile rowdata readhexstring pop }
	false 3
	colorimage
    } {
	exch pop 8 exch
	3 index 12 mul 8 mod 0 ne { 1 } { 0 } ifelse
	4 index
	6 2 roll
	{ 2 copy cvgray }
	image
	pop pop
    } ifelse
} def
/cshow { dup stringwidth pop 2 div neg 0 rmoveto show } bind def
/rshow { dup stringwidth pop neg 0 rmoveto show } bind def
%%EndProlog
%%Page: 1 1
%%BeginPageSetup
/pagelevel save def
54 0 translate
%%EndPageSetup
newpath 0 72 moveto 504 0 rlineto 0 648 rlineto -504 0 rlineto  closepath clip newpath
106.5 703.1 moveto
18 f1
(Backtracking in Regular Expressions) show
393 703.1 moveto
18 f1
( ) show
0 675.2 moveto
12 f0
(A fundamental feature of regular expression matching involves the notion called backtracking. When the) show
0 661.9 moveto
12 f0
(beginning of a pattern succeeds in a way that causes later parts in the pattern to fail, the matching engine) show
0 648.6 moveto
12 f0
(backs up and recalculates the beginning part. Let's say you want to find the word following ``foo'': ) show
0 624.7 moveto
10 f4
(    $_ = "Food is on the foo table.";) show
0 614.2 moveto
10 f4
(    if \( /\\b\(foo\)\\s+\(\\w+\)/i \) {) show
0 603.7 moveto
10 f4
(        print "$2 follows $1.\\n";) show
0 593.2 moveto
10 f4
(    }) show
0 558.5 moveto
12 f0
(When the match runs, it first finds a possible match right at the beginning of the string, and loads up ) show
483.9 558.5 moveto
12 f1
($1) show
0 545.2 moveto
12 f0
(with ``foo''. However, as soon as the matching engine sees that there's no whitespace following the) show
0 531.4 moveto
12 f0
(``foo'' that it had saved in ) show
128.6 531.4 moveto
12 f1
($1) show
140.6 531.4 moveto
12 f0
(, it realizes its mistake and starts over again one character after where it) show
0 518.1 moveto
12 f0
(had had the tentative match. This time it goes all the way until the next ``foo'', which works out, and) show
0 504.8 moveto
12 f0
(you get the expected output of ``table follows foo.'' ) show
0 478.2 moveto
12 f0
(Sometimes minimal matching can help a lot. Imagine you'd like to match everything between ``foo'') show
0 464.9 moveto
12 f0
(and ``bar''. Initially, you write something like this: ) show
0 441 moveto
10 f4
(    $_ =  "The food is under the bar in the barn.";) show
0 430.5 moveto
10 f4
(    if \( /foo\(.*\)bar/ \) {) show
0 420 moveto
10 f4
(        print "got <$1>\\n";) show
0 409.5 moveto
10 f4
(    }) show
0 375.3 moveto
12 f0
(Which perhaps unexpectedly yields: ) show
0 351.4 moveto
10 f4
(  got <d is under the bar in the >) show
0 317.2 moveto
12 f0
(That's because ) show
74.6 317.2 moveto
10 f4
(.*) show
86.6 317.2 moveto
12 f0
( was greedy, so you get everything between the ) show
318.9 317.2 moveto
12 f2
(first) show
338.4 317.2 moveto
12 f0
( ``foo'' and the ) show
414.3 317.2 moveto
12 f2
(last) show
431.8 317.2 moveto
12 f0
( ``bar''. In this) show
0 303.9 moveto
12 f0
(case, it's more effective to use minimal matching to make sure you get the text between a ``foo'' and the) show
0 290.6 moveto
12 f0
(first ``bar'' thereafter. ) show
0 266.7 moveto
10 f4
(    if \( /foo\(.*?\)bar/ \) { print "got <$1>\\n" }) show
0 256.2 moveto
10 f4
(  got <d is under the >) show
0 222 moveto
12 f0
(Here's another example: let's say you'd like to match a number at the end of a string, and you also want) show
0 208.7 moveto
12 f0
(to keep the preceding part the match. So you write this: ) show
0 184.8 moveto
10 f4
(    $_ = "I have 2 numbers: 53147";) show
0 174.3 moveto
10 f4
(    if \( /\(.*\)\(\\d*\)/ \) {) show
0 163.8 moveto
10 f4
(        print "Beginning is <$1>, number is <$2>.\\n";) show
0 153.3 moveto
10 f4
(    }) show
0 118.6 moveto
12 f0
(That won't work at all, because ) show
154.2 118.6 moveto
12 f1
($1) show
166.2 118.6 moveto
12 f0
( was greedy and gobbled up everything, and also because \\d* doesn't) show
0 105.3 moveto
12 f0
(assert the existence of anything, since it can match the null string. ) show
0 81.4 moveto
10 f4
(    Beginning is <I have 2: 53147>, number is <>.) show
pagelevel restore
showpage
%%Page: 2 2
%%BeginPageSetup
/pagelevel save def
54 0 translate
%%EndPageSetup
newpath 0 72 moveto 504 0 rlineto 0 648 rlineto -504 0 rlineto  closepath clip newpath
0 695.2 moveto
12 f0
(Here are some variants, most of which don't work: ) show
0 671.3 moveto
10 f4
(    $_ = "I have 2 numbers: 53147";) show
0 660.8 moveto
10 f4
(    @pats = qw{) show
0 650.3 moveto
10 f4
(        \(.*\)\(\\d*\)) show
0 639.8 moveto
10 f4
(        \(.*\)\(\\d+\)) show
0 629.3 moveto
10 f4
(        \(.*?\)\(\\d*\)) show
0 618.8 moveto
10 f4
(        \(.*?\)\(\\d+\)) show
0 608.3 moveto
10 f4
(        \(.*\)\(\\d+\)$) show
0 597.8 moveto
10 f4
(        \(.*?\)\(\\d+\)$) show
0 587.3 moveto
10 f4
(        \(.*\)\\b\(\\d+\)$) show
0 576.8 moveto
10 f4
(        \(.*\\D\)\(\\d+\)$) show
0 566.3 moveto
10 f4
(    };) show
0 545.3 moveto
10 f4
(    for $pat \(@pats\) {) show
0 534.8 moveto
10 f4
(        printf "%-12s ", $pat;) show
0 524.3 moveto
10 f4
(        if \( /$pat/ \) {) show
0 513.8 moveto
10 f4
(            print "<$1> <$2>\\n";) show
0 503.3 moveto
10 f4
(        } else {) show
0 492.8 moveto
10 f4
(            print "FAIL\\n";) show
0 482.3 moveto
10 f4
(        }) show
0 471.8 moveto
10 f4
(    }) show
0 437.6 moveto
12 f0
(That will print out: ) show
0 413.7 moveto
10 f4
(    \(.*\)\(\\d*\)    <I have 2 numbers: 53147> <>) show
0 403.2 moveto
10 f4
(    \(.*\)\(\\d+\)    <I have 2 numbers: 5314> <7>) show
0 392.7 moveto
10 f4
(    \(.*?\)\(\\d*\)   <> <>) show
0 382.2 moveto
10 f4
(    \(.*?\)\(\\d+\)   <I have > <2>) show
0 371.7 moveto
10 f4
(    \(.*\)\(\\d+\)$   <I have 2 numbers: 5314> <7>) show
0 361.2 moveto
10 f4
(    \(.*?\)\(\\d+\)$  <I have 2 numbers: > <53147>) show
0 350.7 moveto
10 f4
(    \(.*\)\\b\(\\d+\)$ <I have 2 numbers: > <53147>) show
0 340.2 moveto
10 f4
(    \(.*\\D\)\(\\d+\)$ <I have 2 numbers: > <53147>) show
0 306 moveto
12 f0
(As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of) show
0 292.7 moveto
12 f0
(assertions that gives a definition of success. There may be 0, 1, or several different ways that the) show
0 279.4 moveto
12 f0
(definition might succeed against a particular string. And if there are multiple ways it might succeed, you) show
0 266.1 moveto
12 f0
(need to understand backtracking in order to know which variety of success you will achieve. ) show
0 239.5 moveto
12 f0
(When using lookahead assertions and negations, this can all get even tricker. Imagine you'd like to find) show
0 226.2 moveto
12 f0
(a sequence of nondigits not followed by ``123''. You might try to write that as ) show
0 202.3 moveto
10 f4
(        $_ = "ABC123";) show
0 191.8 moveto
10 f4
(        if \( /^\\D*\(?!123\)/ \) {) show
0 181.3 moveto
10 f4
(            print "Yup, no 123 in $_\\n";) show
0 170.8 moveto
10 f4
(        }) show
0 136.6 moveto
12 f0
(But that won't work at all; at least, not the way you're hoping: it claims that there is no 123 in the string.) show
0 123.3 moveto
12 f0
(Here's a clearer picture of why not: ) show
0 99.4 moveto
10 f4
(    $x = 'ABC123' ;) show
0 88.9 moveto
10 f4
(    $y = 'ABC445' ;) show
0 78.4 moveto
10 f4
(    print "1: got $1\\n" if $x =~ /^\(ABC\)\(?!123\)/ ;) show
pagelevel restore
showpage
%%Page: 3 3
%%BeginPageSetup
/pagelevel save def
54 0 translate
%%EndPageSetup
newpath 0 72 moveto 504 0 rlineto 0 648 rlineto -504 0 rlineto  closepath clip newpath
0 711.9 moveto
10 f4
(    print "2: got $1\\n" if $y =~ /^\(ABC\)\(?!123\)/ ;) show
0 701.4 moveto
10 f4
(    print "3: got $1\\n" if $x =~ /^\(\\D*\)\(?!123\)/ ;) show
0 690.9 moveto
10 f4
(    print "4: got $1\\n" if $y =~ /^\(\\D*\)\(?!123\)/ ;) show
0 656.7 moveto
12 f0
(This prints ) show
0 632.8 moveto
10 f4
(    2: got ABC) show
0 622.3 moveto
10 f4
(    3: got AB) show
0 611.8 moveto
10 f4
(    4: got ABC) show
0 577.6 moveto
12 f0
(Many people wouldn't have expected test 3 to succeed. What's happening is that we've asked ``Is it true) show
0 563.8 moveto
12 f0
(that at the start of ) show
86.9 563.8 moveto
12 f1
($x) show
98.9 563.8 moveto
12 f0
(, following 0 or more nondigits, we have something that's not 123?'' If the pattern) show
0 550.5 moveto
12 f0
(matcher had let ) show
76.9 550.5 moveto
10 f4
(\\D*) show
94.9 550.5 moveto
12 f0
( expand to ``ABC'', this would have caused the whole pattern to fail. But the pattern) show
0 537.2 moveto
12 f0
(really, ) show
33.3 537.2 moveto
12 f2
(really) show
61.2 537.2 moveto
12 f0
( wants to succeed, so it uses the standard regexp backoff-and-retry and lets ) show
423.1 537.2 moveto
10 f4
(\\D*) show
441.1 537.2 moveto
12 f0
( expand to) show
0.8 523.9 moveto
12 f0
(just ``AB'' this time. Now there's indeed something following ``AB'' that is not ``123''. It's in fact) show
0 510.6 moveto
12 f0
(``C123'', which suffices. ) show
0 483.5 moveto
12 f0
(We can deal with this by using both an assertion and a negation. We'll say that the first part in ) show
455.6 483.5 moveto
12 f1
($1) show
467.6 483.5 moveto
12 f0
( must) show
0 470.2 moveto
12 f0
(be followed by a digit, and in fact, it must also be followed by something that's not ``123''. Remember) show
0 456.9 moveto
12 f0
(that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in) show
0 443.6 moveto
12 f0
(their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6) show
0 430.3 moveto
12 f0
(succeeds: ) show
0 406.4 moveto
10 f4
(    print "5: got $1\\n" if $x =~ /^\(\\D*\)\(?=\\d\)\(?!123\)/ ;) show
0 395.9 moveto
10 f4
(    print "6: got $1\\n" if $y =~ /^\(\\D*\)\(?=\\d\)\(?!123\)/ ;) show
0 385.4 moveto
10 f4
(    6: got ABC) show
0 351.2 moveto
12 f0
(In other words, the two zero-width assertions next to each other work like they're ANDed together, just) show
0 337.9 moveto
12 f0
(as you'd use any builtin assertions: ) show
171.3 337.9 moveto
10 f4
(/^$/) show
195.3 337.9 moveto
12 f0
( matches only if you're at the beginning of the line AND the) show
0 324.6 moveto
12 f0
(end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions) show
0 311.3 moveto
12 f0
(always means AND, except when you write an explicit OR using the vertical bar. ) show
393.9 311.3 moveto
10 f4
(/ab/) show
417.9 311.3 moveto
12 f0
( means match) show
0 298 moveto
12 f0
(``a'' AND \(then\) match ``b'', although the attempted matches are made at different positions because) show
0 284.7 moveto
12 f0
(``a'' is not a zero-width assertion, but a one-width assertion. ) show
pagelevel restore
showpage
%%EOF
