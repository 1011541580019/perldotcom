<HTML>
<HEAD><TITLE>Compilation vs Interpretation in Perl</TITLE></HEAD>

<BODY>

<UL><TABLE BORDER=0 CELLPADDING=0>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>From:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
		Tom Christiansen
		<A HREF="mailto:tchrist@mox.perl.com">&lt;tchrist@mox.perl.com&gt;</A>
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Newsgroups:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
		<A HREF="news:comp.lang.perl.modules">comp.lang.perl.modules</A>,
		<A HREF="news:comp.lang.perl.misc">comp.lang.perl.misc</A>
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Subject:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
<I><B>FMTEYEWTK <big>about Compilation vs Interpretation in Perl</big></B>
	<small> (was: <i>Question: Compile vs. Run time?)</i></small></i>
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Date:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
    1 Jun 1996 14:49:55 GMT
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Organization:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
		Perl Consulting and Training
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Message-ID:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
 <A HREF="news:4oplaj$rau@csnews.cs.colorado.edu">&lt;4oplaj$rau@csnews.cs.colorado.edu&gt;</a>
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>References:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
 <A HREF="news:4ono8h$hhe@bastion4.hal.com">&lt;4ono8h$hhe@bastion4.hal.com&gt;</a>
	    </TD>
	</TR>

    <DD><TR>
	    <TD ALIGN=RIGHT>
		<big><B>Keywords:&nbsp;&nbsp;</B></big>
	    </TD>
	    <TD>
perl5,compile,run,use,require
	    </TD>
	</TR>

</TABLE> </UL>
		
<HR>

<P>

In <A HREF="news:comp.lang.perl.misc">comp.lang.perl.misc</A>, <A
HREF="mailto:berggren@hal.com">berggren@hal.com</a> writes:

<i>
<blockquote>
I read in the perl5 docs that "use Module" imports the Module.pm
exported names at compile time, whereas the "require Module"
loads the module only at run time.  Can someone please explain
the difference here?  I thought that Perl(5) is an interpreted
language, and is neither compiled nor run.  When I'm running my
script, when is the compile time, and when is the run time?
</blockquote>
</i>

Charitably put, I fear you have an overly na&iuml;ve definition of the
technical terms ``compile'' and ``interpret'' as applied to programming
languages and programs.

<p>

With the possible exception of the <tt>eval("string")</tt> facility, nothing
in the de facto definition of the perl language will clue you in about
whether it's compiled or interpreted.  In fact, these terms don't even
make a great deal of sense if you look at it a bit.  Let's do that now.

<p>
The perl executable you are using has two distinct stages.  First comes
the frontend, which is certainly a compiler of sorts.  It compiles your
perl program source into a parse tree.  This compiler then performs
various optimizations such as one would find in any other compiler,
including throwing out unreachable code, reducing constant expressions to
their results, and loading in certain library definitions.  It is at this
point that the use statements get run, since they are semantically
equivalent to <tt>BEGIN{}</tt> blocks wrapping a <tt>require</tt> and an
<i>import()</i> class-method call against the included module.

<p>
End of compilation.

<p>
Next comes the backend, which is certainly an interpreter of sorts; let's
call it a PP interpreter for now, just because.  While what it actually
executes is a parse tree and not byte code per se, still we would not go
wrong in classifying this backend as a byte-code interpreter (like java or
python).  This is useful in particular when it comes to distinguishing
these languages from ``pure'' interpreters, such as most shell and tcl
implementations you happen to run.  This is where any requires not wrapped
in BEGINs occur.

<blockquote>

    [The reason it's called a PP interpreter is that it's pretending to be
     a virtual machine implementing instructions whose names are things
     like <t>pp_rv2gv</tt>, <tt>pp_chomp</tt>, <tt>pp_ge</tt>, <tt>pp_each</tt>, <tt>pp_split,</tt> and <tt>pp_backtick</tt>.
     See the perl source code itself for details.  This virtual machine's
     language is defined in <tt>pp.h</tt>, and implemented in files like <tt>pp.c</tt>,
     <tt>pp_ctl.c</tt>, <tt>pp_hot.c</tt>, and <tt>pp_sys.c</tt> if you're curious (or even if you're
     not).]

</blockquote>
From the frontend (the ``source-code to parse-tree'' compiler), you can get
at the backend (the PP interpreter) via a <tt>BEGIN</tt> subroutine.
Likewise, to go the other way (get back to the compiler from the
interpreter), you can use an <tt>eval("string")</tt> or a <tt>s/foo/bar/ee</tt> notation.
By the way, despite appearances to the contrary, it turns out that an <tt>eval
{ BLOCK }</tt> and <tt>s/foo/bar/e</tt> are not actually hooks back to the compiler; it
already handled them long ago and far away.)

<p>
Does that make sense?  Think of every call to
<pre>
    $ perl somescript
</pre>

as being

<pre>
    $ perl-compiler &lt; somescript | perl-interpreter
</pre>

At no point did our perl compiler as described above engage in the actual
generation of C code, assembly language, nor machine code take place.

<p>
The seldom-(successfully)-used <i>dump()</i> function and the <b>-u</b> command line
flag provide a way to skip the first stage in that pipeline, but you still
have the parse trees and the PP interpreter in that huge dumped file,
which you must somehow massage into an a.out, usually using the <b>undump</b>
program from the <b>TeX</b> distribution or linking against the C function
<i>unexec()</i> from <b>GNU emacs</b>.  This is normally never done, because the file is
huge and it darned hard to actually get it to work.  As a mere starting
point, you'd have to link your perl executable statically not dynamically,
but it's still extremely hard to get to work for a particular
architecture.  I'm not sure whether it's even ever been done on anything
but a Sun.

<p>
As a brief diversion, let's look at compilation on more traditional system
in which code generation is typically handled by a compiler backend.  For
example, if you were running a Convex system, you might well have a
Fortran, C, and an Ada compiler, which all produce a common intermediary
form.  This intermediary code (whether it be a raw parse-tree or some
hypothetical virtual machine's assembly language, that is: byte code) in
then fed into a a backend code-generator then optimizes and spits out
assembly language, which is in turn fed to the assembler to produce
machine code.  Later on when you ``execute'' this machine code, it is in
turn fed to the firmware interpreter largely implemented in hardware.

<p>
Now, at the risk of further confusing you, permit me to tell you about
something else.  Currently in early public alpha release, a ``perl
compiler'' exists, which will surely blur these distinctions even further.
We throw out the traditional back, and substitute in a new stage.  This
``middle-end'' (as it were) takes the frontend's parse tree code produces as
its output an intermediary byte code form (perl byte code, or PBC).

<p>
Three different backends grok this PBC:

<ol>
<p>

    <li>A byte-code interpreter, or if you would, a perl virtual machine
       if you've been indoctrinated into the java terminology.  This still needs
       the old backend parse-tree interpreter sitting around somewhere.

    <p><li>A code generator that produces compilable C code. This is essentially
       an unroller (or perhaps unraveller) of the parse-tree interpreter.
       That is, it traces the code path that the interpreter would execute.

    <p><li>Another code-generator that produces compilable C code, except that
       this one doesn't just trace the steps the interpreter would have
       followed, but actually produces optimized code (for example, it
       would work with raw integers directly rather than calling the
       interpreter calls that would have done so).


</uL>
<p>
If your code makes use of any dynamically-loaded modules (like POSIX,
Socket, Fcntl, FileHandle, etc.), then you must keep those modules' binary
forms (POSIX.so, Socket.so, etc) around so they can be found when your
executable gets run.  Both backends one and two alleviate the need to
store the original, pre-compiled source code anywhere.  Backends two and
three alleviate the need to keep the old PP interpreter lying about.
Backend number three is the only one which is going to speed up execution
time when compared with the old PP interpreter.

<p>

There, I hope that's all clear now. :-)

<p>

--tom
<HR>
<DL COMPACT>
<DT>PS:<DD>For more information, see the <A HREF="/perl/news/compiler-alpha1.html">alpha announcement</a> that
Malcolm made.
</DL>
</BODY>
</HTML>
<HR>
Return to:
<UL>
<LI>The <A HREF="index.html">FMTYEWTK index page</a>.
<LI>The <A HREF="/perl/index.html">Perl home page</a>.
</UL>
<HR>
Copyright 1996 <A HREF="mailto:tchrist@perl.com">Tom Christiansen</a>.
<BR>All rights reserved.
