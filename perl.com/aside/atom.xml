<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Perl.com</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/" />
    <link rel="self" type="application/atom+xml" href="http://com.perl.org/atom.xml" />
    <id>tag:com.perl.org,2010-06-20://1</id>
    <updated>2010-06-20T16:31:35Z</updated>
    
    <generator uri="http://www.sixapart.com/movabletype/">Movable Type Pro 5.02</generator>

<entry>
    <title>Beginner&apos;s Introduction to Perl 5.10, Part 2</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html" />
    <id>tag:com.perl.org,2008:/pub//2.648</id>

    <published>2008-05-07T07:00:00Z</published>
    <updated>2010-06-20T16:31:35Z</updated>

    <summary> A Beginner&apos;s Introduction to Perl 5.10 talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the for statement). Now it&apos;s time to interact with the world. (A Beginner&apos;s Introduction...</summary>
    <author>
        <name>chromatic</name>
        
    </author>
    
        <category term="Tutorials" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="files" label="files" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl510" label="Perl 5.10" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlfilehandles" label="Perl filehandles" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="string" label="string" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p><a href="http://www.perl.com/pub/a/2008/04/23/a-beginners-introduction-to-perl-510.html">A Beginner's Introduction to Perl 5.10</a> talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the <code>for</code> statement). Now it's time to interact with the world.  (<a href="http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Regular Expressions with Perl 5.10</a> explores regular expressions, matching, and substitutions.  <a href="http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Perl Web Programming</a> demonstrates how to write web programs.)</p>

<p>This installment discusses how to slice and dice strings, how to play with files and how to define your own functions. First, you need to understand one more core concept of the Perl language: conditions and comparisons.</p>

<h3>Comparison operators</h3>

<p>Like all good programming languages, Perl allows you ask questions such as "Is this number greater than that number?" or "Are these two strings the same?" and do different things depending on the answer.</p>

<p>When you're dealing with numbers, Perl has four important operators: <code>&lt;</code>, <code>&gt;</code>, <code>==</code> and <code>!=</code>. These are the "less than," "greater than," "equal to" and "not equal to" operators. (You can also use <code>&lt;=</code>, "less than or equal to," and <code>&gt;=</code>, "greater than or equal to.)</p>

<p>You can use these operators along with one of Perl's <em>conditional</em> keywords, such as <code>if</code> and <code>unless</code>. Both of these keywords take a condition that Perl will test, and a block of code in curly brackets that Perl will run if the test works. These two words work just like their English equivalents -- an <code>if</code> test succeeds if the condition turns out to be true, and an <code>unless</code> test succeeds if the condition turns out to be false:</p>

<pre><code>use 5.010;

if ($year_according_to_computer == 1900) {
    say "Y2K has doomed us all!  Everyone to the compound.";
}

unless ($bank_account &gt; 0) {
    say "I'm broke!";
}</code></pre>

<p>Be careful of the difference between <code>=</code> and <code>==</code>! One equals sign means "assignment", two means "comparison for equality". This is a common, evil bug:</p>

<pre><code>use 5.010;

if ($a = 5) {
    say "This works - but doesn't do what you want!";
}</code></pre>

<p>You may be asking what that extra line of code at the start does. Just like the <code>use feature :5.10;</code> code from the previous article, this enables new features of Perl 5.10. (Why 5.010 and not 5.10? The version number is not a single decimal; there may eventually be a Perl 5.100, but probably not a Perl 5.1000. Just trust me on this for now.)</p>

<p>Instead of testing whether <code>$a</code> is equal to five, you've made <code>$a</code> equal to five and clobbered its old value. (A future article will show how to avoid this bug in running code.)</p>

<p>Both <code>if</code> and <code>unless</code> can be followed by an <code>else</code> statement and code block, which executes if your test failed. You can also use <code>elsif</code> to chain together a bunch of <code>if</code> statements:</p>

<pre><code>use 5.010;

if ($a == 5) {
    say "It's five!";
} elsif ($a == 6) {
    say "It's six!";
} else {
    say "It's something else.";
}

unless ($pie eq 'apple') {
    say "Ew, I don't like $pie flavored pie.";
} else {
    say "Apple!  My favorite!";
}</code></pre>

<p>You don't always need an <code>else</code> condition, and sometimes the code to execute fits on a single line. In that case, you can use <em>postfix conditional</em> statements. The name may sound daunting, but you already understand them if you can read this sentence.</p>

<pre><code>use 5.010;

say "I'm leaving work early!" if $day eq 'Friday';

say "I'm burning the 7 pm oil" unless $day eq 'Friday';</code></pre>

<p>Sometimes this can make your code clearer.</p>

<h3><code>while</code> and <code>until</code></h3>

<p>Two slightly more complex keywords are <code>while</code> and <code>until</code>. They both take a condition and a block of code, just like <code>if</code> and <code>unless</code>, but they act like loops similar to <code>for</code>. Perl tests the condition, runs the block of code and runs it over and over again for as long as the condition is true (for a <code>while</code> loop) or false (for a <code>until</code> loop).</p>

<p>Try to guess what this code will do:</p>

<pre><code>use 5.010;

my $count = 0;

while ($count != 3) {
   $count++;
   say "Counting up to $count...";
}

until ($count == 0) {
   $count--;
   say "Counting down to $count...";
}</code></pre>

<p>Here's what you see when you run this program:</p>

<pre><code>Counting up to 1...
Counting up to 2...
Counting up to 3...
Counting down to 2...
Counting down to 1...
Counting down to 0...</code></pre>

<h3>String comparisons</h3>

<p>That's how you compare numbers. What about strings? The most common string comparison operator is <code>eq</code>, which tests for <em>string equality</em> -- that is, whether two strings have the same value.</p>

<p>Remember the pain of mixing up <code>=</code> and <code>==</code>? You can also mix up <code>==</code> and <code>eq</code>. This is one of the few cases where it <em>does</em> matter whether Perl treats a value as a string or a number. Try this code:</p>

<pre><code>use 5.010;

my $yes_no = 'no';
say "How positive!" if $yes_no == 'yes';</code></pre>

<p>Why does this code think you said yes? Remember that Perl automatically converts strings to numbers whenever it's necessary; the <code>==</code> operator implies that you're using numbers, so Perl converts the value of <code>$yes_no</code> ("no") to the number 0, and "yes" to the number 0 as well. Because this equality test works (0 is equal to 0), the condition is true. Change the condition to <code>$yes_no eq 'yes'</code>, and it'll do what it should.</p>

<p>Things can work the other way, too. The number five is <em>numerically</em> equal to the string <code>" 5 "</code>, so comparing them to <code>==</code> works. When you compare five and <code>" 5 "</code> with <code>eq</code>, Perl will convert the number to the string <code>"5"</code> first, and then ask whether the two strings have the same value. Because they don't, the <code>eq</code> comparison fails. This code fragment will print <code>Numeric equality!</code>, but not <code>String equality!</code>:</p>

<pre><code>use 5.010;

my $five = 5;

say "Numeric equality!" if $five == " 5 ";
say "String equality!"  if $five eq " 5 ";</code></pre>













<h3>More fun with strings</h3>

<p>You'll often want to manipulate strings: Break them into smaller pieces, put them together and change their contents. Perl offers three functions that make string manipulation easy and fun: <code>substr()</code>, <code>split()</code>, and <code>join()</code>.</p>

<p>If you want to retrieve part of a string (say, the first four characters or a 10-character chunk from the middle), use the <code>substr()</code> function. It takes either two or three parameters: the string you want to look at, the character position to start at (the first character is position 0) and the number of characters to retrieve. If you leave out the number of characters, you'll retrieve everything up to the end of the string.</p>

<pre><code>my $greeting = "Welcome to Perl!\n";

print substr($greeting, 0, 7);     # "Welcome"
print substr($greeting, 7);        # " to Perl!\n"</code></pre>

<p>A neat and often-overlooked thing about <code>substr()</code> is that you can use a <em>negative</em> character position. This will retrieve a substring that begins with many characters from the <em>end</em> of the string.</p>

<pre><code>my $greeting = "Welcome to Perl!\n";

print substr($greeting, -6, 4);      # "Perl"</code></pre>

<p>(Remember that inside double quotes, <code>\n</code> represents the single new-line character.)</p>

<p>You can also manipulate the string by using <code>substr()</code> to assign a new value to part of it. One useful trick is using a length of zero to <em>insert</em> characters into a string:</p>

<pre><code>my $greeting = "Welcome to Java!\n";

substr($greeting, 11, 4) = 'Perl';    # $greeting is now "Welcome to Perl!\n";
substr($greeting, 7, 3)  = '';        #       ... "Welcome Perl!\n";
substr($greeting, 0, 0)  = 'Hello. '; #       ... "Hello. Welcome Perl!\n";</code></pre>

<p><code>split()</code> breaks apart a string and returns a list of the pieces. <code>split()</code> generally takes two parameters: a <em>regular expression</em> to split the string with and the string you want to split. (The next article will discuss regular expressions in more detail; for the moment, all you need to know is that this regular expression represents a single space character: <code>/ /</code>.) The characters you split won't show up in any of the list elements.</p>

<pre><code>my $greeting = "Hello. Welcome Perl!\n";
my @words    = split(/ /, $greeting);   # Three items: "Hello.", "Welcome", "Perl!\n"</code></pre>

<p>You can also specify a third parameter: the maximum number of items to put in your list. The splitting will stop as soon as your list contains that many items:</p>

<pre><code>my $greeting = "Hello. Welcome Perl!\n";
my @words    = split(/ /, $greeting, 2);   # Two items: "Hello.", "Welcome Perl!\n";</code></pre>

<p>Of course, what you can split, you can also <code>join()</code>. The <code>join()</code> function takes a list of strings and attaches them together with a specified string between each element, which may be an empty string:</p>

<pre><code>my @words         = ("Hello.", "Welcome", "Perl!\n");
my $greeting      = join(' ', @words);       # "Hello. Welcome Perl!\n";
my $andy_greeting = join(' and ', @words);   # "Hello. and Welcome and Perl!\n";
my $jam_greeting  = join('', @words);        # "Hello.WelcomePerl!\n";</code></pre>

<h3>Filehandles</h3>

<p>That's enough about strings. It's time to consider files -- after all, what good is string manipulation if you can't do it where it counts?</p>

<p>To read from or write to a file, you have to <em>open</em> it. When you open a file, Perl asks the operating system if the file is accessible -- does the file exist if you're trying to read it (or can it be created if you're trying to create a new file), and do you have the necessary file permissions to do what you want? If you're allowed to use the file, the operating system will prepare it for you, and Perl will give you a <em>filehandle</em>.</p>

<p>Ask Perl to create a filehandle for you by using the <code>open()</code> function, which takes two or three arguments: the filehandle you want to create, the mode of the file, and the file you want to work with. First, we'll concentrate on reading files. The following statement opens the file <em>log.txt</em> using the filehandle <code>$logfile</code>:</p>

<pre><code>open my $logfile, 'log.txt';</code></pre>

<p>Opening a file involves several behind-the-scenes tasks that Perl and the operating system undertake together, such as checking that the file you want to open actually exists (or creating it if you're trying to create a new file) and making sure you're allowed to manipulate the file (do you have the necessary file permissions, for instance). Perl will do all of this for you, so in general you don't need to worry about it.</p>

<p>Once you've opened a file to read, you can retrieve lines from it by using the <code>&lt;&gt;</code> construct, also known as <code>readline</code>. Inside the angle brackets, place your filehandle. What you get from this depends on what you <em>want</em> to get: in a scalar context (a more technical way of saying "if you're assigning it to a scalar"), you retrieve the next line from the file, but if you're looking for a list, you get a list of all the remaining lines in the file.</p>

<p>You can, of course, <code>close</code> a filehandle that you've opened. You don't always have to do this, because Perl is clever enough to close a filehandle when your program ends, when you try to reuse an existing filehandle, or when the lexical variable containing the filehandle goes out of scope.</p>

<p>Here's a simple program that will display the contents of the file <em>log.txt</em>, and assumes that the first line of the file is its title:</p>

<pre><code>open my $logfile, 'log.txt' or die "I couldn't get at log.txt: $!";

my $title = &lt;$logfile&gt;;
print "Report Title: $title";

print while &lt;$logfile&gt;;
close $logfile;</code></pre>

<p>That code may seem pretty dense, but it combines ideas you've seen before. The <code>while</code> operator loops over every line of the file, one line at a time, putting each line into the Perl pronoun <code>$_</code>. (A pronoun? Yes -- think of it as <em>it</em>.) For each line read, Perl <code>prints</code> the line. Now the pronoun should make sense. While you read it from the file, print it.</p>

<p>Why not use <code>say</code>? Each <em>line</em> in the file ends with a newline -- that's how Perl knows that it's a line. There's no need to add an additional newline, so <code>say</code> would double-space the output.</p>

<h3>Writing files</h3>

<p>You also use <code>open()</code> when you are writing to a file. There are two ways to open a file for writing: <em>overwrite</em> and <em>append</em>. When you open a file in overwrite mode, you erase whatever it previously contained. In append mode, you attach your new data to the end of the existing file without erasing anything that was already there.</p>

<p>To indicate that you want a filehandle for writing, use a single <code>&gt;</code> character as the mode passed to <code>open</code>. This opens the file in overwrite mode. To open it in append mode, use two <code>&gt;</code> characters.</p>

<pre><code>open my $overwrite, '&gt;', 'overwrite.txt' or die "error trying to overwrite: $!";
# Wave goodbye to the original contents.

open my $append, '&gt;&gt;', 'append.txt' or die "error trying to append: $!";
# Original contents still there; add to the end of the file</code></pre>

<p>Once your filehandle is open, use the humble <code>print</code> or <code>say</code> operator to write to it. Specify the filehandle you want to write to and a list of values you want to write:</p>

<pre><code>use 5.010;

say $overwrite 'This is the new content';
print $append "We're adding to the end here.\n", "And here too.\n";</code></pre>

<h3>Live free or die!</h3>

<p>Most of these <code>open()</code> statements include <code>or die "some sort of message"</code>. This is because we live in an imperfect world, where programs don't always behave exactly the way we want them to. It's always possible for an <code>open()</code> call to fail; maybe you're trying to write to a file that you're not allowed to write, or you're trying to read from a file that doesn't exist. In Perl, you can guard against these problems by using <code>or</code> and <code>and</code>.</p>

<p>A series of statements separated by <code>or</code> will continue until you hit one that works, or returns a true value. This line of code will either succeed at opening <code>$output</code> in overwrite mode, or cause Perl to quit:</p>

<pre><code>open my $output, '&gt;', $outfile or die "Can't write to '$outfile': $!";</code></pre>

<p>The <code>die</code> statement ends your program with an error message. The special variable <code>$!</code> contains Perl's explanation of the error. In this case, you might see something like this if you're not allowed to write to the file. Note that you get both the actual error message ("Permission denied") and the line where it happened:</p>

<pre><code>Can't write to 'a2-die.txt': Permission denied at ./a2-die.pl line 1.</code></pre>

<p>Defensive programming like this is useful for making your programs more error-resistant -- you don't want to write to a file that you haven't successfully opened! (Putting single-quotes around the filename may help you see any unexpected whitespace in the filename. You'll slap your forehead when it happens to you.)</p>

<p>Here's an example: As part of your job, you write a program that records its results in a file called <em>vitalreport.txt</em>. You use the following code:</p>

<pre><code>open my $vital, '&gt;', 'vitalreport.txt';</code></pre>

<p>If this <code>open()</code> call fails (for instance, <em>vitalreport.txt</em> is owned by another user who hasn't given you write permission), you'll never know it until someone looks at the file afterward and wonders why the vital report wasn't written. (Just imagine the joy if that "someone" is your boss, the day before your annual performance review.) When you use <code>or die</code>, you avoid all this:</p>

<pre><code>open my $vital, '&gt;', 'vitalreport.txt' or die "Can't write vital report: $!";</code></pre>

<p>Instead of wondering whether your program wrote your vital report, you'll immediately have an error message that both tells you what went wrong and on what line of your program the error occurred.</p>

<p>You can use <code>or</code> for more than just testing file operations:</p>

<pre><code>use 5.010;
($pie eq 'apple') or ($pie eq 'cherry') or ($pie eq 'blueberry')
        or say 'But I wanted apple, cherry, or blueberry!';</code></pre>

<p>In this sequence, if you have an appropriate pie, Perl skips the rest of the chain. Once one statement works, the rest are ignored. The <code>and</code> operator does the opposite: It evaluates your chain of statements, but stops when one of them <em>doesn't</em> work.</p>

<pre><code>open my $log, 'log.file' and say 'Logfile is open!';
say 'Logfile is open!' if open my $log, 'log.file';</code></pre>

<p>This statement will only show you the words <em>Logfile is open!</em> if the <code>open()</code> succeeds -- do you see why?</p>

<p>Again, just because there's more than one way to execute code conditionally doesn't mean you have to use every way in a single program or the most clever or creative way. You have plenty of options. Consider using the most readable one for the situation.</p>













<h3>Subs</h3>

<p>So far, the example Perl programs have been a bunch of statements in series. This is okay if you're writing very small programs, but as your needs grow, you'll find it limiting. This is why most modern programming languages allow you to define your own functions; in Perl, we call them <em>subs</em>.</p>

<p>A sub, declared with the <code>sub</code> keyword, adds a new function to your program's capabilities. When you want to use this new function, you call it by name. For instance, here's a short definition of a sub called <code>boo</code>:</p>

<pre><code>use 5.010;

sub boo {
    say 'Boo!';
}

boo();   # Eek!</code></pre>

<p>Subs are useful because they allow you to break your program into small, reusable chunks. If you need to analyze a string in four different places in your program, it's much easier to write one <code>analyze_string</code> sub and call it four times. This way, when you make an improvement to your string-analysis routine, you'll only need to do it in one place, instead of four.</p>

<p>In the same way that Perl's built-in functions can take parameters and can return values, your subs can, too. Whenever you call a sub, any parameters you pass to it appear in the special array <code>@_</code>. You can also return a single value or a list by using the <code>return</code> keyword.</p>

<pre><code>use 5.010;

sub multiply {
    my (@ops) = @_;
    return $ops[0] * $ops[1];
}

for my $i (1 .. 10) {
     say "$i squared is ", multiply($i, $i);
}</code></pre>

<p>There's an interesting benefit from using the the <code>my</code> keyword in <code>multiply</code>? It indicates that the variables are private to that sub, so that any existing value for the <code>@ops</code> array used elsewhere in our program won't get overwritten. This means that you'll evade a whole class of hard-to-trace bugs in your programs. You don't <em>have</em> to use <code>my</code>, but you also don't <em>have</em> to avoid smashing your thumb when you're hammering nails into a board. They're both just good ideas.</p>

<p>You can also assign to multiple lexical variables (declared with <code>my</code>) in a single statement. You can change the code within <code>multiply</code> to something like this without having to modify any other code:</p>

<pre><code>sub multiply {
    my ($left, $right) = @_;
    return $left * $right;
}</code></pre>

<p>If you don't expressly use the <code>return</code> statement, the sub returns the result of the last statement. This implicit return value can sometimes be useful, but it does reduce your program's readability. Remember that you'll read your code many more times than you write it!</p>

<h3>Putting it all together</h3>

<p>The previous article demonstrated a simple interest calculator. You can make it more interesting by writing the interest table to a file instead of to the screen. Another change is to break the code into subs to make it easier to read and maintain.</p>

<p><a href="http://www.perl.com/2000/11/compound_interest_file.pl">[Download this program]</a></p>

<pre><code>#! perl

# compound_interest_file.pl - the miracle of compound interest, part 2

use 5.010;

use strict;
use warnings;

# First, we'll set up the variables we want to use.
my $outfile   = 'interest.txt';    # This is the filename of our report.
my $nest_egg  = 10000;             # $nest_egg is our starting amount
my $year      = 2008;              # This is the starting year for our table.
my $duration  = 10;                # How many years are we saving up?
my $apr       = 9.5;               # This is our annual percentage rate.

my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );

sub open_report {
    my ($outfile) = @_;
    open my $report, '&gt;', $outfile or die "Can't open '$outfile': $!";
    return $report;
}

sub print_headers {
    my ($report_fh) = @_;

    # Print the headers for our report.
    say $report_fh "Year\tBalance\tInterest\tNew balance";
}

sub calculate_interest {
    # Given a nest egg and an APR, how much interest do we collect?
    my ( $nest_egg, $apr ) = @_;

    return int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
}

sub interest_report {
    # Get our parameters.  Note that these variables won't clobber the
    # global variables with the same name.
    my ( $report_fh, $nest_egg, $year, $duration, $apr ) = @_;

    # Calculate interest for each year.
    for my $i ( 1 .. $duration ) {
        my $interest = calculate_interest( $nest_egg, $apr );
        my $line     =
            join "\t", $year + $i, $nest_egg, $interest, $nest_egg + $interest;

        say $report_fh $line;

        $nest_egg += $interest;
    }
}

sub report_footer {
    my ($report_fh, $nest_egg, $duration, $apr) = @_;

    say $report_fh "\n Our original assumptions:";
    say $report_fh "   Nest egg: $nest_egg";
    say $report_fh "   Number of years: $duration";
    say $report_fh "   Interest rate: $apr";
}</code></pre>

<p>Notice how much clearer the program logic becomes when you break it down into subs. One nice quality of a program written as small, well-named subs is that it almost becomes <em>self-documenting</em>. Consider these four lines:</p>

<pre><code>my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );</code></pre>

<p>Code like this is invaluable when you come back to it six months later and need to figure out what it does -- would you rather spend your time reading the entire program trying to figure it out or read four lines that tell you the program 1) opens a report file, 2) prints some headers, 3) generates an interest report, and 4) prints a report footer?</p>

<h3>Play around!</h3>

<p>This article has explored files (filehandles, <code>open()</code>, <code>close()</code>, and <code>&lt;&gt;</code>), string manipulation (<code>substr()</code>, <code>split()</code> and <code>join()</code>) and subs. Here's a pair of exercises -- again, one simple and one complex:</p>

<ul>
<li>You have a file called <em>dictionary.txt</em> that contains dictionary definitions, one per line, in the format "word <code>space</code> definition". (<a href="http://www.perl.com/2000/11/dictionary.txt">Here's a sample</a>.) Write a program that will look up a word from the command line. (Hints: <code>@ARGV</code> is a special array that contains your command line arguments and you'll need to use the three-argument form of <code>split()</code>.) Try to enhance it so that your dictionary can also contain words with multiple definitions in the format "word <code>space</code> definition:alternate definition:alternate definition, etc...".</li>

<li>Write an analyzer for your Apache logs. You can find a brief description of the common log format at <a href="http://www.w3.org/Daemon/User/Config/Logging.html">http://www.w3.org/Daemon/User/Config/Logging.html</a>. Your analyzer should count the total number of requests for each URL, the total number of results for each status code and the total number of bytes output.</li>
</ul>

<p>Happy programming!</p>









]]>
        
    </content>
</entry>

<entry>
    <title>A Beginner&apos;s Introduction to Perl 5.10</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/04/23/a-beginners-introduction-to-perl-510.html" />
    <id>tag:com.perl.org,2008:/pub//2.646</id>

    <published>2008-04-23T07:00:00Z</published>
    <updated>2010-06-20T16:31:35Z</updated>

    <summary> First, a Little Sales Pitch Editor&apos;s note: this series is based on Doug Sheppard&apos;s Beginner&apos;s Introduction to Perl. A Beginner&apos;s Introduction to Files and Strings with Perl 5.10 explains how to use files and strings, and A Beginner&apos;s Introduction...</summary>
    <author>
        <name>chromatic</name>
        
    </author>
    
        <category term="Tutorials" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="noviceprogrammers" label="novice programmers" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl510" label="Perl 5.10" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlforbeginners" label="Perl for beginners" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perltutorial" label="Perl tutorial" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<h3>First, a Little Sales Pitch</h3>

<p><em>Editor's note: this series is based on <a href="http://www.perl.com/pub/au/Sheppard_Doug">Doug Sheppard's</a> <a href="http://www.perl.com/pub/a/2000/10/begperl1.html">Beginner's Introduction to Perl</a></em>.  <a href="http://www.perl.com/pub/a/2008/05/07/beginners-introduction-to-perl-510-part-2.html">A Beginner's Introduction to Files and Strings with Perl 5.10</a> explains how to use files and strings, and <a href="http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Regular Expressions with Perl 5.10</a> explores regular expressions, matching, and substitutions.  <a href="http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Perl Web Programming</a> demonstrates how to write web programs.</p>

<p>Welcome to Perl.</p>

<p>Perl is the Swiss Army chainsaw of programming languages: powerful and adaptable. It was first developed by Larry Wall, a linguist working as a systems administrator for NASA in the late 1980s, as a way to make report processing easier. Since then, it has moved into a several other areas: automating system administration, acting as glue between different computer systems, web programming, bioinformatics, data munging, and even application development.</p>

<p>Why did Perl become so popular when the Web came along? Two reasons: First, most of what is being done on the Web happens with text, and is best done with a language that's designed for text processing. More importantly, Perl was appreciably better than the alternatives at the time when people needed something to use. C is complex and can produce security problems (especially with untrusted data), Tcl can be awkward, and Python didn't really have a foothold.</p>

<p>It also didn't hurt that Perl is a friendly language. It plays well with your personal programming style. The Perl slogan is "There's more than one way to do it," and that lends itself well to large and small problems alike. Even more so, Perl is very portable and widespread -- it's available pre-installed almost everywhere -- and of course there are thousands of freely-distributable libraries available from the <a href="http://www.cpan.org/">CPAN</a>.</p>

<p>In this first part of our series, you'll learn a few basics about Perl and see a small sample program.</p>

<h3>A Word About Operating Systems</h3>

<p>This series assumes that you're using a Unix or Unix-like operating system (Mac OS X and Cygwin qualify) and that you have the <code>perl</code> binary available at <em>/usr/bin/perl</em>. It's OK if you're running Windows through ActivePerl or Strawberry Perl; most Perl code is platform-independent.</p>

<h3>Your First Perl Program</h3>

<p>Save this program as a file called <em>first.pl</em>:</p>

<pre><code>use feature ':5.10';
say "Hi there!";</code></pre>

<p>(The traditional first program says <code>Hello world!</code>, but I'm an iconoclast.)</p>

<p>Run the program. From a command line, go to the directory with this file and type <code>perl first.pl</code>. You should see:</p>

<pre><code>Hi there!</code></pre>

<p>Friendly, isn't it?</p>

<p>I'm sure you can guess what <code>say</code> does. What about the <code>use feature ':5.10';</code> line? For now, all you need to know is that it allows you to use nice new features found in Perl 5.10. This is a very good thing.</p>

<h3>Functions and Statements</h3>

<p>Perl has a rich library of built-in <em>functions</em>. They're the verbs of Perl, the commands that the interpreter runs. You can see a list of all the built-in functions in the <a href="http://perldoc.perl.org/index-functions.html">perlfunc</a> man page (<code>perldoc perlfunc</code>, from the command line). Almost all functions can take a list of commma-separated <em>parameters</em>.</p>

<p>The <code>print</code> function is one of the most frequently used parts of Perl. You use it to display things on the screen or to send information to a file. It takes a list of things to output as its parameters.</p>

<pre><code>print "This is a single statement.";
print "Look, ", "a ", "list!";</code></pre>

<p>A Perl program consists of <em>statements</em>, each of which ends with a semicolon. Statements don't need to be on separate lines; there may be multiple statements on one line. You can also split a single statement across multiple lines.</p>

<pre><code>print "This is "; print "two statements.\n";
print "But this ", "is only one statement.\n";</code></pre>

<p>Wait a minute though. What's the difference between <code>say</code> and <code>print</code>? What's this <code>\n</code> in the <code>print</code> statements?</p>

<p>The <code>say</code> function behaves just like the <code>print</code> function, except that it appends a newline at the end of its arguments. It prints all of its arguments, and then a newline character. Always. No exceptions. <code>print</code>, on the other hand, only prints what you see explicitly in these examples. If you want a newline, you have to add it yourself with the special character escape sequence <code>\n</code>.</p>

<pre><code>use feature ':5.10';

say "This is a single statement.";
say "Look, ", "a ", "list!";</code></pre>

<p>Why do both exist? Why would you use one over the other? Usually, most "display something" statements need the newline. It's common enough that <code>say</code> is a good default choice. Occasionally you need a little bit more control over your output, so <code>print</code> is the option.</p>

<p>Note that <code>say</code> is two characters shorter than <code>print</code>. This is an important design principle for Perl -- common things should be easy and simple.</p>

<h3>Numbers, Strings, and Quotes</h3>

<p>There are two basic data types in Perl: numbers and strings.</p>

<p>Numbers are easy; we've all dealt with them. The only thing you need to know is that you never insert commas or spaces into numbers in Perl. Always write 10000, not 10,000 or 10 000.</p>

<p>Strings are a bit more complex. A string is a collection of characters in either single or double quotes:</p>

<pre><code>'This is a test.'
"Hi there!\n"</code></pre>

<p>The difference between single quotes and double quotes is that single quotes mean that their contents should be taken <em>literally</em>, while double quotes mean that their contents should be <em>interpreted</em>. Remember the character sequence <code>\n</code>? It represents a newline character when it appears in a string with double quotes, but is literally the two characters backslash and <code>n</code> when it appears in single quotes.</p>

<pre><code>use feature ':5.10';
say "This string\nshows up on two lines.";
say 'This string \n shows up on only one.';</code></pre>

<p>(Two other useful backslash sequences are <code>\t</code> to insert a tab character, and <code>\\</code> to insert a backslash into a double-quoted string.)</p>













<h3>Variables</h3>

<p>If functions are Perl's verbs, then variables are its nouns. Perl has three types of variables: <em>scalars</em>, <em>arrays</em>, and <em>hashes</em>. Think of them as things, lists, and dictionaries respectively. In Perl, all variable names consist of a punctuation character, a letter or underscore, and one or more alphanumeric characters or underscores.</p>

<p><em>Scalars</em> are single things. This might be a number or a string. The name of a scalar begins with a dollar sign, such as <code>$i</code> or <code>$abacus</code>. Assign a value to a scalar by telling Perl what it equals:</p>

<pre><code>my $i                = 5;
my $pie_flavor       = 'apple';
my $constitution1776 = "We the People, etc.";</code></pre>

<p>You don't need to specify whether a scalar is a number or a string. It doesn't matter, because when Perl needs to treat a scalar as a string, it does; when it needs to treat it as a number, it does. The conversion happens automatically. (This is different from many other languages, where strings and numbers are two separate data types.)</p>

<p>If you use a double-quoted string, Perl will insert the value of any scalar variables you name in the string. This is often useful to fill in strings on the fly:</p>

<pre><code>use feature ':5.10';
my $apple_count  = 5;
my $count_report = "There are $apple_count apples.";
say "The report is: $count_report";</code></pre>

<p>The final output from this code is <code>The report is: There are 5 apples.</code>.</p>

<p>You can manipulate numbers in Perl with the usual mathematical operations: addition, multiplication, division, and subtraction. (The multiplication and division operators in Perl use the <code>*</code> and <code>/</code> symbols, by the way.)</p>

<pre><code>my $a = 5;
my $b = $a + 10;       # $b is now equal to 15.
my $c = $b * 10;       # $c is now equal to 150.
$a    = $a - 1;        # $a is now 4, and algebra teachers are cringing.</code></pre>

<p>That's all well and good, but what's this strange <code>my</code>, and why does it appear with some assignments and not others? The <code>my</code> operator tells Perl that you're <em>declaring</em> a new variable. That is, you promise Perl that you deliberately want to use a scalar, array, or hash of a specific name in your program. This is important for two reasons. First, it helps Perl help you protect against typos; it's embarrassing to discover that you've accidentally mistyped a variable name and spent an hour looking for a bug. Second, it helps you write larger programs, where variables used in one part of the code don't accidentally affect variables used elsewhere.</p>

<p>You can also use special operators like <code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code>. These manipulate a scalar's value without needing two elements in an equation. Some people like them, some don't. I like the fact that they can make code clearer.</p>

<pre><code>my $a = 5;
$a++;        # $a is now 6; we added 1 to it.
$a += 10;    # Now it's 16; we added 10.
$a /= 2;     # And divided it by 2, so it's 8.</code></pre>

<p>Strings in Perl don't have quite as much flexibility. About the only basic operator that you can use on strings is <em>concatenation</em>, which is a ten dollar way of saying "put together." The concatenation operator is the period. Concatenation and addition are two different things:</p>

<pre><code>my $a = "8";    # Note the quotes.  $a is a string.
my $b = $a + "1";   # "1" is a string too.
my $c = $a . "1";   # But $b and $c have different values!</code></pre>

<p>Remember that Perl converts strings to numbers transparently whenever necessary, so to get the value of <code>$b</code>, the Perl interpreter converted the two strings <code>"8"</code> and <code>"1"</code> to numbers, then added them. The value of <code>$b</code> is the number 9. However, <code>$c</code> used concatenation, so its value is the string <code>"81"</code>.</p>

<p>Remember, the plus sign <em>adds numbers</em> and the period <em>puts strings together</em>. If you add things that aren't numbers, Perl will try its best to do what you've told it to do, and will convert those non-numbers to numbers with the best of its ability.</p>

<p><em>Arrays</em> are lists of scalars. Array names begin with <code>@</code>. You define arrays by listing their contents in parentheses, separated by commas:</p>

<pre><code>my @lotto_numbers = (1, 2, 3, 4, 5, 6);  # Hey, it could happen.
my @months        = ("July", "August", "September");</code></pre>

<p>You retrieve the contents of an array by an <em>index</em>, sort of like "Hey, give me the first month of the year." Indexes in Perl start from zero. (Why not 1? Because. It's a computer thing.) To retrieve the elements of an array, you replace the <code>@</code> sign with a <code>$</code> sign, and follow that with the index position of the element you want. (It begins with a dollar sign because you're getting a scalar value.) You can also modify it in place, just like any other scalar.</p>

<pre><code>use feature ':5.10';

my @months = ("July", "August", "September");
say $months[0];         # This prints "July".
$months[2] = "Smarch";  # We just renamed September!</code></pre>

<p>If an array value doesn't exist, Perl will create it for you when you assign to it.</p>

<pre><code>my @winter_months = ("December", "January");
$winter_months[2] = "February";</code></pre>

<p>Arrays always return their contents in the same order; if you go through <code>@months</code> from beginning to end, no matter how many times you do it, you'll get back <code>July</code>, <code>August</code>, and <code>September</code> in that order. If you want to find the number of elements of an array, assign the array to a scalar.</p>

<pre><code>use feature ':5.10';
my @months      = ("July", "August", "September");
my $month_count = @months;
say $month_count;  # This prints 3.

my @autumn_months; # no elements
my $autumn_count = @autumn_months;
say $autumn_count; # this prints 0</code></pre>

<p>Some programming languages call <em>hashes</em> "dictionaries". That's what they are: a term and a definition. More precisely, they contain <em>keys</em> and <em>values</em>. Each key in a hash has one and only one corresponding value. The name of a hash begins with a percentage sign, like <code>%parents</code>. You define hashes by comma-separated pairs of key and value, like so:</p>

<pre><code>my %days_in_month = ( "July" =&gt; 31, "August" =&gt; 31, "September" =&gt; 30 );</code></pre>

<p>You can fetch any value from a hash by referring to <code>$hashname{key}</code>, or modify it in place just like any other scalar.</p>

<pre><code>say $days_in_month{September}; # 30, of course.
$days_in_month{February} = 29; # It's a leap year.</code></pre>

<p>To see what keys are in a hash, use the <code>keys</code> function with the name of the hash. This returns a list containing all of the keys in the hash. The list isn't always in the same order, though; while you can count on <code>@months</code> always to return <code>July</code>, <code>August</code>, <code>September</code> in that order, <code>keys %days_in_summer</code> might return them in any order whatsoever.</p>

<pre><code>my @month_list = keys %days_in_summer;
# @month_list is now ('July', 'September', 'August')!</code></pre>

<p>The three types of variables have three separate <em>namespaces</em>. That means that <code>$abacus</code> and <code>@abacus</code> are two different variables, and <code>$abacus[0]</code> (the first element of <code>@abacus</code>) is not the same as <code>$abacus{0}</code> (the value in <code>%abacus</code> that has the key <code>0</code>).</p>

<h3>Comments</h3>

<p>Some of the code samples from the previous section contained code comments. These are useful for explaining what a particular piece of code does, and vital for any piece of code you plan to modify, enhance, fix, or just look at again. (That is to say, comments are important.)</p>

<p>Anything in a line of Perl code that follows a <code>#</code> sign is a comment, unless that <code>#</code> sign appears in a string.)</p>

<pre><code>use feature ':5.10';
say "Hello world!";  # That's more like it.
# This entire line is a comment.</code></pre>

<h3>Loops</h3>

<p>Almost every program ever written uses a <em>loop</em> of some kind. Loops allow you run a particular piece of code over and over again. This is part of a general concept in programming called <em>flow control</em>.</p>

<p>Perl has several different functions that are useful for flow control, the most basic of which is <code>for</code>. When you use the <code>for</code> function, you specify a variable to use as the <em>loop index</em>, and a list of values to loop over. Inside a pair of curly brackets, you put any code you want to run during the loop:</p>

<pre><code>use feature ':5.10';

for my $i (1, 2, 3, 4, 5) {
     say $i;
}</code></pre>

<p>This loop prints the numbers 1 through 5, each on a separate line. (It's not
very useful; you're might think "Why not just write <code>say 1, 2, 3, 4,
5;</code>?".  This is because <code>say</code> adds only one newline, at the
end of its list of arguments.)</p>

<p>A handy shortcut for defining loop values is the <em>range</em> operator <code>..</code>, which specifies a range of numbers. You can write <code>(1, 2, 3, 4, 5)</code> as <code>(1 .. 5)</code> instead. You can also use arrays and scalars in your loop list. Try this code and see what happens:</p>

<pre><code>use feature ':5.10';

my @one_to_ten = (1 .. 10);
my $top_limit  = 25;

for my $i (@one_to_ten, 15, 20 .. $top_limit) {
    say $i;
}</code></pre>

<p>Of course, again you could write <code>say @one_to_ten, 15, 20 .. $top_limit;</code></p>

<p>The items in your loop list don't have to be numbers; you can use strings just as easily. If the hash <code>%month</code>_has contains names of months and the number of days in each month, you can use the <code>keys</code> function to step through them.</p>

<pre><code>use feature ':5.10';

for my $i (keys %month_has) {
    say "$i has $month_has{$i} days.";
}

for my $marx ('Groucho', 'Harpo', 'Zeppo', 'Karl') {
    say "$marx is my favorite Marx brother.";
}</code></pre>

<h3>The Miracle of Compound Interest</h3>

<p>You now know enough about Perl -- variables, <code>print</code>/<code>say</code>, and <code>for()</code> -- to write a small, useful program. Everyone loves money, so the first sample program is a compound-interest calculator. It will print a (somewhat) nicely formatted table showing the value of an investment over a number of years. (You can see the program at <a href="/2008/04/23/compound_interest.pl"><code>compound_interest.pl</code></a>)</p>

<p>The single most complex line in the program is:</p>

<pre><code>my $interest = int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;</code></pre>

<p><code>$apr / 100</code> is the interest rate, and <code>($apr / 100) * $nest_egg</code> is the amount of interest earned in one year. This line uses the <code>int()</code> function, which returns the integer value of a scalar (its value after any stripping off any fractional part). We use <code>int()</code> here because when you multiply, for example, 10925 by 9.25%, the result is 1010.5625, which we must round off to 1010.56. To do this, we multiply by 100, yielding 101056.25, use <code>int()</code> to throw away the leftover fraction, yielding 101056, and then divide by 100 again, so that the final result is 1010.56. Try stepping through this statement yourself to see just how we end up with the correct result, rounded to cents.</p>

<h3>Play Around!</h3>

<p>At this point you have some basic knowledge of Perl syntax and a few simple toys to play with. Try writing some simple programs with them. Here are two suggestions, one simple and the other a little more complex:</p>

<ul>
<li>A word frequency counter. How often does each word show up in an array of words? Print out a report. (Hint: Use a hash to count of the number of appearances of each word.)</li>

<li>Given a month and the day of the week that's the first of that month, print a calendar for the month.</li>
</ul>




]]>
        
    </content>
</entry>

<entry>
    <title>Using Amazon S3 from Perl</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/04/08/using-amazon-s3-from-perl.html" />
    <id>tag:com.perl.org,2008:/pub//2.644</id>

    <published>2008-04-08T07:00:00Z</published>
    <updated>2010-06-20T16:31:35Z</updated>

    <summary> Data management is a critical and challenging aspect for any online resource. With exponentially growing data sizes and popularity of rich media, even small online resources must effectively manage and distribute a significant amount of data. Moreover, the peace...</summary>
    <author>
        <name>Abel Lin</name>
        
    </author>
    
        <category term="Web Development" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="amazon" label="Amazon" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="cloudstorage" label="cloud storage" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="rest" label="REST" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="s3" label="S3" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="webservices" label="web services" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Data management is a critical and challenging aspect for any online resource. With exponentially growing data sizes and popularity of rich media, even small online resources must effectively manage and distribute a significant amount of data. Moreover, the peace of mind associated with an additional offsite data storage resource is invaluable to everyone involved.</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a>, we manage a growing inventory of GPS and general GIS (Geography Information Systems) data and web content (text, images, videos, etc.) for the end users. In addition, we must also effectively manage daily snapshots, backups, as well as multiple development versions of our web site and supporting software. For any small organization, this can add up to significant costs -- not only as an initial monetary investment but also in terms of ongoing labor costs for maintenance and administration.</p>

<p>Amazon Simple Storage Service (S3) was released specifically to address the problem of data management for online resources -- with the aim to provide "reliable, fast, inexpensive data storage infrastructure that Amazon uses to run its own global network of web sites." Amazon S3 provides a web service interface that allows developers to store and retrieve any amount of data. S3 is attractive to companies like SundayMorningRides.com as it frees us from upfront costs and the ongoing costs of purchasing, administration, maintenance, and scaling our own storage servers.</p>

<p>This article covers the Perl, REST, and the Amazon S3 REST module, walking through the development of a collection of Perl-based tools for UNIX command-line based interaction to Amazon S3. I'll also show how to set access permissions so that you can serve images or other data directly to your site from Amazon S3.</p>

<h4>A Bit on Web Services</h4>

<p>Web services have become the de-facto method of exposing information and, well, services via the Web. Intrinsically, web services provide a means of interaction between two networked resources. Amazon S3 is accessible via both Simple Object Access Protocol (SOAP) or representational state transfer (REST).</p>

<p>The SOAP interface organizes features into custom-built operations, similar to remote objects when using Java Remote Method Invocation (RMI) or Common Object Resource Broker Architecture (CORBA). Unlike RMI or CORBA, SOAP uses XML embedded in the body of HTTP requests as the application protocol.</p>

<p>Like SOAP, REST also uses HTTP for transport. Unlike SOAP, REST operations are the standard HTTP operations -- GET, POST, PUT, and DELETE. I think of REST operations in terms of the CRUD semantics associated with relational databases: POST is Create, GET is Retrieve, PUT is Update, and DELETE is Delete.</p>

<h4>"Storage for the Internet"</h4>

<p>Amazon S3 represents the data space in three core concepts: <em>objects</em>, <em>buckets</em>, and <em>keys</em>.</p>

<ul>
<li>Objects are the base level entities within Amazon S3. They consist of both object data and metadata. This metadata is a set of name-attribute pairs defined in the HTTP header.</li>

<li>Buckets are collections of objects. There is no limit to the number of objects in a bucket, but each developer is limited to 100 buckets.</li>

<li>Keys are unique identifiers for objects.</li>
</ul>

<p>Without wading through the details, I tend think of buckets as folders, objects as files, and keys as filenames. The purpose of this abstraction is to create a unique HTTP namespace for every object.</p>

<p>I'll assume that you have already signed up for <a href="http://aws.amazon.com/s3">Amazon S3</a> and received your Access Key ID and Secret Access Key. If not, please do so.</p>

<p>Please note that the <code>S3::*</code> modules aren't the only Perl modules available for connecting to Amazon S3.  In particular, <a href="http://search.cpan.org/perldoc?Net::Amazon::S3">Net::Amazon::S3</a> hides a lot of the details of the S3 service for you.  For now, I'm going to use a simpler module to explain how the service works internally.</p>

<h4>Connecting, Creating, and Listing Buckets</h4>

<p>Connecting to Amazon S3 is as simple as supplying your Access Key ID and your Secret Access Key to create a connection, called here <code>$conn</code>. Here's how to create and list the contents of a bucket as well as list all buckets.</p>

<pre><code>#!/usr/bin/perl

use S3::AWSAuthConnection;
use S3::QueryStringAuthGenerator;

use Data::Dumper;

my $AWS_ACCESS_KEY_ID     = 'YOUR ACCESS KEY';
my $AWS_SECRET_ACCESS_KEY = 'YOUR SECRET KEY';

my $conn = S3::AWSAuthConnection-&gt;new($AWS_ACCESS_KEY_ID,
                                      $AWS_SECRET_ACCESS_KEY);

my $BUCKET = "foo";

print "creating bucket $BUCKET \n";
print $conn-&gt;create_bucket($BUCKET)-&gt;message, "\n";

print "listing bucket $BUCKET \n";
print Dumper @{$conn-&gt;list_bucket($BUCKET)-&gt;entries}, "\n";

print "listing all my buckets \n";
print Dumper @{$conn-&gt;list_all_my_buckets()-&gt;entries}, "\n";</code></pre>

<p>Because every S3 action takes place over HTTP, it is good practice to check for a 200 response.</p>

<pre><code>my $response = $conn-&gt;create_bucket($BUCKET);
if ($response-&gt;http_response-&gt;code == 200) {
    # Good
} else {
    # Not Good
}</code></pre>

<p>As you can see from the output, the results come back in a hash. I've used <a href="http://search.cpan.org/perldoc?Data::Dumper">Data::Dumper</a> as a convenient way to view the contents. If you are running this for the first time, you will obviously not see anything listed in the bucket.</p>

<pre><code>listing bucket foo
$VAR1 = {
          'Owner' =&gt; {
                     'ID' =&gt; 'xxxxx',
                     'DisplayName' =&gt; 'xxxxx'
                   },
          'Size' =&gt; '66810',
          'ETag' =&gt; '"xxxxx"',
          'StorageClass' =&gt; 'STANDARD',
          'Key' =&gt; 'key',
          'LastModified' =&gt; '2007-12-18T22:08:09.000Z'
        };
$VAR4 = '
';
listing all my buckets
$VAR1 = {
          'CreationDate' =&gt; '2007-11-28T17:31:48.000Z',
          'Name' =&gt; 'foo'
        };
';</code></pre>













<h4>Writing an Object</h4>

<p>Writing an object is simply a matter of using the HTTP PUT method. Be aware that there is nothing to prevent you from overwriting an existing object; Amazon S3 will automatically update the object with the more recent write request. Also, it's currently not possible to append to or otherwise modify an object in place without replacing it.</p>

<pre><code>my %headers = (
    'Content-Type' =&gt; 'text/plain'
);
$response = $conn-&gt;put( $BUCKET, $KEY, S3Object-&gt;new("this is a test"),
                        \%headers);</code></pre>

<p>Likewise, you can read a file from STDIN:</p>

<pre><code>my %headers;

FILE: while(1) {
    my $n = sysread(STDIN, $data, 1024 * 1024, length($data));
    if ($n &lt; 0) {
        print STDERR "Error reading input: $!\n";
        exit 1;
    }
    last FILE if $n == 0;
}
$response = $conn-&gt;put("$BUCKET", "$KEY", $data, \%headers);</code></pre>

<p>To add custom metadata, simply add to the <code>S3Object</code>:</p>

<pre><code>S3Object-&gt;new("this is a test", { name =&gt; "attribute" })</code></pre>

<p>By default, every object has private access control when written. This allows only the user that stored the object to read it back. You can change these settings. Also, note that each object can hold a maximum of 5 GB of data.</p>

<p>You are probably wondering if it is also possible to upload via a standard HTTP POST. The folks at Amazon are working on it as we speak -- see <a href="http://developer.amazonwebservices.com/connect/thread.jspa?threadID=18616&amp;tstart=0">HTTP POST beta discussion</a> for more information. Until that's finished, you'll have to perform web-based uploads via an intermediate server.</p>

<h4>Reading an Object</h4>

<p>Like writing objects, there are several ways to read data from Amazon S3. One way is to generate a temporary URL to use with your favorite client (for example, wget or Curl) or even a browser to view or retrieve the object. All you have to do is generate the URL used to make the REST call.</p>

<pre><code>my $generator = S3::QueryStringAuthGenerator-&gt;new($AWS_ACCESS_KEY_ID,
    $AWS_SECRET_ACCESS_KEY);</code></pre>

<p>...and then perform a simple HTTP GET request. This is a great trick if all you want to do is temporarily view or verify the data.</p>

<pre><code>$generator-&gt;expires_in(60);
my $url = $generator-&gt;get($BUCKET, "$KEY");
print "$url \n";</code></pre>

<p>You can also programmatically read the data directly from the initial connection. This is handy if you have to perform additional processing of the data.</p>

<pre><code>my $response = $conn-&gt;get("$BUCKET", "$KEY");
my $data     = $response-&gt;object-&gt;data;</code></pre>

<p>Another cool feature is <a href="http://docs.amazonwebservices.com/AmazonS3/2006-03-01/">the ability to use BitTorrent to download files from Amazon S3</a> . You can access any object that has anonymous access privileges via BitTorrent.</p>

<h4>Delete an Object</h4>

<p>By now you probably have the hang of the process. If you're going to create objects, you're probably going to have to delete them at some point.</p>

<pre><code>$conn-&gt;delete("$BUCKET", "$KEY");</code></pre>

<h4>Set Access Permissions and Publish to a Website</h4>

<p>As you may have noticed from the previous examples, all Amazon S3 objects access goes through HTTP. This makes Amazon S3 particularly useful as a online repository. In particular, it's useful to manage and serve website media. You could almost imagine Amazon S3 serving as mini Content Delivery Network for media on your website. This example will demonstrate how to build a very simple online page where the images are served dynamically via Amazon S3.</p>

<p>The first thing to do us to upload some images and set the ACL permissions to public. I've modified the previous example with one difference. To make objects publicly readable, include the header <code>x-amz-acl: public-read</code> with the HTTP PUT request.</p>

<pre><code>my %headers = (
    'x-amz-acl' =&gt; 'public-read',
);</code></pre>

<p>Additional ACL permissions include:</p>

<ul>
<li>private (default setting if left blank)</li>

<li>public-read</li>

<li>public-read-write</li>

<li>authenticated-read</li>
</ul>

<p>Now you know enough to put together a small script that will automatically display all images in the bucket to a web page (you'll probably want to spruce up the formatting).</p>

<pre><code>...
my $BUCKET   = "foobar";
my $response = $conn-&gt;list_bucket("$BUCKET");

for my $entry (@{$response-&gt;entries}) {
    my $public_url   = $generator-&gt;get($BUCKET, $entry-&gt;{Key});
    my ($url, undef) = split (/\?/, $public_url);
    $images         .= "&lt;img src=\"$url\"&gt;&lt;br /&gt;";
}
($webpage =  &lt;&lt;"WEBPAGE");
&lt;html&gt;&lt;body&gt;$images&lt;/body&gt;&lt;/html&gt;
WEBPAGE
print $q-&gt;header();
print $webpage;</code></pre>

<p>To add images to this web page, upload more files into the bucket and they will automatically appear the next time you load the page.</p>

<p>It's also simple to link to media one at a time for a webpage. If you examine the HTML generated by this example, you'll see that all Amazon S3 URLs have the basic form <code>http://<em>bucketname</em>.s3.amazon.com/<em>objectname</em></code>. Also note that the namespace for buckets is shared with all Amazon S3 users. You may have already picked up on this.</p>

<h3>Conclusion</h3>

<p>Amazon S3 is a great tool that can help with the data management needs of all sized organizations by offering cheap and unlimited storage. For personal use, it's a great tool for backups (also good for organizations) and general file storage. It's also a great tool for collaboration. Instead of emailing files around, just upload a file and set the proper access controls -- no more dealing with 10 MB attachment restrictions!</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a> we use S3 as part of our web serving infrastructure to reduce the load on our hardware when serving media content.</p>

<p>When combined with other Amazon Web Services such as SimpleDB (for structured data queries) and Elastic Compute Cloud (for data processing) it's easy to envision a low cost solution for web-scale computing and data management.</p>

<h4>More Resources and References</h4>

<ul>
<li><a href="http://aws.amazon.com/s3">Amazon S3 Homepage</a>
</li>

<li><a href="http://developer.amazonwebservices.com/">Amazon Webservices Developer Connection</a>
</li>

<li><a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=133&amp;categoryID=47">Amazon S3 Library for REST in Perl</a>
</li>

<li><a href="http://aws.typepad.com/">Amazon Web Services Blog</a>
</li>
</ul>




]]>
        
    </content>
</entry>

<entry>
    <title>Reverse Callback Templating</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/03/14/reverse-callback-templating.html" />
    <id>tag:com.perl.org,2008:/pub//2.642</id>

    <published>2008-03-14T07:00:00Z</published>
    <updated>2010-06-20T16:31:35Z</updated>

    <summary> Programmers have long recognized that separating code logic from presentation is good. The Perl community has produced many fine systems for doing just this. While there are many systems, they largely fall within two execution models, pipeline and callback...</summary>
    <author>
        <name>James Robson</name>
        
    </author>
    
        <category term="Text Tools" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Web Development" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="mvc" label="MVC" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="presentation" label="presentation" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="templaterecall" label="Template::Recall" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="templating" label="templating" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Programmers have long recognized that separating code logic from presentation is good. The Perl community has produced many fine systems for doing just this. While there are many systems, they largely fall within two execution models, <em>pipeline</em> and <em>callback</em> (as noted by Perrin Harkins in <a href="http://www.perl.com/pub/a/2001/08/21/templating.html">Choosing a Templating System</a>). <a href="http://search.cpan.org/perldoc?HTML::Template">HTML::Template</a> and <a href="http://www.template-toolkit.org/">Template Toolkit</a> are in the pipeline category. Their templates consist of simple presentation logic in the form of loops and conditionals and template variables. The Perl program does its work, then loads and renders the appropriate template, as if data were flowing through a pipeline. <a href="http://www.masonhq.com/">Mason</a> and <a href="http://perl.apache.org/embperl/">Embperl</a> fall into the callback category. They mix code in with the template markup, and the template "calls back" to Perl when it encounters program logic.</p>

<p>A third execution model exists: the <em>reverse callback</em> model. Template and code files are separate, just like in the pipeline approach. Instead of using a mini-language to handle display logic, however, the template consists of named sections. Perl executes and calls a specific section of the template at the appropriate time, rendering it. Effectively, this is the opposite of the callback method, which wraps Perl logic around portions (or sections) of a template in a single file. Reverse callback uses Perl statements to load, or call, specific portions of the the template. This approach has a few distinct advantages.</p>

<h3>A Reverse Callback Example</h3>

<p>Suppose that you have a simple data structure you are dying to output as pretty HTML.</p>

<pre><code>my @goods = (
    "oxfords,Brown leather,\$85,0",
    "hiking,All sizes,\$55,7",
    "tennis shoes,Women's sizes,\$35,15",
    "flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>First, you need an HTML template with the appropriate sections defined. Sections are of vital importance; they enable <code>Template::Recall</code> to keep the logic squarely in the code. <code>Template::Recall</code> uses the default pattern <code>/[\s*=+\s*\w+\s*=+\s*]/</code> (to match, for example, <code>[==== section_name ====]</code>) to determine sections in a single file. The start of one section denotes the end of another. This is because <code>Template::Recall</code> uses a <code>split()</code> operation based on the above regex, saving the <code>\w+</code> as the section key in an internal data structure.</p>

<pre><code>[ =================== header ===================]

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;my site - [' title ']&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h4&gt;The date is [' date ']&lt;/h4&gt;



&lt;table border="1"&gt;

    &lt;tr&gt;
        &lt;th&gt;Shoe&lt;/th&gt;
        &lt;th&gt;Details&lt;/th&gt;
        &lt;th&gt;Price&lt;/th&gt;
        &lt;th&gt;Quantity&lt;/th&gt;
    &lt;/tr&gt;

[ =================== product_row =================== ]
    &lt;tr&gt;
        &lt;td&gt;[' shoe ']&lt;/td&gt;
        &lt;td&gt;[' details ']&lt;/td&gt;
        &lt;td&gt;[' price ']&lt;/td&gt;
        &lt;td&gt;[' quantity ']&lt;/td&gt;
    &lt;/tr&gt;


[= footer =]
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This template is quite simple. It has three sections, a "header," "product_row," and "footer." The sections essentially give away how the program logic is going to work. A driver program would call header and footer only once during program execution (start and end, respectively). product_row will be called multiple times during iteration over an array.</p>

<p>Names contained within the delimeters <code>['</code> and <code>']</code> are template variables for replacement during rendering. For example, <code>[' date ']</code> will be replaced by the current date when the program executes.</p>

<p>The driver code must first instantiate a new Template::Recall object, <code>$tr</code>, and pass it the path of the template, which I've saved as the file <em>template1.html</em>.</p>

<pre><code>use Template::Recall;

my $tr = Template::Recall-&gt;new( template_path =&gt; 'template1.html');</code></pre>

<p>With <code>$tr</code> created, the template sections are loaded and ready for use. The obvious first step is to render the header section with the <code>render()</code> method. <code>render()</code> takes the name of the section to process, and optionally, a hash of names and values to replace in that section. There are two template variables in the header section, <code>[' title ']</code> and <code>[' date ']</code>, so the call looks like:</p>

<pre><code>print $tr-&gt;render( 'header', { title =&gt; 'MyStore', date =&gt; scalar(localtime) } );</code></pre>

<p>The names used in the hash must match the names of the template variables in the section you intend to render. For example, <code>date =&gt; scalar(localtime)</code> means that <code>[' date ']</code> in the header section will be dynamically replaced by the value produced by <code>scalar(localtime)</code>.</p>

<p>You probably noticed from the template that the header section created the start of an HTML table. This is a fine time to render <code>@goods</code> as the table's rows.</p>

<pre><code>for my $good (@goods)
{
    my @attr     = split(/,/, $good);
    my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];

    my %row      = (
        shoe     =&gt; $attr[0],
        details  =&gt; $attr[1],
        price    =&gt; $attr[2],
        quantity =&gt; $quantity,
    );

    print $tr-&gt;render('product_row', \%row);
}</code></pre>

<p>In actual code, this array would likely come from a database. For each row, the driver makes necessary logical decisions (such as displaying "Out of stock" if the quantity equals "0"), then calls <code>$tr-&gt;render()</code> to replace the placeholders in the template section with the values from <code>%row</code>.</p>

<p>Finally, the driver renders the footer of the HTML output. There are no template variables to replace, so there's no need to pass in a hash.</p>

<pre><code>print $tr-&gt;render('footer');</code></pre>

<p>The result is this nice little output of footwear inventory:</p>

<h4>The date is Fri Aug 10 14:22:30 2007</h4>

<table>
<tr>
<th>Shoe</th>
<th>Details</th>
<th>Price</th>
<th>Quantity</th>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>
</table>

<h3>The Logic Is in the Code</h3>

<p>What happens if you extend your shoe data slightly, to add categories? For instance, what if <code>@goods</code> looks like:</p>

<pre><code>my @goods = (
    "dress,oxfords,Brown leather,\$85,0",
    "sports,hiking,All sizes,\$55,7",
    "sports,tennis shoes,Women's sizes,\$35,15",
    "recreation,flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>The output now needs grouping, which implies the use of nested loops. One loop can output the category header -- sports, dress, or recreation shoes -- and another will output the details of each shoe in that category.</p>

<p>To handle this in HTML::Template, you would generally build a nested data structure of anonymous arrays and hashes, and then process it against nested <code>&lt;TMPL_LOOP&gt;</code> directives in the template. Template::Recall logic remains in the code, you would build a nested loop structure in Perl that calls the appropriate sections. You can also use a hash to render the category sections as keys and detail sections as values in a single pass, and output them together using <code>join</code>.</p>

<p>The template needs some modification:</p>

<pre><code>[====== table_start ====]
&lt;table border="1"&gt;
[====== category =======]
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;b&gt;['category']&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
[====== detail ======]
&lt;tr&gt;&lt;td&gt;['shoe']&lt;/td&gt;&lt;td&gt;['detail']&lt;/td&gt;&lt;td&gt;['price']&lt;/td&gt;&lt;td&gt;['quantity']&lt;/td&gt;&lt;/tr&gt;
[======= table_end ====]
&lt;/table&gt;</code></pre>

<p>This template now has a section called "category," a single table row that spans all columns. The "detail" section is pretty much the same as in the previous.</p>

<pre><code>my %inventory;

for my $good (@goods) {
    my @attr = split(/,/, $good);
    my $q    = $attr[4] == 0 ? 'Out of stock' : $attr[4];

    $inventory{ $tr-&gt;render('category', { category =&gt; $attr[0] } ) } .=
        $tr-&gt;render('detail',
            {
                shoe     =&gt; $attr[1],
                detail   =&gt; $attr[2],
                price    =&gt; $attr[3],
                quantity =&gt; $q,
            } );
}

print $tr-&gt;render('table_start') .
    join('', %inventory) .
    $tr-&gt;render('table_end');</code></pre>

<p>This loop looks surprisingly similar to the first example, doesn't it? That's because it is. Instead of printing each row, however, this code renders the first column in <code>@goods</code> against the category template section, and then storing the output as a key in <code>%inventory</code>. In the same iteration, it renders the remaining columns against the detail section and appends to the value of that key.</p>

<p>After storing the rendered sections in this way to <code>%inventory</code>, the code prints everything with a single statement, using <code>join</code> to print all the values in <code>%inventory</code>, including keys. The output is:</p>

<table>
<tr>
<td><strong>recreation</strong>
</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>

<tr>
<td><strong>sports</strong>
</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td><strong>dress</strong>
</td>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>
</table>

<p>The code also handles conditional output. Suppose that at your growing online shoe emporium you provide special deals to customers who have bought over a certain dollar amount. As they browse your shoe inventory, these deals appear.</p>

<pre><code>if ( $customer-&gt;is_elite ) {
    print $tr-&gt;render('special_deals', get_deals('elite') );
}
else {
    print $tr-&gt;render('standard_deals', get_deals() );
}</code></pre>

<p>What about producing XML output? This usually requires a separate template? You can conditionally load a <em>.xml</em> or <em>.html</em> template:</p>

<pre><code>my $tr;
if ( $q-&gt;param('fmt') eq 'xml' ) {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.xml' );
}
else {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.html' );
}</code></pre>

<p>Perl provides everything you need to handle model, controller, <em>and</em> view logic. Template::Recall capitalizes on this and helps to make projects code driven.</p>

<h3>Template Model Comparison</h3>

<p>It's important to note a few things that occurred in these examples -- or failed to occur, rather. First, there's no mixture of code and template markup. All template access occurs through the method call <code>$tr-&gt;render()</code>. This is strong separation of concerns (SOC), just like the pipeline model, and unlike the callback model, which mixes template markup and code in the same file. Not only does strong SOC provide good code organization, it also keeps designers from having to sift through code to change markup. Consider using Mason to output the rows of <code>@goods</code>.</p>

<pre><code>% for my $good (@goods) {
%  my @attr     = split(/,/, $good);
%  my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];
&lt;tr&gt;
&lt;td&gt;&lt;% $attr[0] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[1] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[2] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $quantity %&gt;&lt;/td&gt;
&lt;/tr&gt;
% }</code></pre>

<p>This is an efficient approach, and easy enough for a programmer to walk through. It becomes difficult to maintain though, when designers are involved, if for no other reason than because a designer and a programmer need to access the same file to do their respective work. Design changes and code changes will not always share the same schedule because they belong to different domains. It also means that in order to switch templates, say to output XML or text (or both), you have to add more and more conditionals and templates to the code, making it increasingly difficult to read.</p>

<p>The other thing that did not occur in this example is the leaking of any kind of logic (presentation or otherwise) into the template. Consider that HTML::Template would have to insert the <code>&lt;TMPL_LOOP&gt;</code> statement in the template in order to output the rows of <code>@goods</code>.</p>

<pre><code>    &lt;TMPL_LOOP NAME="PRODUCT"&gt;
    &lt;tr&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=SHOE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=DETAILS&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=PRICE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=QUANTITY&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/TMPL_LOOP&gt;</code></pre>

<p>That's not a big deal, really. If you care about line count, this only requires one extra line over the Template::Recall version, and that's the the closing tag <code>&lt;/TMPL_LOOP&gt;</code>. Nonetheless, the template now states some of the logic for the application. Sure, it's only presentation logic, but it's logic nonetheless. HTML::Template also provides <code>&lt;TMPL_IF&gt;</code> for displaying items conditionally, and <code>&lt;TMPL_INCLUDE&gt;</code> for including other templates. Again, this is logic contained in the template files.</p>

<p>Template::Recall keeps as much logic as possible in the code. If you need to display something conditionally, use Perl's <code>if</code> statement. If you need to include other templates, load them using a Template::Recall object. Whereas the pipeline models likely work better for projects with a fairly sophisticated design team, Template::Recall tries to be the programmer's friend and let him or her steer from the most comfortable place, the code.</p>

<p>There is also a subtle cost to using the pipeline model for a simple loop like that above. Consider this HTML::Template footwear data code:</p>

<pre><code>my $template = HTML::Template-&gt;new(filename =&gt; template1.tmpl');

my @output;

for my $good (@goods)
{
    my @attr = split(/,/, $_);
    my %row  = (
        SHOE     =&gt; $attr[0],
        DETAILS  =&gt; $attr[1],
        PRICE    =&gt; $attr[2],
        QUANTITY =&gt; $attr[3],
    );
    push( @output, \%row );
}

$template-&gt;param(PRODUCT =&gt; \@output);

print $template-&gt;output();</code></pre>

<p>The code iterates over <code>@goods</code> and builds a second array, <code>@output</code>, with the rows as hash references. Then the template iterates over <code>@output</code> within <code>&lt;TMPL_LOOP&gt;</code>. That's walking over the same data twice. Template sections do not suffer this cost, because you can output the data immediately, as you get it:</p>

<pre><code>print $tr-&gt;render('product_row', \%row);</code></pre>

<p>This is essentially what happens with Mason (or JSP/PHP/ASP for that matter). The main difference is that Template::Recall renders the section through a method call rather than mixing code and template.</p>

<p>Template::Recall, by using sectioned templates, combines the efficiency of the callback model with the strong, clean separation of concerns inherent in the pipeline model, and perhaps gets the best of both worlds.</p>
]]>
        
    </content>
</entry>

<entry>
    <title>Elements of Access Control</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/02/13/elements-of-access-control.html" />
    <id>tag:com.perl.org,2008:/pub//2.640</id>

    <published>2008-02-13T08:00:00Z</published>
    <updated>2010-06-20T16:31:35Z</updated>

    <summary> Why Gates? In a perfect world we wouldn&apos;t do things we should not. However the world is not like this; people do forbidden things sometimes. This also applies to computer systems used by more than one person. Almost everyone...</summary>
    <author>
        <name>Vladi Belperchinov-Shabanski</name>
        
    </author>
    
        <category term="Security" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="accesscontrol" label="Access control" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="privacy" label="privacy" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="security" label="security" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="softwaredevelopment" label="software development" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<h3>Why Gates?</h3>

<p>In a perfect world we wouldn't do things we should not. However the world is not like this; people do forbidden things sometimes. This also applies to computer systems used by more than one person. Almost everyone has tried to read someone else's email, view accounting department salary reports, or something else, or access otherwise hidden data.</p>

<p>I know <em>you</em> have never done this, but many people have.</p>

<h3>In Construction</h3>

<p>The simplest way to allow or forbid a user account to do something is to check if the account is in a list of permitted accounts somewhere. If you assume that everything is forbidden unless explicitly allowed, the access function can be as simple as:</p>

<pre><code>  # access_check() return 1 or undef
  sub access_check
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    return $quick_allow{ $user_id };
  }

  my @allowed = ( 11, 12, 23, 45 );

  print "User 23 allowed\n" if access_check( 23, @allowed );
  print "User 13 allowed\n" if access_check( 13, @allowed );
  print "User 99 allowed\n" if access_check( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<p>Usually access control can be almost as simple as this function. Using user IDs for access control is simple, but tends to be hard to maintain. The problem appears with systems with many users or with public systems where new users may be created at any point. Access lists may become very large for each operation, which needs access controls.</p>

<p>One solution to this problem is <em>access groups</em>. Each user may be a member of several groups. The access check will pass if the user is a member of a group with permission for the required operation. This middle level in the access check isolates users from the access check directly. It also helps the system's design--you can associate preset access groups with all controlled operations at their point of creation. Subsequently created users only need to be attached to one or more of those groups:</p>

<pre><code>  # mimic real system environment:
  # %ALL_USER_GROUPS represents "storage" that contains all
  # groups that each user is attached to
  my %ALL_USER_GROUPS = (
                    23 =&gt; [ qw( g1  g4 ) ],
                    13 =&gt; [ qw( g3  g5 ) ],
                    );
  # user 23 is in groups g1 and g4
  # user 13 -- in g3 and g5

  # return list of user's groups. read data from storage or
  # from %ALL_USER_GROUPS in this example
  sub get_user_groups
  {
    my $user_id     = shift;

    return @{ $ALL_USER_GROUPS{ $user_id } || [] };
  }

  # access_check_grp() return 1 or 0
  sub access_check_grp
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    my @user_groups = get_user_groups( $user_id );

    for my $group ( @user_groups )
    {
      # user groups is listed, allow
      return 1 if $quick_allow{ $group };
    }

    # user group not found, deny
    return 0;
  }

  # this groups list is static and will not be altered
  # when users are added or removed from the system
  my @allowed = qw( g1  g2  g7  g9 );

  print "User 23 allowed\n" if access_check_grp( 23, @allowed );
  print "User 13 allowed\n" if access_check_grp( 13, @allowed );
  print "User 99 allowed\n" if access_check_grp( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<h3>Storage</h3>

<p>Probably the most popular storage for system data nowadays is the SQL database. Here is a simple example of how to store users, groups, and mapping between them. Three tables are required:</p>

<pre><code>  SQL CREATE statements:

  create table user  ( id integer primary key, name char(64), pass char(64) );
  create table group ( id integer primary key, name char(64) );
  create table map   ( user integer, group integer );

  TABLE USER:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |
   pass   | character(64) |

  TABLE GROUP:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |

  TABLE MAP:

   Column |  Type   | Modifiers
  --------+---------+-----------
   user   | integer |
   group  | integer |</code></pre>

<p>Let's fill those tables with some data:</p>

<pre><code>  letme=# select id, name from user;
   id |       name
  ----+------------------
    1 | Damian
    2 | Clive
    3 | Lana
  (3 rows)

  letme=# select * from group;
   id |       name
  ----+------------------
    1 | Admin
    2 | Users
    3 | Moderators
  (3 rows)

  letme=# select * from map;
   user | group
  -----+-----
     1 |   1
     1 |   2
     3 |   2
     3 |   3
     2 |   2
  (4 rows)</code></pre>

<p>Users in this example are attached to those groups:</p>

<pre><code>  Damian: Users, Admin
  Clive:  Users
  Lana:   Users, Moderators</code></pre>













<h3>Run-Time</h3>

<p>Applications apply access control after user login. You can combine it with the login procedure--for example to allow only specific group of users to connect on weekends. Even so, the access check occurs only after the login succeeds, that is, when the username and password are correct.</p>

<p>A simple approach for loading required access info is:</p>

<ul>
<li>Login, check username and password</li>

<li>For unsuccessful login, deny access, print message, etc.</li>

<li>For successful login, load group list for the user from database</li>

<li>Check for required group(s) for login

<p>This may deny login, print a message, or continue.</p></li>

<li>User logged in, continue

<p>All access checks for operations happen after this point.</p></li>
</ul>

<p>The run-time storage for a user's groups can be simple hash. It can be either global or inside the user session object, depending on your system design. I've used a global hash here for simplicity of the examples, but if you copy and paste this code, remember that it is <em>mandatory</em> for you to clear and recreate this global hash for every request right after the login or user session changes! You can also use some kind of session object to drop all user data at the end of the session, but this is just an option, not the only correct or possible way.</p>

<p>(Also, a truly robust system would store a well-hashed version of the password, not the literal password, but that's a story for a different article.)</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use DBI;
  use Data::Dumper;

  our $USER_NAME;
  our $USER_ID;
  our %USER_GROUPS;

  my $DBH = DBI-&gt;connect( "dbi:Pg:dbname=letme", "postgres", "",
      { AutoCommit =&gt; 0 } );

  # this is just an example!
  # username and password acquiring depends on the specific application
  user_login( 'Damian', 'secret4' );

  print "User logged in: $USER_NAME\n";
  print "User id:        $USER_ID\n";
  print "User groups:    " . join( ', ', keys %USER_GROUPS ) . "\n";

  sub user_login
  {
    my $user_name = shift;
    my $user_pass = shift;

    $USER_NAME   = undef;
    $USER_ID     = undef;
    %USER_GROUPS = ();

    # both name and password are required
    die "Empty user name"     if $user_name eq '';
    die "Empty user password" if $user_pass eq '';

    eval
    {
      my $ar = $DBH-&gt;selectcol_arrayref(
          'SELECT ID FROM USER WHERE NAME = ? AND PASS = ?',
                                        {},
                                        $user_name, $user_pass );

      $USER_ID   = shift @$ar;

      die "Wrong user name or password" unless $USER_ID &gt; 0;

      $USER_NAME = $user_name;

      # loading groups
      my $ar = $DBH-&gt;selectcol_arrayref( 'SELECT GROUP FROM MAP WHERE USER = ?',
                                        {},
                                        $USER_ID );

      %USER_GROUPS = map { $_ =&gt; 1 } @$ar;
    };
    if( $@ )
    {
      # something failed, it is important to clear user data here
      $USER_NAME   = undef;
      $USER_ID     = undef;
      %USER_GROUPS = ();

      # propagate error
      die $@;
    }
  }</code></pre>

<p>If Damian's password is correct, this code will print:</p>

<pre><code>  User logged in: Damian
  User id:        1
  User groups:    1, 2</code></pre>

<p>The group access check function now is even simpler:</p>

<pre><code>  sub check_access
  {
    my $group = shift;
    return 0 unless $group &gt; 0;
    return $USER_GROUPS{ $group };
  }</code></pre>

<p>Sample code for an access check after login will be something like:</p>

<pre><code>  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_access( 1 );

    # user allowed, group 1 check successful
    ...
  }</code></pre>

<p>or</p>

<pre><code>  if( check_access( 1 ) )
  {
    # user ok
  }
  else
  {
    # access denied
  }</code></pre>

<h3>Access Instructions</h3>

<p>The next problem is how to define which groups can perform specific operations. Where this information is static (most cases), you can store group lists in configuration (text) files:</p>

<pre><code>  LOGIN: 2
  EDIT:  1</code></pre>

<p>That is, the EDIT operation needs group 1 (admin) and LOGIN needs group 2 (all users).</p>

<p>Another example is to allow only administrators to log in during weekends:</p>

<pre><code>  # all users for mon-fri
  LOGIN_WEEKDAYS: 2

  # only admin for sat-sun
  LOGIN_WEEKENDS: 1</code></pre>

<p>Administrators will be in both groups (1, 2), so they will be able to log in anytime. All regular users cannot login on weekends.</p>

<p>This group list includes a moderators group. It could be useful to allow moderators do their job on weekends as well, implying an <code>OR</code> operation:</p>

<pre><code>  # only admin or moderators for sat-sun
  LOGIN_WEEKENDS: 1, 3</code></pre>

<p>This named set of groups is a <em>policy</em>.</p>

<p>For now, there's only one level in the policy and an <code>OR</code> operation between groups in a list. Real-world policies may be more complex. However there is no need to overdesign this. Even large systems may work with just one more level. Here's an <code>AND</code> operation:</p>

<pre><code>  LOGIN_WEEKENDS: 1+3, 4, 1+5+9</code></pre>

<p>This policy will match (allowing login on weekend days) only for users in the following groups:</p>

<pre><code>     1 AND 3
  OR 4
  OR 1 AND 5 AND 9</code></pre>













<p>The login procedure must match the <code>LOGIN_WEEKENDS</code> policy before allowing user to continue with other operations. Thus, you need a procedure for reading policy configuration files:</p>

<pre><code>  our %ACCESS_POLICY;

  sub read_access_config
  {
    my $fn = shift; # config file name

    open( my $f, $fn );
    while( &lt;$f&gt; )
    {
      chomp;
      next unless /\S/; # skip whitespace
      next if  /^[;#]/; # skip comments

      die "Syntax error: $_\n" unless /^\s*(\S+?):\s*(.+)$/;
      my $n = uc $1; # policy name: LOGIN_WEEKENDS
      my $v =    $2; # groups lsit: 1+3, 4, 1+5+9

      # return list of lists:
      # outer list uses comma separator, inner lists use plus sign separator
      $ACCESS_POLICY{ $n } = access_policy_parse( $v );
    }
    close( $f );
  }

  sub access_policy_parse
  {
    my $policy = shift;
    return [ map { [ split /[\s\+]+/ ] } split /[\s,]+/, $policy ];
  }</code></pre>

<p>For the <code>LOGIN_WEEKENDS</code> policy, the resulting value in <code>%ACCESS_POLICY</code> will be:</p>

<pre><code>  $ACCESS_POLICY{ 'LOGIN_WEEKENDS' } =&gt;

                [
                  [ '1', '3' ],
                  [ '4' ],
                  [ '1', '5', '9' ]
                ];</code></pre>

<p>To match this policy, a user must be in every groups listed in any of the inner lists:</p>

<pre><code>  sub check_policy
  {
    my $policy = shift;

    my $out_arr = $ACCESS_POLICY{ $policy };
    die "Invalid policy name; $policy\n" unless $out_arr;

    return check_policy_tree( $out_arr );
  }

  sub check_policy_tree
  {
    my $out_arr = shift;

    for my $in_arr ( @$out_arr )
    {

      my $c = 0; # matching groups count
      for my $group ( @$in_arr )
      {
        $c++ if $USER_GROUPS{ $group };
      }

      # matching groups is equal to all groups count in this list
      # policy match!
      return 1 if $c == @$in_arr;
    }

    # if this code is reached then policy didn't match
    return 0;
  }</code></pre>

<p>The example cases will become:</p>

<pre><code>  sub user_login
  {
      # login checks here
      ...

      # login ok, check weekday policy
      my $wday = (localtime())[6];

      my $policy;
      if( $wday == 0 or $wday == 6 )
      {
        $policy = 'LOGIN_WEEKEND';
      }
      else
      {
        $policy = 'LOGIN_WEEKDAY';
      }

      die "Login denied" unless check_policy( $policy );
  }

  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_policy( 'EDIT' );

    # user allowed, 'EDIT' policy match
    ...
  }</code></pre>

<p>Now you have all the parts of a working access control scheme:</p>

<ul>
<li>Policy configuration syntax</li>

<li>Policy parser</li>

<li>User group storage and mapping</li>

<li>User group loading</li>

<li>Policy match function</li>
</ul>

<p>This scheme may seem complete, but it lacks one thing.</p>

<h3>Data Fences</h3>

<p>In a multiuser system there is always some kind of ownership on the data stored in the database. This means that each user must see only those parts of the data that his user groups own.</p>

<p>This ownership problem solution is separate from the policy scheme. Each row must have one or more fields filled with groups that have access to the data. Any SQL statements for reading data must also check for this field:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $ug  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME
             WHERE READ_GROUP IN ( $rg ) AND UPDATE_GROUP IN ( $ug )";</code></pre>

<p>The result set will contain only rows with read and update groups inside the current user's group set. Sometimes you may need all of rows with the same read group for display, even though some of those rows have update restrictions the user does not meet. This case will use only the <code>READ_GROUP</code> field for select and will cut off users when they try to update the record without permission:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME WHERE READ_GROUP IN ( $rg )";

  $sth = $dbh-&gt;prepare( $sql );
  $sth-&gt;execute();
  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_access( $hr-&gt;{ 'UPDATE_GROUP' } );</code></pre>

<p>When access checks are explicitly after <code>SELECT</code> statements it is possible to store full policy strings inside <code>CHAR</code> fields:</p>

<pre><code>  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_policy_record( $hr, 'UPDATE_GROUP' );

  sub check_policy_record
  {
      my $hr     = shift; # hash with record data
      my $field  = shift; # field containing policy string

      my $policy = $hr-&gt;{ $field };
      my $tree   = access_policy_parse( $policy );

      return check_policy_tree( $tree );
  }</code></pre>

<h3>In the Middle of Nowhere</h3>

<p>This access control scheme is simple and usable as described. It does not cover all possible cases of access control, but every application has its own unique needs. In certain cases, you can push some of these access controls to lower levels -- your database, for example -- depending on your needs. Good luck with building your own great wall!</p>


]]>
        
    </content>
</entry>

<entry>
    <title>How to Tell Your Perl Story (at OSCON)</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2008/01/18/how-to-tell-your-perl-story.html" />
    <id>tag:com.perl.org,2008:/pub//2.638</id>

    <published>2008-01-18T08:00:00Z</published>
    <updated>2010-06-20T16:31:34Z</updated>

    <summary> Ever wanted to tell the world about the cool things you&apos;re doing with Perl? O&apos;Reilly Media recently announced the Call for Participation (CfP) for the 2008 Open Source Convention (OSCON), which includes the 12th Perl Conference. Although the conference...</summary>
    <author>
        <name>brian d foy</name>
        
    </author>
    
        <category term="Courses and Training" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="briandfoy" label="brian d foy" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="conference" label="conference" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="conferencesessions" label="conference sessions" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="lightningtalks" label="lightning talks" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="oscon" label="OSCON" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlconference" label="Perl Conference" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Ever wanted to tell the world about the cool things you're doing with Perl? O'Reilly Media recently announced the <a href="http://en.oreilly.com/oscon2008/public/cfp/13">Call for Participation (CfP) for the 2008 Open Source Convention (OSCON)</a>, which includes the 12th Perl Conference. Although the conference takes place from July 21 to 25, the planning has already started. Now's your opportunity to tell the world about the work you're doing with Perl and the work Perl is doing for you, but you have to propose a presentation by February 4.</p>

<p>(Granted, OSCON's not the only place you can tell your Perl story, so this advice applies to a far wider audience than you might think. There are too many conferences and seminars and workshops in the world to mention, but for the sake of clarity, I'm focusing on OSCON for two important reasons. First, it's probably the largest Perl-friendly conference in the world. Second, I'm on the review committee for the Perl track at OSCON.)</p>

<p>OSCON comprises several different sorts of presentations and sessions. There are tutorials that take from half a day or more, keynote sessions in front of the assembled conference, "break out" sessions for particular subjects, five minute "lightning" talks, and after hours "Birds of a Feather" sessions. There's not only something for every attendee, but an opportunity for every sort of speaker. Anyone can present at OSCON, and the conference organizers encourage everyone to participate; OSCON wants your Perl story!</p>

<h3>Finding the Good Stories</h3>

<p>This year I'm part of the reviewing committee for the OSCON Perl track. I'm not officially a part of O'Reilly and I don't get to make any promises, but I do get to help find and develop presentation ideas; the OSCON organizers don't just announce the CfP and hope for the best. To get the best conference possible, they also solicit proposals from people who can make for an interesting conference and also benefit their subject's community. This year we're trying to do more to find the stories we don't know about: that might be yours.</p>

<p>The review committee goes over and helps the conference organizers create the final schedule of presentations, taking into consideration the expected attendee interest, availability of rooms, and breadth of topics. It's not just about attracting the best celebrities, but also finding the compelling Perl stories for that year's audience.</p>

<p>You might be intimidated by the celebrity status of the usual speakers, the cornerstone people who have their pictures on the posters and the web site, but you shouldn't be. Everyone has to start somewhere, and a compelling story is as good as a name that everyone sees. People also want to know how other people use Perl better to get work done. You don't have to be a Perl guru to have a better way to get things done or a good story about how Perl made your life better.</p>

<h3>What's Your Story and What's Your Audience?</h3>

<p>Perl is a big subject, and I break down presentations into four basic categories, each of which has a different sort of audience and requires a different sort of speaker. To figure out what sort of presentation you can give, you just have to figure out how your story fits into one of these categories:</p>

<ul>
<li>The Perl language itself, and how it works</li>

<li style="list-style: none">
<p>These are the sorts of talks that language designers and gurus such as Larry Wall, Damian Conway, and Mark Jason Dominus give, sometimes in the form of tutorials. The language features aren't necessarily applied to particular problems but the audience can figure out how to adapt them to their own work. You're probably a Perl language architect and your audience would walk barefoot through broken glass to hear the latest Perl developments.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12819">Higher Order Perl</a> by Mark Jason Dominus</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13086">Perl 6 on Parrot</a> by Patrick Michaud</li>
</ul>
</li>
</ul>

<ul>
<li>Using Perl features to provide programmer capabilities</li>

<li style="list-style: none">
<p>These talks focus on modules and frameworks made for other programmers to solve problems in Perl. Often the person who did the work will be the speaker, but the people putting it into practice have good stories to tell too. You're probably working on really big iron moving lots of data, and so is your audience.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12881">DBD::G ofer: A Stateless DBI Proxy. For SOA and more!</a> by Tim Bunce</li>
</ul>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12956">wxPerl : Agile Cross-Platform GUI Design and Development</a> by Eric Wilhelm</li>
</ul>
</li>
</ul>

<ul>
<li>Using other technologies from Perl</li>

<li style="list-style: none">
<p>There are a lot of people out there experimenting with and building on the latest technologies, and they just happen to be using Perl to do it. These talks don't require extensive Perl knowledge so much as familiarity with the other technologies.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13020">Machine Learning Made Easy with Perl</a> by Lino Ramirez</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13137">Care and Feeding of Large Web Applications</a> by Perrin Harkins</li>
</ul>
</li>
</ul>

<ul>
<li>The process of using Perl to get work done</li>

<li style="list-style: none">
<p>Most people just want to get work done, and the more Perl can help them do that the better. These talks focus on using technology to get real value at the end of the day.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12781">Taming Legacy Perl</a> by Peter Scott</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13216">Simple Ways to be a Better Programmer</a> by Michael Schwern</li>
</ul>
</li>
</ul>

<h4>Lightning Talks and Birds of a Feather</h4>

<p>Maybe you aren't up to full 45 minute talk just yet. You can also present a lightning talk&#8212;a five minute mini-presentation. You may not think that you have much to say, but five minutes goes pretty quickly. It's a gentle way to start a career as a speaker. You don't need to develop a long talk; prepare a larger slide deck, and if you're terrified of public speaking, it's over pretty quickly. Everyone needs a place to start, so give this a try.</p>

<p>Birds of a Feather sessions are a bit different. They go on after the scheduled presentations each day. Although these are usually self-organized and decided by attendees while the conference is going on, you don't have to wait until the conference to start thinking about a session for a topic that interests you and talking to other people about it.</p>

<h4>Discussion Panels</h4>

<p>Perhaps you don't fancy yourself a speaker, but you're a subject matter expert and know all the key people in your field. Have you ever thought of moderating a panel? Pull together the right people and guide the discussion.</p>

<h3>What to Do Next</h3>

<p>Now it's up to you. Examine what you're doing with Perl, how you're using it, and how it makes your life better. Figure out how telling your Perl story can fit into OSCON and send us your proposal. If you need a little help or encouragement with your idea, just let me know. I'm here to help.</p>


]]>
        
    </content>
</entry>

<entry>
    <title>Memories of 20 Years of Perl</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/12/21/20-years-of-perl.html" />
    <id>tag:com.perl.org,2007:/pub//2.670</id>

    <published>2007-12-21T08:00:00Z</published>
    <updated>2010-06-20T16:31:38Z</updated>

    <summary> Proving Them Wrong Around 1991 I wrote a very useful program, in C, which took a bunch of files and then sorted them into groups according to which files had identical contents. A lot of sysadmins at the time...</summary>
    <author>
        <name>chromatic</name>
        
    </author>
    
        <category term="Advocacy" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="anniversary" label="anniversary" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="memories" label="memories" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl" label="Perl" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="programmingstories" label="programming stories" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->

<!-- sidebar ends -->

<h3>Proving Them Wrong</h3>

<p>Around 1991 I wrote a very useful program, in C, which took a bunch of files and then sorted them into groups according to which files had identical contents. A lot of sysadmins at the time wrote to thank me for it. But when I boasted about it at Usenix that year, people told me "oh, you should have written then in Perl."</p>

<p>That was pretty annoying, so I got the Camel Book (pink in those days) so that I could learn Perl and prove that they were wrong. But it turned out that they were right.</p>

<p><em>Mark Dominus is the author of <a href="http://hop.perl.plover.com/">Higher-Order Perl</a></em></p>

<h3>My First CGI Program</h3>

<p>It was the year 2000, and I was working at a software startup in San Francisco. I was tasked with writing a simple form handler with an auto thank you email. I had been a C programmer for several years, a Fortran programmer for a few, and this was essentially my first Perl program. It was your standard CGI gateway which presented a form to the user, did some error checking, and sent a thank you email to the user.</p>

<p>After a few hours of learning Perl and putting my form handler together, it was put live on our website. I was delighted that I was able to pick up this language so quickly and produce results in a short period of time. I never like programming C that much (although that has changed), due the fact that it got in my way. Perl just worked.</p>

<p>I came into work the next day and reviewed how my program was doing. It turns out that my first bug had surfaced; the thank you email function managed to get caught in a loop. One poor soul who filled out my form had received 800 thank you emails! I was able to quickly fix the bug.</p>

<p>In honor of my first Perl program, I would like to extend a hearty 800 thank yous to the Perl community! I have been using Perl ever since and love it.</p>

<p><em>Fred Moyer is just another mod_perl hacker</em></p>

<h3>Perl and the University Student</h3>

<p>One cannot imagine how useful Perl proves sometimes to a university student. I can recall several occasions in which I used Perl to facilitate a task or check my homework. Of them, there is one that I still remember very clearly.</p>

<p>It was the course "Introduction to Computer Networks" and we learned about the various variations of networking protocols (Stop-and-wait, Go-back-N, and Selective-Repeat). We were given a simulation of these protocols written in C and compiled to run on Windows. The simulation could be ran with several parameters and would output a verbose file with the parameters of the simulation, the simulation itself and then some statistics of the simulation.</p>

<p>We ran the program several times and got several files in return. Now we had to somehow insert the statistics into Excel so we can analyze them, process them, and create charts out of them. But the statistics were scattered over several different files, all with the same format, but nothing that Excel can understand (at least not without a massive amount of Visual Basic for Applications code).</p>

<p>Without thinking for a moment, I started writing a Perl script that will process the files, extract the corresponding data and output a tab-delimited file that can be inputted into Excel. It took some time to write the script, and meanwhile my partner decided it may be faster to do it by hand. Thus, he occupied the nearby station, and started extracting the data himself. I finished a few minutes after that, though, (while he was just beginning in his manual labour) and we were able to input the data into Excel and continue the assignment. It took about 15 minutes or less, all in all.</p>

<p>Later on I talked to a few fellow students about the assignment. One of them claimed it took him 3 hours to input everything into Excel. (!) Another said it took him one hour, which is still much worse than 15 minutes. Needless to say, none of them knew Perl.</p>

<p>Enough said.</p>

<p>(Originally published at <a href="http://perl.org.il/pipermail/perl/2003-October/003151.html">Perl Success Story, Israel.pm</a>.)</p>

<p><em>Shlomi Fish has worked with Perl since 1996 and considers himself a happy user, developer and advocate of Perl and other open-source technologies.</em></p>

<h3>How To Become a Guru</h3>

<p>In early 1999 I started a new job as a system administrator. In my previous position I'd taught myself Unix and GNU/Linux, and ended up writing a small tracking application for a customer service group in Java.</p>

<p>As a new SA, I took over a pile of work from my predecessor, including some small Perl programs he'd downloaded, installed, and modified to add his name to the comments. Over the next couple of months, I picked up the Camel and the Perl Cookbook, and taught myself enough Perl that I could skim comp.lang.perl.moderated and answer some of the questions in my head.</p>

<p>About that time, I started to do a little work on the Everything Engine -- not much, but a little bit -- and so I was the second external person to register on <a href="http://www.perlmonks.org/">PerlMonks</a> when it started. In those days there was no voting, no XP, and there were just a few people racing to reach the milestone of a hundred posts.</p>

<p>In between troubleshooting problems at work, I'd play with little programs, read whatever tutorials or books I could get, and answer any question I could on the site, and so I learned Perl that way.</p>

<p>I remember the rush to find an idea -- any idea -- worthy of putting on the CPAN, and thinking in 2000 that every problem that anyone could solve, someone had already solved. I remember my first patch to Perl 5, then realizing that I hadn't actually run the tests, and resolving to <em>improve</em> the tests because they didn't actually do what they said they should.</p>

<p>I remember getting job offers from my postings, and meeting some of the top Perl programmers in the world for the first time, and being accepted because I did (some of the) things I said I would, just because no one else was doing them.</p>

<p>That, I think, is the secret to become a contributing member of any community. Look for something that needs someone to do it and do it. You don't have to have permission, just a little bit of determination and stubbornness and some time.</p>

<p>I'm a little sad that I missed the first eleven years of Perl's life, but I'm glad to have caught up in the past nine years.</p>

<p><em>chromatic does a lot of things, some of them even sometimes productive.</em></p>

<h3>How an English Major Saved Christmas</h3>

<p>Right before Christmas of 1998 I was a fairly new employee at Amazon.com.
Not a CS grad hacker with 30,000 shares, but an English grad customer service
rep with 250. I knew about the 29,750 share disparity from picking up a fax
for a star employee in the apps group. Instead of letting it get to me, I
started to look into why it was so. I bought <em>Learning Perl</em> and spent
two of the most painful weeks of self-edification in my life discovering how
the lack of <code>chmod +x</code> was preventing me from getting through
Chapter 2.</p>

<p>Free at last I wrote, in two days, a badly needed and overlooked tax +
shipping costs calculator for customer service for the new product tab
launching that week. It was the kind of script that would take any decent
Perl hacker 30 minutes. A former art critic saved hundreds of reps and tens of
thousands of customers a lot of time and aggravation. I got the company�s
�Just Do It� Award. If it had been C or Java or anything but Perl I wouldn�t
have been able to do it.</p>

<p>If I�d come to anything but Perl, I would not have returned to coding--I
dabbled in BASIC and Assembly as a kid--and I wouldn�t be a software developer
today.</p>

<p><em>Ashley Pond V is a New Mexican writer turned Seattlite software
developer, currently working with Catalyst applications, who credits Perl with
saving his soul as he�d probably have gone into marketing otherwise.</em></p>

<h3>Smells Like Wet Camel</h3>

<p>Standing out in my memory is the day in college (either in late 1993 or
early 1994) when my grandmother had emergency eye surgery. Originally, she only
had a regularly scheduled checkup, and my mother could take her to the
appointment before work began, but not pick her up. The doctor was one street
over from the college (more or less) and I was conscripted to go over and take
her home after her appointment and my first class. The day was rainy,
increasing in intensity as the day grew older.</p>

<p>Everything changed when I arrived at the doctor's office, because the doctor
had found something that required immediate attention. She had to be taken to a
specialist immediately, and I began improvising. Each eye appointment took a
long time, and they would only get longer as my grandmother was worked in to
the specialist's schedule as an emergency patient. So I had time to take her to
the next appointment, leave her to wait for what might be hours, go to my next
class, eat lunch, and come back and get her.</p>

<p>I was trying to keep up with my college work, and brought my O'Reilly Perl
book along so I could work on my computer science project, figuring I might as
well do something useful while I was sitting around. My project involved
writing an e-mail processing system in Perl, so I had bought what was for me at
the time an almost impossibly expensive book to help me learn the language. On
the way to the car, in the hardest and coldest rain I can ever remember, I was
trying to help my grandmother and juggle the umbrella, car keys, car door, and
everything else. The book slipped out from under my arm and landed in a
puddle. Somehow, it landed on its edge, and had about an inch of muddy water
soak into it. My new book! Ruined! Nothing to do but keep going, to the next
appointment, and back to my class. I knew that to leave the college after eight
a.m. was a guarantee of not being able to park anywhere near the building for
the rest of the day, because the only parking spaces left were in the lower
area of an overflow lot far from any building I needed to go to. Without even
a sidewalk near this lot, I had plenty of time to think about my ruined book
and what was happening to my grandmother as I trudged through the mud, in the
pouring rain, to get to my next class.</p>

<p>I also, in these days before mobile phones, had to find a pay phone to tell
my mother about the abrupt change of plans. My grandmother eventually got
settled in the hospital, where it was at least dry, and she pulled through the
eye surgery fine. My waterlogged book with a brown bottom and hastily scribbled
notes on the blank pages in the back was a good enough starting point; I
graduated.</p>

<p><em><a href="http://www.scottmcmahan.net/">Scott McMahan</a> has been
writing Perl code since 1991.</em></p>

<h3>"I Couldn't Believe That Perl Even Worked"</h3>

<p>My first exposure to Perl was a web server with -- I think -- Perl 4.036
installed. This would be 1995 or so. I wanted to write CGI scripts so I started
reading everything I could find about Perl. I nearly lost heart when I read
that the parser was, effectively, heuristic. Coming from a background in Pascal
and C I couldn't believe that Perl even worked.</p>

<p>Fortunately Perl was the only option for my script. I persevered and
discovered that -- not only did Perl work -- I rather enjoyed it. Within two
weeks I had a CGI script that implemented a kind of ad-hoc PHP: chunks of Perl
embedded in HTML. It was ugly -- but Perl had made it possible.</p>

<p>At some time between then and now -- after digressions into Java and even
LotusScript -- Perl became my main language. At the end of 2006 I decided to
concentrate on Perl, release some modules, proactively seek out things I didn't
know about the language and learn them.</p>

<p>As a result 2007 has been the happiest year of my professional career.  I've
written loads of code, most of which works. I attended my first YAPC in Vienna
and came home with a bunch of new friends and a renewed enthusiasm for cranking
out code.</p>

<p>I've still got plenty to learn. Perl may be easy to pick up but mastery
takes years. And if you love programming that's part of the fun. However good
you think you are there's always a way to improve.</p>

<p>I dabble with other languages -- because if you take programming seriously
you must. What do they know of Perl that only Perl know?  There are things
about Perl that grate. It's not perfect but it's, well, loveable I suppose.</p>

<p>Thank you Perl community. Thank you Larry. Thank you for a lovely
language.</p>

<p><em>Andy Armstrong is a compulsive Perl abuser based in Cumbria,
UK.</em></p>

<h3>From awk to perl</h3>

<p>In early 1990, I was working with a large set of data that needed to be
massaged and formatted so that it could be statistically analyzed.</p>

<p>I started the task in awk, but quickly ran into trouble because awk could
only open one file at a time. A quick search through the Usenet comp.lang group
found Perl 3.0, which had just recently been released.</p>

<p>I had to get the source code and build it on my machine, but it compiled
cleanly and I was able to try some simple stuff. Worked real good too.  As I
had already a large awk program, that I didn't want to re-edit for Perl, I ran
it through <code>a2p</code> and the <code>perl</code> version produced the same
results. I was hooked.  When I got stuck, asking questions on comp.lang.perl
almost always got instant answers. There has been an active perl community for
a long time, and they were fabulous! (Just like now). I subsequently
re-factored my code for perl and produced vast quantities of data to be
analyzed. I have been using Perl ever since.</p>

<p><em>Roe McBurnett is a systems engineer for a telecommunications company and
has been working on telephony related projects as a developer, systems
engineer, and software tester since 1985.</em></p>
]]>
        
    </content>
</entry>

<entry>
    <title>Programming is Hard, Let&apos;s Go Scripting...</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/12/06/soto-11.html" />
    <id>tag:com.perl.org,2007:/pub//2.668</id>

    <published>2007-12-06T08:00:00Z</published>
    <updated>2010-06-20T16:31:38Z</updated>

    <summary> I think, to most people, scripting is a lot like obscenity. I can&apos;t define it, but I&apos;ll know it when I see it. Here are some common memes floating around: Simple language &quot;Everything is a string&quot; Rapid prototyping Glue...</summary>
    <author>
        <name>Larry Wall</name>
        
    </author>
    
        <category term="Larry Wall" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="languagedesign" label="language design" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="larrywall" label="Larry Wall" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl5" label="Perl 5" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl6" label="Perl 6" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="programminglanguages" label="programming languages" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="scripting" label="scripting" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="scriptinglanguages" label="scripting languages" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="stateoftheonion" label="state of the onion" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="worseisbetter" label="worse is better" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>I think, to most people, scripting is a lot like obscenity. I can't define it, but I'll know it when I see it. Here are some common memes floating around:</p>

<pre>    Simple language
    "Everything is a string"
    Rapid prototyping
    Glue language
    Process control
    Compact/concise
    Worse-is-better
    Domain specific
    "Batteries included"</pre>

<p>...I don't see any real center here, at least in terms of technology. If I had to pick one metaphor, it'd be easy onramps. And a slow lane. Maybe even with some optional fast lanes.</p>

<h3>Easy Onramps</h3>

<p>But basically, scripting is not a technical term. When we call something a scripting language, we're primarily making a linguistic and cultural judgment, not a technical judgment.</p>

<p>I see scripting as one of the humanities. It's our linguistic roots showing through. So speaking of roots...</p>

<h3>The Past</h3>

<p>Suppose you went back to Ada Lovelace and asked her the difference between a script and a program. She'd probably look at you funny, then say something like: Well, a script is what you give the actors, but a program is what you give the audience. That Ada was one sharp lady...</p>

<p>Since her time, we seem to have gotten a bit more confused about what we mean when we say scripting. It confuses even me, and I'm supposed to be one of the experts.</p>

<p>So I'm afraid all I can do is give you my own worm's eye view of the past, the present, and the future. Let me warn you that I am not without a few prejudices here and there.</p>

<h3>BASIC</h3>

<p>Now, however it was initially intended, I think BASIC turned out to be one of the first major scripting languages, especially the extended version that DEC put onto its minicomputers called BASIC/PLUS, which happily included recursive functions with arguments. I started out as a BASIC programmer. Some people would say that I'm permanently damaged. Some people are undoubtedly right.</p>

<p>But I'm not going to apologize for that. All language designers have their occasional idiosyncracies. I'm just better at it than most. <code>:-)</code></p>

<h3>RSTS BASIC/PLUS</h3>

<p>Anyway, when I was a RSTS programmer on a PDP-11, I certainly treated BASIC as a scripting language, at least in terms of rapid prototyping and process control. I'm sure it warped my brain forever. Perl's statement modifiers are straight out of BASIC/PLUS. It even had some cute sigils on the ends of its variables to distinguish string and integer from floating point.</p>

<p>But you could do extreme programming. In fact, I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane. Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That's rapid prototyping.</p>

<h3>Unix?</h3>

<p>I remember one day our computer center got a letter from Bell Labs telling us that we could get a tape of Unix V6 for cheap, only $100 because they were coming out shortly with V7. We all looked at each other and said, Why would we ever want to use this thing called Unix? We have RSTS.</p>

<h3>JAM (no not that one)</h3>

<p>My first scripting language was written in BASIC. For my job in the computer center I wrote a language that I called JAM, short for Jury-rigged All-purpose Meta-language. Story of my life...</p>

<p>JAM was an inside-out text-processing language much like PHP, except that HTML hadn't been invented yet. We mostly used it as a fancy macro processor for BASIC. Unlike PHP, it did not have 3,000 functions in one namespace. We wouldn't have had the memory, for one thing.</p>

<h3>LISP</h3>

<p>For good or ill, when I went off to grad school, I studied linguistics, so the only computer language I used there was LISP. It was my own personal McCarthy era.</p>

<p>Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.</p>

<p>And, of course, mere mortals have never really forgiven LISP for not catering to them.</p>

<h3>Pascal, Ada</h3>

<p>Once I got into industry, I wrote a compiler in Pascal for a discrete event simulator, and slavered over the forthcoming Ada specs. As a linguist, I don't think of Ada as a big language. Now, English and Japanese, those are big languages. Ada is just a medium-sized language.</p>

<h3>Unix, shell</h3>

<p>After several years I finally became acquainted with Unix and its various scripting languages. OK, to be more precise, BSD, and csh.</p>

<h3>BSD, csh</h3>

<p>Yeah, yeah, I know. More brain damage...</p>

<p>I also learned a little C.</p>

<h3>C</h3>

<p>That's because a little C is all there is. I'm still learning those libraries though.</p>

<h3>shell + awk + sed + find + expr...</h3>

<p>But the frustrations of Unix shell programming led directly to the creation of Perl, which I don't really have time to tell. But essentially, I found that shell scripting was intrinsically limited by the fact that most of its verbs are not under its control and hence largely inconsistent with each other. And the nouns are impoverished, restricted to strings and files, with who-knows-what typology.</p>

<h3>C xor shell</h3>

<p>More destructive was the mindset that it was a one-dimensional universe: you either programmed in C or you programmed in shell, because they're obviously at opposite ends of the One True Continuum. Perl came about when I realized that scripting did not always have to viewed as the opposite of programming, but that a single language could be pretty good for both. That opened up a huge ecological niche. Many of you have seen my old clamshell diagram, with the two dimensions of manipulexity and whipuptitude.</p>

<h3>Tcl</h3>

<p>After Perl came Tcl, which in a sense is a purer scripting language than Perl. Perl just pretends that everything is a string when it's convenient, but Tcl really believes that as a controlling metaphor. The string metaphor tends to have bad performance ramifications, but that's not why Tcl languished, I think. There were two reasons for that.</p>

<p>First, Tcl stayed in the Unix mindset that controlling tools was the opposite of creating tools, so they didn't optimize much. The fast parts can always be written in C, after all.</p>

<p>The second reason was the lack of a decent extension mechanism, so you ended up with separate executables for expect, incr-tcl, etc.</p>

<p>I must say, though, that I've always admired Tcl's delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax:</p>

<h3>Python</h3>

<p>After Tcl came Python, which in Guido's mind was inspired positively by ABC, but in the Python community's mind was inspired negatively by Perl. I'm not terribly qualified to talk about Python however. I don't really know much about Python. I only stole its object system for Perl&nbsp;5. I have since repented.</p>

<h3>Ruby</h3>

<p>I'm much more qualified to talk about Ruby--that's because a great deal of Ruby's syntax is borrowed from Perl, layered over Smalltalk semantics. I've always viewed Ruby as a much closer competitor for Perls ecological niche, not just because of the borrowed ideas, but because both Perl and Ruby take their functional programming support rather more seriously that Python does. On the other hand, I think Ruby kind of screwed up on its declaration syntax, among other things.</p>

<h3>*sh</h3>

<p>Meanwhile, the Bourne shell was extended into the Korn shell and bash. I didn't have much to do with those either. Thankfully. I will say that the continued evolution of the shell shows just how crufty a language can get when you just keep adding on ad hoc syntactic features.</p>













<h3>PHP</h3>

<p>We've also seen the rise of PHP, which takes the worse-is-better approach to dazzling new depths, as it were. By and large PHP seems to be making the same progression of mistakes as early Perl did, only slower. The one thing it does better is packaging. And when I say packaging, I don't mean namespaces.</p>

<h3>JavaScript</h3>

<p>Then there's JavaScript, a nice clean design. It has some issues, but in the long run JavaScript might actually turn out to be a decent platform for running Perl&nbsp;6 on. Pugs already has part of a backend for JavaScript, though sadly that has suffered some bitrot in the last year. I think when the new JavaScript engines come out we'll probably see renewed interest in a JavaScript backend.</p>

<h3>Monad/PowerShell</h3>

<p>I've looked a bit at Microsoft's Monad, and I'm pleased to note that it has object pipes like Perl&nbsp;6. I just hope they don't patent it.</p>

<h3>Lua, AppleScript</h3>

<p>There are other scripting languages in wide use. Sadly, I must confess I never looked closely at Lua or AppleScript, probably because I'm not a game designer with a Mac.</p>

<p>Actually, I suspect it runs deeper than that, which brings us up to the present time.</p>

<h3>The Present</h3>

<p>When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other's way in complacent isolation.</p>

<p>I tend to take an anthropological view of these things. Many of you here are Perl programmers, but some of you come from other programming tribes. And depending on your tribal history, you might think of a string as a pointer to a byte array if you're a C programmer, or as a list if you're a functional programmer, or as an object if you're a Java programmer. I view a string as a Text, with a capital T.</p>

<h3>Text</h3>

<p>I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.</p>

<p>But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don't want to talk to a stupid computer language. I want my computer language to understand the strings I type.</p>

<p>Perl is a postmodern language, and a lot of conservative folks feel like Postmodernism is a rather liberal notion. So it's rather ironic that my views on Postmodernism were primarily informed by studying linguistics and translation as taught by missionaries, specifically, the Wycliffe Bible Translators. One of the things they hammered home is that there's really no such thing as a primitive human language. By which they mean essentially that all human languages are Turing complete.</p>

<p>When you go out to so-called primitive tribes and analyze their languages, you find that structurally they're just about as complex as any other human language. Basically, you can say pretty much anything in any human language, if you work at it long enough. Human languages are Turing complete, as it were.</p>

<p>Human languages therefore differ not so much in what you <em>can</em> say but in what you <em>must</em> say. In English, you are forced to differentiate singular from plural. In Japanese, you don't have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you're talking to, but also your degree of respect for the person or thing you're talking about.</p>

<p>So languages differ in what you're forced to say. Obviously, if your language forces you to say something, you can't be concise in that particular dimension using your language. Which brings us back to scripting.</p>

<p>How many ways are there for different scripting languages to be concise?</p>

<p>How many recipes for borscht are there in Russia?</p>

<p>Language designers have many degrees of freedom. I'd like to point out just a few of them.</p>

<h3>early binding / late binding</h3>

<p>Binding in this context is about exactly when you decide which routine you're going to call for a given routine name. In the early days of computing, most binding was done fairly early for efficiency reasons, either at compile time, or at the latest, at link time. You still tend to see this approach in statically typed languages. With languages like Smalltalk, however, we began to see a different trend, and these days most scripting languages are trending towards later binding. That's because scripting languages are trying to be dwimmy (Do What I Mean), and the dwimmiest decision is usually a late decision because you then have more available semantic and even pragmatic context to work with. Otherwise you have to predict the future, which is hard.</p>

<p>So scripting languages naturally tend to move toward an object-oriented point of view, where the binding doesn't happen 'til method dispatch time. You can still see the scars of conflict in languages like C++ and Java though. C++ makes the default method type non-virtual, so you have to say virtual explicitly to get late binding. Java has the notion of final classes, which force calls to the class to be bound at compile time, essentially. I think both of those approaches are big mistakes. Perl&nbsp;6 will make different mistakes. In Perl&nbsp;6 all methods are virtual by default, and only the application as a whole can tell the optimizer to finalize classes, presumably only after you know how all the classes are going to be used by all the other modules in the program.</p>

<h3>single dispatch / multiple dispatch</h3>

<p>In a sense, multiple dispatch is a way to delay binding even longer. You not only have to delay binding 'til you know the type of the object, but you also have to know the types of all rest of the arguments before you can pick a routine to call. Python and Ruby always do single dispatch, while Dylan does multiple dispatch. Here is one dimension in which Perl&nbsp;6 <em>forces</em> the caller to be explicit for clarity. I think it's an important distinction for the programmer to bear in mind, because single dispatch and multiple dispatch are philosophically very different ideas, based on different metaphors.</p>

<p>With single-dispatch languages, you are basically sending a message to an object, and the object decides what to do with that message. With multiple dispatch languages, however, there is no privileged object. All the objects involved in the call have equal weight. So one way to look at multiple dispatch is that the objects are completely passive. But if the objects aren't deciding how to bind, who is?</p>

<p>Well, it's sort of a democratic thing. All the routines of a given name get together and hold a political conference. (Well, not really, but this is how the metaphor works.) Each of the routines is a delegate to the convention. All the potential candidates put their names in the hat. Then all the routines vote on who the best candidate is, and the next best, and the next best after that. And eventually the routines themselves decide what the best routine to call is.</p>

<p>So basically, multiple dispatch is like democracy. It's the worst way to do late binding, except for all the others.</p>

<p>But I really do think that's true, and likely to become truer as time goes on. I'm spending a lot of time on this multiple dispatch issue because I think programming in the large is mutating away from the command-and-control model implicit in single dispatch. I think the field of computation as a whole is moving more toward the kinds of decisions that are better made by swarms of insects or schools of fish, where no single individual is in control, but the swarm as a whole has emergent behaviors that are somehow much smarter than any of the individual components.</p>

<h3>eager evaluation / lazy evaluation</h3>

<p>Most languages evaluate eagerly, including Perl&#160;5. Some languages evaluate all expressions as lazily as possible. Haskell is a good example of that. It doesn't compute anything until it is forced to. This has the advantage that you can do lots of cool things with infinite lists without running out of memory. Well, at least until someone asks the program to calculate the whole list. Then you're pretty much hosed in any language, unless you have a real Turing machine.</p>

<p>So anyway, in Perl&#160;6 we're experimenting with a mixture of eager and lazy. Interestingly, the distinction maps very nicely onto Perl&#160;5's concept of scalar context vs. list context. So in Perl&#160;6, scalar context is eager and list context is lazy. By default, of course. You can always force a scalar to be lazy or a list to be eager if you like. But you can say things like <code>for 1..Inf</code> as long as your loop exits some other way a little bit before you run into infinity.</p>

<h3>eager typology / lazy typology</h3>

<p>Usually known as static vs. dynamic, but again there are various positions for the adjustment knob. I rather like the gradual typing approach for a number of reasons. Efficiency is one reason. People usually think of strong typing as a reason, but the main reason to put types into Perl&#160;6 turns out not to be strong typing, but rather multiple dispatch. Remember our political convention metaphor? When the various candidates put their names in the hat, what distinguishes them? Well, each candidate has a political platform. The planks in those political platforms are the types of arguments they want to respond to. We all know politicians are only good at responding to the types of arguments they want to have...</p>

<p>There's another way in which Perl&#160;6 is slightly more lazy than Perl&#160;5. We still have the notion of contexts, but exactly when the contexts are decided has changed. In Perl&#160;5, the compiler usually knows at compile time which arguments will be in scalar context, and which arguments will be in list context. But Perl&#160;6 delays that decision until method binding time, which is conceptually at run time, not at compile time. This might seem like an odd thing to you, but it actually fixes a great number of things that are suboptimal in the design of Perl&#160;5. Prototypes, for instance. And the need for explicit references. And other annoying little things like that, many of which end up as frequently asked questions.</p>

<h3>limited structures / rich structures</h3>

<p>Awk, Lua, and PHP all limit their composite structures to associative arrays. That has both pluses and minuses, but the fact that awk did it that way is one of the reasons that Perl does it differently, and differentiates ordered arrays from unordered hashes. I just think about them differently, and I think a lot of other people do too.</p>

<h3>symbolic / wordy</h3>

<p>Arguably APL is also a kind of scripting language, largely symbolic. At the other extreme we have languages that eschew punctuation in favor of words, such as AppleScript and COBOL, and to a lesser extent all the Algolish languages that use words to indicate blocks where the C-derived languages use curlies. I prefer a balanced approach here, where symbols and identifiers are each doing what theyre best at. I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don't like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That's one thing I learned when I switched from Pascal to C. Braces for blocks. It's just right visually.</p>

<p>Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don't want your functors to stand out. It's shouting the wrong words: IF! foo THEN! bar ELSE! baz END! END! END! END!</p>

<p>Anyway, in Perl&#160;6 we're raising the standard for where we use punctuation, and where we don't. We're getting rid of some of our punctuation that isn't really pulling its weight, such as parentheses around conditional expressions, and most of the punctuational variables. And we're making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.</p>

<p>Oddly, there's one spot where we're introducing new punctuation. After your sigil you can add a twigil, or secondary sigil. Just as a sigil tells you the basic structure of an object, a twigil tells you that a particular variable has a weird scope. This is basically an idea stolen from Ruby, which uses sigils to indicate weird scoping. But by hiding our twigils after our sigils, we get the best of both worlds, plus an extensible twigil system for weird scopes we haven't thought of yet.</p>

<p>We think about extensibility a lot. We think about languages we don't know how to think about yet. But leaving spaces in the grammar for new languages is kind of like reserving some of our land for national parks and national forests. Or like an archaeologist not digging up half the archaeological site because we know our descendants will have even better analytical tools than we have.</p>

<p>Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don't make your best guess now, you're not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn't be as sure about that if APL hadn't tried it first.</p>













<h3>compile time / run time</h3>

<p>Many dynamic languages can eval code at run time. Perl also takes it the other direction and runs a lot of code at compile time. This can get messy with operational definitions. You don't want to be doing much file I/O in your <code>BEGIN</code> blocks, for instance. But that leads us to another distinction:</p>

<h3>declarational / operational</h3>

<p>Most scripting languages are way over there on the operational side. I thought Perl&#160;5 had an oversimplified object system till I saw Lua. In Lua, an object is just a hash, and there's a bit of syntactic sugar to call a hash element if it happens to contain code. Thats all there is. They don't even have classes. Anything resembling inheritance has to be handled by explicit delegation. That's a choice the designers of Lua made to keep the language very small and embeddable. For them, maybe it's the right choice.</p>

<p>Perl&#160;5 has always been a bit more declarational than either Python or Ruby. I've always felt strongly that implicit scoping was just asking for trouble, and that scoped variable declarations should be very easy to recognize visually. Thats why we have <code>my</code>. It's short because I knew we'd use it frequently. Huffman coding. Keep common things short, but not too short. In this case, 0 is too short.</p>

<p>Perl&#160;6 has more different kinds of scopes, so we'll have more declarators like <code>my</code> and <code>our</code>. But appearances can be deceiving. While the language looks more declarative on the surface, we make most of the declarations operationally hookable underneath to retain flexibility. When you declare the type of a variable, for instance, you're really just doing a kind of tie, in Perl&#160;5 terms. The main difference is that you're tying the implementation to the variable at compile time rather than run time, which makes things more efficient, or at least potentially optimizable.</p>

<h3>immutable classes / mutable classes</h3>

<p>Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby's classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.</p>

<p>Perl&#160;6 will have an interesting mix of immutable generics and mutable classes here, and interesting policies on who is allowed to close classes when. Classes are never allowed to close or finalize themselves, for instance. Sorry, for some reason I keep talking about Perl&#160;6. It could have something to do with the fact that we've had to think about all of these dimensions in designing Perl&#160;6.</p>

<h3>class-based / prototype-based</h3>

<p>Here's another dimension that can open up to allow both approaches. Some of you may be familiar with classless languages like Self or JavaScript. Instead of classes, objects just clone from their ancestors or delegate to other objects. For many kinds of modeling, it's actually closer to the way the real world works. Real organisms just copy their DNA when they reproduce. They don't have some DNA of their own, and an <code>@ISA</code> array telling you which parent objects contain the rest of their DNA.</p>

<p>The meta-object protocol for Perl&#160;6 defaults to class-based, but is flexible enough to set up prototype-based objects as well. Some of you have played around with <a href="http://search.cpan.org/perldoc?Moose">Moose</a> in Perl&#160;5. Moose is essentially a prototype of Perl&#160;6's object model. On a semantic level, anyway. The syntax is a little different. Hopefully a little more natural in Perl&#160;6.</p>

<h3>passive data, global consistency / active data, local consistency</h3>

<p>Your view of data and control will vary with how functional or object-oriented your brain is. People just think differently. Some people think mathematically, in terms of provable universal truths. Functional programmers don't much care if they strew implicit computation state throughout the stack and heap, as long as everything <em>looks</em> pure and free from side-effects.</p>

<p>Other people think socially, in terms of cooperating entities that each have their own free will. And it's pretty important to them that the state of the computation be stored with each individual object, not off in some heap of continuations somewhere.</p>

<p>Of course, some of us can't make up our minds whether we'd rather emulate the logical Sherlock Holmes or sociable Dr. Watson. Fortunately, scripting is not incompatible with either of these approaches, because both approaches can be made more approachable to normal folk.</p>

<h3>info hiding / scoping / attachment</h3>

<p>And finally, if you're designing a computer language, there are a couple bazillion ways to encapsulate data. You have to decide which ones are important. What's the best way to let the programmer achieve separation of concerns?</p>

<h3>object / class / aspect / closure / module / template / trait</h3>

<p>You can use any of these various traditional encapsulation mechanisms.</p>

<h3>transaction / reaction / dynamic scope</h3>

<p>Or you can isolate information to various time-based domains.</p>

<h3>process / thread / device / environment</h3>

<p>You can attach info to various OS concepts.</p>

<h3>screen / window / panel / menu / icon</h3>

<p>You can hide info various places in your GUI. Yeah, yeah, I know, everything is an object. But some objects are more equal than others.</p>

<h3>syntactic scope / semantic scope / pragmatic scope</h3>

<p>Information can attach to various abstractions of your program, including, bizarrely, lexical scopes. Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn't work right. A <code>state</code> variable is actually more purely lexical than a <code>my</code> variable, because it's shared by all calls to that lexical scope. But even state variables get cloned with closures. Only global variables can be truly lexical, as long as you refer to them only in a given lexical scope. Go figure.</p>

<p>So really, most of our scopes are semantic scopes that happen to be attached to a particular syntactic scope.</p>

<p>You may be wondering what I mean by a <em>pragmatic</em> scope. That's the scope of what the user of the program is storing in their brain, or in some surrogate for their brain, such as a game cartridge. In a sense, most of the web pages out there on the Internet are part of the pragmatic scope. As is most of the data in databases. The hallmark of the pragmatic scope is that you really don't know the lifetime of the container. It's just out there somewhere, and will eventually be collected by that Great Garbage Collector that collects all information that anyone forgets to remember. The Google cache can only last so long. Eventually we will forget the meaning of every URL. But we must not forget the <em>principle</em> of the URL. That leads us to our next degree of freedom.</p>

<h3>use Lingua::Perligata;</h3>

<p>If you allow a language to mutate its own grammar within a lexical scope, how do you keep track of that cleanly? Perl&#160;5 discovered one really bad way to do it, namely source filters, but even so we ended up with Perl dialects such as Perligata and Klingon. What would it be like if we actually did it right?</p>

<p>Doing it right involves treating the evolution of the language as a pragmatic scope, or as a set of pragmatic scopes. You have to be able to name your dialect, kind of like a URL, so there needs to be a universal root language, and ways of warping that universal root language into whatever dialect you like. This is actually near the heart of the vision for Perl&#160;6. We don't see Perl&#160;6 as a single language, but as the root for a family of related languages. As a family, there are shared cultural values that can be passed back and forth among sibling languages as well as to the descendants.</p>

<p>I hope you're all scared stiff by all these degrees of freedom. I'm sure there are other dimensions that are even scarier.</p>

<p>But... I think its a manageable problem. I think its possible to still think of Perl&#160;6 as a scripting language, with easy onramps.</p>

<p>And the reason I think its manageable is because, for each of these dimensions, it's not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.</p>

<h3>You can't even think about X!<br />
There's only one way to do X!<br />
There's more than one way to do X!<br />
There are too many ways to do X!</h3>

<p>You may recognize some slogans in here.</p>

<h3>Curling Up</h3>

<p>So I'm not suggesting that all scripting languages have to take all these dimensions into account, even if Perl&#160;6 tries to. The scripting paradigm is not any one of these dimensions. According to various theories the universe may be laid out in ten or twenty dimensions, but generally we get by with only about three and a half of those dimensions. The rest are said to be curled up. Maybe we live in a scripting universe.</p>

<p>Most of the scripting languages we call Perl&#160;6 will have most of these dimensions curled up most of the time. But unlike the real universe, where it takes huge machines to uncurl these dimensions, we'll make the dimensions uncurl just by keeping our declarations straight. Well, we'll try. And where that fails, we'll rely on the culture to keep things straight.</p>

<p>For example, that's exactly what happened already with Perl&#160;5. We have the declarations, <code>use strict; use warnings;</code>. But it's the culture that decided to enforce the use of them. So much so that we've decided that they should be the default for most of Perl&#160;6. It was one of those decisions by the hive. In this case the swarm turned out to be smarter than the language designer. And that's as it should be.</p>

<h3>The Future</h3>

<p>Well, so what's the future of scripting?</p>

<p>In my completely unbiased opinion, that would be Perl&#160;6. <code>:-)</code></p>

<p>Seriously though, it's always safe to predict that the ecological landscape will end up with many small languages and a few dominant ones. Some languages like AppleScript have particular ecological niches and are unlikely to grow out of them. Other languages get used outside their original niche. There will always be the generalists, like crows and mockingbirds, and the specialists, like penguins and dodos. (Well, maybe not always the dodos...)</p>

<p>Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I'm better at being worser! Is it really true that the worse-is-better approach always wins? With Perl&nbsp;6 we're trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.</p>
]]>
        
    </content>
</entry>

<entry>
    <title>PDF Processing with Perl</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/09/20/pdf-processing-with-perl.html" />
    <id>tag:com.perl.org,2007:/pub//2.666</id>

    <published>2007-09-21T07:00:00Z</published>
    <updated>2010-06-20T16:31:38Z</updated>

    <summary> Adobe&apos;s PDF has become a standard for text documents. Most office products can export their content into PDF. However, this software reaches its limits if you want advanced tasks such as combining different PDF documents into one single document...</summary>
    <author>
        <name>Detlef Groth</name>
        
    </author>
    
        <category term="CPAN" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="creatingpdfs" label="creating PDFs" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pdf" label="PDF" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pdfcreate" label="PDF create" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pdfreuse" label="PDF::Reuse" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p><a href="http://www.adobe.com/">Adobe</a>'s PDF has become a standard for text documents. Most office products can export their content into PDF. However, this software reaches its limits if you want advanced tasks such as combining different PDF documents into one single document or adding and adjusting the bookmarks panel for better navigation. Imagine that you want to collect all relevant Perl.com articles in one PDF file with an up-to-date bookmarks panel. You could use a tool like <a href="http://www.easysw.com/">HTMLDOC</a>, but adding article number 51 would require you to fetch articles one through 50 from the Web again. In most cases you would not be satisfied by the resulting bookmarks panel, either. This article shows how to use <a href="http://search.cpan.org/dist/PDF-Reuse/">PDF::Reuse</a>, by Lars Lundberg, for combining different PDF documents and adding bookmarks to them.</p>

<h3>Example Material</h3>

<p>Although its capabilities are limited in this area, you can also use <code>PDF::Reuse</code> to create PDF documents. If you want to create more sophisticated documents you should investigate other PDF-packages like <a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a> from Alfred Reibenschuh or <a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a> from Martin Hosken. However <code>PDF::Reuse</code> is sufficient to create a simple PDF to use in later examples. The following listing should be rather self explanatory.</p>

<pre><code> # file: examples/create-pdfs.pl
  use strict;
  use PDF::Reuse;

  mkdir "out" if (!-e "out") ;

  foreach my $x (1..4) {
      prFile("out/file-$x.pdf");

      foreach my $y (1..10) {
          prText(35,800,"File: file-$x.pdf");
          prText(510,800,"Page: $y");

          foreach my $z (1..15) {
              prText(35,700-$z*16,"Line $z");
          }

          # add graphics with the prAdd function

          # stroke color
          prAdd("0.1 0.1 0.9 RG\n");

          # fill color
          prAdd("0.9 0.1 0.1 rg\n");

          my $pos = 750 - ($y * 40);

          prAdd("540 $pos 10 40 re\n");
          prAdd("B\n");

          if ($y &lt; 10) {
              prPage();
          }
      }

      prEnd();
  }</code></pre>

<p>Open a new file with with <code>prFile($filename)</code> and close it with <code>prEnd</code>. Between those two calls, add text with the <code>prText</code> command. You can also draw graphics by using the low level command <code>prAdd</code> with plain PDF markup as parameter. Start a new page with <code>prPage</code>. <code>prFile</code> starts the first one automatically, so you need to add a new page only if your document has more than one page. Be aware that for the <code>prText(x,y,Text)</code> command the origin of the coordinate system is on the left bottom of the page.</p>

<p>As an example of adding PDF markup with <code>prAdd</code>, the code creates a red rectangle with blue borders. In case you would like to add more graphics or complex graphics to your PDF, you can study the examples of the <a href="http://partners.adobe.com/public/developer/pdf/index_reference.html">PDF reference manual</a>. If so, consider switching to <code>PDF::API2</code> or <code>Text::PDF</code> instead of using <code>prAdd</code>, as they both provide a comfortable layer of abstraction over the PDF markup language.</p>

<h3>Combining PDF Documents</h3>

<p><code>PDF::Reuse</code>'s main strength is the modification and reassembling of existing PDF documents. The next example assembles a new file from the example material.</p>

<pre><code>  # file: examples/combine-pdfs.pl

  use strict;
  use PDF::Reuse;

  prFile("out/resultat.pdf");

  prDoc('out/file-1.pdf',1,4);
  prDoc('out/file-2.pdf',2,9);
  prDoc('out/file-3.pdf',8);
  prDoc('out/file-4.pdf');

  prEnd();</code></pre>

<p>Again, <code>prFile($filename)</code> opens the file. Next, the <code>prDoc($filename, $firstPage, $lastPage)</code> calls add to the new file various page ranges from the example file. The arguments <code>$firstPage</code> and <code>$lastPage</code> are optional. Omit both to add the entire document. If only <code>$firstPage</code> is present, the call will add everything from that page to the end. Finally, <code>prEnd</code> closes the file.</p>

<h3>Reusing Existing PDF Files</h3>

<p>With <code>PDF::Reuse</code> it is possible to use existing PDF files as templates for creating new documents. Suppose that you have a file <em>customer.txt</em> containing a list of customers to whom to send a letter. You've used a tool to create a PDF document, such as OpenOffice.org or Adobe Acrobat, to produce the letter itself. Now you can write a short program to add the date and the names and addresses of your customers to the letter.</p>

<pre><code>  # file: examples/reuse-letter.pl
  use PDF::Reuse;
  use Date::Formatter;
  use strict;

  my $date = Date::Formatter-&gt;now();
  $date-&gt;createDateFormatter("(DD).(MM). (YYYY)");

  my $n      =  1;
  my $incr   = 14;
  my $infile = 'examples/customer.txt';

  prFile("examples/sample-letters.pdf");

  prCompress(1);
  prFont('Arial');
  prForm("examples/sample-letter.pdf");

  open (my $fh, "&lt;$infile") || die "Couldn't open $infile, $!\n aborts!\n";

  while (my $line = &lt;$fh&gt;)  {
      my $x = 60;
      my $y = 760;

      my ($first, $last, $street, $zipCode, $city, $country) = split(/,/, $line);
      last unless $country;

      prPage() if $n++ &gt; 1 ;
      prText($x, $y, "$first $last");

      $y -= $incr;
      prText($x, $y, $street);

      $y -= $incr;
      prText($x, $y, $zipCode);
      prText(($x + 40), $y, $city);

      $y -= $incr;
      prText($x,   $y, $country);
      prText(60,  600, "Dear $first $last,");
      prText(400, 630, "Berlin, $date");
  }

  prEnd();
  close $fh;</code></pre>

<p>After opening the file with <code>prFile</code>, the call to <code>prCompress(1)</code> enables PDF compression. <code>prFont</code> sets the file's font. The always-available options are Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, and Helvetica-BoldOblique. Set the font size with <code>prFontSize</code>. The default font is Helvetica, with 12 pixel size.</p>

<p>The rest of the code is a simple loop over the file containing the customer data to filling the template with <code>prText</code>.</p>













<h3>Adding Page Numbers</h3>

<p>Sometimes you need only make a small change to a document, such as adding missing page numbers.</p>

<pre><code>  # file: examples/sample-numbers.pl
  use PDF::Reuse;
  use strict;

  my $n = 1;

  prFile('examples/sample-numbers.pdf');

  while (1) {
     prText(550, 40, $n++);
     last unless prSinglePage('sample-letters.pdf');
  }

  prEnd();</code></pre>

<p><code>prSinglePage</code> takes one page after the other from an existing PDFdocument and returns the number of remaining pages after each invocation.</p>

<h3>Low-Level PDF Commands</h3>

<p>If you know low-level PDF instructions, you can add them with with the <code>prAdd(string)</code> subroutine. <code>PDF::Reuse</code> will perform no syntax checks on the instructions, so refer to the PDF reference manual. Here's an example of printing colored rectangles with the <code>prAdd</code> subroutine.</p>

<pre><code>  # file: examples/sample-rectangle.pl
  use PDF::Reuse;
  use strict;

  prFile('examples/sample-rectangle.pdf');

  my $x = 40;
  my $y = 50;
  my @colors;

  foreach my $r (0..5) {
     foreach my $g (0..5) {
         foreach my $b (0..5) {
             push @colors,
                 sprintf("%1.1f %1.1f %1.1f rg\n",
                 $r * 0.2, $g * 0.2, $b * 0.2);
         }
     }
  }

  while (1) {
     if ($x &gt; 500) {
         $x = 40; $y += 40;
         last unless @colors;
     }

     # a rectangle
     my $string = "$x $y 30 30 re\n";
     $string   .= shift @colors;

     # fill and stroke
     $string   .= "b\n";

     prAdd($string);

     $x += 40;
  }

  prEnd();</code></pre>

<h3>Adding Bookmarks</h3>

<p>Working with PDF files becomes comfortable if the document has bookmarks with a table of contents-like structure. Some applications either can't provide the PDF document with bookmarks or support insufficient or incorrect bookmarks. <code>PDF::Reuse</code> can fill this gap with the <code>prBookmark($reference)</code> subroutine.</p>

<p>A bookmark reference is a hash or a array of hashes that looks like:</p>

<pre><code>   {  text  =&gt; 'Document-Text',
             act   =&gt; 'this.pageNum = 0; this.scroll(40, 500);',
             kids  =&gt; [ { text =&gt; 'Chapter 1',
                          act  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          act  =&gt; '10, 40, 600'
                        }
                      ]
   }</code></pre>

<p>...where <code>act</code> is a JavaScript action to trigger when someone clicks on the bookmark. Because those JavaScript actions only work in the Acrobat Reader but not in other PDF viewer applications, I will later show a improvement of <code>PDF::Reuse</code> that fixes this issue.</p>

<p>Other examples for using <code>PDF::Reuse</code>, including image embedding, are available in the <a href="http://search.cpan.org/perldoc?PDF::Reuse::Tutorial">PDF::Reuse::Tutorial</a>.</p>

<h3>A Console Application for Combining PDF Documents</h3>

<p>To avoid editing the Perl code for combining PDF documents every time you want to merge documents, I've written a console application that takes the names of the input files and the page ranges for each file as arguments. That's easy to reuse in a graphical application using Perl/Tk, so I've put that code in a separate Perl module called <code>CombinePDFs</code>. The command-line application will interact with this package instead of directly working on <code>PDF::Reuse</code>. The following diagram shows the relationship between the Packages, example, and applications.</p>

<pre><code>  Examples    |     Packages            |     applications
  -------------------------------------------------------------------
  combine.pdfs                           app-combine-console-pdfs.pl
              \                         /
               PDF::Reuse -- CombinePDFs
              /                         \
   create.pdfs                           app-combine-tk-pdfs.pl</code></pre>

<p>The application <em>app-combine-console-pdfs.pl</em> does not deal directly with <code>PDF::Reuse</code> but parses the command line arguments with <a href="http://search.cpan.org/perldoc?Getopt::Long">Getopt::Long</a> written by Johan Vromans. This is the standard package for this task. Here it parses the input filenames and the page ranges into two arrays of same length. The user also has to supply a filename for the output and, optionally, a bookmarks file. The main subroutine that parses the command line arguments and executes <code>CombinePDFs::createPDF</code> is:</p>

<pre><code>  sub main {
      GetOptions("infile=s"    =&gt; \@infiles,
                 "outfile=s"   =&gt; \$outfile,
                 "pages=s",    =&gt; \@pages,
                 'overwrite'   =&gt; \$overwrite,
                 'bookmarks:s' =&gt; \$bookmarks,
                 'help'        =&gt; \&amp;help);
      help unless ((@infiles and $outfile and @pages) and @pages == @infiles);

      checkPages();
      checkFiles();
      checkBookmarks();

      CombinePDFs::createPDF(\@infiles, \@pages, $outfile, $bookmarks);
  }</code></pre>

<p>If the user passes an insufficient number of arguments, invalid filenames, or incorrect page ranges, the code invokes the the usage subroutine. It also gets invoked if the user asks explicitly for <code>-help</code> on the command line. Any good command line application should be written that way. <code>Getopt::Long</code> can distinguish between mandatory arguments, with <code>=</code> as the symbol after the argument name (infile, pages), optional arguments, with <code>:</code> (bookmarks), or flags (overwrite, usage), without a symbol. It can store these arguments as arrays (infile, pages), hashes, or scalars. It also supports type checking.</p>













<h3>CombinePDFs Package</h3>

<p>The application itself mainly performs error checking. If everything is fine, it calls the <code>CombinePDFs::createPDF</code> subroutine, passing the array of input files, the array of page ranges, and the bookmarks information. The bookmarks scalar is optional.</p>

<p>Page ranges can be comma-separated ranges (<code>1-11,14,17-23</code>), single pages, or the <code>all</code> token. You can include the same page several times in the same document.</p>

<p>The file-checking code looks for read permissions and tests if the file is a PDF document by using the <code>CombinePDFs::isPDF($filename)</code> subroutine. Although <a href="http://search.cpan.org/dist/PDF/">PDF</a>, by Antonio Rosella, also provides such a method, this package was not developed with the <code>use strict</code> pragma and gives a lot of warnings. Furthermore, the package is not actively maintained, so there seems to be no chance to fix this in the near future. Implementing the <code>isPDF</code> subroutine is quite simple; it reads the first line of the PDF file and checks for the magic string <code>%PDF-1.[0-9]</code> in the first line of the document.</p>

<p>Please note that <code>PDF::Reuse</code> is not an object oriented package. Therefore the <code>CombinePDFs</code> package is not object oriented, either. A user of this package could create several instances, but all instances work on the same PDF file.</p>

<p>Submitting complex data structures via the command line is a difficult issue, so I decided that bookmarks should come from a text file. This file has a simple markup to reflect a tree structure, where each line resembles:</p>

<pre><code> &lt;level&gt; "bookmarks text" &lt;page&gt;</code></pre>

<p>The level starts with 0 for root bookmarks. Children of the root bookmarks have a level of 1, their children a level of 2, and so on. Currently, the system supports bookmarks up to three levels of nesting:</p>

<pre><code> 0 "Folder File 1 - Page 1" 1
 1 "File 1 - Page 2" 2
 1 "Subfolder File 1 - Page 3" 3
 2 "File 1 - Page 4"  4
 0 "Folder File 2 - Page 7 " 7
 1 "File 2 - Page 7" 7
 1 "File 2 - Page 9" 9</code></pre>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> should be easy to understand, though that's not necessarily true of the complex data structure created inside this subroutine.</p>

<p>Bookmarks are an array of hashes. <code>addBookmarks</code> uses several attributes. <code>text</code> is the title of the entry in the bookmarks panel. <code>act</code> is the action to trigger when someone clicks the entry. Here it is the page number to open. <code>kids</code> contains a reference to the children of this bookmark entry. During the loop over the file content, the code searches for each level the last entry in a variable and pushes its related children on those last entries. The root bookmarks get collected as an array, and the loop adds the children as a reference to an array, and so on for the grand children. The result is a nested complex data structure which stores all children in the <code>kids</code> attribute of the parent's bookmarks hash&#8212;an array of hashes containing other arrays of hashes and so on.</p>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> collects bookmarks in a array of hashes. At the end, it adds the bookmarks to the document with <code>prBookmarks($reference)</code>. All of this means that you can use a bookmarks file with the PDF file with a command line like:</p>

<pre><code>   $ perl bin/app-combine-pdfs.pl \
      --infile out/file-1.pdf --pages 1-6 \
      --infile out/file-2.pdf --pages 1-4,7,9-10 \
      --bookmarks out/bookmarks.cnt \
      --outfile file-all.pdf --overwrite</code></pre>

<p>Currently, you must open the document's navigation panel manually because <code>PDF::Reuse</code> does not yet allow you to declare a default view, whether full screen or panel view. This is easy to fix, and the author Lars Lundberg has promised me to do so in a next release of <code>PDF::Reuse</code>. In order to enable this feature until a new release will appear I included a modified version of <code>PDF::Reuse</code> in the examples zip file that accompanies this article.</p>

<p>Furthermore, the bookmarks use JavaScript functions. To use the bookmarks in PDF viewers other than Acrobat Reader, my patched <code>PDF::Reuse</code> package replaces JavaScript bookmarks with PDF specification compliant bookmarks. To do that, replace the <code>act</code> key with a <code>page</code> key using the appropiate page number and scroll options:</p>

<pre><code> $bookmarks = {  text  =&gt; 'Document',
                 page  =&gt; '0,40,50;',
                 kids  =&gt; [ { text =&gt; 'Chapter 1',
                          page  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          page  =&gt; '10, 40, 600'
                        }
                      ]
          }</code></pre>

<p>Then print the bookmarks to the PDF document as usual with <code>prBookmark($bookmarks);</code>.</p>

<h3>Tk Application to Combine PDF Documents</h3>

<p>Console applications are fine for experienced users, but you can't expect that all users belong to this category. Therefore it might be worth it to write a GUI for combining PDF documents. The <a href="http://search.cpan.org/dist/Tk/">Perl/Tk toolkit</a> founded on the old Tix widgets for Tcl/Tk is not very modern, although this might change with the <a href="http://www.tcl.tk/software/tcltk/8.5.html">Tcl/Tk release 8.5</a> and the Tile widgets&#8212;but it is very portable. That's why I used it for the GUI example. Because I put a layer between the <code>PDF::Reuse</code> package and the command line application with the <code>CombinePDFs</code> package, it was easy to reuse those parts in the Tk-application <em>app-combine-tk-pdfs.pl</em>.</p>

<p>With the Tk application, the user visually selects PDF files, orders the files in a <code>Tk::Tree</code> widget, and changes the page ranges and the bookmarks text in <code>Tk::Entry</code> fields. Furthermore, the application can store the resulting tree structure inside a session file and restored that later on. It's also possible to copy and paste entries inside the tree, which makes it easy to create a bookmarks panel for single files without using bookmark files. The Tk application can be found in the download at the end of this article.</p>

<p>Beside the final PDF file, the application creates a file with the same basename and the <em>.cnt</em> extension. This file contains the bookmarks for the PDF. It's also useful to continue the processing of the combined PDF file instead of reassembling all the source files again. The entry for this feature is <code>File-&gt;Load Bookmarks-File</code>.</p>

<p>When loading a bookmarks file, the same extension convention is in place.</p>

<h3>Other PDF Packages on CPAN</h3>

<p>I like <code>PDF::Reuse</code>, but there are several other options for PDF creation and manipulation on the CPAN.</p>

<ul>
<li><a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a>, by Alfred Reibenschuh, is actively maintained. It is the package of choice if creating new PDF documents from scratch.</li>

<li><a href="http://search.cpan.org/dist/PDF-API2-Simple/">PDF::API2::Simple</a>, by Red Tree Systems, is a wrapper over the <code>PDF::API2</code> module for users who find the PDF::API2 module to difficult to use.</li>

<li><a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a>, by Martin Hosken, can work on more than PDF file at the same time and has Truetype font support.</li>

<li><a href="http://search.cpan.org/dist/CAM-PDF">CAM::PDF</a>, by Clotho Advanced Media, is like <code>PDF::Reuse</code> more focused on reading and manipulating existing PDF documents. However, it can work on multiple files at the same time. Use it if you need more features than <code>PDF::Reuse</code> actually provides.</li>
</ul>

<h3>Conclusions</h3>

<p><code>PDF::Reuse</code> is a well-written and well-documented package, which makes it easy to create, combine, and change existing PDF documents. The two sample applications show some of its capabilities. Two limitations should be mentioned however, <code>PDF::Reuse</code> can't reuse existing bookmarks, and after combining different PDF documents some of the inner document hyperlinks might stop working properly. The <a href="/2007/09/20/pdf_reuse.zip">example source code</a> for the applications, packages, and the modified <code>PDF::Reuse</code> is available.</p>




]]>
        
    </content>
</entry>

<entry>
    <title>Making Perl Reusable with Modules</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/08/09/making-perl-modules.html" />
    <id>tag:com.perl.org,2007:/pub//2.664</id>

    <published>2007-08-07T07:00:00Z</published>
    <updated>2010-06-20T16:31:37Z</updated>

    <summary> Perl software development can occur at several levels. When first developing the idea for an application, a Perl developer may start with a short program to flesh out the necessary algorithms. After that, the next step might be to...</summary>
    <author>
        <name>Andy Sylvester</name>
        
    </author>
    
        <category term="CPAN" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Modules" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="cpan" label="CPAN" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="modules" label="Modules" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="packaging" label="packaging" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlcode" label="Perl code" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perldistribution" label="Perl distribution" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlreuse" label="Perl reuse" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Perl software development can occur at several levels. When first developing the idea for an application, a Perl developer may start with a short program to flesh out the necessary algorithms. After that, the next step might be to create a package to support object-oriented development. The final work is often to create a Perl module for the package to make the logic available to all parts of the application. Andy Sylvester explores this topic with a simple mathematical function.</p>

<h3>Creating a Perl Subroutine</h3>

<p>I am working on ideas for implementing some mathematical concepts for a method of composing music. The ideas come from the work of <a href="http://en.wikipedia.org/wiki/Joseph_Schillinger">Joseph Schillinger</a>. At the heart of the method is being able to generate patterns using mathematical operations and using those patterns in music composition. One of the basic operations described by Schillinger is creating a "resultant," or series of numbers, based on two integers (or "generators"). Figure 1 shows a diagram of how to create the resultant of the integers 5 and 3.</p>

<p><img src="/pub/2007/08/09/graphics/Figure1.jpg" alt="creating the resultant of 5 and 3" /><br />
<em>Figure 1. Creating the resultant of 5 and 3</em></p>

<p>Figure 1 shows two line patterns with units of 5 and units of 3. The lines continue until both lines come down (or "close") at the same time. The length of each line corresponds to the product of the two generators (5 x 3 = 15). If you draw dotted lines down from where each of the two generator lines change state, you can create a third line that changes state at each of the dotted line points. The lengths of the segments of the third line make up the resultant of the integers 5 and 3 (3, 2, 1, 3, 1, 2, 3).</p>

<p>Schillinger used graph paper to create resultants in his <a href="http://www.schillingersystem.com/whatis.htm">System of Musical Composition</a>. However, another convenient way of creating a resultant is to calculate the modulus of a counter and then calculate a term in the resultant series based on the state of the counter. An algorithm to create the terms in a resultant might resemble:</p>

<pre><code>Read generators from command line
Determine total number of counts for resultant
   (major_generator * minor_generator)
Initialize resultant counter = 0
For MyCounts from 1 to the total number of counts
   Get the modulus of MyCounts to the major and minor generators
   Increment the resultant counter
   If either modulus = 0
     Save the resultant counter to the resultant array
     Re-initialize resultant counter = 0
   End if
End for</code></pre>

<p>From this design, I wrote a short program using the Perl modulus operator (<code>%</code>):</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# FILENAME: result01.pl
#
# USAGE: perl result01.pl major_generator minor_generator
#
# DESCRIPTION:
#    This Perl script will generate a Schillinger resultant
#    based on two integers for the major generator and minor
#    generator.
#
#    In normal usage, the user will input the two integers
#    via the command line. The sequence of numbers representing
#    the resultant will be sent to standard output (the console
#    window).
#
# INPUTS:
#    major_generator - First generator for the resultant, input
#                      as the first calling argument on the
#                      command line.
#
#    minor_generator - Second generator for the resultant, input
#                      as the second calling argument on the
#                      command line.
#
# OUTPUTS:
#    resultant - Sequence of numbers written to the console window
#
#**************************************************************

   use strict;
   use warnings;

   my $major_generator = $ARGV[0];
   my $minor_generator = $ARGV[1];

   my $total_counts   = $major_generator * $minor_generator;
   my $result_counter = 0;
   my $major_mod      = 0;
   my $minor_mod      = 0;
   my $i              = 0;
   my $j              = 0;
   my @resultant;

   print "Generator Total = $total_counts\n";

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $major_generator;
       $minor_mod = $i % $minor_generator;
       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@resultant, $result_counter);
          $result_counter = 0;
       }
       print "$i \n";
       print "Modulus of $major_generator is $major_mod \n";
       print "Modulus of $minor_generator is $minor_mod \n";
   }

   print "\n";
   print "The resultant is @resultant \n";</code></pre>

<p>Run the program with 5 and 3 as the inputs (<code>perl result01.pl 5 3</code>):</p>

<pre><code>Generator Total = 15
1
Modulus of 5 is 1
Modulus of 3 is 1
2
Modulus of 5 is 2
Modulus of 3 is 2
3
Modulus of 5 is 3
Modulus of 3 is 0
4
Modulus of 5 is 4
Modulus of 3 is 1
5
Modulus of 5 is 0
Modulus of 3 is 2
6
Modulus of 5 is 1
Modulus of 3 is 0
7
Modulus of 5 is 2
Modulus of 3 is 1
8
Modulus of 5 is 3
Modulus of 3 is 2
9
Modulus of 5 is 4
Modulus of 3 is 0
10
Modulus of 5 is 0
Modulus of 3 is 1
11
Modulus of 5 is 1
Modulus of 3 is 2
12
Modulus of 5 is 2
Modulus of 3 is 0
13
Modulus of 5 is 3
Modulus of 3 is 1
14
Modulus of 5 is 4
Modulus of 3 is 2
15
Modulus of 5 is 0
Modulus of 3 is 0

The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This result matches the resultant terms as shown in the graph in Figure 1, so it looks like the program generates the correct output.</p>













<h3>Creating a Perl Package from a Program</h3>

<p>With a working program, you can create a Perl package as a step toward being able to reuse code in a larger application. The initial program has two pieces of input data (the major generator and the minor generator). The single output is the list of numbers that make up the resultant. These three pieces of data could be combined in an object. The program could easily become a subroutine to generate the terms in the resultant. This could be a method in the class contained in the package. Creating a class implies adding a constructor method to create a new object. Finally, there should be some methods to get the major generator and minor generator from the object to use in generating the resultant (see the <a href="http://perldoc.perl.org/perlboot.html">perlboot</a> and <a href="http://perldoc.perl.org/perltoot.html">perltoot</a> tutorials for background on object-oriented programming in Perl).</p>

<p>From these requirements, the resulting package might be:</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# Filename: result01a.pl
#
# Description:
#    This Perl script creates a class for a Schillinger resultant
#    based on two integers for the major generator and the
#    minor generator.
#
# Class Name: Resultant
#
# Synopsis:
#
# use Resultant;
#
# Class Methods:
#
#   $seq1 = Resultant -&gt;new(5, 3)
#
#      Creates a new object with a major generator of 5 and
#      a minor generator of 3. These parameters need to be
#      initialized when a new object is created, as there
#      are no methods to set these elements within the object.
#
#   $seq1-&gt;generate()
#
#      Generates a resultant and saves it in the ResultList array
#
# Object Data Methods:
#
#   $major_generator = $seq1-&gt;get_major()
#
#      Returns the major generator
#
#   $minor_generator = $seq1-&gt;get_minor()
#
#      Returns the minor generator
#
#
#**************************************************************

{ package Resultant;
  use strict;
  sub new {
    my $class           = shift;
    my $major_generator = shift;
    my $minor_generator = shift;

    my $self = {Major =&gt; $major_generator,
                Minor =&gt; $minor_generator,
                ResultantList =&gt; []};

    bless $self, $class;
    return $self;
  }

  sub get_major {
    my $self = shift;
    return $self-&gt;{Major};
  }

  sub get_minor {
    my $self = shift;
    return $self-&gt;{Minor};
  }

  sub generate {
    my $self         = shift;
    my $total_counts = $self-&gt;get_major * $self-&gt;get_minor;
    my $i            = 0;
    my $major_mod;
    my $minor_mod;
    my @result;
    my $result_counter = 0;

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $self-&gt;get_major;
       $minor_mod = $i % $self-&gt;get_minor;

       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@result, $result_counter);
          $result_counter = 0;
       }
   }

   @{$self-&gt;{ResultList}} = @result;
  }
}

#
# Test code to check out class methods
#

# Counter declaration
my $j;

# Create new object and initialize major and minor generators
my $seq1 = Resultant-&gt;new(5, 3);

# Print major and minor generators
print "The major generator is ", $seq1-&gt;get_major(), "\n";
print "The minor generator is ", $seq1-&gt;get_minor(), "\n";

# Generate a resultant
$seq1-&gt;generate();

# Print the resultant
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>Execute the file (<code>perl result01a.pl</code>):</p>

<pre><code>The major generator is 5
The minor generator is 3
The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This output text shows the same resultant terms as produced by the first program.</p>

<h3>Creating a Perl Module</h3>

<p>From a package, you can create a Perl module to make the package fully reusable in an application. Also, you can modify our original test code into a series of module tests to show that the module works the same as the standalone package and the original program.</p>

<p>I like to use the Perl module <a href="http://search.cpan.org/perldoc?Module::Starter">Module::Starter</a> to create a skeleton module for the package code. To start, install the <code>Module::Starter</code> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Module::Starter</code> module installed, type <code>perldoc Module::Starter</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Select a working directory to create the module directory. This can be the same directory that you have been using to develop your Perl program. Type the following command (though with your own name and email address):</p>

<pre><code>$ <strong>module-starter --module=Music::Resultant --author="John Doe" \
    --email=john@johndoe.com</strong></code></pre>

<p>Perl should respond with:</p>

<pre><code>Created starter directories and files</code></pre>

<p>In the working directory, you should see a folder or directory called <em>Music-Resultant</em>. Change your current directory to <em>Music-Resultant</em>, then type the commands:</p>

<pre><code>$ <strong>perl Makefile.PL</strong>
$ <strong>make</strong></code></pre>

<p>These commands will create the full directory structure for the module. Now paste the text from the package into the module template at <em>Music-Resultant/lib/Music/Resultant.pm</em>. Open <em>Resultant.pm</em> in a text editor and paste the subroutines from the package after the lines:</p>

<pre><code>=head1 FUNCTIONS

=head2 function1

=cut</code></pre>

<p>When you paste the package source code, remove the opening brace from the package, so that the first lines appear as:</p>

<pre><code> package Resultant;
  sub new {
    use strict;
    my $class = shift;</code></pre>

<p>and the last lines of the source appears without the the final closing brace as:</p>

<pre><code>   @{$self-&gt;{ResultList}} = @result;
  }</code></pre>

<p>After making the above changes, save <em>Resultant.pm</em>. This is all that you need to do to create a module for your own use. If you eventually release your module to the Perl community or upload it to <a href="http://www.cpan.org/">CPAN</a>, you should do some more work to prepare the module and its documentation (see the <a href="http://perldoc.perl.org/perlmod.html">perlmod</a> and <a href="http://perldoc.perl.org/perlmodlib.html">perlmodlib</a> documentation for more information).</p>













<p>After modifying <em>Resultant.pm</em>, you need to install the module to make it available for other Perl applications. To avoid configuration issues, install the module in your home directory, separate from your main Perl installation.</p>

<ol>
<li>
<p>In your home directory, create a <em>lib/</em> directory, then create a <em>perl/</em> directory within the <em>lib/</em> directory. The result should resemble:</p>

<pre><code>/home/myname/lib/perl</code></pre>
</li>

<li>
<p>Go to your module directory (<em>Music-Resultant</em>) and re-run the build process with a directory path to tell Perl where to install the module:</p>

<pre><code>$ <strong>perl Makefile.PL LIB=/home/myname/lib/perl</strong> $
<strong>make install</strong></code></pre>

<p>Once this is complete, the module will be installed in the directory.</p>
</li>
</ol>

<p>The final step in module development is to add tests to the <em>.t</em> file templates created in the module directory. The Perl distribution includes several built-in test modules, such as <a href="http://search.cpan.org/perldoc?Test::Simple">Test::Simple</a> and <a href="http://search.cpan.org/perldoc?Test::More">Test::More</a> to help test Perl subroutines and modules.</p>

<p>To test the module, open the file <em>Music-Resultant/t/00-load.t</em>. The initial text in this file is:</p>

<pre><code>#!perl -T

use Test::More tests =&gt; 1;

BEGIN {
    use_ok( 'Music::Resultant' );
}

diag( "Testing Music::Resultant $Music::Resultant::VERSION, Perl $], $^X" );</code></pre>

<p>You can run this test file from the <em>t/</em> directory using the command:</p>

<pre><code>perl -I/home/myname/lib/perl -T 00-load.t</code></pre>

<p>The <code>-I</code> switch tells the Perl interpreter to look for the module <em>Resultant.pm</em> in your alternate installation directory. The directory path must immediately follow the <code>-I</code> switch, or Perl may not search your alternate directory for your module. The <code>-T</code> switch is necessary because there is a <code>-T</code> switch in the first line of the test script, which turns on taint checking. (Taint checking only works when enabled at Perl startup; <code>perl</code> will exit with an error if you try to enable it later.) Your results should resemble the following(your Perl version may be different).</p>

<pre><code>1..1
ok 1 - use Music::Resultant;
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>The test code from the second listing is easy to convert to the format used by <code>Test::More</code>. Change the number at the end of the tests line from 1 to 4, as you will be adding three more tests to this file. The template file has an initial test to show that the module exists. Next, add tests after the <code>BEGIN</code> block in the file:</p>

<pre><code># Test 2:
my $seq1 = Resultant-&gt;new(5, 3);  # create an object
isa_ok ($seq1, Resultant);        # check object definition

# Test 3: check major generator
my $local_major_generator = $seq1-&gt;get_major();
is ($local_major_generator, 5, 'major generator is correct' );

# Test 4: check minor generator
my $local_minor_generator = $seq1-&gt;get_minor();
is ($local_minor_generator, 3, 'minor generator is correct' );</code></pre>

<p>To run the tests, retype the earlier command line in the <em>Music-Resultant/</em> directory:</p>

<pre><code>$ <strong>perl -I/home/myname/lib/perl -T t/00-load.t</strong></code></pre>

<p>You should see the results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>These tests create a Resultant object with a major generator of 5 and a minor generator of 3 (Test 2), and check to see that the major generator in the object is correct (Test 3), and that the minor generator is correct (Test 4). They do <em>not</em> cover the resultant terms. One way to check the resultant is to add the test code used in the second listing to the <em>.t</em> file:</p>

<pre><code># Generate a resultant
$seq1-&gt;generate();

# Print the resultant
my $j;
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>You should get the following results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
The resultant is 3 2 1 3 1 2 3
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>That's not valid test output, so it needs a little bit of manipulation. To check the elements of a list using a testing function, install the <a href="http://search.cpan.org/perldoc?Test::Differences">Test::Differences</a> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Test::Differences</code> module installed, type <code>perldoc Test::Differences</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Once that module is part of your Perl installation, change the number of tests from 4 to 5 on the <code>Test::More</code> statement line and add a following statement after the <code>use Test::More</code> statement:</p>

<pre><code>use Test::Differences;</code></pre>

<p>Finally, replace the code that prints the resultant with:</p>

<pre><code># Test 5: (uses Test::Differences and associated modules)
$seq1-&gt;generate();
my @result   = @{$seq1-&gt;{ResultList}};
my @expected = (3, 2, 1, 3, 1, 2, 3);
eq_or_diff \@result, \@expected, "resultant terms are correct";</code></pre>

<p>Now when the test file runs, you can confirm that the resultant is correct:</p>

<pre><code>1..5
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
ok 5 - resultant terms are correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<h3>Summary</h3>

<p>There are multiple levels of Perl software development. Once you start to create modules to enable reuse of your Perl code, you will be able to leverage your effort into larger applications. By using Perl testing modules, you can ensure that your code works the way you expect and provide a way to ensure that the modules continue to work as you add more features.</p>

<h3>Resources</h3>

<p>Here are some other good resources on creating Perl modules:</p>

<ul>
<li><a href="http://world.std.com/~swmcd/steven/perl/module_mechanics.html">Perl Module Mechanics</a> goes into detail about the various files created when you create a module directory.</li>

<li><a href="http://mathforum.org/~ken/perl_modules.html">Creating (and Maintaining) Perl Modules</a> includes information on coding, documentation, testing, and installation.</li>

<li><a href="http://www.perlmonks.org/?node_id=431702">Jose's Guide for creating Perl modules</a> gives some helpful tips on getting a module ready for CPAN distribution.</li>
</ul>

<p>Here are some good resources for using Perl testing modules like <code>Test::Simple</code> and <code>Test::More</code>:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?Test::Tutorial">Test::Tutorial</a> gives the basics of using <code>Test:Simple</code> and <code>Test::More</code>.</li>

<li><a href="http://www.perl.com/pub/a/2001/12/04/testing.html">An Introduction to Testing</a> presents the benefits of developing tests and code at the same time, and provides a variety of examples.</li>
</ul>



]]>
        
    </content>
</entry>

<entry>
    <title>Option and Configuration Processing Made Easy</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/07/12/options-and-configuration.html" />
    <id>tag:com.perl.org,2007:/pub//2.662</id>

    <published>2007-07-12T07:00:00Z</published>
    <updated>2010-06-20T16:31:37Z</updated>

    <summary> When you first fire up your editor and start writing a program, it&apos;s tempting to hardcode any settings or configuration so you can focus on the real task of getting the thing working. But as soon as you have...</summary>
    <author>
        <name>Jon Allen</name>
        
    </author>
    
        <category term="CPAN" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Modules" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="argumentprocessing" label="argument processing" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="cli" label="CLI" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="configurationfiles" label="configuration files" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="getopt" label="getopt" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="getoptargvfile" label="Getopt::Argvfile" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="getoptlong" label="Getopt::Long" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>When you first fire up your editor and start writing a program, it's tempting to hardcode any settings or configuration so you can focus on the real task of getting the thing working. But as soon as you have users, even if the user is only yourself, you can bet there will be things they want to choose for themselves.</p>

<p>A search on CPAN reveals almost 200 different modules dedicated to option processing and handling configuration files. By anyone's standards that's quite a lot, certainly too many to evaluate each one.</p>

<p>Luckily, you already have a great module right in front of you for handling options given on the command line: <a href="http://search.cpan.org/perldoc?Getopt::Long"><code>Getopt::Long</code></a>, which is a core module included as standard with Perl. This lets you use the standard double-dash style of option names:</p>

<pre><code>myscript --source-directory "/var/log/httpd" --verbose \ --username=JJ</code></pre>

<h4>Using Getopt::Long</h4>

<p>When your program runs, any command-line arguments will be in the <code>@ARGV</code> array. <code>Getopt::Long</code> exports a function, <code>GetOptions()</code>, which processes <code>@ARGV</code> to do something useful with these arguments, such as set variables or run blocks of code. To allow specific option names, pass a list of option specifiers in the call to <code>GetOptions()</code> together with references to the variables in which you want the option values to be stored.</p>

<p>As an example, the following code defines two options, <code>--run</code> and <code>--verbose</code>. The call to <code>GetOptions()</code> will then assign the value <code>1</code> to the variables <code>$run</code> and <code>$verbose</code> respectively if the relevant option is present on the command line.</p>

<pre><code>use Getopt::Long;
my ($run,$verbose);
GetOptions( 'run'     =&gt; \$run,
             'verbose' =&gt; \$verbose );</code></pre>

<p>When <code>Getopt::Long</code> has finished processing options, any remaining arguments will remain in <code>@ARGV</code> for your script to handle (for example, specified filenames). If you use this example code and call your script as:</p>

<pre><code>myscript --run --verbose file1 file2 file3</code></pre>

<p>then after <code>GetOptions()</code> has been called the <code>@ARGV</code> array will contain the values <code>file1</code>, <code>file2</code>, and <code>file3</code>.</p>

<h4>Types of Command-Line Options</h4>

<p>The option specifier provided to <code>GetOptions()</code> controls not only the option name, but also the option type. <code>Getopt::Long</code> gives a lot of flexibility in the types of option you can use. It supports Boolean switches, incremental switches, options with single values, options with multiple values, and even options with hash values.</p>

<p>Some of the most common specifiers are:</p>

<pre><code>name     # Presence of the option will set $name to 1
name!    # Allows negation, e.g. --name will set $name to 1,
         #    --noname will set $name to 0
name+    # Increments the variable each time the option is found, e.g.
         # if $name = 0 then --name --name --name will set $name to 3
name=s   # String value required
         #    --name JJ or --name=JJ will set $name to JJ
         # Spaces need to be quoted
         #    --name="Jon Allen" or --name "Jon Allen"</code></pre>

<p>So, to create an option that requires a string value, format the call to <code>GetOptions()</code> like this:</p>

<pre><code>my $name;
GetOptions( 'name=s' =&gt; \$name );</code></pre>

<p>The value is required. If the user omits it, as in:</p>

<pre><code>myscript --name</code></pre>

<p>then the call to <code>GetOptions()</code> will <code>die()</code> with an appropriate error message.</p>

<h4>Options with Multiple Values</h4>

<p>The option specifier consists of four components: the option name; data type (Boolean, string, integer, etc.); whether to expect a single value, a list, or a hash; and the minimum and maximum number of values to accept. To require a list of string values, build up the option specifier:</p>

<pre><code>Option name:   name
Option value:  =s    (string)
Option type:   @     (array)
Value counter: {1,}  (at least 1 value required, no upper limit)</code></pre>

<p>Putting these all together gives:</p>

<pre><code>my $name;
GetOptions('name=s@{1,}' =&gt; \$name);</code></pre>

<p>Now invoking the script as:</p>

<pre><code>myscript --name Barbie Brian Steve</code></pre>

<p>will set <code>$name</code> to the array reference <code>['Barbie','Brian','Steve']</code>.</p>

<p>Giving a hash value to an option is very similar. Replace <code>@</code> with <code>%</code> and on the command line give arguments as key=value pairs:</p>

<pre><code>my $name;
GetOptions('name=s%{1,}',\$name);</code></pre>

<p>Running the script as:</p>

<pre><code>myscript --name Barbie=Director JJ=Member</code></pre>

<p>will store the hash reference <code>{ Barbie =&gt; 'Director', JJ =&gt; 'Member' }</code> in <code>$name</code>.</p>

<h4>Storing Options in a Hash</h4>

<p>By passing a hash reference as the first argument to <code>GetOptions</code>, you can store the complete set of option values in a hash instead of defining a separate variable for each one.</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose' );</code></pre>

<p>Option names will be hash keys, so you can refer to the <code>name</code> value as <code>$options{name}</code>. If an option is not present on the command line, then the corresponding hash key will not be present.</p>

<h4>Options that Invoke Subroutines</h4>

<p>A nice feature of <code>Getopt::Long</code> is that, as an alternative to simply setting a variable when an option is found, you can tell the module to run any code of your choosing. Instead of giving <code>GetOptions()</code> a variable reference to store the option value, pass either a subroutine reference or an anonymous code reference. This will then be executed if the relevant option is found.</p>

<pre><code>GetOptions( version =&gt; sub{ print "This is myscript, version 0.01\n"; exit; }
            help    =&gt; \&amp;display_help );</code></pre>

<p>When used in this way, <code>Getopt::Long</code> also passes the option name and value as arguments to the subroutine:</p>

<pre><code>GetOptions( name =&gt; sub{ my ($opt,$value) = @_; print "Hello, $value\n"; } );</code></pre>

<p>You can still include code references in the call to <code>GetOptions()</code> even if you use a hash to store the option values:</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose', 'dest=s',
            'version' =&gt; sub{ print "This is myscript, version 0.01\n"; exit; } );</code></pre>

<h4>Dashes or Underscores?</h4>

<p>If you need to have option names that contain multiple words, such as a setting for "Source directory," you have a few different ways to write them:</p>

<pre><code>--source-directory
--source_directory
--sourcedirectory</code></pre>

<p>To give a better user experience, <code>Getopt::Long</code> allows option aliases to allow either format. Define an alias by using the pipe character (<code>|</code>) in the option specifier:</p>

<pre><code>my %options;
GetOptions( \%options, 'source_directory|source-directory|sourcedirectory=s' );</code></pre>

<p>Note that if you're storing the option values in a hash, the first option name (in this case, <code>source_directory</code>) will be the hash key, even if your user gave an alias on the command line.</p>













<p>If you have a lot of options, it might be helpful to generate the aliases using a function:</p>

<pre><code>use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

my %specifiers = ( 'source-directory' =&gt; '=s',
                   'verbose'          =&gt; '' );
my %options;
GetOptions( \%options, optionspec(%specifiers) );

print Dumper(\%options);

sub optionspec {
  my %option_specs = @_;
  my @getopt_list;

  while (my ($option_name,$spec) = each %option_specs) {
    (my $variable_name = $option_name) =~ tr/-/_/;
    (my $nospace_name  = $option_name) =~ s/-//g;
    my  $getopt_name   = ($variable_name ne $option_name)
        ? "$variable_name|$option_name|$nospace_name" : $option_name;

    push @getopt_list,"$getopt_name$spec";
  }

  return @getopt_list;
}</code></pre>

<p>Running this script with each format in turn shows that they are all valid:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --source-directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --source_directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --sourcedirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<p>Additionally, <code>Getopt::Long</code> is case-insensitive by default (for option names, not values), so your users can also use <code>--SourceDirectory</code>, <code>--sourceDirectory</code>, etc., as well:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --SourceDirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<h4>Configuration Files</h4>

<p>The next stage on from command-line options is to let your users save their settings into config files. After all, if your program expands to have numerous options it's going to be a real pain to type them in every time.</p>

<p>When it comes to the format of a configuration file, there are a lot of choices, such as XML, INI files, and the Apache <em>httpd.conf</em> format. However, all of these formats share a couple of problems. First, your users now have two things to learn: the command-line options and the configuration file syntax. Second, even though many CPAN modules are available to parse the various config file formats, you still must write the code in your program to interact with your chosen module's API to set whatever variables you use internally to store user settings.</p>

<h4>Getopt::ArgvFile to the Rescue</h4>

<p>Fortunately, someone out there in CPAN-land has the answer (you can always count on the Perl community to come up with innovative solutions). <a href="http://search.cpan.org/dist/Getopt-ArgvFile"><code>Getopt::ArgvFile</code></a> tackles both of these problems, simplifying the file format and the programming interface in one fell swoop.</p>

<p>To start with, the file format used by <code>Getopt::ArgvFile</code> is extremely easy for users to understand. Config settings are stored in a plain text file that holds exactly the same directives that a user would type on the command line. Instead of typing:</p>

<pre><code>myscript --source-directory /usr/local/src --verbose --logval=alert</code></pre>

<p>your user can use the config file:</p>

<pre><code>--source-directory /usr/local/src
--verbose
--logval=alert</code></pre>

<p>and then run <code>myscript</code> for instant user gratification with no steep learning curve.</p>

<p>Now to the clever part. <code>Getopt::ArgvFile</code> itself doesn't actually care about the contents of the config file. Instead, it makes it appear to your program that all the settings were actually options typed on the command line--the processing of which you've already covered with <code>Getopt::Long</code>. As well as saving your users time by not making them learn a new syntax, you've also saved yourself time by not needing to code against a different API.</p>

<p>The most straightforward method of using <code>Getopt::ArgvFile</code> involves simply including the module in a <code>use</code> statement:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>A program called <em>myscript</em> that contains this code will search the user's home directory (whatever the environment variable <code>HOME</code> is set to) for a config file called <em>.myscript</em> and extract the contents ready for processing by <code>Getopt::Long</code>.</p>

<p>Here's a complete example:</p>

<pre><code>use strict;
use warnings;
use Getopt::ArgvFile home=&gt;1;
use Getopt::Long;

my %config;
GetOptions( \%config, 'name=s' );

if ($config{name}) {
  print "Hello, $config{name}\n";
} else {
  print "Who am I talking to?\n";
}</code></pre>

<p>Save this as <em>hello</em>, then run the script with and without a command-line option:</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Who am I talking to?

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>

<p>Now, create a settings file called <em>.hello</em> in your home directory containing the <code>--name</code> option. Remember to double quote the value if you want to include spaces.</p>

<pre><code>varos:~/writing/argvfile jj$ cat ~/.hello
--name "Jon Allen"</code></pre>

<p>Running the script without any arguments on the command line will show that it loaded the config file, but you can also override the saved settings by giving the option on the command line as normal.</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>













<h4>Advanced Usage</h4>

<p>In many cases the default behaviour invoked by loading the module will be all you need, but <code>Getopt::ArgvFile</code> can also cater to more specific requirements.</p>

<h4>User-Specified Config Files</h4>

<p>Suppose your users want to save different sets of options and specify which one to use when they run your program. This is possible using the <code>@</code> directive on the command line:</p>

<pre><code>varos:~/writing/argvfile jj$ cat jj.conf
--name JJ

varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello @jj.conf
Hello, JJ</code></pre>

<p>Note that there's no extra programming required to use this feature; handling <code>@</code> options is native to <code>Getopt::ArgvFile</code>.</p>

<h4>Changing the Default Config Filename or Location</h4>

<p>Depending on your target audience, the naming convention offered by <code>Getopt::ArgvFile</code> for config files might not be appropriate. Using a dotfile (<em>.myscript</em>) will render your user's config file invisible in his file manager or when listing files at the command prompt, so you may wish to use a name like <em>myscript.conf</em> instead.</p>

<p>Again, it may also be helpful to allow for default configuration files to appear somewhere other than the user's home directory, for example, if you need to allow system-wide configuration.</p>

<p>A further consideration here is <a href="http://par.perl.org/">PAR</a> , the tool for creating standalone executables from Perl programs. PAR lets you include data files as well as Perl code, so you can bundle a default settings file using a command such as:</p>

<pre><code>pp hello -o hello.exe -a hello.conf</code></pre>

<p>which will be available to your script as <code>$ENV{PAR_TEMP}/inc/hello.conf</code>.</p>

<p>I mentioned earlier that <code>Getopt::ArgvFile</code> can load arbitrary config files if the filename appears with the <code>@</code> directive on the command line. Essentially, what the module does when loaded with:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>is to prepend <code>@ARGV</code> with <code>@$ENV{HOME}/.scriptname</code>, then resolve all <code>@</code> directives, leaving <code>@ARGV</code> with the contents of the files. This means that running the script as:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>is basically equivalent to writing:</p>

<pre><code>myscript @$ENV{HOME}/.myscript --name-JJ</code></pre>

<p>To load other config files, <code>Getopt::ArgvFile</code> supports disabling the automatic <code>@ARGV</code> processing and triggering it later. With a little manipulation of <code>@ARGV</code> first, you can make:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>equivalent to:</p>

<pre><code>myscript @/path/to/default.conf @/path/to/system.conf @/path/to/user.conf \
    --name=JJ</code></pre>

<p>which will load the set of config files in the correct priority order.</p>

<p>All you need to do to enable this feature is change the <code>use</code> statement to read:</p>

<pre><code>use Getopt::ArgvFile qw/argvFile/;</code></pre>

<p>Loading the module in this way tells <code>Getopt::ArgvFile</code> to export the function <code>argvFile()</code>, which your program needs to call to process the <code>@</code> directives, and also prevents any automated processing from occurring.</p>

<p>Here's an example that first loads a config file from the application bundle (if packaged by PAR) and then from the directory containing the application binary:</p>

<pre><code>use File::Basename qw/basename/;
use FindBin qw/$Bin/;
use Getopt::ArgvFile qw/argvFile/;

# Define config filename as &lt;application_name&gt;.conf
(my $configfile = basename($0)) =~ s/^(.*?)(?:\..*)?$/$1.conf/;

# Include config file from the same directory as the application binary
if (-e "$Bin/$configfile") {
  unshift @ARGV,'@'."$Bin/$configfile";
}

# If we have been packaged with PAR, include the config file from the
# application bundle
if ($ENV{PAR_TEMP} and -e "$ENV{PAR_TEMP}/inc/$configfile") {
  unshift @ARGV,'@'."$ENV{PAR_TEMP}/inc/$configfile";
}

argvFile();  # Process @ARGV to load specified config files</code></pre>

<p>You can also use this technique together with <a href="http://search.cpan.org/dist/File-HomeDir"><code>File::HomeDir</code></a> to access the user's application data directory in a cross-platform manner, so that the location of the config file conforms to the conventions set by the user's operating system.</p>

<h4>Summary</h4>

<p><code>Getopt::Long</code> provides an easy to use, extensible system for processing command-line options. With the addition of <code>Getopt::ArgvFile</code>, you can seamlessly handle configuration files with almost no extra coding. Together, these modules should be first on your list when writing scripts that need any amount of configuration.</p>



]]>
        
    </content>
</entry>

<entry>
    <title>Better Code Through Destruction</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/06/07/better-code-through-destruction.html" />
    <id>tag:com.perl.org,2007:/pub//2.660</id>

    <published>2007-06-07T07:00:00Z</published>
    <updated>2010-06-20T16:31:37Z</updated>

    <summary> Larry Wall said that Perl makes easy things easy and hard things possible. Perl is good both for writing a two-line script that saves the world at the last minute (well, at least it saves you and your project)...</summary>
    <author>
        <name>Igor Gariev</name>
        
    </author>
    
        <category term="CPAN" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Modules" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="objectdestructor" label="Object::Destructor" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlmemoryleaks" label="Perl memory leaks" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perlmemorymanagement" label="Perl memory management" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="raii" label="RAII" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="referencecounting" label="reference counting" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Larry Wall said that Perl makes easy things easy and hard things possible. Perl is good both for writing a two-line script that saves the world at the last minute (well, at least it saves you and your project) and for robust projects. However, good Perl programming techniques can be quite different between small and complex applications. Consider, for example, Perl's garbage collector. It frees a programmer from memory management issues most of the time...until the programmer creates circular references.</p>

<p>Perl's garbage collector counts references. When the count reaches zero (which means that no one has a reference), Perl reclaims the entity. The approach is simple and effective. However, circular references (when object A has a reference to object B, and object B has a reference to object A) present a problem. Even if nothing else in the program has a reference to either A or B, the reference count can never reach zero. Objects A and B do not get destroyed. If the code creates them again and again (perhaps in a loop), you get a memory leak. The amount of memory allocated by the program increases without a sensible reason and can never decrease. This effect may be acceptable for simple run-and-exit scripts, but it's not acceptable for programs running 24x365, such as in a mod_perl or FastCGI environment or as standalone servers.</p>

<p>Circular references are sometimes too useful to avoid. A common example is a tree-like data structure. To navigate both directions--from root to leaves and vice versa--a parent node has a list of children and a child node has a reference to its parent. Here are the circular references. Many CPAN modules implement their data models this way, including <a href="http://search.cpan.org/perldoc?HTML::Tree">HTML::Tree</a>, <a href="http://search.cpan.org/perldoc?XML::DOM">XML::DOM</a>, and <a href="http://search.cpan.org/perldoc?Text::PDF::File">Text::PDF::File</a>. All these modules provide a method to release the memory. The client application must call the method when it no longer needs an object. However, the requirement of an explicit call is not very appealing and can result in unsafe code:</p>

<pre><code>    ##
    ## Code with a memory leak
    #
    use HTML::TreeBuilder;

    foreach my $filename (@ARGV) {
        my $tree = HTML::TreeBuilder-&gt;new;
        $tree-&gt;parse_file($filename);

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## Do the actual work (say, extract images) here
        ## ...
        ## and release the memory
        ##
        $tree-&gt;delete;
    }</code></pre>

<p>The problem in the code is the <code>next</code> statement; HTML documents with no <code>&lt;img ...</code> tags will not be released. Actually, any call of <code>next</code>, <code>last</code>, <code>return</code> (inside a subroutine), or <code>die</code> (inside an <code>eval {}</code> block) is unsafe and will lead to a memory leak. Of course, it is possible to move the release code into a <code>continue</code> block for <code>last</code> or <code>next</code>, or to write code to delete the tree before every <code>return</code> or <code>die</code>, but the code easily becomes messy.</p>

<p>There is a better solution--the paradigm of "resource acquisition is initialization (and destruction is resource relinquishment)." (Ironically, the second half of its name is often omitted, even though it's probably the most important part). The idea is simple. Create a special guard object (of another class) whose sole responsibility is to release the resource. When the guard object gets destroyed, its destructor deletes the tree. The code may look like:</p>

<pre><code>    ##
    ## A special sentry object is employed
    ##
    use HTML::TreeBuilder;

    foreach my $filename (@ARGV) {
        my $tree = HTML::TreeBuilder-&gt;new;
        $tree-&gt;parse_file($filename);

        <strong>my $sentry = Sentry-&gt;new($tree);</strong>

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## next, last or return are safe here.
        ## Tree will be deleted automatically.
        ##
    }

    package Sentry;

    sub new {
        my $class = shift;
        my $tree  = shift;
        return bless {tree =&gt; $tree}, $class;
    }

    sub DESTROY {
        my $self = shift;
        $self-&gt;{tree}-&gt;delete;
    }</code></pre>

<p>Note that now there is no need to call <code>$tree-&gt;delete</code> explicitly at the end of the loop. The magic is simple. When program flow leaves the scope, <code>$sentry</code> is reclaimable because it participates in no circular references. The code of <code>DESTROY</code> method of the <code>Sentry</code> package calls, in turn, the method <code>delete</code> of the <code>$tree</code> object. This is one solution for all means; memory will be released however you leave the block.</p>

<p>Finally, there is no need to code your own <code>Sentry</code> class. Use <a href="http://search.cpan.org/perldoc?Object::Destroyer">Object::Destroyer</a>, originally written by Adam Kennedy. As you may guess by its name, it is the object to destroy other objects:</p>

<pre><code>    ##
    ## An of-the-CPAN solution with Object::Destroyer
    ##
    use HTML::TreeBuilder;
    use Object::Destroyer 2.0;

    foreach my $filename (@ARGV) {
        my $tree   = HTML::TreeBuilder-&gt;new;
        <strong>my $sentry = Object::Destroyer-&gt;new($tree, 'delete');</strong>
        $tree-&gt;parse_file($filename);

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## You can safely return, die, next or last here.
        ##
    }</code></pre>

<p>Because the name of the release method may vary between modules, it is the constructor's second argument.</p>













<p>Finally, you can destroy any data structure, not just objects, if you provide code to do so. Pass in a subroutine reference or an anonymous subroutine:</p>

<pre><code>    ##
    ## An unblessed data structure with circular references
    ## that cannot untangle itself.
    ##
    use Object::Destroyer 2.0;
    while (1) {
        my (%a, %b);
        $a{b}      = \%b;
        $b{a}      = \%a;
        my $sentry = Object::Destroyer-&gt;new( sub { undef $a{b} } );
    }</code></pre>

<p>Just for fun, comment out the line with the <code>$sentry</code> object and watch the memory consumption of the running script.</p>

<h3>Using Object::Destroyer As a Wrapper</h3>

<p><code>Object::Destroyer</code> can make life easier for module authors, too.</p>

<p>If you have written a library with circular references, you may ask your clients to explicitly call a disposal method or use a new feature of Perl (stable since 5.8; see <a href="http://search.cpan.org/perldoc?Scalar::Util">Scalar::Util</a>)--weak references. Weak references do not increment reference counts of the objects to which they refer, so the Perl garbage collector can collect the referents. In the tree example, all references from leaves to parents (but not vice versa, or the tree will be lost!) may be weak. When the final reference to the root node goes away, Perl will dispose of it, which will remove its references to all of its children recursively. They will all reach zero, and Perl will reclaim them all down the branches of the tree to every leaf.</p>

<p>Indeed, some CPAN modules use this approach (<a href="http://search.cpan.org/perldoc?XML::Twig">XML::Twig</a>). However, this solution works only if weak refs are available; this is certainly not the case for older Perl. Secondly, this may require quite a bit of rewriting (there are nine calls to <code>weaken</code> throughout the code of <code>XML::Twig</code> 3.26).</p>

<p>Alternatively, you may use <code>Object::Destroyer</code> internally in your library code. It can work as an almost transparent wrapper around your object:</p>

<pre><code>    ##
    ## Object::Destroyer as a wrapper
    ##
    package My::Tree;
    use Object::Destroyer 2.0;

    sub new {
        my $class = shift;
        my $self  = bless {}, $class;
        $self-&gt;populate;

        <strong>return Object::Destroyer-&gt;new( $self, 'release' );</strong>
    }

    sub release{
        ## actual memory release code
    }

    sub say_hello{
        my $self = shift;
        print "Hello, I'm object of class ", ref($self), "\n";
    }

    package main;
    {
        my $tree = My::Tree-&gt;new;
        $tree-&gt;say_hello;
        ##
        ## $tree-&gt;release will be called by Object::Destroyer;
        ##
    }</code></pre>

<p>The object <code>$tree</code> in the client code is actually an <code>Object::Destroyer</code> object that dispatches all invoked methods to the underlying object of class <code>My::Tree</code>. The method <code>say_hello</code> sees no difference at all--it receives an original <code>$self</code> object. Changes to code are minimal and well localized.</p>

<p>The approach has a limitation, too: clients must not access attributes of the object directly (such as <code>$tree-&gt;{age}</code>). This is a bad practice in client code anyway. Additionally, there is a small time penalty for method calls by client-side code. Calls made from the library code itself are not affected.</p>

<h3>Exceptions and Resource Deallocation</h3>

<p><a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource acquisition is initialization</a> is a powerful technique to apply to the management of various critical resources, not only memory. It is most useful when using exceptions to handle errors. This combination makes code quite reliable: exceptions separate normal execution logic and error handling, and RAII sentries guarantee the correct release of every sensitive resource.</p>

<p>Consider alarms as an example. Assume that you have to call some potentially long-running (or even never-ending) code. You don't want your script to hang up, and prefer to break its execution. Alarms are just right for the task. However, the first attempt at good code might be awkward:</p>

<pre><code>    ##
    ## Alarm example 1. Naive.
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        long_running_code();
        ## Cancel the alarm if code returned within 5 sec.
        alarm(0);
    };
    if ($@ &amp;&amp; $@ eq "Timed out\n") {
        ## Process the error here
    }</code></pre>

<p>This code will work fine until <code>long_running_code()</code> dies. In this case, the <code>eval</code> block will catch the <code>die</code>, but not the alarm. If this occurred in a program that must run 24 hours a day, the program would end in 5 seconds.</p>

<p>This next example is much better; actually it is real-world code. It is enough for many applications. However, it's not completely bulletproof either:</p>

<pre><code>    ##
    ## Alarm example 2. A standard solution.
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        long_running_code();
        ## Cancel the alarm if long_running_code() returns within 5 sec.
        alarm(0);
    };
    ## Cancel the alarm if the long_running_code() died.
    alarm(0);</code></pre>

<p>How many times will the alarm be cancelled in the following example?</p>

<pre><code>    ##
    ## Alarm example 3. Malicious code.
    ##
    LOOP:
    foreach my $arg (1..3) {
        eval{
            local $SIG{ALRM} = sub { die "Timed out\n" };
            alarm(5);
            long_running_code($arg);
            alarm(0);
        };
        alarm(0);
    }
    sub long_running_code{ last LOOP; }</code></pre>

<p>Oops, none.</p>

<p>The RAII solution is more reliable:</p>

<pre><code>    ##
    ## Alarm example 4.
    ## Resource is under control of Object::Destroyer
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        my $sentry = Object::Destroyer-&gt;new( sub {alarm(0)} );
        long_running_code();
    };</code></pre>

<p>No matter how the code exits the <code>eval</code> block, Perl will destroy the <code>$sentry</code> object. That destruction will call <code>alarm(0)</code>.</p>













<p>You can manage many sensitive resources this way, including file locks, semaphores, and even locks of database tables.</p>

<pre><code>    ##
    ## File lock.
    ##
    use Fcntl ':flock';

    open my($fh), "&gt;$filename.lock";
    eval{
        flock($fh, LOCK_EX);
        my $sentry = Object::Destroyer-&gt;new( sub {flock($fh, LOCK_UN)} );
        ##
        ## Actual lock-sensitive code is here.
        ## It is safe to die.
        ##
    };

    ##
    ## Semaphore
    ##
    use Thread::Semaphore;
    use Object::Destroyer;

    my $s = Thread::Semaphore-&gt;new();
    eval{
        $s-&gt;down;
        my $sentry = Object::Destroyer-&gt;new( sub { $s-&gt;up } );
        ##
        ## Critical code is here, die is safe
        ##
    };

    ##
    ## MySQL database table lock.
    ##
    use DBI;

    my $dbh = DBI-&gt;connect("dbi:mysql:...", "", "");
    eval{
        $dbh-&gt;do("LOCK TABLE table1 READ");
        my $sentry = Object::Destroyer-&gt;new(
            sub { $dbh-&gt;do("UNLOCK TABLES"); }
        );
        ##
        ## Again, actual code must be here
        ##
    };</code></pre>

<p>The code is clean, simple, and quite self-explanatory.</p>

<h3>Simple Transactions</h3>

<p>Everyone who works with relational databases knows how useful transactions are. One of the features of transactions is atomicity: either all modifications of data are committed at once, or all of them are ignored. Your data is always consistent; it's not possible to leave it in an inconsistent state. The same effect is possible in Perl code:</p>

<pre><code>    use Object::Destroyer 2.0;

    my ($account1, $account2) = (15, 15);

    printf("Account1=%d, Account2=%d, Total=%d\n",
        $account1, $account2, $account1+$account2);

    eval {
        my $coderef = create_savepoint(\$account1, \$account2);
        my $sentry  = Object::Destroyer-&gt;new($coderef);

        die "before changes" if rand &gt; 0.7;
        $account1 += 3;
        die "after account 1 was modified" if rand &gt; 0.7;
        $account2 -= 3;
        die "after account 2 was modified" if rand &gt; 0.7;

        ##
        ## The transaction is considered to be committed here
        ## and $sentry can be dismissed.
        ## $coderef-&gt;() will not be called.
        ##
        $sentry-&gt;dismiss;

        die "after transaction is committed" if rand &gt; 0.7;
    };
    print "Died $@" if $@;
    printf("Account1=%d, Account2=%d, Total=%d\n",
        $account1, $account2, $account1+$account2);

    sub create_savepoint {
        ## Save references to variables and their current values
        my @vars;
        foreach my $ref (@_) {
            die "Can remember only scalar values" unless ref($ref) eq 'SCALAR';
            push @vars, { ref =&gt; $ref, value =&gt; $$ref };
        }

        ## A closure to restore their values
        return sub {
            foreach my $var (@vars) {
                ${ $var-&gt;{ref} } = $var-&gt;{value};
            }
        };
    }</code></pre>

<p>Run the script several times. Due to <code>rand</code>, it will break on varying lines, but it is not possible to get a Total value other than 30.</p>

<h3>See Also</h3>

<p>RAII is by no means a new technique. It is very popular in the world of C++ programming. If you are not afraid of C++, you may find interesting the standard container <a href="http://en.wikipedia.org/wiki/Auto_ptr">auto_ptr</a> and <a href="http://www.gotw.ca/publications/using_auto_ptr_effectively.htm">effective auto_ptr usage</a>. The non-standard <a href="http://www.ddj.com/dept/cpp/184403758">ScopeGuard</a> class provides lexically scoped resource management in C++.</p>

<p>The <a href="http://search.cpan.org/perldoc?Devel::Monitor">Devel::Monitor</a> module has guidelines on how to design data structures with weak and circular references. Its primary goal, by the way, is to trace the memory consumption of a running script.</p>

<p>There are several modules for lexically scoped resource management on CPAN, but the <a href="http://search.cpan.org/perldoc?Object::Destroyer">Object::Destroyer</a> is my favorite. You may also look at <a href="http://search.cpan.org/perldoc?Hook::Scope">Hook::Scope</a>, <a href="http://search.cpan.org/perldoc?Scope::Guard">Scope::Guard</a> and <a href="http://search.cpan.org/perldoc?Sub::ScopeFinalizer">Sub::ScopeFinalizer</a>.</p>

<p>Finally, <a href="http://www.perl.com/pub/a/2002/11/14/exception.html">Object Oriented Exception Handling in Perl</a> discusses why exceptions are invaluable for big projects.</p>

]]>
        
    </content>
</entry>

<entry>
    <title>Everyday Perl 6</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/05/10/everyday-perl-6.html" />
    <id>tag:com.perl.org,2007:/pub//2.658</id>

    <published>2007-05-10T07:00:00Z</published>
    <updated>2010-06-20T16:31:37Z</updated>

    <summary> Perl 6 will soon be here. How will programming in Perl 6 be different from programming in Perl 5 for your average Perl programmer? The answer is: very different yet very much the same. A Perl 6 program viewed...</summary>
    <author>
        <name>Jonathan Scott Duff</name>
        
    </author>
    
        <category term="Perl 6" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="parrot" label="Parrot" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl5" label="Perl 5" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl6" label="Perl 6" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pugs" label="Pugs" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Perl 6 will soon be here. How will programming in Perl 6 be different from programming in Perl 5 for your average Perl programmer? The answer is: very different yet very much the same. A Perl 6 program viewed at arm's length will look much like a Perl 5 program viewed at arm's length. Programming in Perl 6 will still feel like programming in Perl. What will change however, is that Perl 6 will enable programmers to be more expressive by giving them more tools to work with (making easy things easy) and allowing them to be more precise in their expressions.</p>

<p>While many of the changes in Perl 6 make it easier for people new to programming or coming from other programming languages to understand the language, none of the changes were made solely on those grounds. If your favorite part of Perl 5 syntax is that it uses an arrow for method dispatch on objects, don't be dismayed that Perl 6 uses a dot instead. The designers carefully considered each syntactic change to ensure that Perl 6 still has the Perlish nature <em>and</em> that the change was an overall improvement. Some Perl programmers delight in the syntactic differences of the language, but some of those differences aren't that important when compared to the big picture of Perl's culture (which includes the language, CPAN, and the community of programmers).</p>

<h3>Sigil Invariance</h3>

<p>One of the fundamental changes is that whenever you refer to individual elements of an aggregate (an array or hash), rather than changing the sigil to denote the type of thing you get back, the sigil remains the same.</p>

<p>For example, in both Perl 5 and Perl 6 you can create and initialize aggregates:</p>

<pre><code>    my @array = (1,3,5,12,37,42);
    my %hash  = ( alpha =&gt; 4, beta =&gt; 6 );</code></pre>

<p>How you access the individual elements of those aggregates looks just a little different:</p>

<pre><code>    # Perl 6                            # Perl 5
    my $third = @array[2];              my $third = $array[2];
    my $beta  = %hash{'beta'};          my $beta = $hash{'beta'};</code></pre>

<p>Long-time Perl 5 programmers might wonder how slices work in Perl 6. The answer is: the same way as in Perl 5.</p>

<pre><code>    my @odds = @array[1,3,5];           # array slice
    my @bets = %hash{'alpha','beta'};   # hash slice</code></pre>

<p>The only difference is that in Perl 5 the hash slice would have started with a <code>@</code> sigil.</p>

<h3>New Brackets</h3>

<p>In these hash examples, it's awkward quoting the indexes into the hash. Perl 5 allows a syntactic shortcut where <code>$hash{word}</code> works as if you had written <code>$hash{'word'}</code>. A problem with that is that it can cause confusion when your <code>word</code> happens to be the name of a subroutine and you really want Perl to execute that subroutine.</p>

<p>In Perl 6, a syntactic shortcut for accessing hash elements takes advantage of a name change of the "quote word" operator:</p>

<pre><code>    # Perl 6                        # Perl 5
    my @array = &lt;foo bar baz&gt;;      my @array = qw(foo bar baz);
    my %hash  = &lt;a b c d e f g h&gt;;  my %hash = qw(a b c d e f g h);
    my $queue = %hash&lt;q&gt;;           my $queue = $hash{'q'};
    my @vows  = %hash&lt;c a g e&gt;;     my @vows = @hash{qw(c a g e)};</code></pre>

<p>Also, just as double-quoted strings interpolate while single-quoted strings do not, double-bracketed "quote word" constructs also interpolate:</p>

<pre><code>    my $foo  = "This is";
    my $bar  = "the end";
    my @blah = &lt;&lt; $foo $bar &gt;&gt;;     # ('This','is','the','end');</code></pre>

<p>Note that the interpolation happens <em>before</em> the "quote word" aspect of this operator.</p>

<p>Speaking of interpolation, interpolating into double-quoted strings has changed slightly. Now to interpolate an array into a string, you must provide a set of empty brackets at the end of the array name. This has the side benefit of eliminating the ambiguity of whether you meant interpolation if you happen to include (for instance) an email address in your double-quoted string.</p>

<pre><code>    my @items = &lt;names addresses email&gt;;
    say "Send @items[] to test@foo.com";
    # Send names addresses email to test@foo.com</code></pre>

<p>You can also interpolate more things into your double-quoted strings:</p>

<pre><code>    say "Send me $person.name()";         # results of a method call
    say "2 + 2 = { 2+2 }";                # any bit of perl code</code></pre>

<p>That second one means that you'll have to be careful about inserting curly braces in your double-quoted strings, but that's a small price to pay for the ability to interpolate the results of arbitrary Perl code.</p>

<p>By the way, get used to the <code>say</code> subroutine. It's the same as <code>print</code>, but it appends a newline to the end. Quite useful, that.</p>

<h3>Fewer Parentheses</h3>

<p>The usual places in Perl 5 that require parentheses no longer do in Perl 6:</p>

<pre><code>    # Perl 6                        # Perl 5
        if $cond  { ... }                if ($cond)  { ... }
    unless $cond  { ... }            unless ($cond)  { ... }
     while $cond  { ... }             while ($cond)  { ... }
       for @array { ... }               for (@array) { ... }</code></pre>

<p>In Perl 6, parentheses are now only necessary for grouping.</p>













<h3>Idioms</h3>

<p>Another big change is that some of the standard Perl 5 idioms look different in Perl 6. In particular, the standard idiom for reading lines from a file involves a <code>for</code> loop rather than a <code>while</code> loop:</p>

<pre><code>    # Perl 6                        # Perl 5
    for =$fh { ... }                while (&lt;$fh&gt;) { ... }
    for =&lt;&gt;  { ... }                while (&lt;&gt;)    { ... }</code></pre>

<p>The Perl 5 programmers are probably thinking, "but doesn't that put the part that reads the filehandle in list context, causing the entire file to be slurped into memory?" The answer is both yes and no. Yes, it's in list context, but in Perl 6, by default all lists are lazy so they aren't read until necessary.</p>

<p>In this example, unary <code>=</code> is the operator that causes an iterator to, well...iterate. If <code>$fh</code> is a filehandle, <code>=$fh</code> iterates over that file by reading one line at a time. In scalar context <code>=$fh</code> will read one line, and in list context it will read one line at a time as many times as necessary to get to the end of the file. Iterating over the empty string (remember the new role of the angle brackets) is equivalent to Perl 5's reading files from the command line.</p>

<h3>Operator Rename</h3>

<p>Several common operators have new symbols in Perl 6. These symbol changes make the overall language more regular so that it's easier to parse, but most importantly so that it's easier for humans to remember:</p>

<pre><code>    # Perl 6                        # Perl 5
    $object.method(@args);          $obj-&gt;method(@args);
    $x = $cond ?? $true !! $false;  $x = $cond ? $true : $false;
    $s = "con" ~ "cat" ~ "enate";   $s = "con" . "cat" . "enate";
    $str ~~ /$pattern/;             $str =~ /$pattern/;</code></pre>

<p>Any time you see a <code>~</code> in Perl 6, it has something to do with strings. A unary <code>~</code> puts its rvalue in a string context, binary <code>~</code> is string concatenation, and a doubled <code>~</code> lets you match a regular expression against a string (actually, it does more than that, but from a perspective of not knowing the language at all or from knowing Perl 5, it's enough to know initially that <code>~~</code> will pattern match on strings).</p>

<h3>New Perl 6 Syntax</h3>

<p>Perl 6 also has some brand-new syntax.</p>

<h4>Long Comments</h4>

<p>Many people always gripe about the fact that Perl 5 lacks a lightweight multi-line comment mechanism (POD is apparently too verbose). Perl 6 solves this one quite nicely. If a bracketing character immediately follows the comment character (<code>#</code>), the comment extends to the corresponding closing bracket.</p>

<pre><code>    #[  This is a
        multi-line comment
        that ends here ----&gt;  ]</code></pre>

<p>See <a href="http://dev.perl.org/perl6/doc/design/syn/S02.html#Whitespace_and_Comments">Whitespace and Comments in Synopsis 02</a> for more information.</p>

<h4>switch Statement</h4>

<p>For those of you who have forever wished for a switch statement in Perl, Perl 6 will have it (only by another name):</p>

<pre><code>    given $thing {
        when 3      { say "three"; }
        when 5      { say "five";  }
        when 9      { say "nine";  }
        when "a"    { say "what?"; }
        default     { say "none";  }
    }</code></pre>

<p>This construct is much more powerful than I've outlined here, however, as it takes advantage of the smart match operator to do the right thing when the given <code>$thing</code> (or the thing it's being "compared" against in the <code>when</code> clause) is an object or an array or hash, or code, etc.</p>

<h4>New Loops</h4>

<p>The C-style <code>for</code> loop operator has become <code>loop</code>. But you can omit the parenthetical portion to write an infinite loop:</p>

<pre><code>    loop { ... }</code></pre>

<p>Another new looping construct is the <code>repeat</code> loop, which occupies the same niche as Perl 5's <code>do</code>-<code>while</code> pseudoloop. The big difference is that unlike <code>do</code>-<code>while</code>, <code>repeat</code> is a real loop and as such, you are free to use <code>next</code>, <code>last</code>, <code>redo</code> and it does the right thing.</p>

<p>For more information see <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a>.</p>

<h4>Parameterized Blocks</h4>

<p>Essentially, every block in a Perl 6 program is a subroutine. Some blocks, like those used in an <code>if</code> statement, have no parameters; but others do, such as the body of a <code>for</code> loop. But any block may be parameterized. This is especially useful for doing things that aren't easy in Perl 5 but should be -- like examining values three at a time with <code>map</code>:</p>

<pre><code>    my @trimults = map -&gt; $a,$b,$c { $a * $b * $c }, @numbers;</code></pre>

<p>Here is an example where Perl 6 co-opts the arrow notation for a higher purpose. The arrow now introduces parameters to a block. You are most likely to see this in <code>for</code> loops:</p>

<pre><code>    # Perl 6                        # Perl 5
    for @array -&gt; $a     { ... }    for my $a (@array) { ... }
    for @array -&gt; $a, $b { ... }    # too complex :)</code></pre>

<p>The second <code>for</code> loop will take items from <code>@array</code> two at a time and lexically assign them to <code>$a</code> and <code>$b</code> for the duration of the block. The same behavior is not so easy to accomplish in Perl 5.</p>

<p>Another way to write the <code>@trimults</code> example, but slightly less verbose, is:</p>

<pre><code>    my @trimults = map { $^a * $^b * $^c }, @numbers;</code></pre>

<p>Variables with a caret (<code>^</code>) immediately after the sigil are implicit parameters to the block, and Perl 6 assigns them in Unicode-order. That is, <code>$^a</code> is the first parameter, <code>$^b</code> the second, and <code>$^c</code> the third.</p>

<p>There is yet a third way to write a parameterized block that's more verbose but more also powerful. It allows the programmer to take full advantage of subroutine signatures. Yes, TMTOWTDI, is still alive and well :-)</p>

<h4>Subroutine Signatures</h4>

<p>You can still write subroutines the way you always have in Perl 5, but Perl 6 allows you to specify a "signature" that describes how many parameters to pass to the subroutine, which parameters are optional, which parameters are positional, which are named, what the default values are for unpassed parameters, which parameters copy the value that is passed, which parameters alias the variable, etc.</p>

<p>For more information on subroutines in Perl 6, see <a href="http://dev.perl.org/perl6/doc/design/syn/S06.html">Synopsis 06</a> and Phil Crow's recent article <a href="http://www.perl.com/pub/a/2007/03/01/perl-6-parameter-passing.html">The Beauty of Perl 6 Parameter Passing</a>.</p>

<h4>Variable Typing</h4>

<p>In the interest of allowing programmers to be precise in their expressions, Perl 6 allows for optional variable typing. That is, the programmer can not only say, "this variable is a scalar" but can also say "this scalar conforms to the expectation of items in this particular class." In other words, you can say things such as:</p>

<pre><code>    my Dog  $spot;
    my Fish $wanda;</code></pre>

<p>...and it means something useful to Perl as well as the programmer. The variable <code>$spot</code> is only usable in a place where Perl expects a <code>Dog</code>, and the variable <code>$wanda</code> only works in places where Perl expects a <code>Fish</code>. However, the Perl 5-ish code will work perfectly fine, too:</p>

<pre><code>    my Dog  $spot;
    my Fish $wanda;
    my $x;
    $x = $spot;
    $x = $wanda;</code></pre>

<p>...because <code>$x</code> is sufficiently "untyped" that it can accept a <code>Dog</code> or a <code>Fish</code>, or any scalar thing.</p>

<h4>Multiple Dispatch</h4>

<p>Variable typing coupled with subroutine signatures gives the benefit of multiple dispatch. What that means is that you can declare two subroutines with the same name but different signatures, and Perl will select which subroutine to invoke at runtime based on the parameters sent to the subroutine. For example:</p>

<pre><code>    multi sub feed(Dog  $spot)  { say "dog food!";  }
    multi sub feed(Fish $wanda) { say "fish food!";  }

    my Fish $nemo;
    my Dog  $rover;

    feed($nemo);                 # fish food!
    feed($rover);                # dog food!</code></pre>

<p>The <code>multi</code> keyword tells Perl that you intend to declare multiple subroutines with the same name, and it should use the name and the parameters and whatever other distinguishing characteristics it can to decide which one to actually invoke.</p>

<h3>The End</h3>

<p>I hope this introduction gives you a feel for some of the changes in Perl 6 and shows how these changes are good and useful.</p>

<p>A prototype implementation of Perl 6 called <a href="http://www.pugscode.org/"><em>pugs</em></a> should be able to execute all of the examples I've given in this article. If not, get on the freenode IRC network, join #perl6, ask for a commit bit, and submit a test to the Pugs repository, and one of the pugs Developers will probably update Pugs to run it soon enough :-)</p>

<h3>Thanks</h3>

<p>Special thanks to all of the people on IRC (#perl and #perl6) who looked over this article and gave their input and commentary.</p>

]]>
        
    </content>
</entry>

<entry>
    <title>Lightning Strikes Four Times</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/04/12/lightning-four.html" />
    <id>tag:com.perl.org,2007:/pub//2.656</id>

    <published>2007-04-12T07:00:00Z</published>
    <updated>2010-06-20T16:31:37Z</updated>

    <summary> by Mike Friedman Good software design principles tell us that we should work to separate unrelated concerns. For example, the popular Model-View-Controller (MVC) pattern is common in web application designs. In MVC, separate modular components form a model, which...</summary>
    <author>
        <name>Shlomi Fish</name>
        
    </author>
    
        <category term="C and Perl" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="CPAN" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Games" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Graphics" scheme="http://www.sixapart.com/ns/types#category" />
    
        <category term="Modules" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="aop" label="AOP" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="crosscuttingconcerns" label="cross-cutting concerns" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="glut" label="GLUT" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="opengl" label="OpenGL" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pogl" label="POGL" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="subroutineattributes" label="subroutine attributes" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="testcounts" label="test counts" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="testcount" label="Test::Count" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>by Mike Friedman</p>

<p>Good software design principles tell us that we should work to separate unrelated concerns. For example, the popular Model-View-Controller (MVC) pattern is common in web application designs. In MVC, separate modular components form a <em>model</em>, which provides access to a data source, a <em>view</em>, which presents the data to the end user, and a <em>controller</em>, which implements the required features.</p>

<p>Ideally, it's possible to replace any one of these components without breaking the whole system. A templating engine that translates the application's data into HTML (the <em>view</em>) could be replaced with one that generates YAML or a PDF file. The <em>model</em> and <em>controller</em> shouldn't be affected by changing the way that the <em>view</em> presents data to the user.</p>

<p>Other concerns are difficult to separate. In the world of aspect-oriented programming, a <em>crosscutting concern</em> is a facet of a program which is difficult to modularize because it must interact with many disparate pieces of your system.</p>

<p>Consider an application that logs copious trace data when in debugging mode. In order to ensure that it is operating correctly, you may want to log when it enters and exits each subroutine. A typical way to accomplish this is by conditionally executing a logging function based on the value of a constant, which turns debugging on and off.</p>

<pre><code>    use strict;
    use warnings;

    use constant DEBUG =&gt; 1;

    sub do_something { 
        log_message("I'm doing something") if DEBUG;

        # do something here

        log_message("I'm done doing something") if DEBUG;
    }</code></pre>

<p>This solution is simple, but it presents a few problems. Perhaps most strikingly, it's simply a lot of code to write. For each subroutine that you want to log, you must write two nearly identical lines of code. In a large system with hundreds or thousands of subroutines, this gets tedious fast, and can lead to inconsistently formatted messages as every copy-paste-edit cycle tweaks them a little bit.</p>

<p>Further, it offends the simple design goal of an MVC framework, because every component must talk to the logging system directly.</p>

<p>One way to improve this technique is to automatically wrap every interesting subroutine in a special logging function. There are a few ways to go about this. One of the simplest is to use subroutine attributes to install a dynamically generated wrapper.</p>

<h3>Attributes</h3>

<p>Perl 5.6 introduced <em>attributes</em> that allow you to add arbitrary metadata to a variable. Attributes can be attached both to package variables, including subroutines, and lexical variables. Since Perl 5.8, attributes on lexical variables apply at runtime. Attributes on package variables activate at compile-time.</p>

<p>The interface to Perl attributes is via the <a href="http://search.cpan.org/perldoc?attributes">attributes</a> pragma. (The older attrs is deprecated.) The CPAN module <a href="http://search.cpan.org/perldoc?Attribute::Handlers">Attribute::Handlers</a> makes working with attributes a bit easier. Here's an example of how you might rewrite the logging system using an attribute handler.</p>

<pre><code>    use strict;
    use warnings;

    use constant DEBUG =&gt; 1;

    use Attribute::Handlers;

    sub _log : ATTR(CODE) {
        my ($pkg, $sym, $code) = @_;

        if( DEBUG ) {
            my $name = *{ $sym }{NAME};

            no warnings 'redefine';

            *{ $sym } = sub {
                log_message("Entering sub $pkg\:\:$name");
                my @ret = $code-&gt;( @_ );
                log_message("Leaving sub $pkg\:\:$name");
                return @ret;
            };
        }
    }

    sub do_something : _log {
        print "I'm doing something.\n";
    }</code></pre>

<p>Attributes are declared by placing a colon (:) and the attribute name after a variable or subroutine declaration. Optionally, the attribute can receive some data as a parameter; <code>Attribute::Handlers</code> goes to great lengths to massage the passed data for you if necessary.</p>

<p>To set up an attribute handler, the code declares a subroutine, <code>_log</code>, with the <code>ATTR</code> attribute, passing the string <code>CODE</code> as a parameter. <code>Attribute::Handlers</code> provides <code>ATTR</code>, and the <code>CODE</code> parameter tells it that the new handler only applies to subroutines.</p>

<p>During compile time, any subroutine declared with the <code>_log</code> attribute causes Perl to call the attribute handler with several parameters. The first three are the package in which the subroutine was compiled, a reference to the typeglob where its symbol lives, and a reference to the subroutine itself. These are sufficient for now.</p>

<p>If the <code>DEBUG</code> constant is true, the handler sets to work wrapping the newly compiled subroutine. First, it grabs its name from the typeglob, then it adds a new subroutine to its spot in the symbol table. Because the code redefines a package symbol, it's important to turn off warnings for symbol redefinitions in within this block.</p>

<p>Because the new function is a lexical closure over <code>$pkg</code>, <code>$name</code>, and most importantly <code>$code</code>, it can use those values to construct the logging messages and call the original function.</p>

<p>All of this may seem like a lot of work, but once it's done, all you need to do to enable entry and exit logging for any function is to simply apply the <code>_log</code> attribute. The logging messages themselves get manufactured via closures when the program compiles, so we know they'll always be consistent. If you want to change them, you only have to do it in one place.</p>

<p>Best of all, because attribute handlers get inherited, if you define your handler in a base class, any subclass can use it.</p>

<h3>Caveats</h3>

<p>Although this is a powerful technique, it isn't perfect. The code will not properly wrap anonymous subroutines, and it won't necessarily propagate calling context to the wrapped functions. Further, using this technique will significantly increase the number of subroutine dispatches that your program must execute during runtime. Depending on your program's complexity, this may significantly increase the size of your call stack. If blinding speed is a major design goal, this strategy may not be for you.</p>

<h3>Going Further</h3>

<p>Other common cross-cutting concerns are authentication and authorization systems. Subroutine attributes can wrap functions in a security checker that will refuse to call the functions to callers without the proper credentials.</p>
<!-- prod: page break -->












<h3>Perl Outperforms C with OpenGL</h3>

<p>by Bob Free</p>

<p>Desktop developers often assume that compiled languages always perform better than interpreted languages such as Perl.</p>

<p>Conversely, most LAMP online service developers are familiar with mechanisms for preloading Perl interpreters modules (such as Apache mod_perl and ActivePerl/ISAPI), and know that Perl performance often approaches that of C/C++.</p>

<p>However, few 3D developers think of Perl when it comes to performance. They should.</p>

<p>GPUs are increasingly taking the load off of CPUs for number-crunching. Modern GPGPU processing leverages C-like programs and loads large data arrays onto the GPU, where processing executes independent of the CPU. As a result, the overall contribution of CPU-bound programs diminish, while Perl and C differences become statistically insignificant in terms of GPU performance.</p>

<p>The author has recently published a open source update to CPAN's <a href="http://search.cpan.org/perldoc?OpenGL">OpenGL</a> module, adding support for GPGPU features. With this release, he has also posted OpenGL Perl versus C benchmarks--demonstrating cases where Perl outperforms C for OpenGL operations.</p>

<h3>What Is OpenGL?</h3>

<p>OpenGL is an industry-standard, cross-platform language for rendering 3D images. Originally developed by Silicon Graphics Inc. (SGI), it is now in wide use for 3D CAD/GIS systems, game development, and computer graphics (CG) effects in film.</p>

<p>With the advent of Graphic Processing Units (GPU), realistic, real-time 3D rendering has become common--even in game consoles. GPUs are designed to process large arrays of data, such as 3D vertices, textures, surface normals, and color spaces.</p>

<p>It quickly became clear that the GPU's ability to process large amounts of data could expand well beyond just 3D rendering, and could applied to General Purpose GPU (GPGPU) processing. GPGPUs can process complex physics problems, deal with particle simluations, provide database analytics, etc.</p>

<p>Over the years, OpenGL has expanded to support GPGPU processing, making it simple to load C-like programs into GPU memory for fast execution, to load large arrays of data in the form of <em>textures</em>, and to quickly move data between the GPU and CPU via Frame Buffer Objects (FBO).</p>

<p>While OpenGL is in itself a portable language, it provides no interfaces to operating system (OS) display systems. As a result, Unix systems generally rely on an X11-based library called GLX; Windows relies on a WGL interface. Several libraries, such as <a href="http://www.opengl.org/resources/libraries/glut/">GLUT</a>, help to abstract these differences. However, as OpenGL added new extensions, OS vendors (Microsoft in particular) provided different methods for accessing the new APIs, making it difficult to write cross-platform GPGPU code.</p>

<h3>Perl OpenGL (POGL)</h3>

<p>Bob Free of Graphcomp has just released a new, portable, open source Perl OpenGL module (POGL 0.55).</p>

<p>This module adds support for 52 new OpenGL extensions, including many GPGPU features such as Vertex Arrays, Frame Buffer Objects, Vertext Programs, and Fragment Programs.</p>

<p>In terms of 3D processing, these extensions allow developers to perform real-time dynamic vertex and texturemap generation and manipulation within the GPU. This module also simplifies GPGPU processing by moving data to and from the CPU through textures, and loading low-level, assembly-like instructions to the GPU.</p>

<p>POGL 0.55 is a binary Perl module (written in C via XS), that has been tested on Windows (NT/XP/Vista) and Linux (Fedora 6. Ubuntu/Dapper). Source and binaries are available via SVN, PPM, tarball, and ZIP at the <a href="http://graphcomp.com/opengl">POGL homepage</a>.</p>

<p>POGL OS Performance</p>

<p>The POGL homepage includes initial benchmarks comparing POGL on Vista, Fedora, and Ubuntu. These tests show that static texture rendering on an animated object on Fedora was 10x faster than Vista; Ubuntu was 15x faster (using the same nVidia cards, drivers, and machine).</p>

<p>A subsequent, tighter benchmark eliminated UI and FPS counters, and focused more on dynamic texturemap generation. These results, posted on <a href="http://graphcomp.com/opengl/bench.html">OpenGL C versus Perl benchmarks</a>, show comparable numbers for Fedora and Ubuntu, with both outperforming Vista by about 60 percent.</p>

<p>Note: a further performance on these benchmarks could be available through the use of GPU vertex arrays.</p>

<h3>Perl versus C Performance</h3>

<p>These benchmarks also compare Perl against C code. It found no statistical difference between overall Perl and C performance on Linux. Inexplicably, Perl frequently outperformed C on Vista.</p>

<p>In general, C performed better than Perl on Vertex/Fragment Shader operations, while Perl outperformed C on FBO operations. In this benchmark, overall performance was essentially equal between Perl and C.</p>

<p>The similarity in performance is explained by several factors:</p>

<ul>
<li>GPU is performing the bulk of the number-crunching operations</li>

<li>POGL is a compiled C module</li>

<li>Non-GPU operations are minimal</li>
</ul>

<p>In cases where code dynamically generates or otherwise modifies the GPU's vetex/fragment shader code, it is conceivable that Perl would provide even better than C, due to Perl's optimized and interpreted string handling.</p>

<h3>Perl Advantages</h3>

<p>Given that GPGPU performance will be a wash in most cases, the primary reason for using a compiled language is to obfuscate source for intellectual property (IP) reasons.</p>

<p>For server-side development, there's really no reason to use a compiled language for GPGPU operations, and several reasons to go with Perl:</p>

<ul>
<li>Perl OpenGL code is more portable than C; therefore there are fewer lines of code</li>

<li>Numerous imaging modules for loading GPGPU data arrays (textures)</li>

<li>Portable, open source modules for system and auxiliary functions</li>

<li>Perl (under mod-perl/ISAPI) is generally faster than Java</li>

<li>It is easier to port Perl to/from C than Python or Ruby</li>

<li>As of this writing, there is no FBO support in Java, Python, or Ruby</li>
</ul>

<p>There is a side-by-side code comparison between C and Perl posted on the above benchmark page.</p>

<p>Desktop OpenGL/GPU developers may find it faster to prototype code in Perl (e.g., simpler string handling and garbage collection), and then port their code to C later (if necessary). Developers can code in one window and execute in another--with no IDE, no compiling--allowing innovators/researchers to do real-time experiments with new shader algorithms.</p>

<p>Physicists can quickly develop new models; researchers and media developers can create new experimental effects and reduce their time to market.</p>

<h3>Summary</h3>

<p>Performance is not a reason a reason to use C over Perl for OpenGL and GPGPU operations, and there are many cases where Perl is preferable to C (or Java/Python/Ruby).</p>

<p>By writing your OpenGL/GPU code in Perl, you will likely:</p>

<ul>
<li>Reduce your R&amp;D costs and time to market</li>

<li>Expand your platform/deployment options</li>

<li>Accelerate your company's GPGPU ramp up</li>
</ul>
<!-- prod: page break -->












<h3>Using Test::Count</h3>

<p>by Shlomi Fish</p>

<p>A typical <a href="http://search.cpan.org/perldoc?Test::More">Test::More</a> test script contains several checks. It is preferable to keep track of the number of checks that the script is running (using <code>use Test::More tests =&gt; $NUM_CHECKS</code> or the <code>plan tests =&gt; $NUM_CHECKS</code>), so that if some checks are not run (for whatever reason), the test script will still fail when being run by the harness.</p>

<p>If you add more checks to a test file, then you have to remember to update the plan. However, how do you keep track of how many tests <em>should</em> run? I've already encountered a case where <a href="http://dbi.perl.org/">a DBI related module</a> had a different number of tests with an older version of DBI than with a more recent one.</p>

<p>Enter <a href="http://search.cpan.org/dist/Test-Count/">Test::Count</a>. Test::Count originated from a <a href="http://www.vim.org/">Vim</a> script I wrote to keep track of the number of tests by using meta-comments such as <code># TEST</code> (for one test) or <code># TEST*3*5</code> (for 15 tests). However, there was a limit to what I could do with Vim's scripting language, as I wanted a richer syntax for specifying the tests as well as variables.</p>

<p>Thus, I wrote the Test::Count module and placed it on CPAN. <a href="http://search.cpan.org/dist/Test-Count/lib/Test/Count/Filter.pm">Test::Count::Filter</a> acts as a filter, counts the tests, and updates them. Here's an example, taken from a code I wrote for a Perl Quiz of the Week:</p>

<pre><code>#!/usr/bin/perl -w

# This file implements various functions to remove
# all periods ("."'s) except the last from a string.

use strict;

use Test::More tests =&gt; 5;
use String::ShellQuote;

sub via_split
{
    my $s = shift;
    my @components = split(/\./, $s, -1);
    if (@components == 1)
    {
        return $s;
    }
    my $last = pop(@components);
    return join("", @components) . "." . $last;
}

# Other Functions snipped.

# TEST:$num_tests=9
# TEST:$num_funcs=8
# TEST*$num_tests*$num_funcs
foreach my $f (@funcs)
{
    my $ref = eval ("\\&amp;$f");
    is($ref-&gt;("hello.world.txt"), "helloworld.txt", "$f - simple"); # 1
    is($ref-&gt;("hello-there"), "hello-there", "$f - zero periods"); # 2
    is($ref-&gt;("hello..too.pl"), "hellotoo.pl", "$f - double"); # 3
    is($ref-&gt;("magna..carta"), "magna.carta", "$f - double at end"); # 4
    is($ref-&gt;("the-more-the-merrier.jpg"),
       "the-more-the-merrier.jpg", "$f - one period"); # 5
    is($ref-&gt;("hello."), "hello.", "$f - one period at end"); # 6
    is($ref-&gt;("perl.txt."), "perltxt.", "$f - period at end"); # 7
    is($ref-&gt;(".yes"), ".yes", "$f - one period at start"); # 8
    is($ref-&gt;(".yes.txt"), "yes.txt", "$f - period at start"); # 9
}</code></pre>

<p>Filtering this script through <code>Test::Count::Filter</code> provides the correct number of tests. I then add this to my <em>.vimrc</em>:</p>

<pre><code>function! Perl_Tests_Count()
    %!perl -MTest::Count::Filter -e 'Test::Count::Filter-&gt;new({})-&gt;process()'
endfunction

autocmd BufNewFile,BufRead *.t map &lt;F3&gt; :call Perl_Tests_Count()&lt;CR&gt;</code></pre>

<p>Now I can press F3 to update the number of checks.</p>

<p><code>Test::Count</code> supports +,-,*, /, as well as parentheses, so it is expressive enough for most needs.</p>

<h3>Acknowledgements</h3>

<p>Thanks to mrMister from <a href="http://www.freenode.net/">Freenode</a> for going over earlier drafts of this article and correcting some problems.</p>











<h3>What's In that Scalar?</h3>

<p>by brian d foy</p>

<p>Scalars are simple, right? They hold single values, and you don't even have to care what those values are because Perl figures out if they are numbers or strings. Well, scalars show up just about anywhere and it's much more complicated than single values. I could have <code>undef</code>, a number or string, or a reference. That reference can be a normal reference, a blessed reference, or even a hidden reference as a tied variable.</p>

<p>Perhaps I have a scalar variable which should be an object (a blessed reference, which is a single value), but before I call a method on it I want to ensure it is to avoid the "unblessed reference" error that kills my program. I might try the <code>ref</code> built-in to get the class name:</p>

<pre><code>   if( ref $maybe_object ) { ... }</code></pre>

<p>There's a bug there. <code>ref</code> returns an empty string if the scalar isn't an object. It might return <code>0</code>, a false value, and yes, some Perl people have figured out how to create a package named <code>0</code> just to mess with this. I might think that checking for defined-ness would work:</p>

<pre><code>   if( defined ref $maybe_object ) { ... }</code></pre>

<p>... but the empty string is also defined. I want all the cases where it is not the one value that means it's not a reference.</p>

<pre><code>   unless( '' eq ref $maybe_object ) { ... }</code></pre>

<p>This still doesn't tell me if I have an object. I know it's a reference, but maybe it's a regular data reference. The <code>blessed</code> function from <a href="http://search.cpan.org/perldoc?Scalar::Util">Scalar::Util</a> can help:</p>

<pre><code>   if( blessed $maybe_object ) { ... }</code></pre>

<p>This almost has the same problem as <code>ref</code>. <code>blessed</code> returns the package name if it's an object, and <code>undef</code> otherwise. I really need to check for defined-ness.</p>

<pre><code>   if( defined blessed $maybe_object ) { ... }</code></pre>

<p>Even if <code>blessed</code> returns <code>undef</code>, I still might have a hidden object. If the scalar is a tied variable, there's really an object underneath it, although the scalar acts as if it's a normal variable. Although I normally don't need to interact with the secret object, the <code>tied</code> built-in returns the secret object if there is one, and <code>undef</code> otherwise.</p>

<pre><code>        my $secret_object = tied $maybe_tied_scalar;

        if( defined $secret_object ) { ... }</code></pre>

<p>Once I have the secret object in <code>$secret_object</code>, I treat it like any other object.</p>

<p>Now I'm sure I have an object, but that doesn't mean I know which methods I can call. The <code>isa</code> function in the <code>UNIVERSAL</code> package supposedly can figure this out for me. It tells me if a class is somewhere in an object's inheritance tree. I want to know if my object can do what a <code>Horse</code> can do, even if I have a <code>RaceHorse</code>:</p>

<pre><code>   if( UNIVERSAL::isa( $object, 'RaceHorse' ) {
           $object-&gt;method;
           }</code></pre>

<p>...what if the <code>RaceHorse</code> class is just a factory for objects in some other class that I'm not supposed to know about? I'll make a new object as a prototype just to get its reference:</p>

<pre><code>   if( UNIVERSAL::isa( $object, ref RaceHorse-&gt;new() ) {
           $object-&gt;method;
           }</code></pre>

<p>A real object-oriented programmer doesn't care what sort of object it is as long as it can respond to the right method. I should use <code>can</code> instead:</p>

<pre><code>   if( UNIVERSAL::can( $object, $method ) {
           $object-&gt;method;
           }</code></pre>

<p>This doesn't always work either. <code>can</code> only knows about defined subroutine names, and only looks in the inheritance tree for them. It can't detect methods from <code>AUTOLOAD</code> or traits. I could override the <code>can</code> method to handle those, but I have to call it as a method (this works for <code>isa</code> too):</p>

<pre><code>   if( $object-&gt;can( $method ) ) {
           $object-&gt;method;
           }</code></pre>

<p>What if <code>$object</code> wasn't really an object? I just called a method on a non-object! I'm back to my original problem, but I don't want to use all of those tests I just went through. I'll fix this with an <code>eval</code>, which catches the error for non-objects:</p>

<pre><code>   if( eval{ $object-&gt;can( $method ) } ) {
           $object-&gt;method;
           }</code></pre>

<p>...but what if someone installed a <code>__DIE__</code> handler that simply <code>exit</code>-ed instead of <code>die</code>-ing? Programmers do that sort of thing forgetting that it affects the entire program.</p>

<pre><code>   $SIG{__DIE__} = sub { exit };</code></pre>

<p>Now my <code>eval</code> tries to <code>die</code> because it caught the error, but the <code>__DIE__</code> handler says <code>exit</code>, so the program stops without an error. I have to localize the <code>__DIE__</code> handler:</p>

<pre><code>   if( eval{ local $SIG{__DIE__}; $object-&gt;can( $method ) } ) {
           $object-&gt;method;
           }</code></pre>

<p>If I'm the guy responsible for the <code>__DIE__</code> handler, I could use <code>$^S</code> to see if I'm in an <code>eval</code>:</p>

<pre><code>   $SIG{__DIE__} = sub { $^S ? die : exit };</code></pre>

<p>That's solved it, right? Not quite. Why do all of that checking? I can just call the method and hope for the best. If I get an error, so be it:</p>

<pre><code>   my $result = eval { $object-&gt;method };</code></pre>

<p>Now I have to wrap all of my method calls in an eval. None of this would really be a problem if Perl were an object language. Or is it? The <a href="http://search.cpan.org/perldoc?autobox">autobox</a> module makes Perl data types look like objects:</p>

<pre><code>   use autobox;

   sub SCALAR::println { print $_[0], "\n" }

   'Hello World'-&gt;println;</code></pre>

<p>That works because it uses a special package <code>SCALAR</code>, although I need to define methods in it myself. I'll catch unknown methods with <code>AUTOLOAD</code>:</p>

<pre><code>   sub SCALAR::AUTOLOAD {}</code></pre>

<p>Or, I can just wait for Perl 6 when these things get much less murky because everything is an object.</p>





]]>
        
    </content>
</entry>

<entry>
    <title>The Beauty of Perl 6 Parameter Passing</title>
    <link rel="alternate" type="text/html" href="http://com.perl.org/pub/2007/03/01/perl-6-parameter-passing.html" />
    <id>tag:com.perl.org,2007:/pub//2.654</id>

    <published>2007-03-01T08:00:00Z</published>
    <updated>2010-06-20T16:31:36Z</updated>

    <summary> Perl 6 is not finished, but you can already play with it. I hope this article will encourage you to try it. Begin by installing Pugs, a Perl 6 compiler implemented in Haskell. Note that you will also need...</summary>
    <author>
        <name>Phil Crow</name>
        
    </author>
    
        <category term="Perl 6" scheme="http://www.sixapart.com/ns/types#category" />
    
    <category term="exegeses" label="exegeses" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="parameterpassing" label="parameter passing" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="parrot" label="Parrot" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl" label="Perl" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="perl6" label="Perl 6" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="pugs" label="Pugs" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="subroutines" label="subroutines" scheme="http://www.sixapart.com/ns/types#tag" />
    <category term="synopses" label="synopses" scheme="http://www.sixapart.com/ns/types#tag" />
    
    <content type="html" xml:lang="en" xml:base="http://com.perl.org/pub/">
        <![CDATA[
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Perl 6 is not finished, but you can already play with it. I hope this article will encourage you to try it. Begin by installing <a href="http://search.cpan.org/perldoc?pugs">Pugs</a>, a Perl 6 compiler implemented in Haskell. Note that you will also need Haskell (see directions in the Pugs <em>INSTALL</em> file for how to get it).</p>

<p>Of course, Pugs is not finished. It couldn't be. The Perl 6 design is still in progress. However, Pugs still has many key features that are going to turn our favorite language into something even greater.</p>

<h3>A Simple Script</h3>

<p>I'm about to take a big risk. I'm going to show you a script that performs Newton's method. Please don't give up before you get started.</p>

<p>Sir Isaac Newton was a noted computer scientist and sometime astronomer, physicist, and mathematician, as the communications of the ACM once described him. He and others developed a fairly simple way of finding square roots. It goes like this:</p>

<pre><code>    #!/usr/bin/pugs
    use v6;

    my Num  $target = 9;
    my Num  $guess  = $target;

    while (abs( $guess**2 - $target ) &gt; 0.005) {
        $guess += ( $target - $guess**2 ) / ( 2 * $guess );

        say $guess;
    }</code></pre>

<p>This version always finds the square root of 9, which conveniently is 3. This aids testing because I don't have to remember a more interesting square root, for example, the square root of 2. When I run this, the output is:</p>

<pre><code>    5
    3.4
    3.0235294117647058823529411764705882352941
    3.0000915541313801785305561913481345845731</code></pre>

<p>The last number is the square root of 9 accurate to three decimal places.</p>

<p>Here's what's going on.</p>

<p>Once Pugs is installed, you can use it in a shebang line (on Unix or Cygwin, at least). Otherwise, invoke the script through <code>pugs</code> as you would for <code>perl</code>:</p>

<pre><code>$ <strong>pugs newton</strong></code></pre>

<p>To let Perl 6 know that I want Perl 6 and not Perl 5, I type <code>use v6;</code>.</p>

<p>In Perl 6, the basic primitive types are still scalar, array, and hash. There are also more types of scalars. In this case, I'm using the floating-point type Num for both the target (the number whose square root I want) and the guess (which I hope will improve until it is the square root of the target). I can use this syntax in Perl 5. In Perl 6 it will be the norm (or so I hope). I've used <code>my</code> to limit the scope of the variables just as in Perl 5.</p>

<p>Newton's method always needs a guess. Without explaining, I'll say that for square roots the guess makes little difference. To make it easy, I guessed the number itself. Obviously, that's not a good guess, but it works eventually.</p>

<p>The while loop goes until the square of the guess is close to the target. How close is up to me. I chose .005 to give about three places of accuracy.</p>

<p>Inside the loop, the code improves the guess at each step using Newton's formula. I won't explain it at all. (I've resisted the strong temptation from my math-teacher days to explain a lot more. Be glad I resisted. But if you are curious, consult a calculus textbook. Or better yet, send me email. I'd love to say more!) I'll present a more general form of the method soon, which may jog the memories of the calculus lovers in the audience, or not.</p>

<p>Finally, at the end of each iteration, I used <code>say</code> to print the answer. This beats writing: <code>print "$guess\n";</code>.</p>

<p>Except for using <code>say</code> and declaring the type of the numbers to be <code>Num</code>, there's not much to separate the above script from one I might have written in Perl 5. That's okay. It's about to get more Perl 6ish.</p>

<h3>An Exporting Module</h3>

<p>While it's fine to have a script that finds square roots, it would be better to generalize this in a couple of ways. One good change is to make it a module so that others can share it. Another is to turn loose the power of Newton and look for other kinds of roots, like cube roots and other even more exotic ones.</p>

<p>First, I'll turn the script above into a module that exports a <code>newton</code> sub. Then, I'll tackle generalizing the method.</p>

<p>When I'm finished, I want to be able to use the module like this:</p>

<pre><code>    #!/usr/bin/pugs

    use Newton;

    my $answer = newton(4);

    say $answer;</code></pre>

<p>Because <code>say</code> is so helpful, I could combine the last two statements:</p>

<pre><code>        say "{ newton(4) }";</code></pre>

<p>That's right, strings will run code if you put it in braces.</p>

<p>The module, <em>Newton.pm</em>, looks like this:</p>

<pre><code>    package Newton;
    use v6;

    sub newton(Num $target) is export {
        my Num  $guess  = $target;

        while (abs( $guess**2 - $target ) &gt; 0.005) {
            $guess += ( $target - $guess**2 ) / ( 2 * $guess );
        }

        return $guess;
    }</code></pre>

<p>Here begins the familiar package declaration borrowed from Perl 5. (In Perl
6 itself, <code>package</code> identifies Perl 5 source code.  The <a
href="http://search.cpan.org/v6?v6">v6</a> module lets you run some Perl 6 code
in Perl 5 programs.)  Immediately following is <code>use v6;</code>, just as in
the original script.</p>

<p>Declaring subs in Perl 6 doesn't have to be any different than in Perl 5, but it should be. This one says it takes a numeric variable called <code>target</code>. Such genuine prototypes allow for Perl 6 to report compilation errors when you call a sub with the wrong arguments. That single step will move Perl 6 onto the list of possible languages for a lot of large-scale application development shops.</p>

<p>At the end of the declaration, just before the opening brace for the body, I included <code>is export</code>. This puts <code>newton</code> into the namespace of whoever uses the module (at least, if they use the module in the normal way; they could explicitly decline to take imports). There is no need to explicitly use <code>Exporter</code> and set up <code>@EXPORT</code> or its friends.</p>

<p>The rest of the code is the same, except that it returns the answer and no longer proclaims its guess at each iteration.</p>













<h3>Assigning Defaults</h3>

<p>Adding genuine, compiler-enforced parameters to sub declarations is a giant leap forward for Perl. For many people, that particular looseness in Perl 5 keeps it out of any discussions about what language to use for a project. I experienced this unfortunate reality firsthand in my last job. There's a lot more to declarations in Perl 6, though.</p>

<p>Suppose I want to give the caller control over the accuracy of the method, yet I want to provide a sensible default if that caller doesn't want to think of a good one. I might write:</p>

<pre><code>    package Newton;
    use v6;

    sub newton(
        Num  $target,
        Num  :$epsilon = 0.005,  # note the colon
        Bool :$verbose = 0,
    ) is export {
        my Num  $guess  = $target;

        while (abs( $guess**2 - $target ) &gt; $epsilon ) {
            $guess += ( $target - $guess**2 ) / ( 2 * $guess );
                    say $guess if $verbose;
        }

        return $guess;
    }</code></pre>

<p>Here I've introduced two new optional parameters: <code>$verbose</code>, for whether to print at each step (the default is to keep quiet) and <code>$epsilon</code>, the Greek letter we math types often use for tolerances.</p>

<p>While the caller might use this exactly as before, she now has options. She might say:</p>

<pre><code>    my $answer = newton(165, verbose =&gt; 1, epsilon =&gt; .00005);</code></pre>

<p>This gives extra accuracy and prints the values at each iteration (which prints the value of the last iteration twice: once in the loop and again in the driving script). Note that the named parameters may appear in any order.</p>

<h3>Making Assumptions</h3>

<p>Finally, Newton's method can find roots for more things than just squares. To make this general requires a bit more work and some extra math (which I'll again brush under the rug).</p>

<p>It is easy enough to supply the function for which you want roots. For example, the squaring function could be:</p>

<pre><code>        sub f(Num $x) { $x**2 }</code></pre>

<p>Then, in the update line of the loop, write:</p>

<pre><code>    $guess += ( $target - f($guess) ) / ( 2 * $guess );</code></pre>

<p>Changing <code>f</code> would change the roots you seek.</p>

<p>The problem is on the far side of the division symbol. <code>2 * $guess</code> depends on the function (it's the first derivative, for those who care). I could require the caller to provide this, as in:</p>

<pre><code>        sub fprime(Num $x) { 2 * $x }</code></pre>

<p>Then the update would be:</p>

<pre><code>    $guess += ( $target - f($guess) ) / fprime($guess);</code></pre>

<p>There are two problems with this approach. First, you need a way for the caller to pass those functions into the sub. That's actually pretty easy; just add parameters of type Code to the list:</p>

<pre><code>    sub newton(
        Num  $target,
        Code $f,
        Code $fprime,
        Num  :$epsilon = 0.005,
        Bool :$verbose = 0,
    ) is export {</code></pre>

<p>The second problem is that the caller may not know how to calculate <code>$fprime</code>. Perhaps I should make calculus a prerequisite for using the module, but that just might scare away a few potential users. I want to provide a default, but the default depends on what the function is. If I knew what <code>$f</code> was, I could estimate <code>$fprime</code> for users.</p>

<p>Perl 6 provides precisely this ability. Here's the final module, a bit at a time:</p>

<pre><code>    package Newton;

    use v6;</code></pre>

<p>That's nothing new.</p>

<pre><code>    sub approxfprime(Code $f, Num $x) {
        my Num $delta = 0.1;
        return ($f($x + $delta) - $f($x - $delta))/(2 * $delta);
    }</code></pre>

<p>For those who care (surely at least one person does), this is a second-order centered difference. For those who don't, its an approximation suitable for use in the <code>newton</code> sub. It takes a function and a number and returns an estimate of the value needed for division.</p>

<pre><code>    sub newton(
        Num  $target,
        Code $f,
        Code :$fprime         = &amp;approxfprime.assuming( f =&gt; $f ),
        Num  :$epsilon        = 0.0005,
        Bool :$verbose        = 0,
    ) returns Num is export {
        my Num $guess  = $target / 2;

        while (abs($f($guess) - $target) &gt; $epsilon) {

            $guess += ($target - $f($guess)) / $fprime($guess);

            say $guess if $verbose;
        }
        return $guess;
    }</code></pre>

<p>A script using this program could be as simple as:</p>

<pre><code>    #!/usr/bin/pugs

    use Newton;

    sub f(Num $x) { return $x**3 }

    say "{ newton(8, \&amp;f, verbose =&gt; 1, epsilon =&gt; .00005) }";</code></pre>

<p>Note that the caller must supply the function <code>f</code>. The one in the example is for cube roots.</p>

<p>If the caller provides the derivative as <code>fprime</code>, I use it. Otherwise, as in the example, I use <code>approxfprime</code>. Whereas a caller-supplied <code>fprime</code> would take one number and return another, <code>approxfprime</code> needs a number and a function. The function needed is the one the caller passed to <code>newton</code>. How do you pass it on? Currying&#8212;that is, supplying one or more of the parameters of a function once, then using the simplified version after that.</p>

<p>In Perl 6, you can obtain a reference to a sub by placing the sub sigil <code>&amp;</code> in front of the function's name (providing it is in scope). To curry, add <code>.assuming</code> to the end of that and supply values for one or more arguments in parentheses. All of this is harder to talk about than to do:</p>

<pre><code>    Code :$fprime         = &amp;approxfprime.assuming( f =&gt; $f ),</code></pre>

<p>This code means that the caller might supply a value. If this is the case, use it. Otherwise, use <code>approxfprime</code> with the caller's function in place of <code>f</code>.</p>

<h3>Conclusion</h3>

<p>Perl 6 calling conventions are extremely well designed. Not only do they allow compile-time parameter checking, they also allow named parameters with or without complex defaults, even including curried default functions. This is going to be very powerful. In fact, with Pugs, it already is.</p>

<p>There is a slightly more detailed version of the example from this article in the <em>examples/algorithms/</em> directory of the Pugs distribution. It's called <em>Newton.pm</em>.</p>

<h3>Disclaimer</h3>

<p>As much as it pains me to say it, if you need heavy duty numerics, don't code in pure Perl. Rather, use FORTRAN, C, or Perl with PDL. And be careful. Numerics is full of unexpected gotchas, which lead to poor performance or outright incorrect results. Unfortunately, Newton's method, in the general case, is notoriously risky. When in doubt about numerics, do as I do and consult a professional in the field.</p>



]]>
        
    </content>
</entry>

</feed>
