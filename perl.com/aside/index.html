<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="http://com.perl.org/styles.css" type="text/css" />
<link rel="start" href="http://com.perl.org/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="http://com.perl.org/atom.xml" />
<script type="text/javascript" src="http://com.perl.org/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://com.perl.org/rsd.xml" />
    <title>Perl.com</title>
</head>
<body id="modern-aqua" class="mt-main-index layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



        <h1 id="header-name"><a href="http://com.perl.org/" accesskey="1" border="0"><img src="/i/site-logo.gif"></a></h1>
            <h2 id="header-description"></h2>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <div id="entry-648" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html" rel="bookmark">Beginner's Introduction to Perl 5.10, Part 2</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">chromatic</span> on <abbr class="published" title="2008-05-07T00:00:00-08:00">May  7, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p><a href="http://www.perl.com/pub/a/2008/04/23/a-beginners-introduction-to-perl-510.html">A Beginner's Introduction to Perl 5.10</a> talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the <code>for</code> statement). Now it's time to interact with the world.  (<a href="http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Regular Expressions with Perl 5.10</a> explores regular expressions, matching, and substitutions.  <a href="http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Perl Web Programming</a> demonstrates how to write web programs.)</p>

<p>This installment discusses how to slice and dice strings, how to play with files and how to define your own functions. First, you need to understand one more core concept of the Perl language: conditions and comparisons.</p>

<h3>Comparison operators</h3>

<p>Like all good programming languages, Perl allows you ask questions such as "Is this number greater than that number?" or "Are these two strings the same?" and do different things depending on the answer.</p>

<p>When you're dealing with numbers, Perl has four important operators: <code>&lt;</code>, <code>&gt;</code>, <code>==</code> and <code>!=</code>. These are the "less than," "greater than," "equal to" and "not equal to" operators. (You can also use <code>&lt;=</code>, "less than or equal to," and <code>&gt;=</code>, "greater than or equal to.)</p>

<p>You can use these operators along with one of Perl's <em>conditional</em> keywords, such as <code>if</code> and <code>unless</code>. Both of these keywords take a condition that Perl will test, and a block of code in curly brackets that Perl will run if the test works. These two words work just like their English equivalents -- an <code>if</code> test succeeds if the condition turns out to be true, and an <code>unless</code> test succeeds if the condition turns out to be false:</p>

<pre><code>use 5.010;

if ($year_according_to_computer == 1900) {
    say "Y2K has doomed us all!  Everyone to the compound.";
}

unless ($bank_account &gt; 0) {
    say "I'm broke!";
}</code></pre>

<p>Be careful of the difference between <code>=</code> and <code>==</code>! One equals sign means "assignment", two means "comparison for equality". This is a common, evil bug:</p>

<pre><code>use 5.010;

if ($a = 5) {
    say "This works - but doesn't do what you want!";
}</code></pre>

<p>You may be asking what that extra line of code at the start does. Just like the <code>use feature :5.10;</code> code from the previous article, this enables new features of Perl 5.10. (Why 5.010 and not 5.10? The version number is not a single decimal; there may eventually be a Perl 5.100, but probably not a Perl 5.1000. Just trust me on this for now.)</p>

<p>Instead of testing whether <code>$a</code> is equal to five, you've made <code>$a</code> equal to five and clobbered its old value. (A future article will show how to avoid this bug in running code.)</p>

<p>Both <code>if</code> and <code>unless</code> can be followed by an <code>else</code> statement and code block, which executes if your test failed. You can also use <code>elsif</code> to chain together a bunch of <code>if</code> statements:</p>

<pre><code>use 5.010;

if ($a == 5) {
    say "It's five!";
} elsif ($a == 6) {
    say "It's six!";
} else {
    say "It's something else.";
}

unless ($pie eq 'apple') {
    say "Ew, I don't like $pie flavored pie.";
} else {
    say "Apple!  My favorite!";
}</code></pre>

<p>You don't always need an <code>else</code> condition, and sometimes the code to execute fits on a single line. In that case, you can use <em>postfix conditional</em> statements. The name may sound daunting, but you already understand them if you can read this sentence.</p>

<pre><code>use 5.010;

say "I'm leaving work early!" if $day eq 'Friday';

say "I'm burning the 7 pm oil" unless $day eq 'Friday';</code></pre>

<p>Sometimes this can make your code clearer.</p>

<h3><code>while</code> and <code>until</code></h3>

<p>Two slightly more complex keywords are <code>while</code> and <code>until</code>. They both take a condition and a block of code, just like <code>if</code> and <code>unless</code>, but they act like loops similar to <code>for</code>. Perl tests the condition, runs the block of code and runs it over and over again for as long as the condition is true (for a <code>while</code> loop) or false (for a <code>until</code> loop).</p>

<p>Try to guess what this code will do:</p>

<pre><code>use 5.010;

my $count = 0;

while ($count != 3) {
   $count++;
   say "Counting up to $count...";
}

until ($count == 0) {
   $count--;
   say "Counting down to $count...";
}</code></pre>

<p>Here's what you see when you run this program:</p>

<pre><code>Counting up to 1...
Counting up to 2...
Counting up to 3...
Counting down to 2...
Counting down to 1...
Counting down to 0...</code></pre>

<h3>String comparisons</h3>

<p>That's how you compare numbers. What about strings? The most common string comparison operator is <code>eq</code>, which tests for <em>string equality</em> -- that is, whether two strings have the same value.</p>

<p>Remember the pain of mixing up <code>=</code> and <code>==</code>? You can also mix up <code>==</code> and <code>eq</code>. This is one of the few cases where it <em>does</em> matter whether Perl treats a value as a string or a number. Try this code:</p>

<pre><code>use 5.010;

my $yes_no = 'no';
say "How positive!" if $yes_no == 'yes';</code></pre>

<p>Why does this code think you said yes? Remember that Perl automatically converts strings to numbers whenever it's necessary; the <code>==</code> operator implies that you're using numbers, so Perl converts the value of <code>$yes_no</code> ("no") to the number 0, and "yes" to the number 0 as well. Because this equality test works (0 is equal to 0), the condition is true. Change the condition to <code>$yes_no eq 'yes'</code>, and it'll do what it should.</p>

<p>Things can work the other way, too. The number five is <em>numerically</em> equal to the string <code>" 5 "</code>, so comparing them to <code>==</code> works. When you compare five and <code>" 5 "</code> with <code>eq</code>, Perl will convert the number to the string <code>"5"</code> first, and then ask whether the two strings have the same value. Because they don't, the <code>eq</code> comparison fails. This code fragment will print <code>Numeric equality!</code>, but not <code>String equality!</code>:</p>

<pre><code>use 5.010;

my $five = 5;

say "Numeric equality!" if $five == " 5 ";
say "String equality!"  if $five eq " 5 ";</code></pre>













<h3>More fun with strings</h3>

<p>You'll often want to manipulate strings: Break them into smaller pieces, put them together and change their contents. Perl offers three functions that make string manipulation easy and fun: <code>substr()</code>, <code>split()</code>, and <code>join()</code>.</p>

<p>If you want to retrieve part of a string (say, the first four characters or a 10-character chunk from the middle), use the <code>substr()</code> function. It takes either two or three parameters: the string you want to look at, the character position to start at (the first character is position 0) and the number of characters to retrieve. If you leave out the number of characters, you'll retrieve everything up to the end of the string.</p>

<pre><code>my $greeting = "Welcome to Perl!\n";

print substr($greeting, 0, 7);     # "Welcome"
print substr($greeting, 7);        # " to Perl!\n"</code></pre>

<p>A neat and often-overlooked thing about <code>substr()</code> is that you can use a <em>negative</em> character position. This will retrieve a substring that begins with many characters from the <em>end</em> of the string.</p>

<pre><code>my $greeting = "Welcome to Perl!\n";

print substr($greeting, -6, 4);      # "Perl"</code></pre>

<p>(Remember that inside double quotes, <code>\n</code> represents the single new-line character.)</p>

<p>You can also manipulate the string by using <code>substr()</code> to assign a new value to part of it. One useful trick is using a length of zero to <em>insert</em> characters into a string:</p>

<pre><code>my $greeting = "Welcome to Java!\n";

substr($greeting, 11, 4) = 'Perl';    # $greeting is now "Welcome to Perl!\n";
substr($greeting, 7, 3)  = '';        #       ... "Welcome Perl!\n";
substr($greeting, 0, 0)  = 'Hello. '; #       ... "Hello. Welcome Perl!\n";</code></pre>

<p><code>split()</code> breaks apart a string and returns a list of the pieces. <code>split()</code> generally takes two parameters: a <em>regular expression</em> to split the string with and the string you want to split. (The next article will discuss regular expressions in more detail; for the moment, all you need to know is that this regular expression represents a single space character: <code>/ /</code>.) The characters you split won't show up in any of the list elements.</p>

<pre><code>my $greeting = "Hello. Welcome Perl!\n";
my @words    = split(/ /, $greeting);   # Three items: "Hello.", "Welcome", "Perl!\n"</code></pre>

<p>You can also specify a third parameter: the maximum number of items to put in your list. The splitting will stop as soon as your list contains that many items:</p>

<pre><code>my $greeting = "Hello. Welcome Perl!\n";
my @words    = split(/ /, $greeting, 2);   # Two items: "Hello.", "Welcome Perl!\n";</code></pre>

<p>Of course, what you can split, you can also <code>join()</code>. The <code>join()</code> function takes a list of strings and attaches them together with a specified string between each element, which may be an empty string:</p>

<pre><code>my @words         = ("Hello.", "Welcome", "Perl!\n");
my $greeting      = join(' ', @words);       # "Hello. Welcome Perl!\n";
my $andy_greeting = join(' and ', @words);   # "Hello. and Welcome and Perl!\n";
my $jam_greeting  = join('', @words);        # "Hello.WelcomePerl!\n";</code></pre>

<h3>Filehandles</h3>

<p>That's enough about strings. It's time to consider files -- after all, what good is string manipulation if you can't do it where it counts?</p>

<p>To read from or write to a file, you have to <em>open</em> it. When you open a file, Perl asks the operating system if the file is accessible -- does the file exist if you're trying to read it (or can it be created if you're trying to create a new file), and do you have the necessary file permissions to do what you want? If you're allowed to use the file, the operating system will prepare it for you, and Perl will give you a <em>filehandle</em>.</p>

<p>Ask Perl to create a filehandle for you by using the <code>open()</code> function, which takes two or three arguments: the filehandle you want to create, the mode of the file, and the file you want to work with. First, we'll concentrate on reading files. The following statement opens the file <em>log.txt</em> using the filehandle <code>$logfile</code>:</p>

<pre><code>open my $logfile, 'log.txt';</code></pre>

<p>Opening a file involves several behind-the-scenes tasks that Perl and the operating system undertake together, such as checking that the file you want to open actually exists (or creating it if you're trying to create a new file) and making sure you're allowed to manipulate the file (do you have the necessary file permissions, for instance). Perl will do all of this for you, so in general you don't need to worry about it.</p>

<p>Once you've opened a file to read, you can retrieve lines from it by using the <code>&lt;&gt;</code> construct, also known as <code>readline</code>. Inside the angle brackets, place your filehandle. What you get from this depends on what you <em>want</em> to get: in a scalar context (a more technical way of saying "if you're assigning it to a scalar"), you retrieve the next line from the file, but if you're looking for a list, you get a list of all the remaining lines in the file.</p>

<p>You can, of course, <code>close</code> a filehandle that you've opened. You don't always have to do this, because Perl is clever enough to close a filehandle when your program ends, when you try to reuse an existing filehandle, or when the lexical variable containing the filehandle goes out of scope.</p>

<p>Here's a simple program that will display the contents of the file <em>log.txt</em>, and assumes that the first line of the file is its title:</p>

<pre><code>open my $logfile, 'log.txt' or die "I couldn't get at log.txt: $!";

my $title = &lt;$logfile&gt;;
print "Report Title: $title";

print while &lt;$logfile&gt;;
close $logfile;</code></pre>

<p>That code may seem pretty dense, but it combines ideas you've seen before. The <code>while</code> operator loops over every line of the file, one line at a time, putting each line into the Perl pronoun <code>$_</code>. (A pronoun? Yes -- think of it as <em>it</em>.) For each line read, Perl <code>prints</code> the line. Now the pronoun should make sense. While you read it from the file, print it.</p>

<p>Why not use <code>say</code>? Each <em>line</em> in the file ends with a newline -- that's how Perl knows that it's a line. There's no need to add an additional newline, so <code>say</code> would double-space the output.</p>

<h3>Writing files</h3>

<p>You also use <code>open()</code> when you are writing to a file. There are two ways to open a file for writing: <em>overwrite</em> and <em>append</em>. When you open a file in overwrite mode, you erase whatever it previously contained. In append mode, you attach your new data to the end of the existing file without erasing anything that was already there.</p>

<p>To indicate that you want a filehandle for writing, use a single <code>&gt;</code> character as the mode passed to <code>open</code>. This opens the file in overwrite mode. To open it in append mode, use two <code>&gt;</code> characters.</p>

<pre><code>open my $overwrite, '&gt;', 'overwrite.txt' or die "error trying to overwrite: $!";
# Wave goodbye to the original contents.

open my $append, '&gt;&gt;', 'append.txt' or die "error trying to append: $!";
# Original contents still there; add to the end of the file</code></pre>

<p>Once your filehandle is open, use the humble <code>print</code> or <code>say</code> operator to write to it. Specify the filehandle you want to write to and a list of values you want to write:</p>

<pre><code>use 5.010;

say $overwrite 'This is the new content';
print $append "We're adding to the end here.\n", "And here too.\n";</code></pre>

<h3>Live free or die!</h3>

<p>Most of these <code>open()</code> statements include <code>or die "some sort of message"</code>. This is because we live in an imperfect world, where programs don't always behave exactly the way we want them to. It's always possible for an <code>open()</code> call to fail; maybe you're trying to write to a file that you're not allowed to write, or you're trying to read from a file that doesn't exist. In Perl, you can guard against these problems by using <code>or</code> and <code>and</code>.</p>

<p>A series of statements separated by <code>or</code> will continue until you hit one that works, or returns a true value. This line of code will either succeed at opening <code>$output</code> in overwrite mode, or cause Perl to quit:</p>

<pre><code>open my $output, '&gt;', $outfile or die "Can't write to '$outfile': $!";</code></pre>

<p>The <code>die</code> statement ends your program with an error message. The special variable <code>$!</code> contains Perl's explanation of the error. In this case, you might see something like this if you're not allowed to write to the file. Note that you get both the actual error message ("Permission denied") and the line where it happened:</p>

<pre><code>Can't write to 'a2-die.txt': Permission denied at ./a2-die.pl line 1.</code></pre>

<p>Defensive programming like this is useful for making your programs more error-resistant -- you don't want to write to a file that you haven't successfully opened! (Putting single-quotes around the filename may help you see any unexpected whitespace in the filename. You'll slap your forehead when it happens to you.)</p>

<p>Here's an example: As part of your job, you write a program that records its results in a file called <em>vitalreport.txt</em>. You use the following code:</p>

<pre><code>open my $vital, '&gt;', 'vitalreport.txt';</code></pre>

<p>If this <code>open()</code> call fails (for instance, <em>vitalreport.txt</em> is owned by another user who hasn't given you write permission), you'll never know it until someone looks at the file afterward and wonders why the vital report wasn't written. (Just imagine the joy if that "someone" is your boss, the day before your annual performance review.) When you use <code>or die</code>, you avoid all this:</p>

<pre><code>open my $vital, '&gt;', 'vitalreport.txt' or die "Can't write vital report: $!";</code></pre>

<p>Instead of wondering whether your program wrote your vital report, you'll immediately have an error message that both tells you what went wrong and on what line of your program the error occurred.</p>

<p>You can use <code>or</code> for more than just testing file operations:</p>

<pre><code>use 5.010;
($pie eq 'apple') or ($pie eq 'cherry') or ($pie eq 'blueberry')
        or say 'But I wanted apple, cherry, or blueberry!';</code></pre>

<p>In this sequence, if you have an appropriate pie, Perl skips the rest of the chain. Once one statement works, the rest are ignored. The <code>and</code> operator does the opposite: It evaluates your chain of statements, but stops when one of them <em>doesn't</em> work.</p>

<pre><code>open my $log, 'log.file' and say 'Logfile is open!';
say 'Logfile is open!' if open my $log, 'log.file';</code></pre>

<p>This statement will only show you the words <em>Logfile is open!</em> if the <code>open()</code> succeeds -- do you see why?</p>

<p>Again, just because there's more than one way to execute code conditionally doesn't mean you have to use every way in a single program or the most clever or creative way. You have plenty of options. Consider using the most readable one for the situation.</p>













<h3>Subs</h3>

<p>So far, the example Perl programs have been a bunch of statements in series. This is okay if you're writing very small programs, but as your needs grow, you'll find it limiting. This is why most modern programming languages allow you to define your own functions; in Perl, we call them <em>subs</em>.</p>

<p>A sub, declared with the <code>sub</code> keyword, adds a new function to your program's capabilities. When you want to use this new function, you call it by name. For instance, here's a short definition of a sub called <code>boo</code>:</p>

<pre><code>use 5.010;

sub boo {
    say 'Boo!';
}

boo();   # Eek!</code></pre>

<p>Subs are useful because they allow you to break your program into small, reusable chunks. If you need to analyze a string in four different places in your program, it's much easier to write one <code>analyze_string</code> sub and call it four times. This way, when you make an improvement to your string-analysis routine, you'll only need to do it in one place, instead of four.</p>

<p>In the same way that Perl's built-in functions can take parameters and can return values, your subs can, too. Whenever you call a sub, any parameters you pass to it appear in the special array <code>@_</code>. You can also return a single value or a list by using the <code>return</code> keyword.</p>

<pre><code>use 5.010;

sub multiply {
    my (@ops) = @_;
    return $ops[0] * $ops[1];
}

for my $i (1 .. 10) {
     say "$i squared is ", multiply($i, $i);
}</code></pre>

<p>There's an interesting benefit from using the the <code>my</code> keyword in <code>multiply</code>? It indicates that the variables are private to that sub, so that any existing value for the <code>@ops</code> array used elsewhere in our program won't get overwritten. This means that you'll evade a whole class of hard-to-trace bugs in your programs. You don't <em>have</em> to use <code>my</code>, but you also don't <em>have</em> to avoid smashing your thumb when you're hammering nails into a board. They're both just good ideas.</p>

<p>You can also assign to multiple lexical variables (declared with <code>my</code>) in a single statement. You can change the code within <code>multiply</code> to something like this without having to modify any other code:</p>

<pre><code>sub multiply {
    my ($left, $right) = @_;
    return $left * $right;
}</code></pre>

<p>If you don't expressly use the <code>return</code> statement, the sub returns the result of the last statement. This implicit return value can sometimes be useful, but it does reduce your program's readability. Remember that you'll read your code many more times than you write it!</p>

<h3>Putting it all together</h3>

<p>The previous article demonstrated a simple interest calculator. You can make it more interesting by writing the interest table to a file instead of to the screen. Another change is to break the code into subs to make it easier to read and maintain.</p>

<p><a href="http://www.perl.com/2000/11/compound_interest_file.pl">[Download this program]</a></p>

<pre><code>#! perl

# compound_interest_file.pl - the miracle of compound interest, part 2

use 5.010;

use strict;
use warnings;

# First, we'll set up the variables we want to use.
my $outfile   = 'interest.txt';    # This is the filename of our report.
my $nest_egg  = 10000;             # $nest_egg is our starting amount
my $year      = 2008;              # This is the starting year for our table.
my $duration  = 10;                # How many years are we saving up?
my $apr       = 9.5;               # This is our annual percentage rate.

my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );

sub open_report {
    my ($outfile) = @_;
    open my $report, '&gt;', $outfile or die "Can't open '$outfile': $!";
    return $report;
}

sub print_headers {
    my ($report_fh) = @_;

    # Print the headers for our report.
    say $report_fh "Year\tBalance\tInterest\tNew balance";
}

sub calculate_interest {
    # Given a nest egg and an APR, how much interest do we collect?
    my ( $nest_egg, $apr ) = @_;

    return int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
}

sub interest_report {
    # Get our parameters.  Note that these variables won't clobber the
    # global variables with the same name.
    my ( $report_fh, $nest_egg, $year, $duration, $apr ) = @_;

    # Calculate interest for each year.
    for my $i ( 1 .. $duration ) {
        my $interest = calculate_interest( $nest_egg, $apr );
        my $line     =
            join "\t", $year + $i, $nest_egg, $interest, $nest_egg + $interest;

        say $report_fh $line;

        $nest_egg += $interest;
    }
}

sub report_footer {
    my ($report_fh, $nest_egg, $duration, $apr) = @_;

    say $report_fh "\n Our original assumptions:";
    say $report_fh "   Nest egg: $nest_egg";
    say $report_fh "   Number of years: $duration";
    say $report_fh "   Interest rate: $apr";
}</code></pre>

<p>Notice how much clearer the program logic becomes when you break it down into subs. One nice quality of a program written as small, well-named subs is that it almost becomes <em>self-documenting</em>. Consider these four lines:</p>

<pre><code>my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );</code></pre>

<p>Code like this is invaluable when you come back to it six months later and need to figure out what it does -- would you rather spend your time reading the entire program trying to figure it out or read four lines that tell you the program 1) opens a report file, 2) prints some headers, 3) generates an interest report, and 4) prints a report footer?</p>

<h3>Play around!</h3>

<p>This article has explored files (filehandles, <code>open()</code>, <code>close()</code>, and <code>&lt;&gt;</code>), string manipulation (<code>substr()</code>, <code>split()</code> and <code>join()</code>) and subs. Here's a pair of exercises -- again, one simple and one complex:</p>

<ul>
<li>You have a file called <em>dictionary.txt</em> that contains dictionary definitions, one per line, in the format "word <code>space</code> definition". (<a href="http://www.perl.com/2000/11/dictionary.txt">Here's a sample</a>.) Write a program that will look up a word from the command line. (Hints: <code>@ARGV</code> is a special array that contains your command line arguments and you'll need to use the three-argument form of <code>split()</code>.) Try to enhance it so that your dictionary can also contain words with multiple definitions in the format "word <code>space</code> definition:alternate definition:alternate definition, etc...".</li>

<li>Write an analyzer for your Apache logs. You can find a brief description of the common log format at <a href="http://www.w3.org/Daemon/User/Config/Logging.html">http://www.w3.org/Daemon/User/Config/Logging.html</a>. Your analyzer should count the total number of requests for each URL, the total number of results for each status code and the total number of bytes output.</li>
</ul>

<p>Happy programming!</p>










        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-646" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/04/23/a-beginners-introduction-to-perl-510.html" rel="bookmark">A Beginner's Introduction to Perl 5.10</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">chromatic</span> on <abbr class="published" title="2008-04-23T00:00:00-08:00">April 23, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<h3>First, a Little Sales Pitch</h3>

<p><em>Editor's note: this series is based on <a href="http://www.perl.com/pub/au/Sheppard_Doug">Doug Sheppard's</a> <a href="http://www.perl.com/pub/a/2000/10/begperl1.html">Beginner's Introduction to Perl</a></em>.  <a href="http://www.perl.com/pub/a/2008/05/07/beginners-introduction-to-perl-510-part-2.html">A Beginner's Introduction to Files and Strings with Perl 5.10</a> explains how to use files and strings, and <a href="http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Regular Expressions with Perl 5.10</a> explores regular expressions, matching, and substitutions.  <a href="http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html">A Beginner's Introduction to Perl Web Programming</a> demonstrates how to write web programs.</p>

<p>Welcome to Perl.</p>

<p>Perl is the Swiss Army chainsaw of programming languages: powerful and adaptable. It was first developed by Larry Wall, a linguist working as a systems administrator for NASA in the late 1980s, as a way to make report processing easier. Since then, it has moved into a several other areas: automating system administration, acting as glue between different computer systems, web programming, bioinformatics, data munging, and even application development.</p>

<p>Why did Perl become so popular when the Web came along? Two reasons: First, most of what is being done on the Web happens with text, and is best done with a language that's designed for text processing. More importantly, Perl was appreciably better than the alternatives at the time when people needed something to use. C is complex and can produce security problems (especially with untrusted data), Tcl can be awkward, and Python didn't really have a foothold.</p>

<p>It also didn't hurt that Perl is a friendly language. It plays well with your personal programming style. The Perl slogan is "There's more than one way to do it," and that lends itself well to large and small problems alike. Even more so, Perl is very portable and widespread -- it's available pre-installed almost everywhere -- and of course there are thousands of freely-distributable libraries available from the <a href="http://www.cpan.org/">CPAN</a>.</p>

<p>In this first part of our series, you'll learn a few basics about Perl and see a small sample program.</p>

<h3>A Word About Operating Systems</h3>

<p>This series assumes that you're using a Unix or Unix-like operating system (Mac OS X and Cygwin qualify) and that you have the <code>perl</code> binary available at <em>/usr/bin/perl</em>. It's OK if you're running Windows through ActivePerl or Strawberry Perl; most Perl code is platform-independent.</p>

<h3>Your First Perl Program</h3>

<p>Save this program as a file called <em>first.pl</em>:</p>

<pre><code>use feature ':5.10';
say "Hi there!";</code></pre>

<p>(The traditional first program says <code>Hello world!</code>, but I'm an iconoclast.)</p>

<p>Run the program. From a command line, go to the directory with this file and type <code>perl first.pl</code>. You should see:</p>

<pre><code>Hi there!</code></pre>

<p>Friendly, isn't it?</p>

<p>I'm sure you can guess what <code>say</code> does. What about the <code>use feature ':5.10';</code> line? For now, all you need to know is that it allows you to use nice new features found in Perl 5.10. This is a very good thing.</p>

<h3>Functions and Statements</h3>

<p>Perl has a rich library of built-in <em>functions</em>. They're the verbs of Perl, the commands that the interpreter runs. You can see a list of all the built-in functions in the <a href="http://perldoc.perl.org/index-functions.html">perlfunc</a> man page (<code>perldoc perlfunc</code>, from the command line). Almost all functions can take a list of commma-separated <em>parameters</em>.</p>

<p>The <code>print</code> function is one of the most frequently used parts of Perl. You use it to display things on the screen or to send information to a file. It takes a list of things to output as its parameters.</p>

<pre><code>print "This is a single statement.";
print "Look, ", "a ", "list!";</code></pre>

<p>A Perl program consists of <em>statements</em>, each of which ends with a semicolon. Statements don't need to be on separate lines; there may be multiple statements on one line. You can also split a single statement across multiple lines.</p>

<pre><code>print "This is "; print "two statements.\n";
print "But this ", "is only one statement.\n";</code></pre>

<p>Wait a minute though. What's the difference between <code>say</code> and <code>print</code>? What's this <code>\n</code> in the <code>print</code> statements?</p>

<p>The <code>say</code> function behaves just like the <code>print</code> function, except that it appends a newline at the end of its arguments. It prints all of its arguments, and then a newline character. Always. No exceptions. <code>print</code>, on the other hand, only prints what you see explicitly in these examples. If you want a newline, you have to add it yourself with the special character escape sequence <code>\n</code>.</p>

<pre><code>use feature ':5.10';

say "This is a single statement.";
say "Look, ", "a ", "list!";</code></pre>

<p>Why do both exist? Why would you use one over the other? Usually, most "display something" statements need the newline. It's common enough that <code>say</code> is a good default choice. Occasionally you need a little bit more control over your output, so <code>print</code> is the option.</p>

<p>Note that <code>say</code> is two characters shorter than <code>print</code>. This is an important design principle for Perl -- common things should be easy and simple.</p>

<h3>Numbers, Strings, and Quotes</h3>

<p>There are two basic data types in Perl: numbers and strings.</p>

<p>Numbers are easy; we've all dealt with them. The only thing you need to know is that you never insert commas or spaces into numbers in Perl. Always write 10000, not 10,000 or 10 000.</p>

<p>Strings are a bit more complex. A string is a collection of characters in either single or double quotes:</p>

<pre><code>'This is a test.'
"Hi there!\n"</code></pre>

<p>The difference between single quotes and double quotes is that single quotes mean that their contents should be taken <em>literally</em>, while double quotes mean that their contents should be <em>interpreted</em>. Remember the character sequence <code>\n</code>? It represents a newline character when it appears in a string with double quotes, but is literally the two characters backslash and <code>n</code> when it appears in single quotes.</p>

<pre><code>use feature ':5.10';
say "This string\nshows up on two lines.";
say 'This string \n shows up on only one.';</code></pre>

<p>(Two other useful backslash sequences are <code>\t</code> to insert a tab character, and <code>\\</code> to insert a backslash into a double-quoted string.)</p>













<h3>Variables</h3>

<p>If functions are Perl's verbs, then variables are its nouns. Perl has three types of variables: <em>scalars</em>, <em>arrays</em>, and <em>hashes</em>. Think of them as things, lists, and dictionaries respectively. In Perl, all variable names consist of a punctuation character, a letter or underscore, and one or more alphanumeric characters or underscores.</p>

<p><em>Scalars</em> are single things. This might be a number or a string. The name of a scalar begins with a dollar sign, such as <code>$i</code> or <code>$abacus</code>. Assign a value to a scalar by telling Perl what it equals:</p>

<pre><code>my $i                = 5;
my $pie_flavor       = 'apple';
my $constitution1776 = "We the People, etc.";</code></pre>

<p>You don't need to specify whether a scalar is a number or a string. It doesn't matter, because when Perl needs to treat a scalar as a string, it does; when it needs to treat it as a number, it does. The conversion happens automatically. (This is different from many other languages, where strings and numbers are two separate data types.)</p>

<p>If you use a double-quoted string, Perl will insert the value of any scalar variables you name in the string. This is often useful to fill in strings on the fly:</p>

<pre><code>use feature ':5.10';
my $apple_count  = 5;
my $count_report = "There are $apple_count apples.";
say "The report is: $count_report";</code></pre>

<p>The final output from this code is <code>The report is: There are 5 apples.</code>.</p>

<p>You can manipulate numbers in Perl with the usual mathematical operations: addition, multiplication, division, and subtraction. (The multiplication and division operators in Perl use the <code>*</code> and <code>/</code> symbols, by the way.)</p>

<pre><code>my $a = 5;
my $b = $a + 10;       # $b is now equal to 15.
my $c = $b * 10;       # $c is now equal to 150.
$a    = $a - 1;        # $a is now 4, and algebra teachers are cringing.</code></pre>

<p>That's all well and good, but what's this strange <code>my</code>, and why does it appear with some assignments and not others? The <code>my</code> operator tells Perl that you're <em>declaring</em> a new variable. That is, you promise Perl that you deliberately want to use a scalar, array, or hash of a specific name in your program. This is important for two reasons. First, it helps Perl help you protect against typos; it's embarrassing to discover that you've accidentally mistyped a variable name and spent an hour looking for a bug. Second, it helps you write larger programs, where variables used in one part of the code don't accidentally affect variables used elsewhere.</p>

<p>You can also use special operators like <code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code>. These manipulate a scalar's value without needing two elements in an equation. Some people like them, some don't. I like the fact that they can make code clearer.</p>

<pre><code>my $a = 5;
$a++;        # $a is now 6; we added 1 to it.
$a += 10;    # Now it's 16; we added 10.
$a /= 2;     # And divided it by 2, so it's 8.</code></pre>

<p>Strings in Perl don't have quite as much flexibility. About the only basic operator that you can use on strings is <em>concatenation</em>, which is a ten dollar way of saying "put together." The concatenation operator is the period. Concatenation and addition are two different things:</p>

<pre><code>my $a = "8";    # Note the quotes.  $a is a string.
my $b = $a + "1";   # "1" is a string too.
my $c = $a . "1";   # But $b and $c have different values!</code></pre>

<p>Remember that Perl converts strings to numbers transparently whenever necessary, so to get the value of <code>$b</code>, the Perl interpreter converted the two strings <code>"8"</code> and <code>"1"</code> to numbers, then added them. The value of <code>$b</code> is the number 9. However, <code>$c</code> used concatenation, so its value is the string <code>"81"</code>.</p>

<p>Remember, the plus sign <em>adds numbers</em> and the period <em>puts strings together</em>. If you add things that aren't numbers, Perl will try its best to do what you've told it to do, and will convert those non-numbers to numbers with the best of its ability.</p>

<p><em>Arrays</em> are lists of scalars. Array names begin with <code>@</code>. You define arrays by listing their contents in parentheses, separated by commas:</p>

<pre><code>my @lotto_numbers = (1, 2, 3, 4, 5, 6);  # Hey, it could happen.
my @months        = ("July", "August", "September");</code></pre>

<p>You retrieve the contents of an array by an <em>index</em>, sort of like "Hey, give me the first month of the year." Indexes in Perl start from zero. (Why not 1? Because. It's a computer thing.) To retrieve the elements of an array, you replace the <code>@</code> sign with a <code>$</code> sign, and follow that with the index position of the element you want. (It begins with a dollar sign because you're getting a scalar value.) You can also modify it in place, just like any other scalar.</p>

<pre><code>use feature ':5.10';

my @months = ("July", "August", "September");
say $months[0];         # This prints "July".
$months[2] = "Smarch";  # We just renamed September!</code></pre>

<p>If an array value doesn't exist, Perl will create it for you when you assign to it.</p>

<pre><code>my @winter_months = ("December", "January");
$winter_months[2] = "February";</code></pre>

<p>Arrays always return their contents in the same order; if you go through <code>@months</code> from beginning to end, no matter how many times you do it, you'll get back <code>July</code>, <code>August</code>, and <code>September</code> in that order. If you want to find the number of elements of an array, assign the array to a scalar.</p>

<pre><code>use feature ':5.10';
my @months      = ("July", "August", "September");
my $month_count = @months;
say $month_count;  # This prints 3.

my @autumn_months; # no elements
my $autumn_count = @autumn_months;
say $autumn_count; # this prints 0</code></pre>

<p>Some programming languages call <em>hashes</em> "dictionaries". That's what they are: a term and a definition. More precisely, they contain <em>keys</em> and <em>values</em>. Each key in a hash has one and only one corresponding value. The name of a hash begins with a percentage sign, like <code>%parents</code>. You define hashes by comma-separated pairs of key and value, like so:</p>

<pre><code>my %days_in_month = ( "July" =&gt; 31, "August" =&gt; 31, "September" =&gt; 30 );</code></pre>

<p>You can fetch any value from a hash by referring to <code>$hashname{key}</code>, or modify it in place just like any other scalar.</p>

<pre><code>say $days_in_month{September}; # 30, of course.
$days_in_month{February} = 29; # It's a leap year.</code></pre>

<p>To see what keys are in a hash, use the <code>keys</code> function with the name of the hash. This returns a list containing all of the keys in the hash. The list isn't always in the same order, though; while you can count on <code>@months</code> always to return <code>July</code>, <code>August</code>, <code>September</code> in that order, <code>keys %days_in_summer</code> might return them in any order whatsoever.</p>

<pre><code>my @month_list = keys %days_in_summer;
# @month_list is now ('July', 'September', 'August')!</code></pre>

<p>The three types of variables have three separate <em>namespaces</em>. That means that <code>$abacus</code> and <code>@abacus</code> are two different variables, and <code>$abacus[0]</code> (the first element of <code>@abacus</code>) is not the same as <code>$abacus{0}</code> (the value in <code>%abacus</code> that has the key <code>0</code>).</p>

<h3>Comments</h3>

<p>Some of the code samples from the previous section contained code comments. These are useful for explaining what a particular piece of code does, and vital for any piece of code you plan to modify, enhance, fix, or just look at again. (That is to say, comments are important.)</p>

<p>Anything in a line of Perl code that follows a <code>#</code> sign is a comment, unless that <code>#</code> sign appears in a string.)</p>

<pre><code>use feature ':5.10';
say "Hello world!";  # That's more like it.
# This entire line is a comment.</code></pre>

<h3>Loops</h3>

<p>Almost every program ever written uses a <em>loop</em> of some kind. Loops allow you run a particular piece of code over and over again. This is part of a general concept in programming called <em>flow control</em>.</p>

<p>Perl has several different functions that are useful for flow control, the most basic of which is <code>for</code>. When you use the <code>for</code> function, you specify a variable to use as the <em>loop index</em>, and a list of values to loop over. Inside a pair of curly brackets, you put any code you want to run during the loop:</p>

<pre><code>use feature ':5.10';

for my $i (1, 2, 3, 4, 5) {
     say $i;
}</code></pre>

<p>This loop prints the numbers 1 through 5, each on a separate line. (It's not
very useful; you're might think "Why not just write <code>say 1, 2, 3, 4,
5;</code>?".  This is because <code>say</code> adds only one newline, at the
end of its list of arguments.)</p>

<p>A handy shortcut for defining loop values is the <em>range</em> operator <code>..</code>, which specifies a range of numbers. You can write <code>(1, 2, 3, 4, 5)</code> as <code>(1 .. 5)</code> instead. You can also use arrays and scalars in your loop list. Try this code and see what happens:</p>

<pre><code>use feature ':5.10';

my @one_to_ten = (1 .. 10);
my $top_limit  = 25;

for my $i (@one_to_ten, 15, 20 .. $top_limit) {
    say $i;
}</code></pre>

<p>Of course, again you could write <code>say @one_to_ten, 15, 20 .. $top_limit;</code></p>

<p>The items in your loop list don't have to be numbers; you can use strings just as easily. If the hash <code>%month</code>_has contains names of months and the number of days in each month, you can use the <code>keys</code> function to step through them.</p>

<pre><code>use feature ':5.10';

for my $i (keys %month_has) {
    say "$i has $month_has{$i} days.";
}

for my $marx ('Groucho', 'Harpo', 'Zeppo', 'Karl') {
    say "$marx is my favorite Marx brother.";
}</code></pre>

<h3>The Miracle of Compound Interest</h3>

<p>You now know enough about Perl -- variables, <code>print</code>/<code>say</code>, and <code>for()</code> -- to write a small, useful program. Everyone loves money, so the first sample program is a compound-interest calculator. It will print a (somewhat) nicely formatted table showing the value of an investment over a number of years. (You can see the program at <a href="/2008/04/23/compound_interest.pl"><code>compound_interest.pl</code></a>)</p>

<p>The single most complex line in the program is:</p>

<pre><code>my $interest = int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;</code></pre>

<p><code>$apr / 100</code> is the interest rate, and <code>($apr / 100) * $nest_egg</code> is the amount of interest earned in one year. This line uses the <code>int()</code> function, which returns the integer value of a scalar (its value after any stripping off any fractional part). We use <code>int()</code> here because when you multiply, for example, 10925 by 9.25%, the result is 1010.5625, which we must round off to 1010.56. To do this, we multiply by 100, yielding 101056.25, use <code>int()</code> to throw away the leftover fraction, yielding 101056, and then divide by 100 again, so that the final result is 1010.56. Try stepping through this statement yourself to see just how we end up with the correct result, rounded to cents.</p>

<h3>Play Around!</h3>

<p>At this point you have some basic knowledge of Perl syntax and a few simple toys to play with. Try writing some simple programs with them. Here are two suggestions, one simple and the other a little more complex:</p>

<ul>
<li>A word frequency counter. How often does each word show up in an array of words? Print out a report. (Hint: Use a hash to count of the number of appearances of each word.)</li>

<li>Given a month and the day of the week that's the first of that month, print a calendar for the month.</li>
</ul>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-644" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/04/08/using-amazon-s3-from-perl.html" rel="bookmark">Using Amazon S3 from Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Abel Lin</span> on <abbr class="published" title="2008-04-08T00:00:00-08:00">April  8, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Data management is a critical and challenging aspect for any online resource. With exponentially growing data sizes and popularity of rich media, even small online resources must effectively manage and distribute a significant amount of data. Moreover, the peace of mind associated with an additional offsite data storage resource is invaluable to everyone involved.</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a>, we manage a growing inventory of GPS and general GIS (Geography Information Systems) data and web content (text, images, videos, etc.) for the end users. In addition, we must also effectively manage daily snapshots, backups, as well as multiple development versions of our web site and supporting software. For any small organization, this can add up to significant costs -- not only as an initial monetary investment but also in terms of ongoing labor costs for maintenance and administration.</p>

<p>Amazon Simple Storage Service (S3) was released specifically to address the problem of data management for online resources -- with the aim to provide "reliable, fast, inexpensive data storage infrastructure that Amazon uses to run its own global network of web sites." Amazon S3 provides a web service interface that allows developers to store and retrieve any amount of data. S3 is attractive to companies like SundayMorningRides.com as it frees us from upfront costs and the ongoing costs of purchasing, administration, maintenance, and scaling our own storage servers.</p>

<p>This article covers the Perl, REST, and the Amazon S3 REST module, walking through the development of a collection of Perl-based tools for UNIX command-line based interaction to Amazon S3. I'll also show how to set access permissions so that you can serve images or other data directly to your site from Amazon S3.</p>

<h4>A Bit on Web Services</h4>

<p>Web services have become the de-facto method of exposing information and, well, services via the Web. Intrinsically, web services provide a means of interaction between two networked resources. Amazon S3 is accessible via both Simple Object Access Protocol (SOAP) or representational state transfer (REST).</p>

<p>The SOAP interface organizes features into custom-built operations, similar to remote objects when using Java Remote Method Invocation (RMI) or Common Object Resource Broker Architecture (CORBA). Unlike RMI or CORBA, SOAP uses XML embedded in the body of HTTP requests as the application protocol.</p>

<p>Like SOAP, REST also uses HTTP for transport. Unlike SOAP, REST operations are the standard HTTP operations -- GET, POST, PUT, and DELETE. I think of REST operations in terms of the CRUD semantics associated with relational databases: POST is Create, GET is Retrieve, PUT is Update, and DELETE is Delete.</p>

<h4>"Storage for the Internet"</h4>

<p>Amazon S3 represents the data space in three core concepts: <em>objects</em>, <em>buckets</em>, and <em>keys</em>.</p>

<ul>
<li>Objects are the base level entities within Amazon S3. They consist of both object data and metadata. This metadata is a set of name-attribute pairs defined in the HTTP header.</li>

<li>Buckets are collections of objects. There is no limit to the number of objects in a bucket, but each developer is limited to 100 buckets.</li>

<li>Keys are unique identifiers for objects.</li>
</ul>

<p>Without wading through the details, I tend think of buckets as folders, objects as files, and keys as filenames. The purpose of this abstraction is to create a unique HTTP namespace for every object.</p>

<p>I'll assume that you have already signed up for <a href="http://aws.amazon.com/s3">Amazon S3</a> and received your Access Key ID and Secret Access Key. If not, please do so.</p>

<p>Please note that the <code>S3::*</code> modules aren't the only Perl modules available for connecting to Amazon S3.  In particular, <a href="http://search.cpan.org/perldoc?Net::Amazon::S3">Net::Amazon::S3</a> hides a lot of the details of the S3 service for you.  For now, I'm going to use a simpler module to explain how the service works internally.</p>

<h4>Connecting, Creating, and Listing Buckets</h4>

<p>Connecting to Amazon S3 is as simple as supplying your Access Key ID and your Secret Access Key to create a connection, called here <code>$conn</code>. Here's how to create and list the contents of a bucket as well as list all buckets.</p>

<pre><code>#!/usr/bin/perl

use S3::AWSAuthConnection;
use S3::QueryStringAuthGenerator;

use Data::Dumper;

my $AWS_ACCESS_KEY_ID     = 'YOUR ACCESS KEY';
my $AWS_SECRET_ACCESS_KEY = 'YOUR SECRET KEY';

my $conn = S3::AWSAuthConnection-&gt;new($AWS_ACCESS_KEY_ID,
                                      $AWS_SECRET_ACCESS_KEY);

my $BUCKET = "foo";

print "creating bucket $BUCKET \n";
print $conn-&gt;create_bucket($BUCKET)-&gt;message, "\n";

print "listing bucket $BUCKET \n";
print Dumper @{$conn-&gt;list_bucket($BUCKET)-&gt;entries}, "\n";

print "listing all my buckets \n";
print Dumper @{$conn-&gt;list_all_my_buckets()-&gt;entries}, "\n";</code></pre>

<p>Because every S3 action takes place over HTTP, it is good practice to check for a 200 response.</p>

<pre><code>my $response = $conn-&gt;create_bucket($BUCKET);
if ($response-&gt;http_response-&gt;code == 200) {
    # Good
} else {
    # Not Good
}</code></pre>

<p>As you can see from the output, the results come back in a hash. I've used <a href="http://search.cpan.org/perldoc?Data::Dumper">Data::Dumper</a> as a convenient way to view the contents. If you are running this for the first time, you will obviously not see anything listed in the bucket.</p>

<pre><code>listing bucket foo
$VAR1 = {
          'Owner' =&gt; {
                     'ID' =&gt; 'xxxxx',
                     'DisplayName' =&gt; 'xxxxx'
                   },
          'Size' =&gt; '66810',
          'ETag' =&gt; '"xxxxx"',
          'StorageClass' =&gt; 'STANDARD',
          'Key' =&gt; 'key',
          'LastModified' =&gt; '2007-12-18T22:08:09.000Z'
        };
$VAR4 = '
';
listing all my buckets
$VAR1 = {
          'CreationDate' =&gt; '2007-11-28T17:31:48.000Z',
          'Name' =&gt; 'foo'
        };
';</code></pre>













<h4>Writing an Object</h4>

<p>Writing an object is simply a matter of using the HTTP PUT method. Be aware that there is nothing to prevent you from overwriting an existing object; Amazon S3 will automatically update the object with the more recent write request. Also, it's currently not possible to append to or otherwise modify an object in place without replacing it.</p>

<pre><code>my %headers = (
    'Content-Type' =&gt; 'text/plain'
);
$response = $conn-&gt;put( $BUCKET, $KEY, S3Object-&gt;new("this is a test"),
                        \%headers);</code></pre>

<p>Likewise, you can read a file from STDIN:</p>

<pre><code>my %headers;

FILE: while(1) {
    my $n = sysread(STDIN, $data, 1024 * 1024, length($data));
    if ($n &lt; 0) {
        print STDERR "Error reading input: $!\n";
        exit 1;
    }
    last FILE if $n == 0;
}
$response = $conn-&gt;put("$BUCKET", "$KEY", $data, \%headers);</code></pre>

<p>To add custom metadata, simply add to the <code>S3Object</code>:</p>

<pre><code>S3Object-&gt;new("this is a test", { name =&gt; "attribute" })</code></pre>

<p>By default, every object has private access control when written. This allows only the user that stored the object to read it back. You can change these settings. Also, note that each object can hold a maximum of 5 GB of data.</p>

<p>You are probably wondering if it is also possible to upload via a standard HTTP POST. The folks at Amazon are working on it as we speak -- see <a href="http://developer.amazonwebservices.com/connect/thread.jspa?threadID=18616&amp;tstart=0">HTTP POST beta discussion</a> for more information. Until that's finished, you'll have to perform web-based uploads via an intermediate server.</p>

<h4>Reading an Object</h4>

<p>Like writing objects, there are several ways to read data from Amazon S3. One way is to generate a temporary URL to use with your favorite client (for example, wget or Curl) or even a browser to view or retrieve the object. All you have to do is generate the URL used to make the REST call.</p>

<pre><code>my $generator = S3::QueryStringAuthGenerator-&gt;new($AWS_ACCESS_KEY_ID,
    $AWS_SECRET_ACCESS_KEY);</code></pre>

<p>...and then perform a simple HTTP GET request. This is a great trick if all you want to do is temporarily view or verify the data.</p>

<pre><code>$generator-&gt;expires_in(60);
my $url = $generator-&gt;get($BUCKET, "$KEY");
print "$url \n";</code></pre>

<p>You can also programmatically read the data directly from the initial connection. This is handy if you have to perform additional processing of the data.</p>

<pre><code>my $response = $conn-&gt;get("$BUCKET", "$KEY");
my $data     = $response-&gt;object-&gt;data;</code></pre>

<p>Another cool feature is <a href="http://docs.amazonwebservices.com/AmazonS3/2006-03-01/">the ability to use BitTorrent to download files from Amazon S3</a> . You can access any object that has anonymous access privileges via BitTorrent.</p>

<h4>Delete an Object</h4>

<p>By now you probably have the hang of the process. If you're going to create objects, you're probably going to have to delete them at some point.</p>

<pre><code>$conn-&gt;delete("$BUCKET", "$KEY");</code></pre>

<h4>Set Access Permissions and Publish to a Website</h4>

<p>As you may have noticed from the previous examples, all Amazon S3 objects access goes through HTTP. This makes Amazon S3 particularly useful as a online repository. In particular, it's useful to manage and serve website media. You could almost imagine Amazon S3 serving as mini Content Delivery Network for media on your website. This example will demonstrate how to build a very simple online page where the images are served dynamically via Amazon S3.</p>

<p>The first thing to do us to upload some images and set the ACL permissions to public. I've modified the previous example with one difference. To make objects publicly readable, include the header <code>x-amz-acl: public-read</code> with the HTTP PUT request.</p>

<pre><code>my %headers = (
    'x-amz-acl' =&gt; 'public-read',
);</code></pre>

<p>Additional ACL permissions include:</p>

<ul>
<li>private (default setting if left blank)</li>

<li>public-read</li>

<li>public-read-write</li>

<li>authenticated-read</li>
</ul>

<p>Now you know enough to put together a small script that will automatically display all images in the bucket to a web page (you'll probably want to spruce up the formatting).</p>

<pre><code>...
my $BUCKET   = "foobar";
my $response = $conn-&gt;list_bucket("$BUCKET");

for my $entry (@{$response-&gt;entries}) {
    my $public_url   = $generator-&gt;get($BUCKET, $entry-&gt;{Key});
    my ($url, undef) = split (/\?/, $public_url);
    $images         .= "&lt;img src=\"$url\"&gt;&lt;br /&gt;";
}
($webpage =  &lt;&lt;"WEBPAGE");
&lt;html&gt;&lt;body&gt;$images&lt;/body&gt;&lt;/html&gt;
WEBPAGE
print $q-&gt;header();
print $webpage;</code></pre>

<p>To add images to this web page, upload more files into the bucket and they will automatically appear the next time you load the page.</p>

<p>It's also simple to link to media one at a time for a webpage. If you examine the HTML generated by this example, you'll see that all Amazon S3 URLs have the basic form <code>http://<em>bucketname</em>.s3.amazon.com/<em>objectname</em></code>. Also note that the namespace for buckets is shared with all Amazon S3 users. You may have already picked up on this.</p>

<h3>Conclusion</h3>

<p>Amazon S3 is a great tool that can help with the data management needs of all sized organizations by offering cheap and unlimited storage. For personal use, it's a great tool for backups (also good for organizations) and general file storage. It's also a great tool for collaboration. Instead of emailing files around, just upload a file and set the proper access controls -- no more dealing with 10 MB attachment restrictions!</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a> we use S3 as part of our web serving infrastructure to reduce the load on our hardware when serving media content.</p>

<p>When combined with other Amazon Web Services such as SimpleDB (for structured data queries) and Elastic Compute Cloud (for data processing) it's easy to envision a low cost solution for web-scale computing and data management.</p>

<h4>More Resources and References</h4>

<ul>
<li><a href="http://aws.amazon.com/s3">Amazon S3 Homepage</a>
</li>

<li><a href="http://developer.amazonwebservices.com/">Amazon Webservices Developer Connection</a>
</li>

<li><a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=133&amp;categoryID=47">Amazon S3 Library for REST in Perl</a>
</li>

<li><a href="http://aws.typepad.com/">Amazon Web Services Blog</a>
</li>
</ul>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-642" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/03/14/reverse-callback-templating.html" rel="bookmark">Reverse Callback Templating</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">James Robson</span> on <abbr class="published" title="2008-03-14T00:00:00-08:00">March 14, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Programmers have long recognized that separating code logic from presentation is good. The Perl community has produced many fine systems for doing just this. While there are many systems, they largely fall within two execution models, <em>pipeline</em> and <em>callback</em> (as noted by Perrin Harkins in <a href="http://www.perl.com/pub/a/2001/08/21/templating.html">Choosing a Templating System</a>). <a href="http://search.cpan.org/perldoc?HTML::Template">HTML::Template</a> and <a href="http://www.template-toolkit.org/">Template Toolkit</a> are in the pipeline category. Their templates consist of simple presentation logic in the form of loops and conditionals and template variables. The Perl program does its work, then loads and renders the appropriate template, as if data were flowing through a pipeline. <a href="http://www.masonhq.com/">Mason</a> and <a href="http://perl.apache.org/embperl/">Embperl</a> fall into the callback category. They mix code in with the template markup, and the template "calls back" to Perl when it encounters program logic.</p>

<p>A third execution model exists: the <em>reverse callback</em> model. Template and code files are separate, just like in the pipeline approach. Instead of using a mini-language to handle display logic, however, the template consists of named sections. Perl executes and calls a specific section of the template at the appropriate time, rendering it. Effectively, this is the opposite of the callback method, which wraps Perl logic around portions (or sections) of a template in a single file. Reverse callback uses Perl statements to load, or call, specific portions of the the template. This approach has a few distinct advantages.</p>

<h3>A Reverse Callback Example</h3>

<p>Suppose that you have a simple data structure you are dying to output as pretty HTML.</p>

<pre><code>my @goods = (
    "oxfords,Brown leather,\$85,0",
    "hiking,All sizes,\$55,7",
    "tennis shoes,Women's sizes,\$35,15",
    "flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>First, you need an HTML template with the appropriate sections defined. Sections are of vital importance; they enable <code>Template::Recall</code> to keep the logic squarely in the code. <code>Template::Recall</code> uses the default pattern <code>/[\s*=+\s*\w+\s*=+\s*]/</code> (to match, for example, <code>[==== section_name ====]</code>) to determine sections in a single file. The start of one section denotes the end of another. This is because <code>Template::Recall</code> uses a <code>split()</code> operation based on the above regex, saving the <code>\w+</code> as the section key in an internal data structure.</p>

<pre><code>[ =================== header ===================]

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;my site - [' title ']&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h4&gt;The date is [' date ']&lt;/h4&gt;



&lt;table border="1"&gt;

    &lt;tr&gt;
        &lt;th&gt;Shoe&lt;/th&gt;
        &lt;th&gt;Details&lt;/th&gt;
        &lt;th&gt;Price&lt;/th&gt;
        &lt;th&gt;Quantity&lt;/th&gt;
    &lt;/tr&gt;

[ =================== product_row =================== ]
    &lt;tr&gt;
        &lt;td&gt;[' shoe ']&lt;/td&gt;
        &lt;td&gt;[' details ']&lt;/td&gt;
        &lt;td&gt;[' price ']&lt;/td&gt;
        &lt;td&gt;[' quantity ']&lt;/td&gt;
    &lt;/tr&gt;


[= footer =]
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This template is quite simple. It has three sections, a "header," "product_row," and "footer." The sections essentially give away how the program logic is going to work. A driver program would call header and footer only once during program execution (start and end, respectively). product_row will be called multiple times during iteration over an array.</p>

<p>Names contained within the delimeters <code>['</code> and <code>']</code> are template variables for replacement during rendering. For example, <code>[' date ']</code> will be replaced by the current date when the program executes.</p>

<p>The driver code must first instantiate a new Template::Recall object, <code>$tr</code>, and pass it the path of the template, which I've saved as the file <em>template1.html</em>.</p>

<pre><code>use Template::Recall;

my $tr = Template::Recall-&gt;new( template_path =&gt; 'template1.html');</code></pre>

<p>With <code>$tr</code> created, the template sections are loaded and ready for use. The obvious first step is to render the header section with the <code>render()</code> method. <code>render()</code> takes the name of the section to process, and optionally, a hash of names and values to replace in that section. There are two template variables in the header section, <code>[' title ']</code> and <code>[' date ']</code>, so the call looks like:</p>

<pre><code>print $tr-&gt;render( 'header', { title =&gt; 'MyStore', date =&gt; scalar(localtime) } );</code></pre>

<p>The names used in the hash must match the names of the template variables in the section you intend to render. For example, <code>date =&gt; scalar(localtime)</code> means that <code>[' date ']</code> in the header section will be dynamically replaced by the value produced by <code>scalar(localtime)</code>.</p>

<p>You probably noticed from the template that the header section created the start of an HTML table. This is a fine time to render <code>@goods</code> as the table's rows.</p>

<pre><code>for my $good (@goods)
{
    my @attr     = split(/,/, $good);
    my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];

    my %row      = (
        shoe     =&gt; $attr[0],
        details  =&gt; $attr[1],
        price    =&gt; $attr[2],
        quantity =&gt; $quantity,
    );

    print $tr-&gt;render('product_row', \%row);
}</code></pre>

<p>In actual code, this array would likely come from a database. For each row, the driver makes necessary logical decisions (such as displaying "Out of stock" if the quantity equals "0"), then calls <code>$tr-&gt;render()</code> to replace the placeholders in the template section with the values from <code>%row</code>.</p>

<p>Finally, the driver renders the footer of the HTML output. There are no template variables to replace, so there's no need to pass in a hash.</p>

<pre><code>print $tr-&gt;render('footer');</code></pre>

<p>The result is this nice little output of footwear inventory:</p>

<h4>The date is Fri Aug 10 14:22:30 2007</h4>

<table>
<tr>
<th>Shoe</th>
<th>Details</th>
<th>Price</th>
<th>Quantity</th>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>
</table>

<h3>The Logic Is in the Code</h3>

<p>What happens if you extend your shoe data slightly, to add categories? For instance, what if <code>@goods</code> looks like:</p>

<pre><code>my @goods = (
    "dress,oxfords,Brown leather,\$85,0",
    "sports,hiking,All sizes,\$55,7",
    "sports,tennis shoes,Women's sizes,\$35,15",
    "recreation,flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>The output now needs grouping, which implies the use of nested loops. One loop can output the category header -- sports, dress, or recreation shoes -- and another will output the details of each shoe in that category.</p>

<p>To handle this in HTML::Template, you would generally build a nested data structure of anonymous arrays and hashes, and then process it against nested <code>&lt;TMPL_LOOP&gt;</code> directives in the template. Template::Recall logic remains in the code, you would build a nested loop structure in Perl that calls the appropriate sections. You can also use a hash to render the category sections as keys and detail sections as values in a single pass, and output them together using <code>join</code>.</p>

<p>The template needs some modification:</p>

<pre><code>[====== table_start ====]
&lt;table border="1"&gt;
[====== category =======]
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;b&gt;['category']&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
[====== detail ======]
&lt;tr&gt;&lt;td&gt;['shoe']&lt;/td&gt;&lt;td&gt;['detail']&lt;/td&gt;&lt;td&gt;['price']&lt;/td&gt;&lt;td&gt;['quantity']&lt;/td&gt;&lt;/tr&gt;
[======= table_end ====]
&lt;/table&gt;</code></pre>

<p>This template now has a section called "category," a single table row that spans all columns. The "detail" section is pretty much the same as in the previous.</p>

<pre><code>my %inventory;

for my $good (@goods) {
    my @attr = split(/,/, $good);
    my $q    = $attr[4] == 0 ? 'Out of stock' : $attr[4];

    $inventory{ $tr-&gt;render('category', { category =&gt; $attr[0] } ) } .=
        $tr-&gt;render('detail',
            {
                shoe     =&gt; $attr[1],
                detail   =&gt; $attr[2],
                price    =&gt; $attr[3],
                quantity =&gt; $q,
            } );
}

print $tr-&gt;render('table_start') .
    join('', %inventory) .
    $tr-&gt;render('table_end');</code></pre>

<p>This loop looks surprisingly similar to the first example, doesn't it? That's because it is. Instead of printing each row, however, this code renders the first column in <code>@goods</code> against the category template section, and then storing the output as a key in <code>%inventory</code>. In the same iteration, it renders the remaining columns against the detail section and appends to the value of that key.</p>

<p>After storing the rendered sections in this way to <code>%inventory</code>, the code prints everything with a single statement, using <code>join</code> to print all the values in <code>%inventory</code>, including keys. The output is:</p>

<table>
<tr>
<td><strong>recreation</strong>
</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>

<tr>
<td><strong>sports</strong>
</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td><strong>dress</strong>
</td>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>
</table>

<p>The code also handles conditional output. Suppose that at your growing online shoe emporium you provide special deals to customers who have bought over a certain dollar amount. As they browse your shoe inventory, these deals appear.</p>

<pre><code>if ( $customer-&gt;is_elite ) {
    print $tr-&gt;render('special_deals', get_deals('elite') );
}
else {
    print $tr-&gt;render('standard_deals', get_deals() );
}</code></pre>

<p>What about producing XML output? This usually requires a separate template? You can conditionally load a <em>.xml</em> or <em>.html</em> template:</p>

<pre><code>my $tr;
if ( $q-&gt;param('fmt') eq 'xml' ) {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.xml' );
}
else {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.html' );
}</code></pre>

<p>Perl provides everything you need to handle model, controller, <em>and</em> view logic. Template::Recall capitalizes on this and helps to make projects code driven.</p>

<h3>Template Model Comparison</h3>

<p>It's important to note a few things that occurred in these examples -- or failed to occur, rather. First, there's no mixture of code and template markup. All template access occurs through the method call <code>$tr-&gt;render()</code>. This is strong separation of concerns (SOC), just like the pipeline model, and unlike the callback model, which mixes template markup and code in the same file. Not only does strong SOC provide good code organization, it also keeps designers from having to sift through code to change markup. Consider using Mason to output the rows of <code>@goods</code>.</p>

<pre><code>% for my $good (@goods) {
%  my @attr     = split(/,/, $good);
%  my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];
&lt;tr&gt;
&lt;td&gt;&lt;% $attr[0] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[1] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[2] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $quantity %&gt;&lt;/td&gt;
&lt;/tr&gt;
% }</code></pre>

<p>This is an efficient approach, and easy enough for a programmer to walk through. It becomes difficult to maintain though, when designers are involved, if for no other reason than because a designer and a programmer need to access the same file to do their respective work. Design changes and code changes will not always share the same schedule because they belong to different domains. It also means that in order to switch templates, say to output XML or text (or both), you have to add more and more conditionals and templates to the code, making it increasingly difficult to read.</p>

<p>The other thing that did not occur in this example is the leaking of any kind of logic (presentation or otherwise) into the template. Consider that HTML::Template would have to insert the <code>&lt;TMPL_LOOP&gt;</code> statement in the template in order to output the rows of <code>@goods</code>.</p>

<pre><code>    &lt;TMPL_LOOP NAME="PRODUCT"&gt;
    &lt;tr&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=SHOE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=DETAILS&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=PRICE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=QUANTITY&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/TMPL_LOOP&gt;</code></pre>

<p>That's not a big deal, really. If you care about line count, this only requires one extra line over the Template::Recall version, and that's the the closing tag <code>&lt;/TMPL_LOOP&gt;</code>. Nonetheless, the template now states some of the logic for the application. Sure, it's only presentation logic, but it's logic nonetheless. HTML::Template also provides <code>&lt;TMPL_IF&gt;</code> for displaying items conditionally, and <code>&lt;TMPL_INCLUDE&gt;</code> for including other templates. Again, this is logic contained in the template files.</p>

<p>Template::Recall keeps as much logic as possible in the code. If you need to display something conditionally, use Perl's <code>if</code> statement. If you need to include other templates, load them using a Template::Recall object. Whereas the pipeline models likely work better for projects with a fairly sophisticated design team, Template::Recall tries to be the programmer's friend and let him or her steer from the most comfortable place, the code.</p>

<p>There is also a subtle cost to using the pipeline model for a simple loop like that above. Consider this HTML::Template footwear data code:</p>

<pre><code>my $template = HTML::Template-&gt;new(filename =&gt; template1.tmpl');

my @output;

for my $good (@goods)
{
    my @attr = split(/,/, $_);
    my %row  = (
        SHOE     =&gt; $attr[0],
        DETAILS  =&gt; $attr[1],
        PRICE    =&gt; $attr[2],
        QUANTITY =&gt; $attr[3],
    );
    push( @output, \%row );
}

$template-&gt;param(PRODUCT =&gt; \@output);

print $template-&gt;output();</code></pre>

<p>The code iterates over <code>@goods</code> and builds a second array, <code>@output</code>, with the rows as hash references. Then the template iterates over <code>@output</code> within <code>&lt;TMPL_LOOP&gt;</code>. That's walking over the same data twice. Template sections do not suffer this cost, because you can output the data immediately, as you get it:</p>

<pre><code>print $tr-&gt;render('product_row', \%row);</code></pre>

<p>This is essentially what happens with Mason (or JSP/PHP/ASP for that matter). The main difference is that Template::Recall renders the section through a method call rather than mixing code and template.</p>

<p>Template::Recall, by using sectioned templates, combines the efficiency of the callback model with the strong, clean separation of concerns inherent in the pipeline model, and perhaps gets the best of both worlds.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-640" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/02/13/elements-of-access-control.html" rel="bookmark">Elements of Access Control</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Vladi Belperchinov-Shabanski</span> on <abbr class="published" title="2008-02-13T00:00:00-08:00">February 13, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<h3>Why Gates?</h3>

<p>In a perfect world we wouldn't do things we should not. However the world is not like this; people do forbidden things sometimes. This also applies to computer systems used by more than one person. Almost everyone has tried to read someone else's email, view accounting department salary reports, or something else, or access otherwise hidden data.</p>

<p>I know <em>you</em> have never done this, but many people have.</p>

<h3>In Construction</h3>

<p>The simplest way to allow or forbid a user account to do something is to check if the account is in a list of permitted accounts somewhere. If you assume that everything is forbidden unless explicitly allowed, the access function can be as simple as:</p>

<pre><code>  # access_check() return 1 or undef
  sub access_check
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    return $quick_allow{ $user_id };
  }

  my @allowed = ( 11, 12, 23, 45 );

  print "User 23 allowed\n" if access_check( 23, @allowed );
  print "User 13 allowed\n" if access_check( 13, @allowed );
  print "User 99 allowed\n" if access_check( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<p>Usually access control can be almost as simple as this function. Using user IDs for access control is simple, but tends to be hard to maintain. The problem appears with systems with many users or with public systems where new users may be created at any point. Access lists may become very large for each operation, which needs access controls.</p>

<p>One solution to this problem is <em>access groups</em>. Each user may be a member of several groups. The access check will pass if the user is a member of a group with permission for the required operation. This middle level in the access check isolates users from the access check directly. It also helps the system's design--you can associate preset access groups with all controlled operations at their point of creation. Subsequently created users only need to be attached to one or more of those groups:</p>

<pre><code>  # mimic real system environment:
  # %ALL_USER_GROUPS represents "storage" that contains all
  # groups that each user is attached to
  my %ALL_USER_GROUPS = (
                    23 =&gt; [ qw( g1  g4 ) ],
                    13 =&gt; [ qw( g3  g5 ) ],
                    );
  # user 23 is in groups g1 and g4
  # user 13 -- in g3 and g5

  # return list of user's groups. read data from storage or
  # from %ALL_USER_GROUPS in this example
  sub get_user_groups
  {
    my $user_id     = shift;

    return @{ $ALL_USER_GROUPS{ $user_id } || [] };
  }

  # access_check_grp() return 1 or 0
  sub access_check_grp
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    my @user_groups = get_user_groups( $user_id );

    for my $group ( @user_groups )
    {
      # user groups is listed, allow
      return 1 if $quick_allow{ $group };
    }

    # user group not found, deny
    return 0;
  }

  # this groups list is static and will not be altered
  # when users are added or removed from the system
  my @allowed = qw( g1  g2  g7  g9 );

  print "User 23 allowed\n" if access_check_grp( 23, @allowed );
  print "User 13 allowed\n" if access_check_grp( 13, @allowed );
  print "User 99 allowed\n" if access_check_grp( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<h3>Storage</h3>

<p>Probably the most popular storage for system data nowadays is the SQL database. Here is a simple example of how to store users, groups, and mapping between them. Three tables are required:</p>

<pre><code>  SQL CREATE statements:

  create table user  ( id integer primary key, name char(64), pass char(64) );
  create table group ( id integer primary key, name char(64) );
  create table map   ( user integer, group integer );

  TABLE USER:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |
   pass   | character(64) |

  TABLE GROUP:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |

  TABLE MAP:

   Column |  Type   | Modifiers
  --------+---------+-----------
   user   | integer |
   group  | integer |</code></pre>

<p>Let's fill those tables with some data:</p>

<pre><code>  letme=# select id, name from user;
   id |       name
  ----+------------------
    1 | Damian
    2 | Clive
    3 | Lana
  (3 rows)

  letme=# select * from group;
   id |       name
  ----+------------------
    1 | Admin
    2 | Users
    3 | Moderators
  (3 rows)

  letme=# select * from map;
   user | group
  -----+-----
     1 |   1
     1 |   2
     3 |   2
     3 |   3
     2 |   2
  (4 rows)</code></pre>

<p>Users in this example are attached to those groups:</p>

<pre><code>  Damian: Users, Admin
  Clive:  Users
  Lana:   Users, Moderators</code></pre>













<h3>Run-Time</h3>

<p>Applications apply access control after user login. You can combine it with the login procedure--for example to allow only specific group of users to connect on weekends. Even so, the access check occurs only after the login succeeds, that is, when the username and password are correct.</p>

<p>A simple approach for loading required access info is:</p>

<ul>
<li>Login, check username and password</li>

<li>For unsuccessful login, deny access, print message, etc.</li>

<li>For successful login, load group list for the user from database</li>

<li>Check for required group(s) for login

<p>This may deny login, print a message, or continue.</p></li>

<li>User logged in, continue

<p>All access checks for operations happen after this point.</p></li>
</ul>

<p>The run-time storage for a user's groups can be simple hash. It can be either global or inside the user session object, depending on your system design. I've used a global hash here for simplicity of the examples, but if you copy and paste this code, remember that it is <em>mandatory</em> for you to clear and recreate this global hash for every request right after the login or user session changes! You can also use some kind of session object to drop all user data at the end of the session, but this is just an option, not the only correct or possible way.</p>

<p>(Also, a truly robust system would store a well-hashed version of the password, not the literal password, but that's a story for a different article.)</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use DBI;
  use Data::Dumper;

  our $USER_NAME;
  our $USER_ID;
  our %USER_GROUPS;

  my $DBH = DBI-&gt;connect( "dbi:Pg:dbname=letme", "postgres", "",
      { AutoCommit =&gt; 0 } );

  # this is just an example!
  # username and password acquiring depends on the specific application
  user_login( 'Damian', 'secret4' );

  print "User logged in: $USER_NAME\n";
  print "User id:        $USER_ID\n";
  print "User groups:    " . join( ', ', keys %USER_GROUPS ) . "\n";

  sub user_login
  {
    my $user_name = shift;
    my $user_pass = shift;

    $USER_NAME   = undef;
    $USER_ID     = undef;
    %USER_GROUPS = ();

    # both name and password are required
    die "Empty user name"     if $user_name eq '';
    die "Empty user password" if $user_pass eq '';

    eval
    {
      my $ar = $DBH-&gt;selectcol_arrayref(
          'SELECT ID FROM USER WHERE NAME = ? AND PASS = ?',
                                        {},
                                        $user_name, $user_pass );

      $USER_ID   = shift @$ar;

      die "Wrong user name or password" unless $USER_ID &gt; 0;

      $USER_NAME = $user_name;

      # loading groups
      my $ar = $DBH-&gt;selectcol_arrayref( 'SELECT GROUP FROM MAP WHERE USER = ?',
                                        {},
                                        $USER_ID );

      %USER_GROUPS = map { $_ =&gt; 1 } @$ar;
    };
    if( $@ )
    {
      # something failed, it is important to clear user data here
      $USER_NAME   = undef;
      $USER_ID     = undef;
      %USER_GROUPS = ();

      # propagate error
      die $@;
    }
  }</code></pre>

<p>If Damian's password is correct, this code will print:</p>

<pre><code>  User logged in: Damian
  User id:        1
  User groups:    1, 2</code></pre>

<p>The group access check function now is even simpler:</p>

<pre><code>  sub check_access
  {
    my $group = shift;
    return 0 unless $group &gt; 0;
    return $USER_GROUPS{ $group };
  }</code></pre>

<p>Sample code for an access check after login will be something like:</p>

<pre><code>  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_access( 1 );

    # user allowed, group 1 check successful
    ...
  }</code></pre>

<p>or</p>

<pre><code>  if( check_access( 1 ) )
  {
    # user ok
  }
  else
  {
    # access denied
  }</code></pre>

<h3>Access Instructions</h3>

<p>The next problem is how to define which groups can perform specific operations. Where this information is static (most cases), you can store group lists in configuration (text) files:</p>

<pre><code>  LOGIN: 2
  EDIT:  1</code></pre>

<p>That is, the EDIT operation needs group 1 (admin) and LOGIN needs group 2 (all users).</p>

<p>Another example is to allow only administrators to log in during weekends:</p>

<pre><code>  # all users for mon-fri
  LOGIN_WEEKDAYS: 2

  # only admin for sat-sun
  LOGIN_WEEKENDS: 1</code></pre>

<p>Administrators will be in both groups (1, 2), so they will be able to log in anytime. All regular users cannot login on weekends.</p>

<p>This group list includes a moderators group. It could be useful to allow moderators do their job on weekends as well, implying an <code>OR</code> operation:</p>

<pre><code>  # only admin or moderators for sat-sun
  LOGIN_WEEKENDS: 1, 3</code></pre>

<p>This named set of groups is a <em>policy</em>.</p>

<p>For now, there's only one level in the policy and an <code>OR</code> operation between groups in a list. Real-world policies may be more complex. However there is no need to overdesign this. Even large systems may work with just one more level. Here's an <code>AND</code> operation:</p>

<pre><code>  LOGIN_WEEKENDS: 1+3, 4, 1+5+9</code></pre>

<p>This policy will match (allowing login on weekend days) only for users in the following groups:</p>

<pre><code>     1 AND 3
  OR 4
  OR 1 AND 5 AND 9</code></pre>













<p>The login procedure must match the <code>LOGIN_WEEKENDS</code> policy before allowing user to continue with other operations. Thus, you need a procedure for reading policy configuration files:</p>

<pre><code>  our %ACCESS_POLICY;

  sub read_access_config
  {
    my $fn = shift; # config file name

    open( my $f, $fn );
    while( &lt;$f&gt; )
    {
      chomp;
      next unless /\S/; # skip whitespace
      next if  /^[;#]/; # skip comments

      die "Syntax error: $_\n" unless /^\s*(\S+?):\s*(.+)$/;
      my $n = uc $1; # policy name: LOGIN_WEEKENDS
      my $v =    $2; # groups lsit: 1+3, 4, 1+5+9

      # return list of lists:
      # outer list uses comma separator, inner lists use plus sign separator
      $ACCESS_POLICY{ $n } = access_policy_parse( $v );
    }
    close( $f );
  }

  sub access_policy_parse
  {
    my $policy = shift;
    return [ map { [ split /[\s\+]+/ ] } split /[\s,]+/, $policy ];
  }</code></pre>

<p>For the <code>LOGIN_WEEKENDS</code> policy, the resulting value in <code>%ACCESS_POLICY</code> will be:</p>

<pre><code>  $ACCESS_POLICY{ 'LOGIN_WEEKENDS' } =&gt;

                [
                  [ '1', '3' ],
                  [ '4' ],
                  [ '1', '5', '9' ]
                ];</code></pre>

<p>To match this policy, a user must be in every groups listed in any of the inner lists:</p>

<pre><code>  sub check_policy
  {
    my $policy = shift;

    my $out_arr = $ACCESS_POLICY{ $policy };
    die "Invalid policy name; $policy\n" unless $out_arr;

    return check_policy_tree( $out_arr );
  }

  sub check_policy_tree
  {
    my $out_arr = shift;

    for my $in_arr ( @$out_arr )
    {

      my $c = 0; # matching groups count
      for my $group ( @$in_arr )
      {
        $c++ if $USER_GROUPS{ $group };
      }

      # matching groups is equal to all groups count in this list
      # policy match!
      return 1 if $c == @$in_arr;
    }

    # if this code is reached then policy didn't match
    return 0;
  }</code></pre>

<p>The example cases will become:</p>

<pre><code>  sub user_login
  {
      # login checks here
      ...

      # login ok, check weekday policy
      my $wday = (localtime())[6];

      my $policy;
      if( $wday == 0 or $wday == 6 )
      {
        $policy = 'LOGIN_WEEKEND';
      }
      else
      {
        $policy = 'LOGIN_WEEKDAY';
      }

      die "Login denied" unless check_policy( $policy );
  }

  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_policy( 'EDIT' );

    # user allowed, 'EDIT' policy match
    ...
  }</code></pre>

<p>Now you have all the parts of a working access control scheme:</p>

<ul>
<li>Policy configuration syntax</li>

<li>Policy parser</li>

<li>User group storage and mapping</li>

<li>User group loading</li>

<li>Policy match function</li>
</ul>

<p>This scheme may seem complete, but it lacks one thing.</p>

<h3>Data Fences</h3>

<p>In a multiuser system there is always some kind of ownership on the data stored in the database. This means that each user must see only those parts of the data that his user groups own.</p>

<p>This ownership problem solution is separate from the policy scheme. Each row must have one or more fields filled with groups that have access to the data. Any SQL statements for reading data must also check for this field:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $ug  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME
             WHERE READ_GROUP IN ( $rg ) AND UPDATE_GROUP IN ( $ug )";</code></pre>

<p>The result set will contain only rows with read and update groups inside the current user's group set. Sometimes you may need all of rows with the same read group for display, even though some of those rows have update restrictions the user does not meet. This case will use only the <code>READ_GROUP</code> field for select and will cut off users when they try to update the record without permission:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME WHERE READ_GROUP IN ( $rg )";

  $sth = $dbh-&gt;prepare( $sql );
  $sth-&gt;execute();
  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_access( $hr-&gt;{ 'UPDATE_GROUP' } );</code></pre>

<p>When access checks are explicitly after <code>SELECT</code> statements it is possible to store full policy strings inside <code>CHAR</code> fields:</p>

<pre><code>  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_policy_record( $hr, 'UPDATE_GROUP' );

  sub check_policy_record
  {
      my $hr     = shift; # hash with record data
      my $field  = shift; # field containing policy string

      my $policy = $hr-&gt;{ $field };
      my $tree   = access_policy_parse( $policy );

      return check_policy_tree( $tree );
  }</code></pre>

<h3>In the Middle of Nowhere</h3>

<p>This access control scheme is simple and usable as described. It does not cover all possible cases of access control, but every application has its own unique needs. In certain cases, you can push some of these access controls to lower levels -- your database, for example -- depending on your needs. Good luck with building your own great wall!</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-638" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2008/01/18/how-to-tell-your-perl-story.html" rel="bookmark">How to Tell Your Perl Story (at OSCON)</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">brian d foy</span> on <abbr class="published" title="2008-01-18T00:00:00-08:00">January 18, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Ever wanted to tell the world about the cool things you're doing with Perl? O'Reilly Media recently announced the <a href="http://en.oreilly.com/oscon2008/public/cfp/13">Call for Participation (CfP) for the 2008 Open Source Convention (OSCON)</a>, which includes the 12th Perl Conference. Although the conference takes place from July 21 to 25, the planning has already started. Now's your opportunity to tell the world about the work you're doing with Perl and the work Perl is doing for you, but you have to propose a presentation by February 4.</p>

<p>(Granted, OSCON's not the only place you can tell your Perl story, so this advice applies to a far wider audience than you might think. There are too many conferences and seminars and workshops in the world to mention, but for the sake of clarity, I'm focusing on OSCON for two important reasons. First, it's probably the largest Perl-friendly conference in the world. Second, I'm on the review committee for the Perl track at OSCON.)</p>

<p>OSCON comprises several different sorts of presentations and sessions. There are tutorials that take from half a day or more, keynote sessions in front of the assembled conference, "break out" sessions for particular subjects, five minute "lightning" talks, and after hours "Birds of a Feather" sessions. There's not only something for every attendee, but an opportunity for every sort of speaker. Anyone can present at OSCON, and the conference organizers encourage everyone to participate; OSCON wants your Perl story!</p>

<h3>Finding the Good Stories</h3>

<p>This year I'm part of the reviewing committee for the OSCON Perl track. I'm not officially a part of O'Reilly and I don't get to make any promises, but I do get to help find and develop presentation ideas; the OSCON organizers don't just announce the CfP and hope for the best. To get the best conference possible, they also solicit proposals from people who can make for an interesting conference and also benefit their subject's community. This year we're trying to do more to find the stories we don't know about: that might be yours.</p>

<p>The review committee goes over and helps the conference organizers create the final schedule of presentations, taking into consideration the expected attendee interest, availability of rooms, and breadth of topics. It's not just about attracting the best celebrities, but also finding the compelling Perl stories for that year's audience.</p>

<p>You might be intimidated by the celebrity status of the usual speakers, the cornerstone people who have their pictures on the posters and the web site, but you shouldn't be. Everyone has to start somewhere, and a compelling story is as good as a name that everyone sees. People also want to know how other people use Perl better to get work done. You don't have to be a Perl guru to have a better way to get things done or a good story about how Perl made your life better.</p>

<h3>What's Your Story and What's Your Audience?</h3>

<p>Perl is a big subject, and I break down presentations into four basic categories, each of which has a different sort of audience and requires a different sort of speaker. To figure out what sort of presentation you can give, you just have to figure out how your story fits into one of these categories:</p>

<ul>
<li>The Perl language itself, and how it works</li>

<li style="list-style: none">
<p>These are the sorts of talks that language designers and gurus such as Larry Wall, Damian Conway, and Mark Jason Dominus give, sometimes in the form of tutorials. The language features aren't necessarily applied to particular problems but the audience can figure out how to adapt them to their own work. You're probably a Perl language architect and your audience would walk barefoot through broken glass to hear the latest Perl developments.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12819">Higher Order Perl</a> by Mark Jason Dominus</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13086">Perl 6 on Parrot</a> by Patrick Michaud</li>
</ul>
</li>
</ul>

<ul>
<li>Using Perl features to provide programmer capabilities</li>

<li style="list-style: none">
<p>These talks focus on modules and frameworks made for other programmers to solve problems in Perl. Often the person who did the work will be the speaker, but the people putting it into practice have good stories to tell too. You're probably working on really big iron moving lots of data, and so is your audience.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12881">DBD::G ofer: A Stateless DBI Proxy. For SOA and more!</a> by Tim Bunce</li>
</ul>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12956">wxPerl : Agile Cross-Platform GUI Design and Development</a> by Eric Wilhelm</li>
</ul>
</li>
</ul>

<ul>
<li>Using other technologies from Perl</li>

<li style="list-style: none">
<p>There are a lot of people out there experimenting with and building on the latest technologies, and they just happen to be using Perl to do it. These talks don't require extensive Perl knowledge so much as familiarity with the other technologies.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13020">Machine Learning Made Easy with Perl</a> by Lino Ramirez</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13137">Care and Feeding of Large Web Applications</a> by Perrin Harkins</li>
</ul>
</li>
</ul>

<ul>
<li>The process of using Perl to get work done</li>

<li style="list-style: none">
<p>Most people just want to get work done, and the more Perl can help them do that the better. These talks focus on using technology to get real value at the end of the day.</p>

<p>Examples from OSCON 2007:</p>

<ul>
<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/12781">Taming Legacy Perl</a> by Peter Scott</li>

<li><a href="http://conferences.oreillynet.com/cs/os2007/view/e_sess/13216">Simple Ways to be a Better Programmer</a> by Michael Schwern</li>
</ul>
</li>
</ul>

<h4>Lightning Talks and Birds of a Feather</h4>

<p>Maybe you aren't up to full 45 minute talk just yet. You can also present a lightning talk&#8212;a five minute mini-presentation. You may not think that you have much to say, but five minutes goes pretty quickly. It's a gentle way to start a career as a speaker. You don't need to develop a long talk; prepare a larger slide deck, and if you're terrified of public speaking, it's over pretty quickly. Everyone needs a place to start, so give this a try.</p>

<p>Birds of a Feather sessions are a bit different. They go on after the scheduled presentations each day. Although these are usually self-organized and decided by attendees while the conference is going on, you don't have to wait until the conference to start thinking about a session for a topic that interests you and talking to other people about it.</p>

<h4>Discussion Panels</h4>

<p>Perhaps you don't fancy yourself a speaker, but you're a subject matter expert and know all the key people in your field. Have you ever thought of moderating a panel? Pull together the right people and guide the discussion.</p>

<h3>What to Do Next</h3>

<p>Now it's up to you. Examine what you're doing with Perl, how you're using it, and how it makes your life better. Figure out how telling your Perl story can fit into OSCON and send us your proposal. If you need a little help or encouragement with your idea, just let me know. I'm here to help.</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-670" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2007/12/21/20-years-of-perl.html" rel="bookmark">Memories of 20 Years of Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">chromatic</span> on <abbr class="published" title="2007-12-21T00:00:00-08:00">December 21, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->

<!-- sidebar ends -->

<h3>Proving Them Wrong</h3>

<p>Around 1991 I wrote a very useful program, in C, which took a bunch of files and then sorted them into groups according to which files had identical contents. A lot of sysadmins at the time wrote to thank me for it. But when I boasted about it at Usenix that year, people told me "oh, you should have written then in Perl."</p>

<p>That was pretty annoying, so I got the Camel Book (pink in those days) so that I could learn Perl and prove that they were wrong. But it turned out that they were right.</p>

<p><em>Mark Dominus is the author of <a href="http://hop.perl.plover.com/">Higher-Order Perl</a></em></p>

<h3>My First CGI Program</h3>

<p>It was the year 2000, and I was working at a software startup in San Francisco. I was tasked with writing a simple form handler with an auto thank you email. I had been a C programmer for several years, a Fortran programmer for a few, and this was essentially my first Perl program. It was your standard CGI gateway which presented a form to the user, did some error checking, and sent a thank you email to the user.</p>

<p>After a few hours of learning Perl and putting my form handler together, it was put live on our website. I was delighted that I was able to pick up this language so quickly and produce results in a short period of time. I never like programming C that much (although that has changed), due the fact that it got in my way. Perl just worked.</p>

<p>I came into work the next day and reviewed how my program was doing. It turns out that my first bug had surfaced; the thank you email function managed to get caught in a loop. One poor soul who filled out my form had received 800 thank you emails! I was able to quickly fix the bug.</p>

<p>In honor of my first Perl program, I would like to extend a hearty 800 thank yous to the Perl community! I have been using Perl ever since and love it.</p>

<p><em>Fred Moyer is just another mod_perl hacker</em></p>

<h3>Perl and the University Student</h3>

<p>One cannot imagine how useful Perl proves sometimes to a university student. I can recall several occasions in which I used Perl to facilitate a task or check my homework. Of them, there is one that I still remember very clearly.</p>

<p>It was the course "Introduction to Computer Networks" and we learned about the various variations of networking protocols (Stop-and-wait, Go-back-N, and Selective-Repeat). We were given a simulation of these protocols written in C and compiled to run on Windows. The simulation could be ran with several parameters and would output a verbose file with the parameters of the simulation, the simulation itself and then some statistics of the simulation.</p>

<p>We ran the program several times and got several files in return. Now we had to somehow insert the statistics into Excel so we can analyze them, process them, and create charts out of them. But the statistics were scattered over several different files, all with the same format, but nothing that Excel can understand (at least not without a massive amount of Visual Basic for Applications code).</p>

<p>Without thinking for a moment, I started writing a Perl script that will process the files, extract the corresponding data and output a tab-delimited file that can be inputted into Excel. It took some time to write the script, and meanwhile my partner decided it may be faster to do it by hand. Thus, he occupied the nearby station, and started extracting the data himself. I finished a few minutes after that, though, (while he was just beginning in his manual labour) and we were able to input the data into Excel and continue the assignment. It took about 15 minutes or less, all in all.</p>

<p>Later on I talked to a few fellow students about the assignment. One of them claimed it took him 3 hours to input everything into Excel. (!) Another said it took him one hour, which is still much worse than 15 minutes. Needless to say, none of them knew Perl.</p>

<p>Enough said.</p>

<p>(Originally published at <a href="http://perl.org.il/pipermail/perl/2003-October/003151.html">Perl Success Story, Israel.pm</a>.)</p>

<p><em>Shlomi Fish has worked with Perl since 1996 and considers himself a happy user, developer and advocate of Perl and other open-source technologies.</em></p>

<h3>How To Become a Guru</h3>

<p>In early 1999 I started a new job as a system administrator. In my previous position I'd taught myself Unix and GNU/Linux, and ended up writing a small tracking application for a customer service group in Java.</p>

<p>As a new SA, I took over a pile of work from my predecessor, including some small Perl programs he'd downloaded, installed, and modified to add his name to the comments. Over the next couple of months, I picked up the Camel and the Perl Cookbook, and taught myself enough Perl that I could skim comp.lang.perl.moderated and answer some of the questions in my head.</p>

<p>About that time, I started to do a little work on the Everything Engine -- not much, but a little bit -- and so I was the second external person to register on <a href="http://www.perlmonks.org/">PerlMonks</a> when it started. In those days there was no voting, no XP, and there were just a few people racing to reach the milestone of a hundred posts.</p>

<p>In between troubleshooting problems at work, I'd play with little programs, read whatever tutorials or books I could get, and answer any question I could on the site, and so I learned Perl that way.</p>

<p>I remember the rush to find an idea -- any idea -- worthy of putting on the CPAN, and thinking in 2000 that every problem that anyone could solve, someone had already solved. I remember my first patch to Perl 5, then realizing that I hadn't actually run the tests, and resolving to <em>improve</em> the tests because they didn't actually do what they said they should.</p>

<p>I remember getting job offers from my postings, and meeting some of the top Perl programmers in the world for the first time, and being accepted because I did (some of the) things I said I would, just because no one else was doing them.</p>

<p>That, I think, is the secret to become a contributing member of any community. Look for something that needs someone to do it and do it. You don't have to have permission, just a little bit of determination and stubbornness and some time.</p>

<p>I'm a little sad that I missed the first eleven years of Perl's life, but I'm glad to have caught up in the past nine years.</p>

<p><em>chromatic does a lot of things, some of them even sometimes productive.</em></p>

<h3>How an English Major Saved Christmas</h3>

<p>Right before Christmas of 1998 I was a fairly new employee at Amazon.com.
Not a CS grad hacker with 30,000 shares, but an English grad customer service
rep with 250. I knew about the 29,750 share disparity from picking up a fax
for a star employee in the apps group. Instead of letting it get to me, I
started to look into why it was so. I bought <em>Learning Perl</em> and spent
two of the most painful weeks of self-edification in my life discovering how
the lack of <code>chmod +x</code> was preventing me from getting through
Chapter 2.</p>

<p>Free at last I wrote, in two days, a badly needed and overlooked tax +
shipping costs calculator for customer service for the new product tab
launching that week. It was the kind of script that would take any decent
Perl hacker 30 minutes. A former art critic saved hundreds of reps and tens of
thousands of customers a lot of time and aggravation. I got the company�s
�Just Do It� Award. If it had been C or Java or anything but Perl I wouldn�t
have been able to do it.</p>

<p>If I�d come to anything but Perl, I would not have returned to coding--I
dabbled in BASIC and Assembly as a kid--and I wouldn�t be a software developer
today.</p>

<p><em>Ashley Pond V is a New Mexican writer turned Seattlite software
developer, currently working with Catalyst applications, who credits Perl with
saving his soul as he�d probably have gone into marketing otherwise.</em></p>

<h3>Smells Like Wet Camel</h3>

<p>Standing out in my memory is the day in college (either in late 1993 or
early 1994) when my grandmother had emergency eye surgery. Originally, she only
had a regularly scheduled checkup, and my mother could take her to the
appointment before work began, but not pick her up. The doctor was one street
over from the college (more or less) and I was conscripted to go over and take
her home after her appointment and my first class. The day was rainy,
increasing in intensity as the day grew older.</p>

<p>Everything changed when I arrived at the doctor's office, because the doctor
had found something that required immediate attention. She had to be taken to a
specialist immediately, and I began improvising. Each eye appointment took a
long time, and they would only get longer as my grandmother was worked in to
the specialist's schedule as an emergency patient. So I had time to take her to
the next appointment, leave her to wait for what might be hours, go to my next
class, eat lunch, and come back and get her.</p>

<p>I was trying to keep up with my college work, and brought my O'Reilly Perl
book along so I could work on my computer science project, figuring I might as
well do something useful while I was sitting around. My project involved
writing an e-mail processing system in Perl, so I had bought what was for me at
the time an almost impossibly expensive book to help me learn the language. On
the way to the car, in the hardest and coldest rain I can ever remember, I was
trying to help my grandmother and juggle the umbrella, car keys, car door, and
everything else. The book slipped out from under my arm and landed in a
puddle. Somehow, it landed on its edge, and had about an inch of muddy water
soak into it. My new book! Ruined! Nothing to do but keep going, to the next
appointment, and back to my class. I knew that to leave the college after eight
a.m. was a guarantee of not being able to park anywhere near the building for
the rest of the day, because the only parking spaces left were in the lower
area of an overflow lot far from any building I needed to go to. Without even
a sidewalk near this lot, I had plenty of time to think about my ruined book
and what was happening to my grandmother as I trudged through the mud, in the
pouring rain, to get to my next class.</p>

<p>I also, in these days before mobile phones, had to find a pay phone to tell
my mother about the abrupt change of plans. My grandmother eventually got
settled in the hospital, where it was at least dry, and she pulled through the
eye surgery fine. My waterlogged book with a brown bottom and hastily scribbled
notes on the blank pages in the back was a good enough starting point; I
graduated.</p>

<p><em><a href="http://www.scottmcmahan.net/">Scott McMahan</a> has been
writing Perl code since 1991.</em></p>

<h3>"I Couldn't Believe That Perl Even Worked"</h3>

<p>My first exposure to Perl was a web server with -- I think -- Perl 4.036
installed. This would be 1995 or so. I wanted to write CGI scripts so I started
reading everything I could find about Perl. I nearly lost heart when I read
that the parser was, effectively, heuristic. Coming from a background in Pascal
and C I couldn't believe that Perl even worked.</p>

<p>Fortunately Perl was the only option for my script. I persevered and
discovered that -- not only did Perl work -- I rather enjoyed it. Within two
weeks I had a CGI script that implemented a kind of ad-hoc PHP: chunks of Perl
embedded in HTML. It was ugly -- but Perl had made it possible.</p>

<p>At some time between then and now -- after digressions into Java and even
LotusScript -- Perl became my main language. At the end of 2006 I decided to
concentrate on Perl, release some modules, proactively seek out things I didn't
know about the language and learn them.</p>

<p>As a result 2007 has been the happiest year of my professional career.  I've
written loads of code, most of which works. I attended my first YAPC in Vienna
and came home with a bunch of new friends and a renewed enthusiasm for cranking
out code.</p>

<p>I've still got plenty to learn. Perl may be easy to pick up but mastery
takes years. And if you love programming that's part of the fun. However good
you think you are there's always a way to improve.</p>

<p>I dabble with other languages -- because if you take programming seriously
you must. What do they know of Perl that only Perl know?  There are things
about Perl that grate. It's not perfect but it's, well, loveable I suppose.</p>

<p>Thank you Perl community. Thank you Larry. Thank you for a lovely
language.</p>

<p><em>Andy Armstrong is a compulsive Perl abuser based in Cumbria,
UK.</em></p>

<h3>From awk to perl</h3>

<p>In early 1990, I was working with a large set of data that needed to be
massaged and formatted so that it could be statistically analyzed.</p>

<p>I started the task in awk, but quickly ran into trouble because awk could
only open one file at a time. A quick search through the Usenet comp.lang group
found Perl 3.0, which had just recently been released.</p>

<p>I had to get the source code and build it on my machine, but it compiled
cleanly and I was able to try some simple stuff. Worked real good too.  As I
had already a large awk program, that I didn't want to re-edit for Perl, I ran
it through <code>a2p</code> and the <code>perl</code> version produced the same
results. I was hooked.  When I got stuck, asking questions on comp.lang.perl
almost always got instant answers. There has been an active perl community for
a long time, and they were fabulous! (Just like now). I subsequently
re-factored my code for perl and produced vast quantities of data to be
analyzed. I have been using Perl ever since.</p>

<p><em>Roe McBurnett is a systems engineer for a telecommunications company and
has been working on telephony related projects as a developer, systems
engineer, and software tester since 1985.</em></p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-668" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2007/12/06/soto-11.html" rel="bookmark">Programming is Hard, Let's Go Scripting...</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Larry Wall</span> on <abbr class="published" title="2007-12-06T00:00:00-08:00">December  6, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>I think, to most people, scripting is a lot like obscenity. I can't define it, but I'll know it when I see it. Here are some common memes floating around:</p>

<pre>    Simple language
    "Everything is a string"
    Rapid prototyping
    Glue language
    Process control
    Compact/concise
    Worse-is-better
    Domain specific
    "Batteries included"</pre>

<p>...I don't see any real center here, at least in terms of technology. If I had to pick one metaphor, it'd be easy onramps. And a slow lane. Maybe even with some optional fast lanes.</p>

<h3>Easy Onramps</h3>

<p>But basically, scripting is not a technical term. When we call something a scripting language, we're primarily making a linguistic and cultural judgment, not a technical judgment.</p>

<p>I see scripting as one of the humanities. It's our linguistic roots showing through. So speaking of roots...</p>

<h3>The Past</h3>

<p>Suppose you went back to Ada Lovelace and asked her the difference between a script and a program. She'd probably look at you funny, then say something like: Well, a script is what you give the actors, but a program is what you give the audience. That Ada was one sharp lady...</p>

<p>Since her time, we seem to have gotten a bit more confused about what we mean when we say scripting. It confuses even me, and I'm supposed to be one of the experts.</p>

<p>So I'm afraid all I can do is give you my own worm's eye view of the past, the present, and the future. Let me warn you that I am not without a few prejudices here and there.</p>

<h3>BASIC</h3>

<p>Now, however it was initially intended, I think BASIC turned out to be one of the first major scripting languages, especially the extended version that DEC put onto its minicomputers called BASIC/PLUS, which happily included recursive functions with arguments. I started out as a BASIC programmer. Some people would say that I'm permanently damaged. Some people are undoubtedly right.</p>

<p>But I'm not going to apologize for that. All language designers have their occasional idiosyncracies. I'm just better at it than most. <code>:-)</code></p>

<h3>RSTS BASIC/PLUS</h3>

<p>Anyway, when I was a RSTS programmer on a PDP-11, I certainly treated BASIC as a scripting language, at least in terms of rapid prototyping and process control. I'm sure it warped my brain forever. Perl's statement modifiers are straight out of BASIC/PLUS. It even had some cute sigils on the ends of its variables to distinguish string and integer from floating point.</p>

<p>But you could do extreme programming. In fact, I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane. Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That's rapid prototyping.</p>

<h3>Unix?</h3>

<p>I remember one day our computer center got a letter from Bell Labs telling us that we could get a tape of Unix V6 for cheap, only $100 because they were coming out shortly with V7. We all looked at each other and said, Why would we ever want to use this thing called Unix? We have RSTS.</p>

<h3>JAM (no not that one)</h3>

<p>My first scripting language was written in BASIC. For my job in the computer center I wrote a language that I called JAM, short for Jury-rigged All-purpose Meta-language. Story of my life...</p>

<p>JAM was an inside-out text-processing language much like PHP, except that HTML hadn't been invented yet. We mostly used it as a fancy macro processor for BASIC. Unlike PHP, it did not have 3,000 functions in one namespace. We wouldn't have had the memory, for one thing.</p>

<h3>LISP</h3>

<p>For good or ill, when I went off to grad school, I studied linguistics, so the only computer language I used there was LISP. It was my own personal McCarthy era.</p>

<p>Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.</p>

<p>And, of course, mere mortals have never really forgiven LISP for not catering to them.</p>

<h3>Pascal, Ada</h3>

<p>Once I got into industry, I wrote a compiler in Pascal for a discrete event simulator, and slavered over the forthcoming Ada specs. As a linguist, I don't think of Ada as a big language. Now, English and Japanese, those are big languages. Ada is just a medium-sized language.</p>

<h3>Unix, shell</h3>

<p>After several years I finally became acquainted with Unix and its various scripting languages. OK, to be more precise, BSD, and csh.</p>

<h3>BSD, csh</h3>

<p>Yeah, yeah, I know. More brain damage...</p>

<p>I also learned a little C.</p>

<h3>C</h3>

<p>That's because a little C is all there is. I'm still learning those libraries though.</p>

<h3>shell + awk + sed + find + expr...</h3>

<p>But the frustrations of Unix shell programming led directly to the creation of Perl, which I don't really have time to tell. But essentially, I found that shell scripting was intrinsically limited by the fact that most of its verbs are not under its control and hence largely inconsistent with each other. And the nouns are impoverished, restricted to strings and files, with who-knows-what typology.</p>

<h3>C xor shell</h3>

<p>More destructive was the mindset that it was a one-dimensional universe: you either programmed in C or you programmed in shell, because they're obviously at opposite ends of the One True Continuum. Perl came about when I realized that scripting did not always have to viewed as the opposite of programming, but that a single language could be pretty good for both. That opened up a huge ecological niche. Many of you have seen my old clamshell diagram, with the two dimensions of manipulexity and whipuptitude.</p>

<h3>Tcl</h3>

<p>After Perl came Tcl, which in a sense is a purer scripting language than Perl. Perl just pretends that everything is a string when it's convenient, but Tcl really believes that as a controlling metaphor. The string metaphor tends to have bad performance ramifications, but that's not why Tcl languished, I think. There were two reasons for that.</p>

<p>First, Tcl stayed in the Unix mindset that controlling tools was the opposite of creating tools, so they didn't optimize much. The fast parts can always be written in C, after all.</p>

<p>The second reason was the lack of a decent extension mechanism, so you ended up with separate executables for expect, incr-tcl, etc.</p>

<p>I must say, though, that I've always admired Tcl's delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax:</p>

<h3>Python</h3>

<p>After Tcl came Python, which in Guido's mind was inspired positively by ABC, but in the Python community's mind was inspired negatively by Perl. I'm not terribly qualified to talk about Python however. I don't really know much about Python. I only stole its object system for Perl&nbsp;5. I have since repented.</p>

<h3>Ruby</h3>

<p>I'm much more qualified to talk about Ruby--that's because a great deal of Ruby's syntax is borrowed from Perl, layered over Smalltalk semantics. I've always viewed Ruby as a much closer competitor for Perls ecological niche, not just because of the borrowed ideas, but because both Perl and Ruby take their functional programming support rather more seriously that Python does. On the other hand, I think Ruby kind of screwed up on its declaration syntax, among other things.</p>

<h3>*sh</h3>

<p>Meanwhile, the Bourne shell was extended into the Korn shell and bash. I didn't have much to do with those either. Thankfully. I will say that the continued evolution of the shell shows just how crufty a language can get when you just keep adding on ad hoc syntactic features.</p>













<h3>PHP</h3>

<p>We've also seen the rise of PHP, which takes the worse-is-better approach to dazzling new depths, as it were. By and large PHP seems to be making the same progression of mistakes as early Perl did, only slower. The one thing it does better is packaging. And when I say packaging, I don't mean namespaces.</p>

<h3>JavaScript</h3>

<p>Then there's JavaScript, a nice clean design. It has some issues, but in the long run JavaScript might actually turn out to be a decent platform for running Perl&nbsp;6 on. Pugs already has part of a backend for JavaScript, though sadly that has suffered some bitrot in the last year. I think when the new JavaScript engines come out we'll probably see renewed interest in a JavaScript backend.</p>

<h3>Monad/PowerShell</h3>

<p>I've looked a bit at Microsoft's Monad, and I'm pleased to note that it has object pipes like Perl&nbsp;6. I just hope they don't patent it.</p>

<h3>Lua, AppleScript</h3>

<p>There are other scripting languages in wide use. Sadly, I must confess I never looked closely at Lua or AppleScript, probably because I'm not a game designer with a Mac.</p>

<p>Actually, I suspect it runs deeper than that, which brings us up to the present time.</p>

<h3>The Present</h3>

<p>When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other's way in complacent isolation.</p>

<p>I tend to take an anthropological view of these things. Many of you here are Perl programmers, but some of you come from other programming tribes. And depending on your tribal history, you might think of a string as a pointer to a byte array if you're a C programmer, or as a list if you're a functional programmer, or as an object if you're a Java programmer. I view a string as a Text, with a capital T.</p>

<h3>Text</h3>

<p>I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.</p>

<p>But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don't want to talk to a stupid computer language. I want my computer language to understand the strings I type.</p>

<p>Perl is a postmodern language, and a lot of conservative folks feel like Postmodernism is a rather liberal notion. So it's rather ironic that my views on Postmodernism were primarily informed by studying linguistics and translation as taught by missionaries, specifically, the Wycliffe Bible Translators. One of the things they hammered home is that there's really no such thing as a primitive human language. By which they mean essentially that all human languages are Turing complete.</p>

<p>When you go out to so-called primitive tribes and analyze their languages, you find that structurally they're just about as complex as any other human language. Basically, you can say pretty much anything in any human language, if you work at it long enough. Human languages are Turing complete, as it were.</p>

<p>Human languages therefore differ not so much in what you <em>can</em> say but in what you <em>must</em> say. In English, you are forced to differentiate singular from plural. In Japanese, you don't have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you're talking to, but also your degree of respect for the person or thing you're talking about.</p>

<p>So languages differ in what you're forced to say. Obviously, if your language forces you to say something, you can't be concise in that particular dimension using your language. Which brings us back to scripting.</p>

<p>How many ways are there for different scripting languages to be concise?</p>

<p>How many recipes for borscht are there in Russia?</p>

<p>Language designers have many degrees of freedom. I'd like to point out just a few of them.</p>

<h3>early binding / late binding</h3>

<p>Binding in this context is about exactly when you decide which routine you're going to call for a given routine name. In the early days of computing, most binding was done fairly early for efficiency reasons, either at compile time, or at the latest, at link time. You still tend to see this approach in statically typed languages. With languages like Smalltalk, however, we began to see a different trend, and these days most scripting languages are trending towards later binding. That's because scripting languages are trying to be dwimmy (Do What I Mean), and the dwimmiest decision is usually a late decision because you then have more available semantic and even pragmatic context to work with. Otherwise you have to predict the future, which is hard.</p>

<p>So scripting languages naturally tend to move toward an object-oriented point of view, where the binding doesn't happen 'til method dispatch time. You can still see the scars of conflict in languages like C++ and Java though. C++ makes the default method type non-virtual, so you have to say virtual explicitly to get late binding. Java has the notion of final classes, which force calls to the class to be bound at compile time, essentially. I think both of those approaches are big mistakes. Perl&nbsp;6 will make different mistakes. In Perl&nbsp;6 all methods are virtual by default, and only the application as a whole can tell the optimizer to finalize classes, presumably only after you know how all the classes are going to be used by all the other modules in the program.</p>

<h3>single dispatch / multiple dispatch</h3>

<p>In a sense, multiple dispatch is a way to delay binding even longer. You not only have to delay binding 'til you know the type of the object, but you also have to know the types of all rest of the arguments before you can pick a routine to call. Python and Ruby always do single dispatch, while Dylan does multiple dispatch. Here is one dimension in which Perl&nbsp;6 <em>forces</em> the caller to be explicit for clarity. I think it's an important distinction for the programmer to bear in mind, because single dispatch and multiple dispatch are philosophically very different ideas, based on different metaphors.</p>

<p>With single-dispatch languages, you are basically sending a message to an object, and the object decides what to do with that message. With multiple dispatch languages, however, there is no privileged object. All the objects involved in the call have equal weight. So one way to look at multiple dispatch is that the objects are completely passive. But if the objects aren't deciding how to bind, who is?</p>

<p>Well, it's sort of a democratic thing. All the routines of a given name get together and hold a political conference. (Well, not really, but this is how the metaphor works.) Each of the routines is a delegate to the convention. All the potential candidates put their names in the hat. Then all the routines vote on who the best candidate is, and the next best, and the next best after that. And eventually the routines themselves decide what the best routine to call is.</p>

<p>So basically, multiple dispatch is like democracy. It's the worst way to do late binding, except for all the others.</p>

<p>But I really do think that's true, and likely to become truer as time goes on. I'm spending a lot of time on this multiple dispatch issue because I think programming in the large is mutating away from the command-and-control model implicit in single dispatch. I think the field of computation as a whole is moving more toward the kinds of decisions that are better made by swarms of insects or schools of fish, where no single individual is in control, but the swarm as a whole has emergent behaviors that are somehow much smarter than any of the individual components.</p>

<h3>eager evaluation / lazy evaluation</h3>

<p>Most languages evaluate eagerly, including Perl&#160;5. Some languages evaluate all expressions as lazily as possible. Haskell is a good example of that. It doesn't compute anything until it is forced to. This has the advantage that you can do lots of cool things with infinite lists without running out of memory. Well, at least until someone asks the program to calculate the whole list. Then you're pretty much hosed in any language, unless you have a real Turing machine.</p>

<p>So anyway, in Perl&#160;6 we're experimenting with a mixture of eager and lazy. Interestingly, the distinction maps very nicely onto Perl&#160;5's concept of scalar context vs. list context. So in Perl&#160;6, scalar context is eager and list context is lazy. By default, of course. You can always force a scalar to be lazy or a list to be eager if you like. But you can say things like <code>for 1..Inf</code> as long as your loop exits some other way a little bit before you run into infinity.</p>

<h3>eager typology / lazy typology</h3>

<p>Usually known as static vs. dynamic, but again there are various positions for the adjustment knob. I rather like the gradual typing approach for a number of reasons. Efficiency is one reason. People usually think of strong typing as a reason, but the main reason to put types into Perl&#160;6 turns out not to be strong typing, but rather multiple dispatch. Remember our political convention metaphor? When the various candidates put their names in the hat, what distinguishes them? Well, each candidate has a political platform. The planks in those political platforms are the types of arguments they want to respond to. We all know politicians are only good at responding to the types of arguments they want to have...</p>

<p>There's another way in which Perl&#160;6 is slightly more lazy than Perl&#160;5. We still have the notion of contexts, but exactly when the contexts are decided has changed. In Perl&#160;5, the compiler usually knows at compile time which arguments will be in scalar context, and which arguments will be in list context. But Perl&#160;6 delays that decision until method binding time, which is conceptually at run time, not at compile time. This might seem like an odd thing to you, but it actually fixes a great number of things that are suboptimal in the design of Perl&#160;5. Prototypes, for instance. And the need for explicit references. And other annoying little things like that, many of which end up as frequently asked questions.</p>

<h3>limited structures / rich structures</h3>

<p>Awk, Lua, and PHP all limit their composite structures to associative arrays. That has both pluses and minuses, but the fact that awk did it that way is one of the reasons that Perl does it differently, and differentiates ordered arrays from unordered hashes. I just think about them differently, and I think a lot of other people do too.</p>

<h3>symbolic / wordy</h3>

<p>Arguably APL is also a kind of scripting language, largely symbolic. At the other extreme we have languages that eschew punctuation in favor of words, such as AppleScript and COBOL, and to a lesser extent all the Algolish languages that use words to indicate blocks where the C-derived languages use curlies. I prefer a balanced approach here, where symbols and identifiers are each doing what theyre best at. I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don't like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That's one thing I learned when I switched from Pascal to C. Braces for blocks. It's just right visually.</p>

<p>Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don't want your functors to stand out. It's shouting the wrong words: IF! foo THEN! bar ELSE! baz END! END! END! END!</p>

<p>Anyway, in Perl&#160;6 we're raising the standard for where we use punctuation, and where we don't. We're getting rid of some of our punctuation that isn't really pulling its weight, such as parentheses around conditional expressions, and most of the punctuational variables. And we're making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.</p>

<p>Oddly, there's one spot where we're introducing new punctuation. After your sigil you can add a twigil, or secondary sigil. Just as a sigil tells you the basic structure of an object, a twigil tells you that a particular variable has a weird scope. This is basically an idea stolen from Ruby, which uses sigils to indicate weird scoping. But by hiding our twigils after our sigils, we get the best of both worlds, plus an extensible twigil system for weird scopes we haven't thought of yet.</p>

<p>We think about extensibility a lot. We think about languages we don't know how to think about yet. But leaving spaces in the grammar for new languages is kind of like reserving some of our land for national parks and national forests. Or like an archaeologist not digging up half the archaeological site because we know our descendants will have even better analytical tools than we have.</p>

<p>Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don't make your best guess now, you're not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn't be as sure about that if APL hadn't tried it first.</p>













<h3>compile time / run time</h3>

<p>Many dynamic languages can eval code at run time. Perl also takes it the other direction and runs a lot of code at compile time. This can get messy with operational definitions. You don't want to be doing much file I/O in your <code>BEGIN</code> blocks, for instance. But that leads us to another distinction:</p>

<h3>declarational / operational</h3>

<p>Most scripting languages are way over there on the operational side. I thought Perl&#160;5 had an oversimplified object system till I saw Lua. In Lua, an object is just a hash, and there's a bit of syntactic sugar to call a hash element if it happens to contain code. Thats all there is. They don't even have classes. Anything resembling inheritance has to be handled by explicit delegation. That's a choice the designers of Lua made to keep the language very small and embeddable. For them, maybe it's the right choice.</p>

<p>Perl&#160;5 has always been a bit more declarational than either Python or Ruby. I've always felt strongly that implicit scoping was just asking for trouble, and that scoped variable declarations should be very easy to recognize visually. Thats why we have <code>my</code>. It's short because I knew we'd use it frequently. Huffman coding. Keep common things short, but not too short. In this case, 0 is too short.</p>

<p>Perl&#160;6 has more different kinds of scopes, so we'll have more declarators like <code>my</code> and <code>our</code>. But appearances can be deceiving. While the language looks more declarative on the surface, we make most of the declarations operationally hookable underneath to retain flexibility. When you declare the type of a variable, for instance, you're really just doing a kind of tie, in Perl&#160;5 terms. The main difference is that you're tying the implementation to the variable at compile time rather than run time, which makes things more efficient, or at least potentially optimizable.</p>

<h3>immutable classes / mutable classes</h3>

<p>Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby's classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.</p>

<p>Perl&#160;6 will have an interesting mix of immutable generics and mutable classes here, and interesting policies on who is allowed to close classes when. Classes are never allowed to close or finalize themselves, for instance. Sorry, for some reason I keep talking about Perl&#160;6. It could have something to do with the fact that we've had to think about all of these dimensions in designing Perl&#160;6.</p>

<h3>class-based / prototype-based</h3>

<p>Here's another dimension that can open up to allow both approaches. Some of you may be familiar with classless languages like Self or JavaScript. Instead of classes, objects just clone from their ancestors or delegate to other objects. For many kinds of modeling, it's actually closer to the way the real world works. Real organisms just copy their DNA when they reproduce. They don't have some DNA of their own, and an <code>@ISA</code> array telling you which parent objects contain the rest of their DNA.</p>

<p>The meta-object protocol for Perl&#160;6 defaults to class-based, but is flexible enough to set up prototype-based objects as well. Some of you have played around with <a href="http://search.cpan.org/perldoc?Moose">Moose</a> in Perl&#160;5. Moose is essentially a prototype of Perl&#160;6's object model. On a semantic level, anyway. The syntax is a little different. Hopefully a little more natural in Perl&#160;6.</p>

<h3>passive data, global consistency / active data, local consistency</h3>

<p>Your view of data and control will vary with how functional or object-oriented your brain is. People just think differently. Some people think mathematically, in terms of provable universal truths. Functional programmers don't much care if they strew implicit computation state throughout the stack and heap, as long as everything <em>looks</em> pure and free from side-effects.</p>

<p>Other people think socially, in terms of cooperating entities that each have their own free will. And it's pretty important to them that the state of the computation be stored with each individual object, not off in some heap of continuations somewhere.</p>

<p>Of course, some of us can't make up our minds whether we'd rather emulate the logical Sherlock Holmes or sociable Dr. Watson. Fortunately, scripting is not incompatible with either of these approaches, because both approaches can be made more approachable to normal folk.</p>

<h3>info hiding / scoping / attachment</h3>

<p>And finally, if you're designing a computer language, there are a couple bazillion ways to encapsulate data. You have to decide which ones are important. What's the best way to let the programmer achieve separation of concerns?</p>

<h3>object / class / aspect / closure / module / template / trait</h3>

<p>You can use any of these various traditional encapsulation mechanisms.</p>

<h3>transaction / reaction / dynamic scope</h3>

<p>Or you can isolate information to various time-based domains.</p>

<h3>process / thread / device / environment</h3>

<p>You can attach info to various OS concepts.</p>

<h3>screen / window / panel / menu / icon</h3>

<p>You can hide info various places in your GUI. Yeah, yeah, I know, everything is an object. But some objects are more equal than others.</p>

<h3>syntactic scope / semantic scope / pragmatic scope</h3>

<p>Information can attach to various abstractions of your program, including, bizarrely, lexical scopes. Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn't work right. A <code>state</code> variable is actually more purely lexical than a <code>my</code> variable, because it's shared by all calls to that lexical scope. But even state variables get cloned with closures. Only global variables can be truly lexical, as long as you refer to them only in a given lexical scope. Go figure.</p>

<p>So really, most of our scopes are semantic scopes that happen to be attached to a particular syntactic scope.</p>

<p>You may be wondering what I mean by a <em>pragmatic</em> scope. That's the scope of what the user of the program is storing in their brain, or in some surrogate for their brain, such as a game cartridge. In a sense, most of the web pages out there on the Internet are part of the pragmatic scope. As is most of the data in databases. The hallmark of the pragmatic scope is that you really don't know the lifetime of the container. It's just out there somewhere, and will eventually be collected by that Great Garbage Collector that collects all information that anyone forgets to remember. The Google cache can only last so long. Eventually we will forget the meaning of every URL. But we must not forget the <em>principle</em> of the URL. That leads us to our next degree of freedom.</p>

<h3>use Lingua::Perligata;</h3>

<p>If you allow a language to mutate its own grammar within a lexical scope, how do you keep track of that cleanly? Perl&#160;5 discovered one really bad way to do it, namely source filters, but even so we ended up with Perl dialects such as Perligata and Klingon. What would it be like if we actually did it right?</p>

<p>Doing it right involves treating the evolution of the language as a pragmatic scope, or as a set of pragmatic scopes. You have to be able to name your dialect, kind of like a URL, so there needs to be a universal root language, and ways of warping that universal root language into whatever dialect you like. This is actually near the heart of the vision for Perl&#160;6. We don't see Perl&#160;6 as a single language, but as the root for a family of related languages. As a family, there are shared cultural values that can be passed back and forth among sibling languages as well as to the descendants.</p>

<p>I hope you're all scared stiff by all these degrees of freedom. I'm sure there are other dimensions that are even scarier.</p>

<p>But... I think its a manageable problem. I think its possible to still think of Perl&#160;6 as a scripting language, with easy onramps.</p>

<p>And the reason I think its manageable is because, for each of these dimensions, it's not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.</p>

<h3>You can't even think about X!<br />
There's only one way to do X!<br />
There's more than one way to do X!<br />
There are too many ways to do X!</h3>

<p>You may recognize some slogans in here.</p>

<h3>Curling Up</h3>

<p>So I'm not suggesting that all scripting languages have to take all these dimensions into account, even if Perl&#160;6 tries to. The scripting paradigm is not any one of these dimensions. According to various theories the universe may be laid out in ten or twenty dimensions, but generally we get by with only about three and a half of those dimensions. The rest are said to be curled up. Maybe we live in a scripting universe.</p>

<p>Most of the scripting languages we call Perl&#160;6 will have most of these dimensions curled up most of the time. But unlike the real universe, where it takes huge machines to uncurl these dimensions, we'll make the dimensions uncurl just by keeping our declarations straight. Well, we'll try. And where that fails, we'll rely on the culture to keep things straight.</p>

<p>For example, that's exactly what happened already with Perl&#160;5. We have the declarations, <code>use strict; use warnings;</code>. But it's the culture that decided to enforce the use of them. So much so that we've decided that they should be the default for most of Perl&#160;6. It was one of those decisions by the hive. In this case the swarm turned out to be smarter than the language designer. And that's as it should be.</p>

<h3>The Future</h3>

<p>Well, so what's the future of scripting?</p>

<p>In my completely unbiased opinion, that would be Perl&#160;6. <code>:-)</code></p>

<p>Seriously though, it's always safe to predict that the ecological landscape will end up with many small languages and a few dominant ones. Some languages like AppleScript have particular ecological niches and are unlikely to grow out of them. Other languages get used outside their original niche. There will always be the generalists, like crows and mockingbirds, and the specialists, like penguins and dodos. (Well, maybe not always the dodos...)</p>

<p>Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I'm better at being worser! Is it really true that the worse-is-better approach always wins? With Perl&nbsp;6 we're trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-666" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2007/09/20/pdf-processing-with-perl.html" rel="bookmark">PDF Processing with Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Detlef Groth</span> on <abbr class="published" title="2007-09-21T00:00:00-08:00">September 21, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p><a href="http://www.adobe.com/">Adobe</a>'s PDF has become a standard for text documents. Most office products can export their content into PDF. However, this software reaches its limits if you want advanced tasks such as combining different PDF documents into one single document or adding and adjusting the bookmarks panel for better navigation. Imagine that you want to collect all relevant Perl.com articles in one PDF file with an up-to-date bookmarks panel. You could use a tool like <a href="http://www.easysw.com/">HTMLDOC</a>, but adding article number 51 would require you to fetch articles one through 50 from the Web again. In most cases you would not be satisfied by the resulting bookmarks panel, either. This article shows how to use <a href="http://search.cpan.org/dist/PDF-Reuse/">PDF::Reuse</a>, by Lars Lundberg, for combining different PDF documents and adding bookmarks to them.</p>

<h3>Example Material</h3>

<p>Although its capabilities are limited in this area, you can also use <code>PDF::Reuse</code> to create PDF documents. If you want to create more sophisticated documents you should investigate other PDF-packages like <a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a> from Alfred Reibenschuh or <a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a> from Martin Hosken. However <code>PDF::Reuse</code> is sufficient to create a simple PDF to use in later examples. The following listing should be rather self explanatory.</p>

<pre><code> # file: examples/create-pdfs.pl
  use strict;
  use PDF::Reuse;

  mkdir "out" if (!-e "out") ;

  foreach my $x (1..4) {
      prFile("out/file-$x.pdf");

      foreach my $y (1..10) {
          prText(35,800,"File: file-$x.pdf");
          prText(510,800,"Page: $y");

          foreach my $z (1..15) {
              prText(35,700-$z*16,"Line $z");
          }

          # add graphics with the prAdd function

          # stroke color
          prAdd("0.1 0.1 0.9 RG\n");

          # fill color
          prAdd("0.9 0.1 0.1 rg\n");

          my $pos = 750 - ($y * 40);

          prAdd("540 $pos 10 40 re\n");
          prAdd("B\n");

          if ($y &lt; 10) {
              prPage();
          }
      }

      prEnd();
  }</code></pre>

<p>Open a new file with with <code>prFile($filename)</code> and close it with <code>prEnd</code>. Between those two calls, add text with the <code>prText</code> command. You can also draw graphics by using the low level command <code>prAdd</code> with plain PDF markup as parameter. Start a new page with <code>prPage</code>. <code>prFile</code> starts the first one automatically, so you need to add a new page only if your document has more than one page. Be aware that for the <code>prText(x,y,Text)</code> command the origin of the coordinate system is on the left bottom of the page.</p>

<p>As an example of adding PDF markup with <code>prAdd</code>, the code creates a red rectangle with blue borders. In case you would like to add more graphics or complex graphics to your PDF, you can study the examples of the <a href="http://partners.adobe.com/public/developer/pdf/index_reference.html">PDF reference manual</a>. If so, consider switching to <code>PDF::API2</code> or <code>Text::PDF</code> instead of using <code>prAdd</code>, as they both provide a comfortable layer of abstraction over the PDF markup language.</p>

<h3>Combining PDF Documents</h3>

<p><code>PDF::Reuse</code>'s main strength is the modification and reassembling of existing PDF documents. The next example assembles a new file from the example material.</p>

<pre><code>  # file: examples/combine-pdfs.pl

  use strict;
  use PDF::Reuse;

  prFile("out/resultat.pdf");

  prDoc('out/file-1.pdf',1,4);
  prDoc('out/file-2.pdf',2,9);
  prDoc('out/file-3.pdf',8);
  prDoc('out/file-4.pdf');

  prEnd();</code></pre>

<p>Again, <code>prFile($filename)</code> opens the file. Next, the <code>prDoc($filename, $firstPage, $lastPage)</code> calls add to the new file various page ranges from the example file. The arguments <code>$firstPage</code> and <code>$lastPage</code> are optional. Omit both to add the entire document. If only <code>$firstPage</code> is present, the call will add everything from that page to the end. Finally, <code>prEnd</code> closes the file.</p>

<h3>Reusing Existing PDF Files</h3>

<p>With <code>PDF::Reuse</code> it is possible to use existing PDF files as templates for creating new documents. Suppose that you have a file <em>customer.txt</em> containing a list of customers to whom to send a letter. You've used a tool to create a PDF document, such as OpenOffice.org or Adobe Acrobat, to produce the letter itself. Now you can write a short program to add the date and the names and addresses of your customers to the letter.</p>

<pre><code>  # file: examples/reuse-letter.pl
  use PDF::Reuse;
  use Date::Formatter;
  use strict;

  my $date = Date::Formatter-&gt;now();
  $date-&gt;createDateFormatter("(DD).(MM). (YYYY)");

  my $n      =  1;
  my $incr   = 14;
  my $infile = 'examples/customer.txt';

  prFile("examples/sample-letters.pdf");

  prCompress(1);
  prFont('Arial');
  prForm("examples/sample-letter.pdf");

  open (my $fh, "&lt;$infile") || die "Couldn't open $infile, $!\n aborts!\n";

  while (my $line = &lt;$fh&gt;)  {
      my $x = 60;
      my $y = 760;

      my ($first, $last, $street, $zipCode, $city, $country) = split(/,/, $line);
      last unless $country;

      prPage() if $n++ &gt; 1 ;
      prText($x, $y, "$first $last");

      $y -= $incr;
      prText($x, $y, $street);

      $y -= $incr;
      prText($x, $y, $zipCode);
      prText(($x + 40), $y, $city);

      $y -= $incr;
      prText($x,   $y, $country);
      prText(60,  600, "Dear $first $last,");
      prText(400, 630, "Berlin, $date");
  }

  prEnd();
  close $fh;</code></pre>

<p>After opening the file with <code>prFile</code>, the call to <code>prCompress(1)</code> enables PDF compression. <code>prFont</code> sets the file's font. The always-available options are Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, and Helvetica-BoldOblique. Set the font size with <code>prFontSize</code>. The default font is Helvetica, with 12 pixel size.</p>

<p>The rest of the code is a simple loop over the file containing the customer data to filling the template with <code>prText</code>.</p>













<h3>Adding Page Numbers</h3>

<p>Sometimes you need only make a small change to a document, such as adding missing page numbers.</p>

<pre><code>  # file: examples/sample-numbers.pl
  use PDF::Reuse;
  use strict;

  my $n = 1;

  prFile('examples/sample-numbers.pdf');

  while (1) {
     prText(550, 40, $n++);
     last unless prSinglePage('sample-letters.pdf');
  }

  prEnd();</code></pre>

<p><code>prSinglePage</code> takes one page after the other from an existing PDFdocument and returns the number of remaining pages after each invocation.</p>

<h3>Low-Level PDF Commands</h3>

<p>If you know low-level PDF instructions, you can add them with with the <code>prAdd(string)</code> subroutine. <code>PDF::Reuse</code> will perform no syntax checks on the instructions, so refer to the PDF reference manual. Here's an example of printing colored rectangles with the <code>prAdd</code> subroutine.</p>

<pre><code>  # file: examples/sample-rectangle.pl
  use PDF::Reuse;
  use strict;

  prFile('examples/sample-rectangle.pdf');

  my $x = 40;
  my $y = 50;
  my @colors;

  foreach my $r (0..5) {
     foreach my $g (0..5) {
         foreach my $b (0..5) {
             push @colors,
                 sprintf("%1.1f %1.1f %1.1f rg\n",
                 $r * 0.2, $g * 0.2, $b * 0.2);
         }
     }
  }

  while (1) {
     if ($x &gt; 500) {
         $x = 40; $y += 40;
         last unless @colors;
     }

     # a rectangle
     my $string = "$x $y 30 30 re\n";
     $string   .= shift @colors;

     # fill and stroke
     $string   .= "b\n";

     prAdd($string);

     $x += 40;
  }

  prEnd();</code></pre>

<h3>Adding Bookmarks</h3>

<p>Working with PDF files becomes comfortable if the document has bookmarks with a table of contents-like structure. Some applications either can't provide the PDF document with bookmarks or support insufficient or incorrect bookmarks. <code>PDF::Reuse</code> can fill this gap with the <code>prBookmark($reference)</code> subroutine.</p>

<p>A bookmark reference is a hash or a array of hashes that looks like:</p>

<pre><code>   {  text  =&gt; 'Document-Text',
             act   =&gt; 'this.pageNum = 0; this.scroll(40, 500);',
             kids  =&gt; [ { text =&gt; 'Chapter 1',
                          act  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          act  =&gt; '10, 40, 600'
                        }
                      ]
   }</code></pre>

<p>...where <code>act</code> is a JavaScript action to trigger when someone clicks on the bookmark. Because those JavaScript actions only work in the Acrobat Reader but not in other PDF viewer applications, I will later show a improvement of <code>PDF::Reuse</code> that fixes this issue.</p>

<p>Other examples for using <code>PDF::Reuse</code>, including image embedding, are available in the <a href="http://search.cpan.org/perldoc?PDF::Reuse::Tutorial">PDF::Reuse::Tutorial</a>.</p>

<h3>A Console Application for Combining PDF Documents</h3>

<p>To avoid editing the Perl code for combining PDF documents every time you want to merge documents, I've written a console application that takes the names of the input files and the page ranges for each file as arguments. That's easy to reuse in a graphical application using Perl/Tk, so I've put that code in a separate Perl module called <code>CombinePDFs</code>. The command-line application will interact with this package instead of directly working on <code>PDF::Reuse</code>. The following diagram shows the relationship between the Packages, example, and applications.</p>

<pre><code>  Examples    |     Packages            |     applications
  -------------------------------------------------------------------
  combine.pdfs                           app-combine-console-pdfs.pl
              \                         /
               PDF::Reuse -- CombinePDFs
              /                         \
   create.pdfs                           app-combine-tk-pdfs.pl</code></pre>

<p>The application <em>app-combine-console-pdfs.pl</em> does not deal directly with <code>PDF::Reuse</code> but parses the command line arguments with <a href="http://search.cpan.org/perldoc?Getopt::Long">Getopt::Long</a> written by Johan Vromans. This is the standard package for this task. Here it parses the input filenames and the page ranges into two arrays of same length. The user also has to supply a filename for the output and, optionally, a bookmarks file. The main subroutine that parses the command line arguments and executes <code>CombinePDFs::createPDF</code> is:</p>

<pre><code>  sub main {
      GetOptions("infile=s"    =&gt; \@infiles,
                 "outfile=s"   =&gt; \$outfile,
                 "pages=s",    =&gt; \@pages,
                 'overwrite'   =&gt; \$overwrite,
                 'bookmarks:s' =&gt; \$bookmarks,
                 'help'        =&gt; \&amp;help);
      help unless ((@infiles and $outfile and @pages) and @pages == @infiles);

      checkPages();
      checkFiles();
      checkBookmarks();

      CombinePDFs::createPDF(\@infiles, \@pages, $outfile, $bookmarks);
  }</code></pre>

<p>If the user passes an insufficient number of arguments, invalid filenames, or incorrect page ranges, the code invokes the the usage subroutine. It also gets invoked if the user asks explicitly for <code>-help</code> on the command line. Any good command line application should be written that way. <code>Getopt::Long</code> can distinguish between mandatory arguments, with <code>=</code> as the symbol after the argument name (infile, pages), optional arguments, with <code>:</code> (bookmarks), or flags (overwrite, usage), without a symbol. It can store these arguments as arrays (infile, pages), hashes, or scalars. It also supports type checking.</p>













<h3>CombinePDFs Package</h3>

<p>The application itself mainly performs error checking. If everything is fine, it calls the <code>CombinePDFs::createPDF</code> subroutine, passing the array of input files, the array of page ranges, and the bookmarks information. The bookmarks scalar is optional.</p>

<p>Page ranges can be comma-separated ranges (<code>1-11,14,17-23</code>), single pages, or the <code>all</code> token. You can include the same page several times in the same document.</p>

<p>The file-checking code looks for read permissions and tests if the file is a PDF document by using the <code>CombinePDFs::isPDF($filename)</code> subroutine. Although <a href="http://search.cpan.org/dist/PDF/">PDF</a>, by Antonio Rosella, also provides such a method, this package was not developed with the <code>use strict</code> pragma and gives a lot of warnings. Furthermore, the package is not actively maintained, so there seems to be no chance to fix this in the near future. Implementing the <code>isPDF</code> subroutine is quite simple; it reads the first line of the PDF file and checks for the magic string <code>%PDF-1.[0-9]</code> in the first line of the document.</p>

<p>Please note that <code>PDF::Reuse</code> is not an object oriented package. Therefore the <code>CombinePDFs</code> package is not object oriented, either. A user of this package could create several instances, but all instances work on the same PDF file.</p>

<p>Submitting complex data structures via the command line is a difficult issue, so I decided that bookmarks should come from a text file. This file has a simple markup to reflect a tree structure, where each line resembles:</p>

<pre><code> &lt;level&gt; "bookmarks text" &lt;page&gt;</code></pre>

<p>The level starts with 0 for root bookmarks. Children of the root bookmarks have a level of 1, their children a level of 2, and so on. Currently, the system supports bookmarks up to three levels of nesting:</p>

<pre><code> 0 "Folder File 1 - Page 1" 1
 1 "File 1 - Page 2" 2
 1 "Subfolder File 1 - Page 3" 3
 2 "File 1 - Page 4"  4
 0 "Folder File 2 - Page 7 " 7
 1 "File 2 - Page 7" 7
 1 "File 2 - Page 9" 9</code></pre>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> should be easy to understand, though that's not necessarily true of the complex data structure created inside this subroutine.</p>

<p>Bookmarks are an array of hashes. <code>addBookmarks</code> uses several attributes. <code>text</code> is the title of the entry in the bookmarks panel. <code>act</code> is the action to trigger when someone clicks the entry. Here it is the page number to open. <code>kids</code> contains a reference to the children of this bookmark entry. During the loop over the file content, the code searches for each level the last entry in a variable and pushes its related children on those last entries. The root bookmarks get collected as an array, and the loop adds the children as a reference to an array, and so on for the grand children. The result is a nested complex data structure which stores all children in the <code>kids</code> attribute of the parent's bookmarks hash&#8212;an array of hashes containing other arrays of hashes and so on.</p>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> collects bookmarks in a array of hashes. At the end, it adds the bookmarks to the document with <code>prBookmarks($reference)</code>. All of this means that you can use a bookmarks file with the PDF file with a command line like:</p>

<pre><code>   $ perl bin/app-combine-pdfs.pl \
      --infile out/file-1.pdf --pages 1-6 \
      --infile out/file-2.pdf --pages 1-4,7,9-10 \
      --bookmarks out/bookmarks.cnt \
      --outfile file-all.pdf --overwrite</code></pre>

<p>Currently, you must open the document's navigation panel manually because <code>PDF::Reuse</code> does not yet allow you to declare a default view, whether full screen or panel view. This is easy to fix, and the author Lars Lundberg has promised me to do so in a next release of <code>PDF::Reuse</code>. In order to enable this feature until a new release will appear I included a modified version of <code>PDF::Reuse</code> in the examples zip file that accompanies this article.</p>

<p>Furthermore, the bookmarks use JavaScript functions. To use the bookmarks in PDF viewers other than Acrobat Reader, my patched <code>PDF::Reuse</code> package replaces JavaScript bookmarks with PDF specification compliant bookmarks. To do that, replace the <code>act</code> key with a <code>page</code> key using the appropiate page number and scroll options:</p>

<pre><code> $bookmarks = {  text  =&gt; 'Document',
                 page  =&gt; '0,40,50;',
                 kids  =&gt; [ { text =&gt; 'Chapter 1',
                          page  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          page  =&gt; '10, 40, 600'
                        }
                      ]
          }</code></pre>

<p>Then print the bookmarks to the PDF document as usual with <code>prBookmark($bookmarks);</code>.</p>

<h3>Tk Application to Combine PDF Documents</h3>

<p>Console applications are fine for experienced users, but you can't expect that all users belong to this category. Therefore it might be worth it to write a GUI for combining PDF documents. The <a href="http://search.cpan.org/dist/Tk/">Perl/Tk toolkit</a> founded on the old Tix widgets for Tcl/Tk is not very modern, although this might change with the <a href="http://www.tcl.tk/software/tcltk/8.5.html">Tcl/Tk release 8.5</a> and the Tile widgets&#8212;but it is very portable. That's why I used it for the GUI example. Because I put a layer between the <code>PDF::Reuse</code> package and the command line application with the <code>CombinePDFs</code> package, it was easy to reuse those parts in the Tk-application <em>app-combine-tk-pdfs.pl</em>.</p>

<p>With the Tk application, the user visually selects PDF files, orders the files in a <code>Tk::Tree</code> widget, and changes the page ranges and the bookmarks text in <code>Tk::Entry</code> fields. Furthermore, the application can store the resulting tree structure inside a session file and restored that later on. It's also possible to copy and paste entries inside the tree, which makes it easy to create a bookmarks panel for single files without using bookmark files. The Tk application can be found in the download at the end of this article.</p>

<p>Beside the final PDF file, the application creates a file with the same basename and the <em>.cnt</em> extension. This file contains the bookmarks for the PDF. It's also useful to continue the processing of the combined PDF file instead of reassembling all the source files again. The entry for this feature is <code>File-&gt;Load Bookmarks-File</code>.</p>

<p>When loading a bookmarks file, the same extension convention is in place.</p>

<h3>Other PDF Packages on CPAN</h3>

<p>I like <code>PDF::Reuse</code>, but there are several other options for PDF creation and manipulation on the CPAN.</p>

<ul>
<li><a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a>, by Alfred Reibenschuh, is actively maintained. It is the package of choice if creating new PDF documents from scratch.</li>

<li><a href="http://search.cpan.org/dist/PDF-API2-Simple/">PDF::API2::Simple</a>, by Red Tree Systems, is a wrapper over the <code>PDF::API2</code> module for users who find the PDF::API2 module to difficult to use.</li>

<li><a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a>, by Martin Hosken, can work on more than PDF file at the same time and has Truetype font support.</li>

<li><a href="http://search.cpan.org/dist/CAM-PDF">CAM::PDF</a>, by Clotho Advanced Media, is like <code>PDF::Reuse</code> more focused on reading and manipulating existing PDF documents. However, it can work on multiple files at the same time. Use it if you need more features than <code>PDF::Reuse</code> actually provides.</li>
</ul>

<h3>Conclusions</h3>

<p><code>PDF::Reuse</code> is a well-written and well-documented package, which makes it easy to create, combine, and change existing PDF documents. The two sample applications show some of its capabilities. Two limitations should be mentioned however, <code>PDF::Reuse</code> can't reuse existing bookmarks, and after combining different PDF documents some of the inner document hyperlinks might stop working properly. The <a href="/2007/09/20/pdf_reuse.zip">example source code</a> for the applications, packages, and the modified <code>PDF::Reuse</code> is available.</p>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-664" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="http://com.perl.org/pub/2007/08/09/making-perl-modules.html" rel="bookmark">Making Perl Reusable with Modules</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Andy Sylvester</span> on <abbr class="published" title="2007-08-07T00:00:00-08:00">August  7, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Perl software development can occur at several levels. When first developing the idea for an application, a Perl developer may start with a short program to flesh out the necessary algorithms. After that, the next step might be to create a package to support object-oriented development. The final work is often to create a Perl module for the package to make the logic available to all parts of the application. Andy Sylvester explores this topic with a simple mathematical function.</p>

<h3>Creating a Perl Subroutine</h3>

<p>I am working on ideas for implementing some mathematical concepts for a method of composing music. The ideas come from the work of <a href="http://en.wikipedia.org/wiki/Joseph_Schillinger">Joseph Schillinger</a>. At the heart of the method is being able to generate patterns using mathematical operations and using those patterns in music composition. One of the basic operations described by Schillinger is creating a "resultant," or series of numbers, based on two integers (or "generators"). Figure 1 shows a diagram of how to create the resultant of the integers 5 and 3.</p>

<p><img src="/pub/2007/08/09/graphics/Figure1.jpg" alt="creating the resultant of 5 and 3" /><br />
<em>Figure 1. Creating the resultant of 5 and 3</em></p>

<p>Figure 1 shows two line patterns with units of 5 and units of 3. The lines continue until both lines come down (or "close") at the same time. The length of each line corresponds to the product of the two generators (5 x 3 = 15). If you draw dotted lines down from where each of the two generator lines change state, you can create a third line that changes state at each of the dotted line points. The lengths of the segments of the third line make up the resultant of the integers 5 and 3 (3, 2, 1, 3, 1, 2, 3).</p>

<p>Schillinger used graph paper to create resultants in his <a href="http://www.schillingersystem.com/whatis.htm">System of Musical Composition</a>. However, another convenient way of creating a resultant is to calculate the modulus of a counter and then calculate a term in the resultant series based on the state of the counter. An algorithm to create the terms in a resultant might resemble:</p>

<pre><code>Read generators from command line
Determine total number of counts for resultant
   (major_generator * minor_generator)
Initialize resultant counter = 0
For MyCounts from 1 to the total number of counts
   Get the modulus of MyCounts to the major and minor generators
   Increment the resultant counter
   If either modulus = 0
     Save the resultant counter to the resultant array
     Re-initialize resultant counter = 0
   End if
End for</code></pre>

<p>From this design, I wrote a short program using the Perl modulus operator (<code>%</code>):</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# FILENAME: result01.pl
#
# USAGE: perl result01.pl major_generator minor_generator
#
# DESCRIPTION:
#    This Perl script will generate a Schillinger resultant
#    based on two integers for the major generator and minor
#    generator.
#
#    In normal usage, the user will input the two integers
#    via the command line. The sequence of numbers representing
#    the resultant will be sent to standard output (the console
#    window).
#
# INPUTS:
#    major_generator - First generator for the resultant, input
#                      as the first calling argument on the
#                      command line.
#
#    minor_generator - Second generator for the resultant, input
#                      as the second calling argument on the
#                      command line.
#
# OUTPUTS:
#    resultant - Sequence of numbers written to the console window
#
#**************************************************************

   use strict;
   use warnings;

   my $major_generator = $ARGV[0];
   my $minor_generator = $ARGV[1];

   my $total_counts   = $major_generator * $minor_generator;
   my $result_counter = 0;
   my $major_mod      = 0;
   my $minor_mod      = 0;
   my $i              = 0;
   my $j              = 0;
   my @resultant;

   print "Generator Total = $total_counts\n";

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $major_generator;
       $minor_mod = $i % $minor_generator;
       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@resultant, $result_counter);
          $result_counter = 0;
       }
       print "$i \n";
       print "Modulus of $major_generator is $major_mod \n";
       print "Modulus of $minor_generator is $minor_mod \n";
   }

   print "\n";
   print "The resultant is @resultant \n";</code></pre>

<p>Run the program with 5 and 3 as the inputs (<code>perl result01.pl 5 3</code>):</p>

<pre><code>Generator Total = 15
1
Modulus of 5 is 1
Modulus of 3 is 1
2
Modulus of 5 is 2
Modulus of 3 is 2
3
Modulus of 5 is 3
Modulus of 3 is 0
4
Modulus of 5 is 4
Modulus of 3 is 1
5
Modulus of 5 is 0
Modulus of 3 is 2
6
Modulus of 5 is 1
Modulus of 3 is 0
7
Modulus of 5 is 2
Modulus of 3 is 1
8
Modulus of 5 is 3
Modulus of 3 is 2
9
Modulus of 5 is 4
Modulus of 3 is 0
10
Modulus of 5 is 0
Modulus of 3 is 1
11
Modulus of 5 is 1
Modulus of 3 is 2
12
Modulus of 5 is 2
Modulus of 3 is 0
13
Modulus of 5 is 3
Modulus of 3 is 1
14
Modulus of 5 is 4
Modulus of 3 is 2
15
Modulus of 5 is 0
Modulus of 3 is 0

The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This result matches the resultant terms as shown in the graph in Figure 1, so it looks like the program generates the correct output.</p>













<h3>Creating a Perl Package from a Program</h3>

<p>With a working program, you can create a Perl package as a step toward being able to reuse code in a larger application. The initial program has two pieces of input data (the major generator and the minor generator). The single output is the list of numbers that make up the resultant. These three pieces of data could be combined in an object. The program could easily become a subroutine to generate the terms in the resultant. This could be a method in the class contained in the package. Creating a class implies adding a constructor method to create a new object. Finally, there should be some methods to get the major generator and minor generator from the object to use in generating the resultant (see the <a href="http://perldoc.perl.org/perlboot.html">perlboot</a> and <a href="http://perldoc.perl.org/perltoot.html">perltoot</a> tutorials for background on object-oriented programming in Perl).</p>

<p>From these requirements, the resulting package might be:</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# Filename: result01a.pl
#
# Description:
#    This Perl script creates a class for a Schillinger resultant
#    based on two integers for the major generator and the
#    minor generator.
#
# Class Name: Resultant
#
# Synopsis:
#
# use Resultant;
#
# Class Methods:
#
#   $seq1 = Resultant -&gt;new(5, 3)
#
#      Creates a new object with a major generator of 5 and
#      a minor generator of 3. These parameters need to be
#      initialized when a new object is created, as there
#      are no methods to set these elements within the object.
#
#   $seq1-&gt;generate()
#
#      Generates a resultant and saves it in the ResultList array
#
# Object Data Methods:
#
#   $major_generator = $seq1-&gt;get_major()
#
#      Returns the major generator
#
#   $minor_generator = $seq1-&gt;get_minor()
#
#      Returns the minor generator
#
#
#**************************************************************

{ package Resultant;
  use strict;
  sub new {
    my $class           = shift;
    my $major_generator = shift;
    my $minor_generator = shift;

    my $self = {Major =&gt; $major_generator,
                Minor =&gt; $minor_generator,
                ResultantList =&gt; []};

    bless $self, $class;
    return $self;
  }

  sub get_major {
    my $self = shift;
    return $self-&gt;{Major};
  }

  sub get_minor {
    my $self = shift;
    return $self-&gt;{Minor};
  }

  sub generate {
    my $self         = shift;
    my $total_counts = $self-&gt;get_major * $self-&gt;get_minor;
    my $i            = 0;
    my $major_mod;
    my $minor_mod;
    my @result;
    my $result_counter = 0;

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $self-&gt;get_major;
       $minor_mod = $i % $self-&gt;get_minor;

       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@result, $result_counter);
          $result_counter = 0;
       }
   }

   @{$self-&gt;{ResultList}} = @result;
  }
}

#
# Test code to check out class methods
#

# Counter declaration
my $j;

# Create new object and initialize major and minor generators
my $seq1 = Resultant-&gt;new(5, 3);

# Print major and minor generators
print "The major generator is ", $seq1-&gt;get_major(), "\n";
print "The minor generator is ", $seq1-&gt;get_minor(), "\n";

# Generate a resultant
$seq1-&gt;generate();

# Print the resultant
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>Execute the file (<code>perl result01a.pl</code>):</p>

<pre><code>The major generator is 5
The minor generator is 3
The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This output text shows the same resultant terms as produced by the first program.</p>

<h3>Creating a Perl Module</h3>

<p>From a package, you can create a Perl module to make the package fully reusable in an application. Also, you can modify our original test code into a series of module tests to show that the module works the same as the standalone package and the original program.</p>

<p>I like to use the Perl module <a href="http://search.cpan.org/perldoc?Module::Starter">Module::Starter</a> to create a skeleton module for the package code. To start, install the <code>Module::Starter</code> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Module::Starter</code> module installed, type <code>perldoc Module::Starter</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Select a working directory to create the module directory. This can be the same directory that you have been using to develop your Perl program. Type the following command (though with your own name and email address):</p>

<pre><code>$ <strong>module-starter --module=Music::Resultant --author="John Doe" \
    --email=john@johndoe.com</strong></code></pre>

<p>Perl should respond with:</p>

<pre><code>Created starter directories and files</code></pre>

<p>In the working directory, you should see a folder or directory called <em>Music-Resultant</em>. Change your current directory to <em>Music-Resultant</em>, then type the commands:</p>

<pre><code>$ <strong>perl Makefile.PL</strong>
$ <strong>make</strong></code></pre>

<p>These commands will create the full directory structure for the module. Now paste the text from the package into the module template at <em>Music-Resultant/lib/Music/Resultant.pm</em>. Open <em>Resultant.pm</em> in a text editor and paste the subroutines from the package after the lines:</p>

<pre><code>=head1 FUNCTIONS

=head2 function1

=cut</code></pre>

<p>When you paste the package source code, remove the opening brace from the package, so that the first lines appear as:</p>

<pre><code> package Resultant;
  sub new {
    use strict;
    my $class = shift;</code></pre>

<p>and the last lines of the source appears without the the final closing brace as:</p>

<pre><code>   @{$self-&gt;{ResultList}} = @result;
  }</code></pre>

<p>After making the above changes, save <em>Resultant.pm</em>. This is all that you need to do to create a module for your own use. If you eventually release your module to the Perl community or upload it to <a href="http://www.cpan.org/">CPAN</a>, you should do some more work to prepare the module and its documentation (see the <a href="http://perldoc.perl.org/perlmod.html">perlmod</a> and <a href="http://perldoc.perl.org/perlmodlib.html">perlmodlib</a> documentation for more information).</p>













<p>After modifying <em>Resultant.pm</em>, you need to install the module to make it available for other Perl applications. To avoid configuration issues, install the module in your home directory, separate from your main Perl installation.</p>

<ol>
<li>
<p>In your home directory, create a <em>lib/</em> directory, then create a <em>perl/</em> directory within the <em>lib/</em> directory. The result should resemble:</p>

<pre><code>/home/myname/lib/perl</code></pre>
</li>

<li>
<p>Go to your module directory (<em>Music-Resultant</em>) and re-run the build process with a directory path to tell Perl where to install the module:</p>

<pre><code>$ <strong>perl Makefile.PL LIB=/home/myname/lib/perl</strong> $
<strong>make install</strong></code></pre>

<p>Once this is complete, the module will be installed in the directory.</p>
</li>
</ol>

<p>The final step in module development is to add tests to the <em>.t</em> file templates created in the module directory. The Perl distribution includes several built-in test modules, such as <a href="http://search.cpan.org/perldoc?Test::Simple">Test::Simple</a> and <a href="http://search.cpan.org/perldoc?Test::More">Test::More</a> to help test Perl subroutines and modules.</p>

<p>To test the module, open the file <em>Music-Resultant/t/00-load.t</em>. The initial text in this file is:</p>

<pre><code>#!perl -T

use Test::More tests =&gt; 1;

BEGIN {
    use_ok( 'Music::Resultant' );
}

diag( "Testing Music::Resultant $Music::Resultant::VERSION, Perl $], $^X" );</code></pre>

<p>You can run this test file from the <em>t/</em> directory using the command:</p>

<pre><code>perl -I/home/myname/lib/perl -T 00-load.t</code></pre>

<p>The <code>-I</code> switch tells the Perl interpreter to look for the module <em>Resultant.pm</em> in your alternate installation directory. The directory path must immediately follow the <code>-I</code> switch, or Perl may not search your alternate directory for your module. The <code>-T</code> switch is necessary because there is a <code>-T</code> switch in the first line of the test script, which turns on taint checking. (Taint checking only works when enabled at Perl startup; <code>perl</code> will exit with an error if you try to enable it later.) Your results should resemble the following(your Perl version may be different).</p>

<pre><code>1..1
ok 1 - use Music::Resultant;
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>The test code from the second listing is easy to convert to the format used by <code>Test::More</code>. Change the number at the end of the tests line from 1 to 4, as you will be adding three more tests to this file. The template file has an initial test to show that the module exists. Next, add tests after the <code>BEGIN</code> block in the file:</p>

<pre><code># Test 2:
my $seq1 = Resultant-&gt;new(5, 3);  # create an object
isa_ok ($seq1, Resultant);        # check object definition

# Test 3: check major generator
my $local_major_generator = $seq1-&gt;get_major();
is ($local_major_generator, 5, 'major generator is correct' );

# Test 4: check minor generator
my $local_minor_generator = $seq1-&gt;get_minor();
is ($local_minor_generator, 3, 'minor generator is correct' );</code></pre>

<p>To run the tests, retype the earlier command line in the <em>Music-Resultant/</em> directory:</p>

<pre><code>$ <strong>perl -I/home/myname/lib/perl -T t/00-load.t</strong></code></pre>

<p>You should see the results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>These tests create a Resultant object with a major generator of 5 and a minor generator of 3 (Test 2), and check to see that the major generator in the object is correct (Test 3), and that the minor generator is correct (Test 4). They do <em>not</em> cover the resultant terms. One way to check the resultant is to add the test code used in the second listing to the <em>.t</em> file:</p>

<pre><code># Generate a resultant
$seq1-&gt;generate();

# Print the resultant
my $j;
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>You should get the following results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
The resultant is 3 2 1 3 1 2 3
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>That's not valid test output, so it needs a little bit of manipulation. To check the elements of a list using a testing function, install the <a href="http://search.cpan.org/perldoc?Test::Differences">Test::Differences</a> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Test::Differences</code> module installed, type <code>perldoc Test::Differences</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Once that module is part of your Perl installation, change the number of tests from 4 to 5 on the <code>Test::More</code> statement line and add a following statement after the <code>use Test::More</code> statement:</p>

<pre><code>use Test::Differences;</code></pre>

<p>Finally, replace the code that prints the resultant with:</p>

<pre><code># Test 5: (uses Test::Differences and associated modules)
$seq1-&gt;generate();
my @result   = @{$seq1-&gt;{ResultList}};
my @expected = (3, 2, 1, 3, 1, 2, 3);
eq_or_diff \@result, \@expected, "resultant terms are correct";</code></pre>

<p>Now when the test file runs, you can confirm that the resultant is correct:</p>

<pre><code>1..5
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
ok 5 - resultant terms are correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<h3>Summary</h3>

<p>There are multiple levels of Perl software development. Once you start to create modules to enable reuse of your Perl code, you will be able to leverage your effort into larger applications. By using Perl testing modules, you can ensure that your code works the way you expect and provide a way to ensure that the modules continue to work as you add more features.</p>

<h3>Resources</h3>

<p>Here are some other good resources on creating Perl modules:</p>

<ul>
<li><a href="http://world.std.com/~swmcd/steven/perl/module_mechanics.html">Perl Module Mechanics</a> goes into detail about the various files created when you create a module directory.</li>

<li><a href="http://mathforum.org/~ken/perl_modules.html">Creating (and Maintaining) Perl Modules</a> includes information on coding, documentation, testing, and installation.</li>

<li><a href="http://www.perlmonks.org/?node_id=431702">Jose's Guide for creating Perl modules</a> gives some helpful tips on getting a module ready for CPAN distribution.</li>
</ul>

<p>Here are some good resources for using Perl testing modules like <code>Test::Simple</code> and <code>Test::More</code>:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?Test::Tutorial">Test::Tutorial</a> gives the basics of using <code>Test:Simple</code> and <code>Test::More</code>.</li>

<li><a href="http://www.perl.com/pub/a/2001/12/04/testing.html">An Introduction to Testing</a> presents the benefits of developing tests and code at the same time, and provides a variety of examples.</li>
</ul>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>



                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-recent-entries widget-archives widget">
    <h3 class="widget-header">Recent Entries</h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="http://com.perl.org/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html">Beginner's Introduction to Perl 5.10, Part 2</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2008/04/23/a-beginners-introduction-to-perl-510.html">A Beginner's Introduction to Perl 5.10</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2008/04/08/using-amazon-s3-from-perl.html">Using Amazon S3 from Perl</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2008/03/14/reverse-callback-templating.html">Reverse Callback Templating</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2008/02/13/elements-of-access-control.html">Elements of Access Control</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2008/01/18/how-to-tell-your-perl-story.html">How to Tell Your Perl Story (at OSCON)</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2007/12/21/20-years-of-perl.html">Memories of 20 Years of Perl</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2007/12/06/soto-11.html">Programming is Hard, Let's Go Scripting...</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2007/09/20/pdf-processing-with-perl.html">PDF Processing with Perl</a></li>
        
    
        
            <li><a href="http://com.perl.org/pub/2007/08/09/making-perl-modules.html">Making Perl Reusable with Modules</a></li>
        
        </ul>
    </div>
</div>
        
    



<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="http://com.perl.org/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="http://com.perl.org/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="http://com.perl.org/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
