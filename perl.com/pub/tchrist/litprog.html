<!-- INDEX BEGIN -->
<table width="180" cellspacing="0" cellpadding="4" align="right" border="1">
<tr>
<td align="center" valign="top" bgcolor="#6097cf">
<font color="#ffffff">Table of Contents</td>
</tr>
<tr>
<td>

&#149;<a href="#POD_is_Not_Literate_Programming">POD is Not Literate Programming</a><br />
&#149;<a href="#What_is_Literate_Programming_">What is Literate Programming?</a><br />
&#149;<a href="#How_Literate_Programming_Works">How Literate
 Programming Systems Work</a><br />
&nbsp;&nbsp;&nbsp;&#149;<a href="#C_tangle_"><code>tangle</code></a><br />
&nbsp;&nbsp;&nbsp;&#149;<a href="#C_weave_"><code>weave</code></a><br />
&#149;<a href="#Summary">Summary</a><br />

</td>
</tr>
</table>
<!-- INDEX END -->

<p>
I frequently come across assertions that POD, Perl's documentation
system, is an example of `Literate Programming'. For example, FOLDOC, the Free
On-Line Dictionary of Computing, says <a href="http://burks.bton.ac.uk/burks/foldoc/35/63.htm">``Perl's literate programming
system is called pod.''</a> The manual
for Ian Clatworthy's Simple Document Format (SDF) package says <a href="http://www.mincom.com/mtr/sdf/paper/sdfintro.html#POD">``Like
SDF, POD supports literate programming.''</a> But POD is <em>not</em>
literate programming.</p>

<p>
Why is this important? POD is a really good idea. But literate programming
is an even better idea. Perl has a long history of borrowing good ideas
from elsewhere. If we go around thinking that POD is literate programming
when it isn't, that'll lead us to disregard literate programming when we
hear about it. ``Oh, I already know what that is,'' we'll say. But we <em>don't</em> know what it is, and since it's such an excellent idea, it would be a shame
if we missed out on it just because we thought we already knew what it was.

<h1><a name="What_is_Literate_Programming_">What is Literate Programming?</a></h1>
<p>
Literate programming was invented around 1983 by the very famous Donald Knuth,
author of the TeX typesetting system and the multi-volume series <em>The Art of Computer Programming</em>. It is based on two important ideas.

<p>
The first idea is that good program documentation shouldn't be squeezed
into little `comments'. It should be structured more like a technical
article for a journal, and it should have all the support that a journal
article usually gets, including good typesetting. The programmer should
have the opportunity to annotate each section of the code with as much
explanation as is necessary and appropriate.

<p>
So far this sounds just like POD. Where POD comes up short is in the other
important idea.  

<p>
Knuth's other idea was that the best order to explain the parts of the
program in a journal article is not going to be the same as the order that
the computer needs to see the code. When you write a computer program, you
have to present the code to the computer in a certain order, or else it
doesn't work. This order might not be a good order for explaining the way
the program works.

<p>
For example, you might have

<p>
<pre>        unless (open(F, &quot;&lt; $file&quot;)) {
           # 55 lines of error handling here ...        
        }
</pre>
<p>
<pre>        $line = &lt;F&gt;;
</pre>
<p>
When you're explaining the program to someone else, you want to talk about
opening the file and reading a line. You don't want to have to interrupt
yourself with a huge digression about the error handling just because the
computer language you're using requires that you put the error handling in
between the open and the read; you'd might prefer to talk about the main
logic first, and return to discuss the error-handling part much later.  

<p>
For the same reason, having the error handling code in the middle there is
no just an impediment to you when you try to explain the code, it's also an
impediment to another programmer trying to understand the code. One
frequent criticism of C is that it's too hard to follow the flow of logic
because it is visually dominated by block after block of error handling
code.

<p>
It's sometimes possible to work around this kind of problem by using
subroutines or exceptions or some other kind of non-local control flow, but
Knuth's idea goes right to the heart of the problem. When you program in a
literate programming system, you get to write the code in any order you
want to. The literate programming system comes with a utility program,
usually called <code>tangle</code>, which permutes the code into the right order so that you can compile or
execute it.

<p>
Perl doesn't have anything like <code>tangle</code>. You can write comments and typeset them with your favorite typesetting
system, but you still have to explain the code in an order that makes sense
for the perl interpreter, and not for the person who's trying to understand
it.

<h1><a name="How_Literate_Programming_Works">How Literate Programming Systems Work</a></h1>
<p>
The world's full of examples of literate programming in action; see the
links at the end of this article. Here's a super-simple incomplete example,
to give you the idea.

<p>
This is a fragment of a typical file written in the literate programming
style. You should focus on the main idea, rather than on the details of
syntax, because this example was written for a notional literate
programming system that doesn't actually exist.

<p>
<pre>
        # much code omitted....
        =head1 Open the file
        
        First we will need to open the file.  Blah blah blah.  In a
        real example, this might be much more complicated and might
        require an extended explanation such as a description of the
        algorithm or pictures of the data structures.

        =cut

        unless (open FH, $file) {
          &lt;&lt;handle the errors&gt;&gt;
        }

        =head1 Handle the errors
        
        If `normal' errors occur, we will just ask the user for a new
        filename.  `Normal' errors are if the file doesn't exist
        (perhaps the user mispelled the name) or if the user lacks
        permission to read it.  In case of some other error, such as
        `disk is on fire', the program will abort immediately.

        =cut

        if (   $! =~ /no such file/i
            || $! =~ /permission denied/i) {
          warn &quot;Could not open file `$file': $!.\n&quot;;
          &lt;&lt;get new filename and start over&gt;&gt;
        }

        =head1 Process input

        Notice how we don't need to deal with ``get new filename and
        start over'' until we feel like it.  We have postponed that
        section for later.

        =cut

        # and so on...
</pre>
<p>
The file is divided up into sections. Each section has some documentation,
a title, and some code. The code might be incomplete; if it contains <code>&lt;&lt;title&gt;&gt;</code> then that means the code from another section should be inserted at that
point.

<!-- <a name="C_tangle_"><code>tangle</code></a> -->
<p>
A literate programming system comes with two important programs. One,
typically called <code>tangle</code>, discards the documentation sections and rearranges the code into the
right order. The output of tangling the example above would look something
like this:

<p>
<pre>
        # Open the file
        unless (open FH, $file) {
          # handle the errors
        if (   $! =~ /no such file/i
            || $! =~ /permission denied/i) {
          warn &quot;Could not open file `$file': $!.\n&quot;;
           #Get new filename and start over
           print &quot;Enter new filename: &quot;;
           #[Etc.]
        }
</pre>
<p>
This actually runs. The code from `Handle the errors' was inserted into the
appropriate place in `Open the file', and the code from `Get new filename
and start over' (which I didn't show before) was inserted into the
appropriate place in `Handle the errors'. This code is ugly, but no uglier
than the output of the C preprocessor, or a C compiler. Just consider the
output of <code>tangle</code> to be object code: You can run it, but you don't want to look at it.

<h2><a name="C_weave_"><code>weave</code></a></h2>
<p>
The other important program that comes with a literate programming system
is typically called <code>weave</code>. It formats and typesets the documentation and the code, generates an
appropriate index and table of contents, and so on. The result of running <code>weave</code> on our example above might look something like this:

<p align=center>
<table width=80%>
<tr><td bgcolor="#dddddd">
<h4><a name="open_the_file">Open the file</a></h4>
        
<p>First we will need to open the file.  Blah blah blah.  In a
real example, this might be much more complicated and might
require an extended explanation such as a description of the
algorithm or pictures of the data structures.</p>

<pre>
unless (open FH, <b>$file</b>) {
  <a href="#handle_the_errors"><i>handle the errors</i></a>
}
</pre>

<h4><a name="handle_the_errors">Handle the errors</a></h4>
        
<p>If `normal' errors occur, we will just ask the user for a new
filename.  `Normal' errors are if the file doesn't exist (perhaps the
user mispelled the name) or if the user lacks permission to read it.
In  case of some other error, such as `disk is on fire', the program
will abort immediately.</p>

<pre>
warn "Could not open file `<b>$file</b>': <b>$!</b>.\n";
if (   <b>$!</b> =~ /no such file/i
    || <b>$!</b> =~ /permission denied/i) {
  <a name="get_new_filename_and_start_over"><i>get new filename and start over</i></a>
} else {
  exit 1;
}
</pre>

<h4><a name="process_input">Process input</a></h4>

<p>        Notice how we don't need to deal with ``get new filename and
        start over'' until we feel like it.  We have postponed that
        section for later.</p>

<pre>
# Much omitted...
</pre>

<h3><a name="#INDEX">Index</a></h3>

<ul>
  <li><a href="#get_new_filename_and_start_over">Get new filename and start over</a>
  <li><a href="#handle_the_errors">Handle the errors</a>
  <li><a href="#open_the_file">Open the file</a>
  <li><a href="#process_input">Process input</a>
</ul>
</td></tr>
</table></p>

<h1><a name="Summary">Summary</a></h1>
<p>
Literate programming systems have the following properties:

<ol>
<li>
<p>
Code and extended, detailed comments are intermingled.

<li>
<p>
The code sections can be written in whatever order is best for people to
understand, and are re-ordered automatically when the computer needs to run
the program.

<li>
<p>
The program and its documentation can be handsomely typeset into a single
article that explains the program and how it works. Indices and
cross-references are generated automatically.

</ol>
<p>
POD only does task 1, but the other tasks are much more important.

<p>
Literate programming is an intersting idea, and worth looking into, but if we think that we
already know all about it, we won't bother.   Let's bother.
For an introduction, <a href="http://www.literateprogramming.com/knuthweb.pdf">see
Knuth's original paper</a>
which has a short but complete example. For a slightly longer example,
<a href="http://www.plover.com/~mjd/23tree.tgz">here's a library I
wrote in literate style</a>
that manages 2-3 trees in C.</p>


<p>
Andrew Johnson's new book <a href="http://www.manning.com/Johnson/"><em>Elements of Programming with Perl</em></a> uses literate programming techniques extensively, and shows the source code
for a literate programming system written in Perl.</p>

<p>Finally, 
<a href="http://www.literateprogramming.com/">the Literate Programming web site</a> has
links to many other resources, including literate programming
environments that you can try out yourself.
</p>
