<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Objects Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Objects</em> Category</h1>






                            
                            <div id="entry-698" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/08/sequence-diagrams.html" rel="bookmark">Generating UML and Sequence Diagrams</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Phil Crow</span> on <abbr class="published" title="2006-08-03T00:00:00-08:00">August  3, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Imagine yourself in a meeting with management. You're about to begin your third attempt to explain how to process online credit card payments. After a couple of sentences, you see some eyes glazing over. Someone says, "Perhaps you could draw us a picture."</p>

<p>Imagine me handling a recent request from my boss. He came in to the bat cave and said (in summary), "We want customers to sign up for email accounts without calling customer service. All the account creation code is in the customer care app." It didn't take long to find the relevant web screen, where the CSR presses Save to kick off the account creation, but there sure were a lot of layers between there and the final result. Keeping them in mind is hard enough when I'm deep in the problem. Three months from now, when an odd bug surfaces, it'll be nearly impossible without the right memory aid.</p>

<p>In both of these cases, the right diagram is the sequence diagram. (I'd show you mine for the situations above, but they're secret.) Sequence diagrams clearly show the time flow of method or function calls between modules. For complex systems, these diagrams can save a lot of time--like the time you and your fellow programmers spend during initial design, the time spent explaining what's possible to management, the time you spend remembering how things work when you revisit an old system that needs a new feature, and especially the time it takes a new programmer in your shop to get up to speed.</p>

<p>In short, sequence diagrams help with complex call stacks just as data model diagrams help with complex database schema.</p>

<p>While the sequence diagram is useful to me, I don't like on-screen drawing tools. Therefore, I wrote the original <a href="http://search.cpan.org/perldoc?UML::Sequence"><code>UML::Sequence</code></a> to make the drawings for me. With recent help from Dean Arnold, the current version has many nice features and is closer to standards compliance (but, both Dean and I prefer a useful diagram to a compliant one). Using <code>UML::Sequence</code>, you can quickly make proposed diagrams of systems not yet built. You can even run it against existing programs to have it diagram what they actually do.</p>

<h3>Reading a Sequence Diagram</h3>

<p>If you already know how to read sequence diagrams, you can skip to the next section.</p>

<p>Because most uses of UML involve object-oriented projects, that's where I've drawn my examples. Don't think that objects are necessary for sequence diagrams. I've diagrammed many non-OO programs with it (including some in COBOL).</p>

<p>A simple example will work best for a first look at UML sequence diagrams, so consider rolling two dice. My over-engineered solution gives a nice diagram to discuss. In it, I made each die an object of the <code>Die</code> class and the pair of dice an object of the <code>DiePair</code> class. To roll the dice, I wrote a little script. Here are these pieces:</p>

<pre><code>    package Die;
    use strict;

    sub new {
        my $class = shift;
        my $sides = shift || 6;
        return bless { SIDES =&gt; $sides }, $class;
    }

    sub roll {
        my $self       = shift;
        $self-&gt;{VALUE} = int( rand * $self-&gt;{SIDES} ) + 1;

        return $self-&gt;{VALUE};
    }

    1;</code></pre>

<p>The <code>Die</code> constructor takes an optional number of sides for the new die object, but supplies six as a default. It bundles that number of sides into a hash reference, blesses, and returns it.</p>

<p>The <code>roll()</code> method makes a random number and uses it to pick a new value for the die, which it returns.</p>

<p><code>DiePair</code> is equally scintillating:</p>

<pre><code>    package DiePair;
    use strict;

    use Die;

    sub new {
        my $class     = shift;
        my $self      = {};
        $self-&gt;{DIE1} = Die-&gt;new( shift );
        $self-&gt;{DIE2} = Die-&gt;new( shift );

        return bless $self, $class;
    }

    sub roll {
        my $self   = shift;
        my $value1 = $self-&gt;{DIE1}-&gt;roll();
        my $value2 = $self-&gt;{DIE2}-&gt;roll();

        $self-&gt;{TOTAL}   = $value1 + $value2;
        $self-&gt;{DOUBLES} = ( $value1 == $value2 ) ? 1 : 0;

        return $self-&gt;{TOTAL}, $self-&gt;{DOUBLES};
    }

    1;</code></pre>

<p>The constructor makes two die objects and stores them in a hash reference, which it blesses and returns.</p>

<p>The <code>roll()</code> method rolls each die, storing the value, then totals them and decides whether the roll was doubles. It returns both total and doubles, saving the driver from having to call back for them.</p>

<p>Rather than modeling a real game like craps, I use a small driver, which will simplify the resulting diagram.</p>

<pre><code>    #!/usr/bin/perl
    use strict;

    use DiePair;

    my $die_pair          = DiePair-&gt;new(6, 6);
    my ($total, $doubles) = $die_pair-&gt;roll();

    print "Your total is $total ";
    print "it was doubles" if $doubles;
    print "\n";</code></pre>

<p>Figure 1 shows the sequence diagram for this driver.</p>

<p><img src="/pub/2006/08/03/graphics/roller.gif" alt="the sequence diagram for the die roller" /><br />
<em>Figure 1. The sequence diagram for the die roller</em></p>

<p>Each package has a box at the top of the diagram. The script is in the <code>main</code> package (which is always Perl's default). Time flows from top to bottom. Arrows represent method (or function) calls.</p>

<p>The vertical boxes, or <em>activations</em>, represent the life of a call. Between the activations are dashed lines called the <em>life lines</em> of the objects.</p>

<p>You can see that <code>main</code> begins first (because its first activation is higher than the others). It calls <code>new()</code> on the <code>DiePair</code> class. That call lasts long enough for <code>DiePair</code>'s constructor to call <code>new()</code> on the <code>Die</code> class twice.</p>

<p>After making the objects, the script calls <code>roll()</code> on the <code>DiePar</code>, which forwards the request to the individual dice.</p>

<p>This diagram is unorthodox. The boxes at the top <em>should</em> represent individual instances, not classes. Sometimes I prefer this style because it compacts the diagram horizontally. Figure 2 shows a more orthodox diagram (divergent only in the lack of name underlining).</p>

<p><img src="/pub/2006/08/03/graphics/rollerinst.gif" alt="a more orthodox UML diagram" /><br />
<em>Figure 2. A more orthodox UML diagram</em></p>

<p>You can see the individual <code>Die</code> objects that the <code>DiePair</code> instance aggregates, because there is now a box at the top for each object (use your imagination when thinking about the driver as an instance). The names do not come from the code; they are sequentially assigned from the class name.</p>

<p>Diagrams like this are especially helpful when many classes interact. For instance, many of them start with a user event (like a button press on a GUI application) and show how the view communicates with the controller and how the controller in turn communicates with the data model.</p>

<p>Another particularly useful application is for programs communicating via network sockets. In their diagrams, each program has a box, and the arrows represent writing on a socket. Note that UML sequence diagrams may also have dashed arrows, which show return values going back to callers. Unless there is something unusual about that value, there is no use to waste space on the diagram for those returns. However, in a network situation, showing the back and forth can be quite helpful. <code>UML::Sequence</code> now has support for return arrows.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/2403" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3>Using UML::Sequence</h3>

<p>Now that you understand how to read a sequence diagram, I can show you how to make them without mouse-driven drawing tools.</p>

<p>Making diagrams with <code>UML::Sequence</code> is a three-step process:</p>

<ol>
<li>Create a program or a text file.</li>

<li>Use <em>genericseq.pl</em> to create an XML description of the diagram.</li>

<li>Use a rendering script to turn the XML into an image file.</li>
</ol>

<p>If the image is in the wrong format for your purposes, you might need an extra step to convert to another format.</p>

<h4>Running Perl Programs</h4>

<p>Here is how I generated Figure 1 above by running the driver program. If your program is in Perl, you can use this approach (see the next subsection for Java programs).</p>

<p>First, create a file listing the subs you want to see in the diagram:</p>

<pre><code>    DiePair::new
    DiePair::roll
    Die::new
    Die::roll</code></pre>

<p>I called this file <em>roller.methods</em> to correspond to the script's name, <em>roller</em>. When you make your method list, remember that sequence diagrams are visual space hogs, so pick a short list of the most important methods.</p>

<p>Then, run the program through the <code>genericseq.pl</code> script:</p>

<pre><code>$ <strong>genericseq.pl UML::Sequence::PerlSeq roller.methods roller &gt; roller.xml</strong></code></pre>

<p><a href="http://search.cpan.org/perldoc?UML::Sequence::PerlSeq"><code>UML::Sequence::PerlSeq</code></a> uses the Perl debugger's hooks to profile the code as it runs, watching for the methods listed in <em>roller.methods</em>. The result is an XML file describing the calls that actually happened during this run.</p>

<p>To turn this into a picture, use one of the image scripts:</p>

<pre><code>$ <strong>seq2svg.pl roller.xml &gt; roller.svg</strong></code></pre>

<p>Obviously, <code>seq2svg.pl</code> makes SVG images. If you have no way to view those, get Firefox 1.5, use a tool like the batik rasterizer, or use <code>seq2rast.pl</code>, which makes PNG images directly using the <a href="http://search.cpan.org/perldoc?GD"><code>GD</code></a> module.</p>

<p>If you want diagrams like Figure 2, use <a href="http://search.cpan.org/perldoc?UML::Sequence::PerlOOSeq"><code>UML::Sequence::PerlOOSeq</code></a> in place of <code>UML::Sequence::PerlSeq</code> when you run <code>genericseq.pl</code>.</p>

<h4>Running Java Programs</h4>

<p>I wrote <code>UML::Sequence</code> while working as a Java programmer, so I made it work on Java (at least sometimes it works). The process is similar to the above. First, make a methods file:</p>

<pre><code>    ALL
    Roller
    DiePair
    Die</code></pre>

<p>Here I use <code>ALL</code> to mean all methods from the following classes. You can also list full signatures (but they have to be full, valid, and expressed in the internal signature format as if generated by <code>javap</code>).</p>

<p>Then run <code>genericseq.pl</code> with <a href="http://search.cpan.org/perldoc?UML::Sequence::JavaSeq">UML::Sequence::JavaSeq</a> in place of <code>UML::Sequence::PerlSeq</code>. Of course, this requires you to have a Java development environment on your machine. In particular, it must be able to find <em>tools.jar</em>, which provides the debugger hooks necessary to watch the calls.</p>

<p>Produce the image from the resulting XML file as shown earlier for Perl programs.</p>

<h4>Text File Input</h4>

<p>While I pat myself on the back every time I make a sequence diagram of a running program, that's not always (or even usually) practical. For instance, you might want to show the boss what you have planned for code you haven't written yet. Alternately, you might have a program that is so complex that no amount of tweaking the methods file will restrict the diagram enough to make it useful.</p>

<p>In these cases, there is a small text language you can use to specify the diagram. It is based on indentation and uses dot notation for method names. Here is a sample:</p>

<pre><code>At Home.Wash Car
    Garage.retrieve bucket
    Kitchen.prepare bucket
        Kitchen.pour soap in bucket
        Kitchen.fill bucket
    Garage.get sponge
    Garage.open door
    Driveway.apply soapy water
    Driveway.rinse
    Driveway.empty bucket
    Garage.close door
    Garage.replace sponge
    Garage.replace bucket</code></pre>

<p>Each line will become an arrow in the final diagram (except the first line). Indentation indicates the call depth. The "class" name comes before the dot and the "method" name after it.</p>

<p>There is no need for a methods file in this case, because presumably you didn't bother to type things you didn't care about. You may go directly to running <code>genericseq.pl</code>:</p>

<pre><code>$ <strong>genericseq.pl UML::Sequence::SimpleSeq inputfile &gt; wash.xml</strong></code></pre>

<p>Once you have the XML file, render it as before.</p>

<h3>Getting Fancy</h3>

<p>As I mentioned earlier, Dean Arnold recently added lots of cool features to amaze and impress your bosses and/or clients. In particular, he expanded the legal syntax for text outlines. Here is his sample of car washing with the new features:</p>

<pre><code>AtHome.Wash Car
        /* the bucket is in the garage */
    Garage.retrieve bucket
    Kitchen.prepare bucket
        Kitchen.pour soap in bucket
        Kitchen.fill bucket
    Garage.get sponge
    Garage.checkDoor
            -&gt; clickDoorOpener
        [ ifDoorClosed ] Garage.open door
    * Driveway.apply soapy water
    ! Driveway.rinse
    Driveway.empty bucket
    Garage.close door
    Garage.replace sponge
    Garage.replace bucket</code></pre>

<p>There are several new features here:</p>

<ul>
<li>You can include UML annotations by using C-style comments, as shown on the second line of the example. Each annotation attaches to the following line as a footnote (or tooltip, if you install a third-party open source library).</li>

<li>There is a <code>-&gt;</code> in front of <code>clickDoorOpener</code>. This becomes an asynchronous message arrow. When <code>-&gt;</code> comes between a method and additional text, it indicates that a regular method is returning the value on the righthand side of the arrow. The return appears as a dashed arrow from the called activation back to the caller.</li>

<li><code>ifDoorClosed</code> is in brackets, which mark a conditional in UML. These appear in the diagram in front of the method name.</li>

<li>There is a star in front of <code>Driveway.apply</code>, which indicates a loop construct in UML. (UML people call this <em>iteration</em>.)</li>

<li>There is an exclamation point in front of <code>Driveway.rinse</code>, indicating urgency.</li>
</ul>

<p>In addition to these changes to the outline syntax, both <code>seq2svg.pl</code> and <code>seq2rast.pl</code> now support options to control appearance (including colors) and to generate HTML imagemaps for raster versions of the diagrams. The imagemaps hyperlink diagram elements--columns header and method call names--to supporting documents. For example, clicking on the <code>Garage</code> header will open <em>Garage.html</em>, while clicking on <code>checkDoor</code> will also open <em>Garage.html</em>, but at the <code>#checkDoor</code> anchor.</p>

<h3>Summary</h3>

<p>UML Sequence diagrams are a great way to see how function or method calls (or network messages) flow through a multi-module application, whether it is object-oriented or not. Using <code>UML::Sequence</code> and its helper scripts, you can make those diagrams without having to point and click in a drawing program.</p>

<h3>References</h3>

<p><a href="http://www.presicient.com/umlseq/deluxewash.html">The imagemapped HTML version of car washing</a> is viewable online.</p>

<p>To read more about UML diagrams, check out the aptly named <em>UML Distilled</em>, by Martin Fowler, available from your favorite bookseller.</p>

<p>I recommend Walter Zorn's <a href="http://www.walterzorn.com/tooltip/tooltip_e.htm">JavaScript, DHTML tooltips</a> package to display embedded annotations.</p>

<p><a href="http://xml.apache.org/batik/">Batik</a> is an Apache project for managing and viewing SVG.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1168" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2003/07/overloading.html" rel="bookmark">Overloading</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                <abbr class="published" title="2003-07-22T00:00:00-08:00">July 22, 2003 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<h3>Introduction: What is Overloading?</h3>

<p>All object-oriented programming languages have a feature called overloading,
but in most of them this term means something different from what it means in
Perl. Take a look at this Java example:</p>

<pre><code>public Fraction(int num, int den);
public Fraction(Fraction F);
public Fraction();</code></pre>

<p>In this example, we have three methods called <code>Fraction</code>. Java,
like many languages, is very strict about the number and type of arguments that
you can pass to a function. We therefore need three different methods to cover
the three possibilities. In the first example, the method takes two integers (a
numerator and a denominator) and it returns a <code>Fraction</code> object
based on those numbers. In the second example, the method takes an existing
<code>Fraction</code> object as an argument and returns a copy (or clone) of
that object.  The final method takes no arguments and returns a default
<code>Fraction</code> object, maybe representing 1/1 or 0/1.  When you call one
of these methods, the Java Virtual Machine determines which of the three
methods you wanted by looking at the number and type of the arguments.</p>

<csperl file="grab" domain="on" record="b/936" template="b/article_sidebar.view">

<p>In Perl, of course, we are far more flexible about what arguments we can
pass to a method. Therefore the same method can be used to handle all of the
three cases from the Java example.  (We'll see an example of this in a short
while.) This means that in Perl we can save the term "overloading" for
something far more interesting &mdash; <em>operator overloading</em>.</p>

<h3><code>Number::Fraction</code> &mdash; The Constructor</h3>

<p>Imagine you have a Perl object that represents fractions (or, more
accurately, rational numbers, but we'll call them fractions as we're not all math geeks). In order to handle the same situations as the Java class we mentioned above, we need to be able to run code like this:</p>

<pre><code>use Number::Fraction;

my $half       = Number::Fraction-&gt;new(1, 2);
my $other_half = Number::Fraction-&gt;new($half);
my $default    = Number::Fraction-&gt;new;</code></pre>

<p>To do this, we would write a constructor method like this:</p>

<pre><code>sub new {
    my $class = shift;
    my $self;
    if (@_ &gt;= 2) {
        return if $_[0] =~ /\D/ or $_[1] =~ /\D/;
        $self-&gt;{num} = $_[0];
        $self-&gt;{den} = $_[1];
    } elsif (@_ == 1) {
        if (ref $_[0]) {
            if (UNIVERSAL::isa($_[0], $class) {
                return $class-&gt;new($_[0]-&gt;{num}, $_[0]-&gt;{den});
            } else {
                croak "Can't make a $class from a ", ref $_[0];
            }
        } else {
            return unless $_[0] =~ m|^(\d+)/(\d+)|;

            $self-&gt;{num} = $1;
            $self-&gt;{den} = $2;
        }
    } elsif (!@_) {
        $self-&gt;{num} = 0;
        $self-&gt;{den} = 1;
    }

    bless $self, $class;
    $self-&gt;normalise;
    return $self;
}</code></pre>

<p>As promised, there's just one method here and it does everything that the
three Java methods did and more even, so it's a good example of why we don't
need method overloading in Perl. Let's look at the various parts in some
detail.</p>

<pre><code>sub new {
    my $class = shift;
    my $self;</code></pre>

<p>The method starts out just like most Perl object constructors.  It grabs the
class which is passed in as the first argument and then declares a variable
called <code>$self</code> which will contain the object.</p>

<pre><code>    if (@_ &gt;= 2) {
        return if $_[0] =~ /\D/ or $_[1] =~ /\D/;
        $self-&gt;{num} = $_[0];
        $self-&gt;{den} = $_[1];</code></pre>

<p>This is where we start to work out just how the method was called. We look
at <code>@_</code> to see how many arguments we have been given. If we've got
two arguments then we assume that they are the numerator and denominator of the
fraction. Notice that there's also another check to ensure that both arguments
contain only digits. If this check fails, we return <code>undef</code> from the
constructor.</p>

<pre><code>     } elsif (@_ == 1) {
        if (ref $_[0]) {
            if (UNIVERSAL::isa($_[0], $class) {
                return $class-&gt;new($_[0]-&gt;num, $_[0]-&gt;den);
            } else {
                croak "Can't make a $class from a ", ref $_[0];
            }
        } else {
            return unless $_[0] =~ m|^(\d+)/(\d+)|;
            $self-&gt;{num} = $1;
            $self-&gt;{den} = $2;
        }</code></pre>

<p>If we've been given just one argument, then there are a couple of things we can do. First we see if the argument is a reference, and if it is, we check that it's a reference to another <code>Number::Fraction</code> object (or a subclass). If it's the right kind of object then we get the numerators and denominators (using the accessor functions) and use them to call the two argument forms of <code>new</code>. It the argument is the wrong type of reference then we complain bitterly to the user.</p>

<p>If the single argument isn't a reference then we assume it's a string
of the form <code>num/den</code>, which we can split apart to get the numerator
and denominator of the fraction. Once more we check for the correct format
using a regex and return <code>undef</code> if the check fails.</p>

<pre><code>     } elsif (!@_) {
        $self-&gt;{num} = 0;
        $self-&gt;{den} = 1;
    }</code></pre>

<p>If we are given no arguments, then we just create a default fraction which
is <code>0/1</code>.</p>

<pre><code>    bless $self, $class;
    $self-&gt;normalise;
    return $self;
}</code></pre>

<p>At the end of the constructor we do more of the normal OO Perl stuff. We
<code>bless</code> the object into the correct class and return the reference
to our caller. Between these two actions we pause to call the
<code>normalise</code> method, which converts the fraction to its simplest form.
For example, it will convert <code>12/16</code> to <code>3/4</code>.</p>

<h3><code>Number::Fraction</code> &mdash; Doing Calculations</h3>

<p>Having now created fraction objects, we will want to start doing
calculations with them. For that we'll need methods that implement the various
mathematical functions. Here's the <code>add</code> method:</p>

<pre><code>sub add {
    my ($self, $delta) = @_;

    if (ref $delta) {
        if (UNIVERSAL::isa($delta, ref $self)) {
            $self-&gt;{num} = $self-&gt;num  * $delta-&gt;den
                + $delta-&gt;num * $self-&gt;den;
            $self-&gt;{den} = $self-&gt;den  * $delta-&gt;den;
        } else {
            croak "Can't add a ", ref $delta, " to a ", ref $self;
        }
    } else {
        if ($delta =~ m|(\d+)/(\d+)|) {
            $self-&gt;add(Number::Fraction-&gt;new($1, $2));
        } elsif ($delta !~ /\D/) {
            $self-&gt;add(Number::Fraction-&gt;new($delta, 1));
        } else {
            croak "Can't add $delta to a ", ref $self;
        }
    }
    $self-&gt;normalise;
}</code></pre>

<p>Once more we try to handle a number of different types of arguments. We can
add the following things to our fraction object:</p>

<ul>

<li>Another object of the same class (or a subclass).</li>
<li>A string in the format <code>num/den</code>.</li>
<li>An integer. This is converted to a fraction with a denominator of 1.</li>

</ul>

<p>This then allows us to write code like this:</p>

<pre><code>my $half           = Number::Fraction-&gt;new(1, 2);
my $quarter        = Number::Fraction-&gt;new(1, 4);
my $three_quarters = $half;
$three_quarters-&gt;add($quarter);</code></pre>

<p>In my opinion, this code looks pretty horrible. It also has a nasty, subtle
bug. Can you spot it? (Hint: What will be in <code>$half</code> after running
this code?) To tidy up this code we can turn to <em>operator
overloading</em>.</p>

<h3><code>Number::Fraction</code> &mdash; Operator Overloading</h3>

<p>The module <code>overload.pm</code> is a standard part of the Perl
distribution.  It allows your objects to define how they will react to a number
of Perl's operators. For example, we can add code like this to
<code>Number::Fraction</code>:</p>

<pre><code>use overload '+' =&gt; 'add';</code></pre>

<p>Whenever a Number::Fraction is used as one of the operands
to the <code>+</code> operator, the <code>add</code> method will be
called instead. Code like:</p>

<pre><code>$three_quarters = $half + '3/4';</code></pre>

<p>is converted to:</p>

<pre><code>$three_quarters = $half-&gt;add('3/4');</code></pre>

<p>This is getting closer, but it still has a serious problem. The
<code>add</code> method works on the <code>$half</code> object.  In general,
however, that's not how an assignment should work. If you were working with
ordinary scalars and had code like:</p>

<pre><code>$foo = $bar + 0.75;</code></pre>

<p>You would be very surprised if this altered the value of <code>$bar</code>.
Our objects need to work in the same way. We need to change our add method so
that it doesn't alter <code>$self</code> but instead returns the new
fraction.</p>

<pre>sub add {
    my ($l, $r) = @_;
    if (ref $r) {
        if (UNIVERSAL::isa($r, ref $l) {
            return Number::Fraction-&gt;new($l-&gt;num * $r-&gt;den + $r-&gt;num * $l-&gt;den,
                    $l-&gt;den * $r-&gt;den})
        } else {
            ...
        } else {
            ...
        }
    }
}</code></pre>

<p>In this example, I've only shown one of the sections, but I hope it's clear
how it would work. Notice that I've also renamed <code>$self</code> and
<code>$delta</code> to <code>$l</code> and <code>$r</code>. I find this makes
more sense as we are working with the left and right operands of the
<code>+</code> operator.</p>













<h3><a name="overloading noncommutative operators"
id="overloading noncommutative operators">Overloading
Non-Commutative Operators</a></h3>

<p>We can now happily handle code like:</p>

<pre><code>$three_quarters = $half + '1/4';</code></pre>

<p>Our object will do the right thing &mdash; <code>$three_quarters</code> will
end up as a <code>Number::Fraction</code> object that contains the value
<code>3/4</code>. What will happen if we write code like this?</p>

<pre><code>$three_quarters = '1/4' + $half;</code></pre>

<p>The <code>overload</code> modules handle this case as well. If your object
is <em>either</em> operand of one of the overloaded operators, then your method
will be called. You get passed an extra argument which indicates whether your
object was the left or right operand of the operator. This argument is
false if your object is the left operand and true if it is the right
operand.</p>

<p>For commutative operators you probably don't need to take any
notice of this argument as, for example:</p>

<pre><code>$half + '1/4'</code></pre>

<p>is the same as:</p>

<pre><code>'1/4' + $half</code></pre>

<p>However, for non-commutative operators (like <code>-</code> and
<code>/</code>) you will need to do something like this:</p>

<pre><code>sub subtract {
    my ($l, $r, $swap) = @_;

    ($l, $r) = ($r, $l) if $swap;
    ...
}</code></pre>

<h3>Overloadable Operators</h3>

<p>Just about any Perl operator can be overloaded in this way. This
is a partial list:</p>

<ul>

<li>Arithmetic: <code>+</code>, <code>+=</code>, <code>-</code>,
<code>-=</code>, <code>*</code>, <code>*=</code>, <code>/</code>,
<code>/=</code>, <code>%</code>, <code>%=</code>, <code>**</code>,
<code>**=</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;=</code>,
<code>&gt;&gt;</code>, <code>&gt;&gt;=</code>, <code>x</code>, <code>x=</code>,
<code>.</code>, <code>.=</code></li>

<li>Comparison: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>=&gt;</code>, <code>==</code>, <code>!=</code>, <code>&lt;=&gt;</code>
<code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>,
<code>eq</code>, <code>ne</code>, <code>cmp</code></li>

<li>Increment/Decrement: <code>++</code>, <code>--</code> (both pre- and post-
versions)</li>

</ul>

<p>A full list is given in <code>overload</code>.</p>

<p>It's a very long list, but thankfully you rarely have to supply
an implementation for more than a few operators. Perl is quite
happy to synthesize (or <em>autogenerate</em>) many of the missing
operators. For example:</p>

<ul>
<li>++ can be derived from +</li>
<li>+= can be derived from +</li>
<li>- (unary) can be derived from - (binary)</li>
<li>All numeric comparisons can be derived from <code>&lt;=&gt;</code></li>
<li>All string comparisons can be derived from <code>cmp</code></li>
</ul>

<p>Two other special operators give finer control over this autogeneration of
methods. <code>nomethod</code> defines a subroutine that is called when no
other function is found and <code>fallback</code> controls how hard Perl tries
to autogenerate a method. <code>fallback</code> can have one of three
values:</p>

<dl>

<dt><code>undef</code></dt>
<dd>Attempt to autogenerate methods and <code>die</code> if a method can't be
autogenerated.  This is the default.</dd>

<dt><code>0</code></dt>
<dd>Never try to autogenerate methods.</dd>

<dt><code>1</code></dt>
<dd>Attempt to autogenerate methods but fall back on Perl's default behavior
for the the object if a method can't be autogenerated.</dd>
</dl>

<p>Here's an example of an object that will die gracefully when an unknown
operator is called. Notice that the <code>nomethod</code> subroutine is passed
the usual three arguments (left operand, right operand, and the swap flag)
together with an extra argument containing the operator that was used.</p>

<pre><code>use overload
    '-' =&gt; 'subtract',
    fallback =&gt; 0,
    nomethod =&gt; sub { 
        croak "illegal operator $_[3]" 
};</code></pre>

<p>Three special operators are provided to control type conversion.  They
define methods to be called if the object is used in string, numeric, and
boolean contexts. These operators are denoted by <code>q{""}</code>,
<code>0+</code>, and <code>bool</code>. Here's how we can use these in
<code>Number::Fraction</code>:</p>

<pre><code>use overload
    q{""} =&gt; 'to_string',
    '0+'  =&gt; 'to_num';

sub to_string {
    my $self = shift;
    return "$_-&gt;{num}/$_-&gt;{den}";
}

sub to_num {
    my $self = shift;
    return $_{num}/$_-&gt;{den};
}</code></pre>

<p>Now, when we print a <code>Number::Fraction</code> object, it will be
displayed in <code>num/den</code> format.  When we use the object in a numeric
context, Perl will automatically convert it to its numeric equivalent.</p>

<p>We can use these type-conversion and fallback operators to cut down the
number of operators we need to define even further.</p>

<pre><code>use overload
    '0+' =&gt; 'to_num',
    fallback =&gt; 1;</code></pre>

<p>Now, whenever our object is used where Perl is expecting a number and we
haven't already defined an overloading method, Perl will try to use our object
as a number, which will, in turn, trigger our <code>to_num</code> method. This
means that we only need to define operators where their behavior will differ
from that of a normal number. In the case of <code>Number::Fraction</code>, we
don't need to define any numeric comparison operators since the numeric value of
the object will give the correct behavior. The same is true of the string
comparison operators if we define <code>to_string</code>.</p>

<h3>Overloading Constants</h3>

<p>We've come a long way with our overloaded objects. Instead of nasty code
like:</p>

<pre><code>use Number::Fraction;

$f = Number::Fraction-&gt;new(1, 2);
$f-&gt;add('1/4');</code></pre>

<p>we can now write code like:</p>

<pre><code>use Number::Fraction;

$f = Number::Fraction-&gt;new(1, 2) + '1/4';</code></pre>

<p>There are still, however, two places where we need to use the full name of
the class &mdash; when we load the module and when we create a new fraction
object. We can't do much about the first of these, but we <em>can</em> remove
the need for that ugly <code>new</code> call by <em>overloading
constants</em>.</p>

<p>You can use <code>overload::constant</code> to control how Perl interprets
constants in your program.  <code>overload::constant</code> expects a hash
where the keys identify various kinds of constants and the values are
subroutines which handle the constants. The keys can be any of
<code>integer</code> (for integers), <code>float</code> (for floating point
numbers), <code>binary</code> (for binary, octal, and hex numbers),
<code>q</code> (for strings), and <code>qr</code> (for the constant parts of
regular expressions).</p>

<p>When a constant of the right type is found, Perl will call the associated
subroutine, passing it the string representation of the constant and the way
that Perl would interpret the constant by default. Subroutines associated with
<code>q</code> or <code>qr</code> also get a third argument -- either
<code>qq</code>, <code>q</code>, <code>s</code>, or <code>tr</code> --which
indicates how the string is being used in the program.</p>

<p>As an example, here is how we would set up constant handlers so that strings
of the form <code>num/den</code> are always converted to the equivalent
<code>Number::Fraction</code> object:</p>

<pre>
my %_const_handlers = 
    (q =&gt; sub { 
        return __PACKAGE__-&gt;new($_[0]) || $_[1] 
});

sub import {
    overload::constant %_const_handlers if $_[1] eq ':constants';
}

sub unimport {
    overload::remove_constant(q =&gt; undef);
}</code></pre>

<p>We've defined a hash, <code>%_const_handlers</code>, which only contains one
entry as we are only interested in strings. The associated subroutine calls the
<code>new</code> method in the current package (which will be
<code>Number::Fraction</code> or a subclass) passing it the string as found in
the program source. If this string can be used to create a valid
<code>Number::Fraction</code> object, a reference to that object is returned.</p>

<p>If a valid object isn't returned then the subroutine returns its second
argument, which is Perl's default intepretation of the constant. As a result,
any strings in the program that can be intepreted as a fraction are converted
to the correct <code>Number::Fraction</code> object and other strings are left
unchanged.</p>

<p>The constant handler is loaded as part of our package's <code>import</code>
subroutine. Notice that it is only loaded if the <code>import</code> subroutine
is passed the optional argument <code>:constants</code>. This is because this
is a potentially big change to the way that a program's source code is
interpreted so we only want to turn it on if the user wants it.
<code>Number::Fraction</code> can be used in this way by putting the following
line in your program:</p>

<pre><code>use Number::Fraction ':constants';</code></pre>

<p>If you don't want the scary constant-refining stuff you can
just use:</p>

<pre><code>use Number::Fraction;</code></pre>

<p>Also note that we've defined an <code>unimport</code> subroutine which
removes the constant handler. An <code>unimport</code> subroutine is called
when a program calls <code>no Number::Fraction</code> &mdash; it's the opposite
of <code>use</code>. If you're going to make major changes to the way that Perl
parses a program then it's only polite to undo your changes if the programmer
askes you to.</p>

<h3>Conclusion</h3>

<p>We've finally managed to get rid of most of the ugly class names from our
code. We can now write code like this:</p>

<pre><code>use Number::Fraction ':constants';

my $half = '1/2';
my $three_quarters = $half + '1/4';
print $three_quarters;  # prints 3/4</code></pre>

<p>I hope you can agree that this has the potential to make code far easier to
read and understand.</p>

<p><code>Number::Fraction</code> is available on the CPAN. Please feel free to
take a closer look at how it is implemented. If you come up with any more
interesting overloaded modules, I'd love to hear about them.</p>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1108" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2003/04/pool.html" rel="bookmark">POOL</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Cozens</span> on <abbr class="published" title="2003-04-22T00:00:00-08:00">April 22, 2003 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->
<p>In this article, we're going to look at POOL, a handy &quot;little language&quot;
I recently created for templating object-oriented modules. Now you may
not write many object-oriented modules, so this may not sound too
interesting to you. Don't worry; I also plan to discuss, among other
things, Ruby, how to use the Template Toolkit, profiling, computational
linguistic trie structures, Ruby again, and the oil paintings of the
Great Masters. Hopefully, something in here will be enough to keep your
interest.</p>


<h3><a name="splashing_around">Splashing Around</a></h3>
<p>One of the reasons that I always feel I never get anything substantial
done in Perl is that I'm always distracted unduly by subtasks, 
particularly metaprogramming. I write so many &quot;labor-saving&quot; modules
that I never get around to doing the original labor in the first place.</p>
<p>For instance, I wanted to write something to handle my accounts; I
needed something to handle command-line options but I couldn't be
bothered with the <code>Getopt::Long</code> rigmarole, so I wrote <a href="http://search.cpan.org/~simon/Getopt-Auto-1.00/Auto.pm"><code>Getopt::Auto</code></a>.
Next, I needed to parse a simple configuration file and I couldn't face
writing yet another colon-separated file parser, so I wrote
<a href="http://search.cpan.org/~simon/Config-Auto-0.03/Auto.pm"><code>Config::Auto</code></a>. Finally, I wrote something that examined a database
schema and wrote <code>Class::DBI</code> packages for each table -- all 
helpful tasks, and they meant I would never have to worry about
configuration files or command-line options again. But, of
course, I forgot about my accounts-handling application.</p>
<p>Something like this happened again recently. I started writing a module
I'm calling <code>Devel::DProfPP</code>, which parses the data output by
<code>Devel::DProf</code> in a neat object-oriented way. I was about five minutes
into it when found myself writing:</p>
<pre><code>
    =head1 CONSTRUCTOR

        $object = Devel::DProfPP-&gt;new( %options )

    Creates a new C&lt;Devel::DProfPP&gt; instance.

    =cut

    sub new {
        my ($class, %opts) = @_;
        bless { %opts }, $class;
    }</code></pre>
<p>And then I wrote my test: (I'm a bad boy, I write my tests after I write 
the code)</p>
<pre><code>
    use Test::More;
    use_ok(&quot;Devel::DProfPP&quot;);
    my $x = Devel::DProfPP-&gt;new();
    isa_ok($x, &quot;Devel::DProfPP&quot;);
    ...</code></pre>
<p>Nothing strange about that, you might think. It's something I've written
a dozen of times before, and something I will probably write a
dozen times again. And that's when it hit me. I don't
<strong>want</strong> to spend my time pounding out constructors and accessors,
documentation that's practically identical from class to class, tests
that are eminently predictable, and I never, ever wanted to have to
write <code>my $self = shift;</code> again.</p>
<p>There are two ways to solve this. Now I'm not going to last long as
editor of <code>perl.com</code> if I suggest everyone should do the first, and
switching to Ruby wouldn't help with the documentation and tests part of
the problem anyway.</p>
<p>The second is, of course, to make the computer do the hard work. I
sketched out a short description of what I wanted in my
<code>Devel::DProfPP</code> module, and wrote a little parser to read in that
description, and then had some code generate the module. Then, I made a
critical decision. I had just been doing some work with Template
Toolkit, and wanted some more opportunity to play with it. So instead of
hard-coding what the output module ought to look like, I simply passed
the parsed data structure to a bunch of templates and let them do the
work. This gave me an amazing amount of flexibility in terms of styling
the output, and that's where I think the power of this system, the Perl
Object Oriented Language, (POOL) lies.</p>
<p>In order to investigate that, let's look at some POOL files and
the output they generate, and then we'll examine how the templates work
and fit together.</p>


<h3><a name="diving_in">Diving In</a></h3>
<p>The POOL language is very, very ad hoc. It's bizarre and inconsistent,
but that's because it was created by rationalizing a module description
I scribbled down late one night. But it does the job. It's essentially a
brain dump, and if your brain happens not to work like mine, then you might
not like it; if yours does work like mine, my commiserations.</p>
<p>The POOL distribution, available from CPAN, ships with a handy reference
manual, and that very description; these are the original notes I made
when I was mocking up <code>Devel::DProfPP</code>, and they look like this:</p>
<pre><code>
    Devel::DProfPP - Parse C&lt;Devel::DProf&gt; output
        DESCRIPTION

    This module takes the output file from L&lt;Devel::DProf&gt; (typically
    F&lt;tmon.out&gt;) and parses it into a Perl data structure. Additionally, it
    can be used in an event-driven style to produce reports more
    immediately.

        EOD
        @fh
        -&gt;@enter    || sub {}
        -&gt;@leave    || sub {}
        ro-&gt;@stack  []
        @syms       []
        parse
        top_frame   -&gt;stack-&gt;[0]</code></pre>
<p>The first line should be familiar to anyone who writes or uses Perl modules:
it's the description line that goes at the top of the documentation. It's
enough to identify the class name and provide some documentation about it.</p>
<p>The next thing is the module description, again for the documentation, which
begins with <code>DESCRIPTION</code> and ends with <code>EOD</code>.</p>
<p>When you look at the things starting with <code>@</code>, don't think Perl, think Ruby -
they're not arrays, they're instance variables. Our <code>Devel::DProfPP</code> object
will contain a filehandle to read the profiling data from, a subroutine
reference for what to do when we enter a subroutine and when we leave one,
the current Perl stack, and an array of symbols to hold the subroutine names.</p>
<p>These instance variables come in three types. The first are variables
that the user doesn't set, but come with every new instance. I call
these &quot;set&quot; variables, because they're come set to a particular value.
Then there are &quot;defaulting&quot; instance variables, which the user may
specify but otherwise default to a particular value. And then there are
just ordinary ones, which are not initialized at all. Thankfully for me,
the <code>Devel::DProfPP</code> brain dump contained all three types.</p>
<p>The symbol table and the stack are &quot;set&quot; variables. They come set to the
an empty array reference; we signify this by simply putting an empty
array reference on the same line.</p>
<pre><code>
        @syms       []</code></pre>
<p>The enter subroutine, on the other hand, is a defaulting variable.
(Don't worry about the arrow for now.) If the user doesn't specify an
action to be performed when the profiler says that a subroutine has been
entered, then we want to default to a coderef that does nothing.</p>
<p>In Perl, when we want to default to a value, we say something like:</p>
<pre><code>
    $object-&gt;{enter} = $args{enter} || sub {};</code></pre>
<p>So the POOL encoding of that is:</p>
<pre><code>
        @enter      || sub {}</code></pre>
<p>Finally, there's the filehandle, which the user supplies. Nothing
special has to occur for this instance variable, so we just name it:</p>
<pre><code>
        @fh</code></pre>
<p>From this, we know enough to create a constructor like so:</p>
<pre><code>
    sub new {
        my $class = shift;
        my %args = @_;
        my $self = bless {
            fh =&gt; $args{fh},
            enter =&gt; $args{enter} || sub {},
            leave =&gt; $args{leave} || sub {},
            syms =&gt; [],
            stack =&gt; [],
        }, $class;
        return $self;
    }</code></pre>
<p>And that's precisely what POOL does. After the constructor, comes the
accessors; we want to be able to say <code>$obj-&gt;enter</code> to retrieve the
on-enter action, for instance. This thought led naturally to the syntax</p>
<pre><code>
    -&gt;@enter || sub {}</code></pre>
<p>When POOL sees an arrow attached to an instance variable, it creates an
accessor for it:</p>
<pre><code>
    sub enter {
        my $self = shift;
        if (defined @_) { $self-&gt;{enter} = @_ };

        return $self-&gt;{enter};
    }</code></pre>
<p>The stack accessor is an interesting one. First, we only want this to be
an accessor and not a mutator -- we really don't want people modifying the
profiler's idea of the stack behind its back. This is signified by the
letters <code>ro</code> (read-only) before the accessor arrow.</p>
<pre><code>
    ro-&gt;@stack []</code></pre>
<p>A further twist comes from the fact that POOL is still trying to DWIM
around my brain and my brain expects POOL to be very clever indeed.
Because we have declared <code>stack</code> to be set to an array reference, we
know that the <code>stack</code> accessor deals with arrays. Hence, when 
<code>$obj-&gt;stack</code> is called, it should know to dereference the
reference and return a list. This means the code ends up looking like
this:</p>
<pre><code>
    sub stack {
        my $self = shift;
        return @{$self-&gt;{stack}};
    }</code></pre>
<p>Aside from constructors and accessors, POOL knows about two other
styles of method. (For now; there are more coming.) There are ordinary
methods, which are simply named:</p>
<pre><code>
    parse</code></pre>
<p>Sadly we can't DWIM the entire code for this method, so we generate the
best we can:</p>
<pre><code>
    sub parse {
        my $self = shift;
        #...
    }</code></pre>
<p>And the final style is the delegate. The sad thing about the delegate
given in the <code>DProfPP</code> example is that it doesn't actually work, but we'll
pretend that it does. Delegates are useful when you have an object that
contains another object; you can provide a method in your class that
simply diverts off to the contained object. For instance, if we have a 
class representing a mail message, then we may wish to store the head and body
as separate objects inside our main object. (<code>Mail::Internet</code> does something
like this, containing a <code>Mail::Header</code> object.) Now we can provide a
method called <code>get_header</code>, which simply locates the header object and passes
on its arguments to that:</p>
<pre><code>
    sub get_header {
        my $self = shift;
        $self-&gt;header-&gt;get(@_);
    }</code></pre>
<p>In POOL lingo, this is a delegate <strong>via</strong> the <code>header</code> method, and <code>get</code>
tells us <strong>how</strong> to do the delegation. It would be specified like this:</p>
<pre><code>
    get_header  -&gt;header-&gt;get</code></pre>
<p>Notice that this is precisely what appears in the middle of the Perl code
for this method. An additional feature is that the &quot;how&quot; part of the delegation
is optional. If we were happy for our top-level method to be called <code>get</code>
instead of <code>get_header</code>, then we could say:</p>
<pre><code>
    get         -&gt;header-&gt;</code></pre>
<p>To me, this symbolizes going &quot;through&quot; the <code>header</code> method in order to call
the <code>get</code> method.</p>
<p>These are the basics of the POOL language, and we've seen a little of the
code it generates. It also generates a full set of documentation and
tests, as well as a <code>MANIFEST</code> file and <code>Makefile.PL</code> or <code>Build.PL</code>
file, but we'll look at those a little later.</p>
<p>In case you're interested, the reason why the delegation in the example
doesn't work is because I was being too clever. I thought I could say:</p>
<pre><code>
    top_frame   -&gt;stack-&gt;[0]</code></pre>
<p>and have a <code>top_frame</code> method which &quot;calls&quot; <code>[0]</code> on the stack array
reference, returning its first entry. This doesn't work for two reasons.
First, I was too clever about <code>-&gt;stack</code> and now it returns a list
instead of an array reference. Second, delegates need to pass arguments,
so POOL ends up generating code that looks like:</p>
<pre><code>
    return $self-&gt;stack-&gt;[0](@_);</code></pre>
<p>(The third reason, of course, is that the top of the stack when
represented as an array is element <code>-1</code>, not element <code>0</code>. Oops.)</p>
<p>I thought about fixing this to do what I really, really mean, but decided
that would be too nasty.</p>













<h3><a name="another_example">Another Example</a></h3>
<p>Now that I had this neat tool for generating modules, I set it to work
on the next module I wrote; this was a variant of <a href="http://search.cpan.org/~avif/Tree-Trie-0.4/Trie.pm"><code>Tree::Trie</code></a>, a
class to represent the trie data structure. Tries are a handy way of
representing prefix and suffix relationships between words. They're
conceptually simple; each letter in a word is inserted into a tree
as the child of the previous letter. If we wanted a trie to count the
prefices in the phrase <code>THERE IS A TAVERN IN THE TOWN</code>, then we would first
insert the chain <code>T-H-E-R-E-#</code>, then <code>I-S-#</code>, then <code>A-#</code>, and so on,
where <code>#</code> represents &quot;end-of-word&quot;. We'd end up with a trie looking
like this:</p>

<table border="0" cellpadding="2" cellspacing="2" align="center">
<tr>
<td width="450" align="center">
<img src="/pub/2003/04/22/graphics/tavern-trie.png" width="315" height="378" alt="An example of a trie" />
</td>
</tr>
<tr>
<td align="center" class="secondary"><strong>Figure 1: An Example of a Trie</strong></td>
</tr>
</table>
<p><code>Tree::Trie</code> is good at this sort of thing, but it didn't do a few
extra things I needed, so I wrote an internal-use module called
<code>Kasei::Trie</code>; this was the POOL file I used to generate it:</p>
<pre><code>
    Kasei::Trie - Implement the trie data structure
        DESCRIPTION

    &quot;Trie&quot;s are compact tree-like representations of multiple words, where
    each successive letter is introduced as the child of the previous.

        EOD
        @children {}
        insert

    Kasei::Trie::Node
        @children
        -&gt;@data</code></pre>
<p>The main class, <code>Kasei::Trie</code>, has a constructor with one instance variable
that is initialized to be an empty hash reference, and one method, <code>insert</code>.
There's also a secondary class representing each node in the trie, which has
its own children, and has a <code>data</code> variable with its own accessor.</p>
<p>After generating this with POOL, all I needed to do was to fill in the
code for the <code>insert</code> method, and modify some tests. A manifest,
<code>Makefile.PL</code>, test suite with nine tests, and 161 lines of code and
documentation were automatically created for me. I suspect that POOL
saved me one to two hours.</p>


<h3><a name="the_high_dive">The High Dive</a></h3>
<p>Let's now take a look at the templates that make this all happen. The
main template is called <code>module</code>, and it looks like this:</p>
<pre><code>
    package [% module.package %];
    [% INCLUDE module_header %]
    =head1 SYNOPSIS

    [% INCLUDE synopsis %]
    =head1 DESCRIPTION

    [% module.description  %]

    =head1 METHODS
    [% 
        FOREACH method = module.methods;
        INCLUDE do_method;
        END
    %]

    [% INCLUDE module_footer %]

    1;</code></pre>
<p>As you can probably guess, in the Template Toolkit language, interesting
things happen between <code>[%</code> and <code>%]</code>. Everything else is just output
wholesale, but all kinds of things can happen inside the brackets. The
first thing that happens is that we look at the module's package name.
All the data we've collated from the parsing phase is stuffed into a hash
reference, which we have passed into the template as <code>module</code>. The
dot operator in Template Toolkit is a general do-the-right-thing operator
that can be a method call, a hash reference look-up or an array reference
look-up. In this case, it's a hash reference look-up, and 
we perform the equivalent of <code>$module-&gt;{package}</code> to extract the name.</p>
<p>Template Toolkit's <code>[% INCLUDE template %]</code> directive looks for the file
<em>template</em> in its template path, processes it passing in all the relevant
variables, and includes its output. So after the initial <code>package ...;</code> line,
we include another template that contains everything that goes at the top of
the module. As we'll see later, part of the beauty of templating things this
way is that you can override templates by placing your own idea of what should
go at the top of a module into your private version of <code>module_header</code> earlier
in the template path, in a sense &quot;inheriting&quot; from the base set of templates.</p>
<p>Similarly, we include a file that will output the synopsis, and output the
description that we collected between the <code>DESCRIPTION</code> and <code>EOD</code>
lines of our POOL definition file.</p>
<p>Next, we want to document the various methods and output the code for
them. POOL will have placed all the metadata for the methods we've
defined, plus a constructor, in the appropriate order in the <code>methods</code>
hash entry of <code>module</code>. As this is an array reference, we want to use a
<code>foreach</code>-style loop to look at each method in turn. Not surprisingly,
Template Toolkit's <code>foreach</code>-style loop is called <code>FOREACH</code>.</p>
<p>So this code:</p>
<pre><code>
    [% 
        FOREACH method = module.methods;
        INCLUDE do_method;
        END
    %]</code></pre>
<p>will set a variable called <code>method</code> to each method in the array, and
then call the <code>do_method</code> template. This simply dispatches to
appropriate templates for each type of method. For instance, there's the
set of templates for the &quot;delegate&quot; style; <em>delegate_code</em> looks like
this:</p>
<pre><code>
    sub [% method.name %] {
        my $self = shift;
        return $self-&gt;[% method.via %]-&gt;[% method.how %](@_);
    }</code></pre>
<p>Whereas the documentation template contains some generic commentary:</p>
<pre><code>
    =head2 [% method.name %]

    [% INCLUDE delegate_synopsis -%]
    Delegates to the [%method.how%] method of this object's [%method.via%].

    =cut</code></pre>
<p>The synopsis that appears in the documentation here and in the synopsis
at the top of the file simply explains how the delegation is done:</p>
<pre><code>
    $self-&gt;[% method.name %](...); # $self-&gt;[% method.via %]-&gt;[%method.how%]</code></pre>
<p>Of course, there are some templates that are a little more complex, 
particularly those that generate the tests, but the main thing is that
you can override any or none of those. If you don't like
the standard same-terms-as-Perl-itself licensing block that appears at the
end of the module, then create a file called <em>~/.pool/license</em> containing:</p>
<pre><code>
    =head1 LICENSE

    This module is licensed under the Crowley Public License: do what thou
    wilt shall be the whole of the license.</code></pre>
<p>POOL will pick up this template and use it instead of the standard one.</p>


<h3><a name="there's_no_p_in_our_pool">There's No P in Our POOL</a></h3>
<p>When I started planning this article in the bath this morning, I realized
that POOL is actually fantastically badly named; there's nothing actually
Perl-specific about the language itself, and it's a handy definition language
for any object-oriented system. Hence, I hereby retroactively name the project
&quot;the POOL Object Oriented Language&quot;, which also satisfies the recursive
acronym freaks. But can we, using the same parser and templating system,
turn POOL files into other languages? Of course we can; this is all part
of the flexibility of the Template Toolkit system. What's more, we don't
even have to override <strong>all</strong> of the templates in order to do so, just some
of them. For instance, here's a Ruby equivalent of <em>accessor_code</em>:</p>
<pre><code>
    [% IF method.ro == &quot;ro&quot;; %]
        attr_reader :[% method.name %]
    [% ELSE; %]
        attr_accessor :[% method.name %]
    [% END; %]</code></pre>
<p><em>do_method</em> and <em>module_footer</em>, however, never need to change, since all
they do is include other methods. With a complete set of toolkits, the same
POOL description can be used to output a Perl, Ruby, Python, Java and C++
implementation of a given class.</p>


<h3><a name="going_deeper">Going Deeper</a></h3>
<p>When Frans Hals' famous painting
&quot;The Laughing Cavalier&quot; was being examined in a museum's labs,
someone had the bright idea of putting it through an X-ray machine. When
they did this, they were amazed to find underneath the famous painting a
completely different work -- a painting of a young girl. They then
adjusted the settings on the X-ray machine and tried again, and
underneath the young girl, they found another painting. Since then, it's
been common practice to X-ray pictures, and art historians have found
many layers of paint underneath some of the most-famous pictures.</p>
<p>What's this got to do with POOL? Well, very little, but I wanted to
throw that in. Since I realised that POOL's templates can be inherited
so easily, I've had the idea of POOL &quot;flavors&quot;; coherent sets of
templates that can be layered like oil paintings to impart certain
properties to the output.</p>
<p>For instance, at the moment, POOL outputs unit tests in separate files in
the <em>t/</em> directory, one for each class. Some people, however, prefer
to have their tests in the module right alongside the documentation and
implementation, using the method described in <a href="http://search.cpan.org/author/MSCHWERN/Test-Inline-0.15/lib/Test/Inline.pm"><code>Test::Inline</code></a>. Well,
there's no reason why POOL shouldn't be able to support this. All you'd
need to do is create a new directory, let's say <em>testinline/</em>, and put
a modified version of <em>do_method</em> in there which says something like:</p>
<pre><code>
    [% INCLUDE method_pod %]
    =head2 begin testing
    [% INCLUDE method_test %]
    =cut
    [% INCLUDE method_code %]</code></pre>
<p>Next, arrange for <em>testinline/</em> to appear in the Template Toolkit
template path, and magically your tests will appear in the right place.</p>
<p>It's not inconcievable that multiple &quot;flavours&quot; could combine in order
to theme a module; for instance, you might want a module which uses
<a href="http://search.cpan.org/author/ADIE/Test-Class-0.03/Class.pm"><code>Test::Class</code></a> for its tests, and <a href="http://search.cpan.org/author/KWILLIAMS/Module-Build-0.18/lib/Module/Build.pm"><code>Module::Build</code></a> for its build file,
with a BSD license flavor and <a href="http://search.cpan.org/author/KASEI/Class-Accessor-0.18/lib/Class/Accessor.pm"><code>Class::Accessor</code></a> for its accessors
instead of having them explicitly coded. Conceptually, you'd then say:</p>
<pre><code>
    pool --flavours=testclass,modulebuild,bsdlicense,classaccessor mymodule.pool</code></pre>
<p>and the module would come out just as you want. This hasn't happened
yet for two reasons: First, although it's only a two- or three-line
change to the <em>pool</em> parser to support pushing these directories onto
the template path, I haven't needed it yet so I haven't done it, and
second, because I haven't written any flavors yet. But it's easy
enough to do.</p>
<p>Other future directions for POOL include a syntax for class methods and
class variables, support for other languages as mentioned about, (which
basically means ripping out the hard-coding of <em>MANIFEST</em>,
<em>Makefile.PL</em> and so on and replacing that with a more flexible method)
and other minor modifications. For instance, I'd like some syntax to
specify dependencies; other Perl modules which will then be <code>use</code>'d in
the main modules and which would be named at the appropriate place in the
<em>Makefile.PL</em>. And, of course, there's building up a library of
flavors, including &quot;total conversion&quot; flavors like Ruby and Python.</p>
<p>
The one thing that's becoming really, really important is the need for
nondestructive editing -- the ability to fill in some additional code
for a method, then regenerate the class from a slight change to the POOL
file without losing the new method's code. I'm going to need to add that
soon to allow for iterative redesigning of modules.
</p>
<p>But the main thing about POOL is what it does now -- it saves me time,
and it takes away the drudgery of writing OO classes in Perl.</p>
<p>And I will finish <code>Devel::DProfPP</code> soon. I promise.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/networking-applications/">&laquo; Networking Applications</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/oddities/">Oddities &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
