<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Text Tools Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Text Tools</em> Category</h1>






                            
                            <div id="entry-642" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2008/03/reverse-callback-templating.html" rel="bookmark">Reverse Callback Templating</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">James Robson</span> on <abbr class="published" title="2008-03-14T00:00:00-08:00">March 14, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Programmers have long recognized that separating code logic from presentation is good. The Perl community has produced many fine systems for doing just this. While there are many systems, they largely fall within two execution models, <em>pipeline</em> and <em>callback</em> (as noted by Perrin Harkins in <a href="/pub/a/2001/08/21/templating.html">Choosing a Templating System</a>). <a href="http://search.cpan.org/perldoc?HTML::Template">HTML::Template</a> and <a href="http://www.template-toolkit.org/">Template Toolkit</a> are in the pipeline category. Their templates consist of simple presentation logic in the form of loops and conditionals and template variables. The Perl program does its work, then loads and renders the appropriate template, as if data were flowing through a pipeline. <a href="http://www.masonhq.com/">Mason</a> and <a href="http://perl.apache.org/embperl/">Embperl</a> fall into the callback category. They mix code in with the template markup, and the template "calls back" to Perl when it encounters program logic.</p>

<p>A third execution model exists: the <em>reverse callback</em> model. Template and code files are separate, just like in the pipeline approach. Instead of using a mini-language to handle display logic, however, the template consists of named sections. Perl executes and calls a specific section of the template at the appropriate time, rendering it. Effectively, this is the opposite of the callback method, which wraps Perl logic around portions (or sections) of a template in a single file. Reverse callback uses Perl statements to load, or call, specific portions of the the template. This approach has a few distinct advantages.</p>

<h3>A Reverse Callback Example</h3>

<p>Suppose that you have a simple data structure you are dying to output as pretty HTML.</p>

<pre><code>my @goods = (
    "oxfords,Brown leather,\$85,0",
    "hiking,All sizes,\$55,7",
    "tennis shoes,Women's sizes,\$35,15",
    "flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>First, you need an HTML template with the appropriate sections defined. Sections are of vital importance; they enable <code>Template::Recall</code> to keep the logic squarely in the code. <code>Template::Recall</code> uses the default pattern <code>/[\s*=+\s*\w+\s*=+\s*]/</code> (to match, for example, <code>[==== section_name ====]</code>) to determine sections in a single file. The start of one section denotes the end of another. This is because <code>Template::Recall</code> uses a <code>split()</code> operation based on the above regex, saving the <code>\w+</code> as the section key in an internal data structure.</p>

<pre><code>[ =================== header ===================]

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;my site - [' title ']&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h4&gt;The date is [' date ']&lt;/h4&gt;



&lt;table border="1"&gt;

    &lt;tr&gt;
        &lt;th&gt;Shoe&lt;/th&gt;
        &lt;th&gt;Details&lt;/th&gt;
        &lt;th&gt;Price&lt;/th&gt;
        &lt;th&gt;Quantity&lt;/th&gt;
    &lt;/tr&gt;

[ =================== product_row =================== ]
    &lt;tr&gt;
        &lt;td&gt;[' shoe ']&lt;/td&gt;
        &lt;td&gt;[' details ']&lt;/td&gt;
        &lt;td&gt;[' price ']&lt;/td&gt;
        &lt;td&gt;[' quantity ']&lt;/td&gt;
    &lt;/tr&gt;


[= footer =]
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This template is quite simple. It has three sections, a "header," "product_row," and "footer." The sections essentially give away how the program logic is going to work. A driver program would call header and footer only once during program execution (start and end, respectively). product_row will be called multiple times during iteration over an array.</p>

<p>Names contained within the delimeters <code>['</code> and <code>']</code> are template variables for replacement during rendering. For example, <code>[' date ']</code> will be replaced by the current date when the program executes.</p>

<p>The driver code must first instantiate a new Template::Recall object, <code>$tr</code>, and pass it the path of the template, which I've saved as the file <em>template1.html</em>.</p>

<pre><code>use Template::Recall;

my $tr = Template::Recall-&gt;new( template_path =&gt; 'template1.html');</code></pre>

<p>With <code>$tr</code> created, the template sections are loaded and ready for use. The obvious first step is to render the header section with the <code>render()</code> method. <code>render()</code> takes the name of the section to process, and optionally, a hash of names and values to replace in that section. There are two template variables in the header section, <code>[' title ']</code> and <code>[' date ']</code>, so the call looks like:</p>

<pre><code>print $tr-&gt;render( 'header', { title =&gt; 'MyStore', date =&gt; scalar(localtime) } );</code></pre>

<p>The names used in the hash must match the names of the template variables in the section you intend to render. For example, <code>date =&gt; scalar(localtime)</code> means that <code>[' date ']</code> in the header section will be dynamically replaced by the value produced by <code>scalar(localtime)</code>.</p>

<p>You probably noticed from the template that the header section created the start of an HTML table. This is a fine time to render <code>@goods</code> as the table's rows.</p>

<pre><code>for my $good (@goods)
{
    my @attr     = split(/,/, $good);
    my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];

    my %row      = (
        shoe     =&gt; $attr[0],
        details  =&gt; $attr[1],
        price    =&gt; $attr[2],
        quantity =&gt; $quantity,
    );

    print $tr-&gt;render('product_row', \%row);
}</code></pre>

<p>In actual code, this array would likely come from a database. For each row, the driver makes necessary logical decisions (such as displaying "Out of stock" if the quantity equals "0"), then calls <code>$tr-&gt;render()</code> to replace the placeholders in the template section with the values from <code>%row</code>.</p>

<p>Finally, the driver renders the footer of the HTML output. There are no template variables to replace, so there's no need to pass in a hash.</p>

<pre><code>print $tr-&gt;render('footer');</code></pre>

<p>The result is this nice little output of footwear inventory:</p>

<h4>The date is Fri Aug 10 14:22:30 2007</h4>

<table>
<tr>
<th>Shoe</th>
<th>Details</th>
<th>Price</th>
<th>Quantity</th>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>
</table>

<h3>The Logic Is in the Code</h3>

<p>What happens if you extend your shoe data slightly, to add categories? For instance, what if <code>@goods</code> looks like:</p>

<pre><code>my @goods = (
    "dress,oxfords,Brown leather,\$85,0",
    "sports,hiking,All sizes,\$55,7",
    "sports,tennis shoes,Women's sizes,\$35,15",
    "recreation,flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>The output now needs grouping, which implies the use of nested loops. One loop can output the category header -- sports, dress, or recreation shoes -- and another will output the details of each shoe in that category.</p>

<p>To handle this in HTML::Template, you would generally build a nested data structure of anonymous arrays and hashes, and then process it against nested <code>&lt;TMPL_LOOP&gt;</code> directives in the template. Template::Recall logic remains in the code, you would build a nested loop structure in Perl that calls the appropriate sections. You can also use a hash to render the category sections as keys and detail sections as values in a single pass, and output them together using <code>join</code>.</p>

<p>The template needs some modification:</p>

<pre><code>[====== table_start ====]
&lt;table border="1"&gt;
[====== category =======]
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;b&gt;['category']&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
[====== detail ======]
&lt;tr&gt;&lt;td&gt;['shoe']&lt;/td&gt;&lt;td&gt;['detail']&lt;/td&gt;&lt;td&gt;['price']&lt;/td&gt;&lt;td&gt;['quantity']&lt;/td&gt;&lt;/tr&gt;
[======= table_end ====]
&lt;/table&gt;</code></pre>

<p>This template now has a section called "category," a single table row that spans all columns. The "detail" section is pretty much the same as in the previous.</p>

<pre><code>my %inventory;

for my $good (@goods) {
    my @attr = split(/,/, $good);
    my $q    = $attr[4] == 0 ? 'Out of stock' : $attr[4];

    $inventory{ $tr-&gt;render('category', { category =&gt; $attr[0] } ) } .=
        $tr-&gt;render('detail',
            {
                shoe     =&gt; $attr[1],
                detail   =&gt; $attr[2],
                price    =&gt; $attr[3],
                quantity =&gt; $q,
            } );
}

print $tr-&gt;render('table_start') .
    join('', %inventory) .
    $tr-&gt;render('table_end');</code></pre>

<p>This loop looks surprisingly similar to the first example, doesn't it? That's because it is. Instead of printing each row, however, this code renders the first column in <code>@goods</code> against the category template section, and then storing the output as a key in <code>%inventory</code>. In the same iteration, it renders the remaining columns against the detail section and appends to the value of that key.</p>

<p>After storing the rendered sections in this way to <code>%inventory</code>, the code prints everything with a single statement, using <code>join</code> to print all the values in <code>%inventory</code>, including keys. The output is:</p>

<table>
<tr>
<td><strong>recreation</strong>
</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>

<tr>
<td><strong>sports</strong>
</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td><strong>dress</strong>
</td>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>
</table>

<p>The code also handles conditional output. Suppose that at your growing online shoe emporium you provide special deals to customers who have bought over a certain dollar amount. As they browse your shoe inventory, these deals appear.</p>

<pre><code>if ( $customer-&gt;is_elite ) {
    print $tr-&gt;render('special_deals', get_deals('elite') );
}
else {
    print $tr-&gt;render('standard_deals', get_deals() );
}</code></pre>

<p>What about producing XML output? This usually requires a separate template? You can conditionally load a <em>.xml</em> or <em>.html</em> template:</p>

<pre><code>my $tr;
if ( $q-&gt;param('fmt') eq 'xml' ) {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.xml' );
}
else {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.html' );
}</code></pre>

<p>Perl provides everything you need to handle model, controller, <em>and</em> view logic. Template::Recall capitalizes on this and helps to make projects code driven.</p>

<h3>Template Model Comparison</h3>

<p>It's important to note a few things that occurred in these examples -- or failed to occur, rather. First, there's no mixture of code and template markup. All template access occurs through the method call <code>$tr-&gt;render()</code>. This is strong separation of concerns (SOC), just like the pipeline model, and unlike the callback model, which mixes template markup and code in the same file. Not only does strong SOC provide good code organization, it also keeps designers from having to sift through code to change markup. Consider using Mason to output the rows of <code>@goods</code>.</p>

<pre><code>% for my $good (@goods) {
%  my @attr     = split(/,/, $good);
%  my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];
&lt;tr&gt;
&lt;td&gt;&lt;% $attr[0] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[1] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[2] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $quantity %&gt;&lt;/td&gt;
&lt;/tr&gt;
% }</code></pre>

<p>This is an efficient approach, and easy enough for a programmer to walk through. It becomes difficult to maintain though, when designers are involved, if for no other reason than because a designer and a programmer need to access the same file to do their respective work. Design changes and code changes will not always share the same schedule because they belong to different domains. It also means that in order to switch templates, say to output XML or text (or both), you have to add more and more conditionals and templates to the code, making it increasingly difficult to read.</p>

<p>The other thing that did not occur in this example is the leaking of any kind of logic (presentation or otherwise) into the template. Consider that HTML::Template would have to insert the <code>&lt;TMPL_LOOP&gt;</code> statement in the template in order to output the rows of <code>@goods</code>.</p>

<pre><code>    &lt;TMPL_LOOP NAME="PRODUCT"&gt;
    &lt;tr&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=SHOE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=DETAILS&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=PRICE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=QUANTITY&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/TMPL_LOOP&gt;</code></pre>

<p>That's not a big deal, really. If you care about line count, this only requires one extra line over the Template::Recall version, and that's the the closing tag <code>&lt;/TMPL_LOOP&gt;</code>. Nonetheless, the template now states some of the logic for the application. Sure, it's only presentation logic, but it's logic nonetheless. HTML::Template also provides <code>&lt;TMPL_IF&gt;</code> for displaying items conditionally, and <code>&lt;TMPL_INCLUDE&gt;</code> for including other templates. Again, this is logic contained in the template files.</p>

<p>Template::Recall keeps as much logic as possible in the code. If you need to display something conditionally, use Perl's <code>if</code> statement. If you need to include other templates, load them using a Template::Recall object. Whereas the pipeline models likely work better for projects with a fairly sophisticated design team, Template::Recall tries to be the programmer's friend and let him or her steer from the most comfortable place, the code.</p>

<p>There is also a subtle cost to using the pipeline model for a simple loop like that above. Consider this HTML::Template footwear data code:</p>

<pre><code>my $template = HTML::Template-&gt;new(filename =&gt; template1.tmpl');

my @output;

for my $good (@goods)
{
    my @attr = split(/,/, $_);
    my %row  = (
        SHOE     =&gt; $attr[0],
        DETAILS  =&gt; $attr[1],
        PRICE    =&gt; $attr[2],
        QUANTITY =&gt; $attr[3],
    );
    push( @output, \%row );
}

$template-&gt;param(PRODUCT =&gt; \@output);

print $template-&gt;output();</code></pre>

<p>The code iterates over <code>@goods</code> and builds a second array, <code>@output</code>, with the rows as hash references. Then the template iterates over <code>@output</code> within <code>&lt;TMPL_LOOP&gt;</code>. That's walking over the same data twice. Template sections do not suffer this cost, because you can output the data immediately, as you get it:</p>

<pre><code>print $tr-&gt;render('product_row', \%row);</code></pre>

<p>This is essentially what happens with Mason (or JSP/PHP/ASP for that matter). The main difference is that Template::Recall renders the section through a method call rather than mixing code and template.</p>

<p>Template::Recall, by using sectioned templates, combines the efficiency of the callback model with the strong, clean separation of concerns inherent in the pipeline model, and perhaps gets the best of both worlds.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1004" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/10/file-editing.html" rel="bookmark">FMTYEWTK About Mass Edits In Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Geoff Broadwell</span> on <abbr class="published" title="2004-10-14T00:00:00-08:00">October 14, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>For those not used to the terminology, FMTYEWTK stands for <em>F</em>ar
<em>M</em>ore <em>T</em>han <em>Y</em>ou <em>E</em>ver <em>W</em>anted
<em>T</em>o <em>K</em>now. This one is fairly light as FMTYEWTKs usually go. In
any case, the question before us is, "How do you apply an edit against a list
of files using Perl?" Well, that depends on what you want to do....</p>

<h3><a id="beginning">The Beginning</a></h3>

<p>If you only want to read in one or more files, apply a regex to the
contents, and spit out the altered text as one big stream -- the best approach is
probably a one-liner such as the following:</p>

<pre><code>perl -p -e "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<p>This command calls <code>perl</code> with the options <code>-p</code> and
<code>-e "s/Foo/Bar/g"</code> against the files listed in
<code><em>FileList</em></code>. The first argument, <code>-p</code>, tells Perl
to <em>p</em>rint each line it reads after applying the alteration. The second
option, <code>-e</code>, tells Perl to <em>e</em>valuate the provided
substitution regex rather than reading a script from a file. The Perl interpreter
then evaluates this regex against every line of all (space separated) files
listed on the command line and spits out one huge stream of the concatenated
fixed lines.</p>

<p>In standard fashion, Perl allows you to concatenate options without
arguments with following options for brevity and convenience.  Therefore,
you'll more often see the previous example written as:</p>

<pre><code>perl -pe "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<h3><a id="inplace">In-place Editing</a></h3>

<p>If you want to edit the files in place, editing each file before going on to
the next, that's pretty easy, too:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<p>The only change from the last command is the new option <code>-i.bak</code>,
which tells Perl to operate on files <em>i</em>n-place, rather than
concatenating them together into one big output stream. Like the
<code>-e</code> option, <code>-i</code> takes one argument, an extension to add
to the original file names when making backup copies; for this example I chose
<code>.bak</code>.  <strong>Warning:</strong> If you execute the command twice,
you've most likely just overwritten your backups with the changed versions from
the first run. You probably didn't want to do that.</p>

<p>Because <code>-i</code> takes an argument, I had to separate out the
<code>-e</code> option, which Perl otherwise would interpret as the argument to
<code>-i</code>, leaving us with a backup extension of <code>.bake</code>,
unlikely to be correct unless you happen to be a pastry chef. In addition, Perl
would have thought that <code>"s/Foo/Bar/"</code> was the filename of the
script to run, and would complain when it could not find a script by that
name.</p>

<h3><a id="multiple">Running Multiple Regexes</a></h3>

<p>Of course, you may want to make more extensive changes than just one regex.
To make several changes all at once, add more code to the evaluated script.
Remember to separate each additional line of code with a semicolon
(technically, you should place a semicolon at the end of each line of code, but
the very last one in any code block is optional). For example, you could make a
series of changes:</p>

<pre><code>perl -pi.bak -e "s/Bill Gates/Microsoft CEO/g;
 	s/CEO/Overlord/g" <em>&lt;FileList&gt;</em></code></pre>

<p>"Bill Gates" would then become "Microsoft Overlord" throughout the files.
(Here, as in all examples, we ignore such finicky things as making sure we
don't change "HERBACEOUS" to "HERBAOverlordUS"; for that kind of information,
refer to a good treatise on regular expressions, such as Jeffrey Friedl's
impressive book <a href="http://www.oreilly.com/catalog/regex2/">Mastering
Regular Expressions, 2nd Edition</a>. Also, I've wrapped the command to
fit, but you should type it in as just one line.)</p>

<h3><a id="printing">Doing Your Own Printing</a></h3>

<p>You may wish to override the behavior created by <code>-p</code>, which
prints every line read in, after any changes made by your script. In this case,
change to the <code>-n</code> option. <code>-p -e "s/Foo/Bar/"</code> is
roughly equivalent to <code>-n -e "s/Foo/Bar/; print"</code>. This allows you
to write interesting commands, such as removing lines beginning with hash marks
(Perl comments, C-style preprocessor directives, etc.):</p>

<pre><code>perl -ni.bak -e "print unless /^\s*#/;" <em>&lt;FileList&gt;</em></code></pre>

<h3><a id="fields">Fields and Scripts</a></h3>

<p>Of course, there are far more powerful things you can do with this. For
example, imagine a flat-file database, with one row per line of the file, and
fields separated by colons, like so:</p>

<pre><code>Bill:Hennig:Male:43:62000
Mary:Myrtle:Female:28:56000
Jim:Smith:Male:24:50700
Mike:Jones:Male:29:35200
...</code></pre>

<p>Suppose you want to find everyone who was over 25, but paid less than
$40,000. At the same time, you'd like to document the number and percentage of
women and men found. This time, instead of providing a mini-script on the
command line, we'll create a file, <code>glass.pl</code>, which contains the
script.  Here's how to run the query:</p>

<pre><code>perl -naF':' glass.pl <em>&lt;FileList&gt;</em></code></pre>

<p><em><code>glass.pl</code> contains the following</em>:</p>

<pre><code>BEGIN { $men = $women = $lowmen = $lowwomen = 0; }

next unless /:/;
/Female/ ? $women++ : $men++;
if ($F[3] &gt; 25 and $F[4] &lt; 40000)
    { print; /Female/ ? $lowwomen++ : $lowmen++; }

END {
print "\n\n$lowwomen of $women women (",
      int($lowwomen / $women * 100),
      "%) and $lowmen of $men men (",
      int($lowmen / $men * 100),
      "%) seem to be underpaid.\n";
}</code></pre>

<p>Don't worry too much about the syntax, other than to note some of the awk
and C similarities. The important thing here and in later sections is to see
how Perl makes these problems easily solvable.</p>

<p>Several new features appear in this example; first, if there is no
<code>-e</code> option to evaluate, Perl assumes the first filename listed, in
this case <code>glass.pl</code>, refers to a Perl script for it to execute. Secondly, two new options make it easy to deal with field-based data. <code>-a</code> (<em>a</em>utosplit mode) takes each line and splits its fields
into the array <code>@F</code>, based on the field delimiter given by the
<code>-F</code> (<em>F</em>ield delimiter) option, which can be a string or a
regex. If no <code>-F</code> option exists, the field delimiter defaults to
<code>' '</code> (one single-quoted space). By default, arrays in Perl are
zero-based, so <code>$F[3]</code> and <code>$F[4]</code> refer to the age and
pay fields, respectively.  Finally, the <code>BEGIN</code> and <code>END</code>
blocks allow the programmer to perform actions before file reading begins and
after it finishes, respectively.</p>

<h3><a id="files">File Handling</a></h3>

<p>All of these little tidbits have made use only of data from within the files
being operated on. What if you want to be able to read in data from elsewhere?
For example, imagine that you had some sort of file that allows includes; in
this case, we'll assume that you somehow specify these files by relative
pathname, rather than looking them up in an include path.  Perhaps the includes
look like the following:</p>

<pre><code>...
#include foo.bar, baz.bar, boo.bar
...</code></pre>

<p>If you want to see what the file looks like with the includes placed into
the master file, you might try something like this:</p>

<pre><code>perl -ni.bak -e "if (s/#include\s+//) {foreach $file
 (split /,\s*/) {open FILE, '&lt;', $file; print &lt;FILE&gt;}}
 else {print}" <em>&lt;FileList&gt;</em></code></pre>

<p>To make it easier to see what's going on here, this is what it looks like
with a full set of line breaks added for clarity:</p>

<pre><code>perl -ni.bak -e "
        if (s/#include\s+//) {
            foreach $file (split /,\s*/) {
                open FILE, '&lt;', $file;
                print &lt;FILE&gt;
            }
        } else {
            print
        }
    " <em>&lt;FileList&gt;</em></code></pre>


<p>Of course, this only expands one level of include, but then we haven't
provided any way for the script to know when to stop if there's an include
loop. In this little example, we take advantage of the fact that the
substitution operator returns the number of changes made, so if it manages to
chop off the <code>#include</code> at the beginning of the line, it returns a
non-zero (true) value, and the rest of the code splits apart the list of
includes, opens each one in turn, and prints its entire contents.</p>

<p>There are some handy shortcuts as well: if you open a new file using the
name of an old file handle (<code>FILE</code> in this case), Perl automatically
closes the old file first.  In addition, if you read from a file using the
<code>&lt;&gt;</code> operator into a list (which the <code>print</code>
function expects), it happily reads in the entire file at once, one line per
list entry.  The <code>print</code> call then prints the entire list, inserting
it into the current file, as expected. Finally, the <code>else</code> clause
handles printing non-include lines from the source, because we are using
<code>-n</code> rather than <code>-p</code>.</p>

<h3><a id="filelists">Better File Lists</a></h3>

<p>The fact that it is relatively easy to handle filenames listed within other
files indicates that it ought to be fairly easy to deal entirely with files
read from some other source than a list on the end of the command line. The
simplest case is to read all of the file contents from standard input as a
single stream, which is common when building up pipes. As a matter of fact,
this is so common that Perl automatically switches to this mode if there are no
files listed on the command line:</p>

<pre><code><em>&lt;Source&gt;</em> | perl -pe "s/Foo/Bar/g" | <em>&lt;Sink&gt;</em></code></pre>

<p>Here <em>Source</em> and <em>Sink</em> are the commands that generate the
raw data and handle the altered output from Perl, respectively. Incidentally, the
filename consisting of a single hyphen (<code>-</code>) is an explicit alias
for standard input; this allows the Perl programmer to merge input from files
and pipes, like so:</p>

<pre><code><em>&lt;Source&gt;</em> | perl -pe "s/Foo/Bar/g" header.bar - footer.bar
 | <em>&lt;Sink&gt;</em></code></pre>

<p>This example first reads a header file, then the input from the pipe source,
and then a footer file &mdash; the whole mess.  The program modifies this text
and sends it through to the out pipe.</p>

<p>As I mentioned earlier, when dealing with multiple files it is usually
better to keep the files separate, by using in-place editing or by explicitly
handling each file separately. On the other hand, it can be a pain to list all
of the files on the command line, especially if there are a lot of files, or
when dealing with files generated programmatically.</p>

<p>The simplest method is to read the files from standard input, pushing them
onto <code>@ARGV</code> in a <code>BEGIN</code> block; this has the effect of
tricking Perl into thinking it received all of the filenames on the command
line!  Assuming the common case of one filename per input line, the following
will do the trick:</p>

<pre><code><em>&lt;FilenamesSource&gt;</em> | perl -pi.bak -e "BEGIN {push @ARGV,
 &lt;STDIN&gt;; chomp @ARGV} s/Foo/Bar/g"</code></pre>

<p>Here we once again use the shortcut that reading in a file in a list context
(which <code>push</code> provides) will read in the entire file.  This adds the
entire contents, one filename per entry, to the <code>@ARGV</code> array, which
normally contains the list of arguments to the script. To complete the trick,
we <code>chomp</code> the line endings from the filenames, because Perl
normally returns the line ending characters (a carriage return and/or a line
feed) when reading lines from a file.  We don't want to consider these to be
part of the filenames. (On some platforms, you <em>could</em> actually have
filenames containing line ending characters, but then you'd have to make the
Perl code a little more complex, and you deserve to figure that out for
yourself for trying it in the first place.)</p>

<h3><a id="response">Response Files</a></h3>

<p>Another common design is to provide filenames on the command line as usual,
treating filenames starting with an <code>@</code> specially.  The program
should consider their contents to be lists of filenames to insert directly into
the command line. For example, if the contents of the file
<code>names.baz</code> (often called a <em>response file</em>) are:</p>

<pre><code>two
three
four</code></pre>

<p>then this command:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" one @names.baz five</code></pre>

<p>should work equivalently to:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" one two three four five</code></pre>

<p>To make this work, we once again need to do a little magic in a
<code>BEGIN</code> block. Essentially, we want to parse through the
<code>@ARGV</code> array, looking for filenames that begin with <code>@</code>.
We pass through any unmarked filenames, but for each response file found, we
read in the contents of the response file and insert the new list of filenames
into <code>@ARGV</code>.  Finally, we chomp the line endings, just as in the <a
href="#filelists">previous section</a>.  This produces a canonical file list in
<code>@ARGV</code>, just as if we'd specified all of the files on the command
line. Here's what it looks like in action:</p>

<pre><code>perl -pi.bak -e "BEGIN {@ARGV = map {s/^@// ? @{open RESP,
 '&lt;', $_; [&lt;RESP&gt;]} : $_} @ARGV; chomp @ARGV} s/Foo/Bar/g"
 <em>&lt;ResponseFileList&gt;</em></code></pre>

<p>Here's the same code with line breaks added so you can see what's going
on:</p>

<pre><code>perl -pi.bak -e "
        BEGIN {
            @ARGV = map {
                        s/^@// ? @{open RESP, '&lt;', $_;
                                   [&lt;RESP&gt;]}
                               : $_
                    } @ARGV;
            chomp @ARGV
        }
        
        s/Foo/Bar/g
    " <em>&lt;ResponseFileList&gt;</em></code></pre>

<p>The only tricky part is the <code>map</code> block.  <code>map</code>
applies a piece of code to every element of a list, returning a list of the
return values of the code; the current element is in the <code>$_</code>
special variable. The block here checks to see if it could remove a
<code>@</code> from the beginning of each filename. If so, it opens the file,
reads the whole thing into an anonymous temporary array (that's what the square
brackets are there for), and then inserts that array instead of the response
file's name (that's the odd <code>@{...}</code> construct). If there is no
<code>@</code> at the beginning of the filename to remove, the filename goes
directly into the map results. Once we've performed this expansion and chomped
any line endings, we can then proceed with the main work, in this case our
usual substitution, <code>s/Foo/Bar/g</code>.</p>

<h3><a id="recursing">Recursing Directories</a></h3>

<p>For our final example, let's deal with a major weakness in the way we've
been doing things so far &mdash; we're not recursing into directories, instead
expecting all of the files we need to read to appear explicitly on the command
line. To perform the recursion, we need to pull out the big guns:
<code>File::Find</code>. This Perl module provides very powerful recursion
methods.  It also comes standard with any recent version of the Perl
interpreter. The command line is deceptively simple, because all of the brains
are in the script:</p>

<pre><code>perl cleanup.pl <em>&lt;DirectoryList&gt;</em></code></pre>

<p>This script will perform some basic housecleaning, marking all files
readable and writeable, removing those with the extensions <code>.bak</code>,
<code>.$$$</code>, and <code>.tmp</code>, and cleaning up <code>.log</code>
files. For the log files, we will create a master log file (for archiving or
perusal) containing the contents of all of the other logs, and then delete the
logs so that they remain short over time. Here's the script:</p>

<pre><code>use File::Find;

die "All arguments must be directories!"
    if grep {!-d} @ARGV;
open MASTER, '&gt;', 'master.lgm';
finddepth(\&amp;filehandler, @ARGV);
close MASTER;
rename 'master.lgm', 'master.log';

sub filehandler
{
    chmod stat(_) | 0666, $_ unless (-r and -w);
    unlink if (/\.bak$/ or /\.tmp$/ or /\.\$\$\$$/);
    if (/\.log$/) {
        open LOG, '&lt;', $_;
        print MASTER "\n\n****\n$File::Find::name\n****\n";
        print MASTER &lt;LOG&gt;;
        close LOG;
        unlink;
    }
}</code></pre>

<p>This example shows just how powerful Perl and Perl modules can be, and at
the same time just how obtuse Perl can appear to the inexperienced.  In this
case, the short explanation is that the <code>finddepth()</code> function
iterates through all of the program arguments (<code>@ARGV</code>), recursing
into each directory and calling the <code>filehandler()</code> subroutine for
each file. That subroutine then can examine the file and decide what to do with
it. The example checks for readability and writability with <code>-r</code> and
<code>-w</code>, fixing the file's security settings if needed with
<code>chmod</code>. It then <code>unlink</code>s (deletes) any file with a name
ending in any of the three unwanted extensions. Finally, if the extension is
<code>.log</code>, it opens the file, writes a few header lines to the master
log, copies the file into the master log, closes it, and deletes it.</p>

<p>Instead of using <code>finddepth()</code>, which does a depth-first search
of the directories and visits them from the bottom up, we could have used
<code>find()</code>, which does the same depth-first search from the top down.
As a side note, the program writes the master log file with the extension
<code>.lgm</code>, then renames it at the end to have the extension
<code>.log</code>, so as to avoid the possibility of writing the master log
into itself if the program is searching the current directory.</p>

<h3><a id="end"></a>Conclusion</h3>

<p>That's it. Sure, there's a lot more that you could do with these examples,
including adding error checking, generating additional statistics, producing
help text, etc. To learn how to do this, find a copy of <em><a
href="http://www.oreilly.com/catalog/pperl3/">Programming Perl, 3rd
Edition</a></em>, by Larry Wall, Tom Christiansen, and Jon Orwant. This is the
bible (or the Camel, rather) of the Perl community, and well worth the read.
Good luck!</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-864" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/01/ttbook.html" rel="bookmark">How We Wrote the Template Toolkit Book ...</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                <abbr class="published" title="2004-01-30T00:00:00-08:00">January 30, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>There are a number of tools available for writing books.
Many people would immediately reach for their favorite word processor,
but having written one book using Microsoft Word I'm very unlikely to repeat the experience.
Darren Chamberlain,
Andy Wardley, and I are all Perl hackers, so when we got together to write <a href="http://www.oreilly.com/catalog/perltt/index.html?CMP=IL7015">Perl Template Toolkit</a>,
it didn't take us long to agree that we wanted to write it using POD (Plain Old Documentation).</p>

<p>Of course, any chosen format has its pros and cons.
With POD we had all the advantages of working with plain text files and all of the existing POD tools were available to convert our text into various other formats,
but there were also some disadvantages.
These largely stem from the way that books (especially technical books) are written.
Authors rarely write the chapters in the order in which they are published in the finished book.
In fact, it's very common for the chapters to rearranged a few times before the book is published.</p>

<p>Now this poses a problem with internal references.
It's all very well saying &quot;see chapter Six for further details&quot;,
but when the book is rearranged and Chapter Six becomes Chapter Four,
all of these references are broken.
Most word processors will allow you to insert these references as &quot;tags&quot; that get expanded (correctly) as the document is printed.
POD and emacs doesn't support this functionality.</p>

<csperl file="grab" domain="on" record="b/971" template="b/article_sidebar.view">

<p>Another common problem with technical books is the discrepancy between the code listings in the book and the code that actually got run to produce the output shown.
It's easily done.
You create an example program and cut-and-paste the code into the document.
You then find a subtle bug in the code and fix it in the version that you're running but forget to fix it in the book.
What would be really useful would be if you could just use tags saying &quot;insert this program file here&quot; and even &quot;insert the output of running the program here&quot;.
That's functionality that no word processor offers.</p>

<p>Of course,
these shortcomings would be simple to solve if you had a powerful templating system at the ready.
Luckily Andy,
Darren, and I had the Template Toolkit (TT) handy.</p>

<h3><a name="The_Book_Templates">The Book Templates</a></h3>

<p>We produced a series of templates that controlled the book's structure and a Perl program that pulled together each chapter into a single POD file.
This program was very similar to the <code>tpage</code> program that comes with TT,
but was specialized for our requirements.</p>

<h4><a name="Separating_code_from_code">Separating Code from Code</a></h4>

<p>There was one problem we had to address very early on with our book templates. This was the problem of listing TT code within a TT template.
We needed a way to distinguish the template directives we were using to produce the book from the template directives we were demonstrating <i>in the book</i>.</p>

<p>Of course TT provides a simple way to achieve this.
You can define the characters that TT uses to recognize template directives.
By default it looks for <code>[% ... %]</code>,
but there are a number of predefined groups of tags that you can turn on using the <code>TAGS</code> directive.
All of our book templates started with the line:</p>

<pre><code>  [% TAGS star %]</code></pre>

<p>When it sees this directive, the TT parser starts to look for template directives that are delimited with <code>[* ... *]</code>. The default delimiters (<code>[% ... %]</code>) are treated as plain text and passed through unaltered. Therefore, by using this directive we can use <code>[% ... %]</code> in our example code and <code>[* ... *]</code> for the template directives that we wanted TT to process.</p>

<p>Of course, the page where we introduced the <code>TAGS</code> directive and gave examples of its usage was still a little complex.</p>

<p>In the rest of this article, I'll go back to using the <code>[% ... %]</code> style of tags.</p>

<h4><a name="Useful_blocks_and_macros">Useful Blocks and Macros</a></h4>

<p>We defined a number of useful blocks and macros that expanded to useful phrases that would be used throughout the book. For example:</p>

<pre><code>  [% TT = 'Template Toolkit';

     versions = {
       stable = '2.10'
       developer = '2.10a'
     } %]</code></pre>

<p>The first of these must have saved each of us many hours of typing time and the second gave us an easy way to keep the text up-to-date if Andy released a new version of TT while we were writing the book. A template using these variables might look like this:</p>

<pre><code>  The current stable version of the [% TT %] is [% stable %]</code></pre>

<h4><a name="Keeping_track_of_chapters">Keeping Track of Chapters</a></h4>

<p>We used a slightly more complex set of variables and macros to solve the problem of keeping chapter references consistent. First we defined an array that contained details of the chapters (in the current order):</p>

<pre><code>  Chapters = [
    {  name  = 'intro'
       title = &quot;Introduction to the Template Toolkit&quot;
    }
    {  name  = 'web'
       title = &quot;A Simple Web Site&quot;
    }
    {  name  = 'language'
       title = &quot;The Template Language&quot;
    }
    {  name  = 'directives'
       title = &quot;Template Directives&quot;
    }
    {  name  = 'filters'
       title = &quot;Filters&quot;
    }
    {  name  = 'plugins'
       title = &quot;Plugins&quot;
    }
    ... etc ...
   ]</code></pre>

<p>Each entry in this array is a hash with two keys. The name is the name of the directory in our source tree that contains that chapter's files and the title is the human-readable name of the chapter.</p>

<p>The next step is to convert this into a hash so that we can look up the details of a chapter when given its symbolic name.</p>

<pre><code>    FOREACH c = Chapters;
      c.number = loop.count;
      Chapter.${c.name} = c;
    END;</code></pre>

<p>Notice that we are adding a new key to the hash that describes a chapter. We use the <code>loop.count</code> variable to set the chapter number. This means that we can reorder our original <code>Chapters</code> array and the chapter numbers in the <code>Chapter</code> hash will always remain accurate.</p>

<p>Using this hash, it's now simple to create a macro that lets us reference chapters. It looks like this:</p>

<pre><code>  MACRO chref(id) BLOCK;
    THROW chapter &quot;invalid chapter id: $id&quot;
      UNLESS (c = Chapter.$id);
    seen = global.chapter.$id;
    global.chapter.$id = 1;
    seen ? &quot;Chapter $c.number&quot;
         : &quot;Chapter $c.number, I&lt;$c.title&gt;&quot;;
  END;</code></pre>

<p>The macro takes one argument, which is the id of the chapter (this is the unique name from the original array). If this chapter doesn't exist in the <code>Chapter</code> hash then the macro throws an error. If the chapter exists in the hash then the macro displays a reference to the chapter. Notice that we remember when we have seen a particular chapter (using <code>global.chapter.$id</code>) -- this is because O'Reilly's style guide says that a chapter is referenced differently the first time it is mentioned in another chapter. The first time, it is referenced as &quot;Chapter 2, <i>A Simple Web Site</i>&quot;, and on subsequent references it is simply called &quot;Chapter 2. &quot;</p>

<p>So with this mechanism in place, we can have templates that say things like this:</p>

<pre><code>  Plugins are covered in more detail in [% chref(plugins) %].</code></pre>

<p>And TT will convert that to:</p>

<pre><code>  Plugins are covered in more detail in Chapter 6, I&lt;Plugins&gt;.</code></pre>

<p>And if we subsequently reorder the book again, the chapter number will be replaced with the new correct number.</p>

<h4><a name="Running_example_code">Running Example Code</a></h4>

<p>The other problem I mentioned above is that of ensuring that sample code and its output remain in step. The solution to this problem is a great example of the power of TT.</p>

<p>The macro that inserts an example piece of code looks like this:</p>

<pre><code>  MACRO example(file, title) BLOCK;
    global.example = global.example + 1;
    INCLUDE example
      title = title or &quot;F&lt;$file&gt;&quot;
      id    = &quot;$chapter.id/example/$file&quot;
      file  = &quot;example/$file&quot;
      n     = global.example;
    global.exref.$file = global.example;
  END;</code></pre>

<p>The macro takes two arguments, the name of the file containing the example code and (optionally) a title for the example. If the title is omitted then the filename is used in its place. All of the examples in a particular chapter are numbered sequentially and the <code>global.example</code> variable holds the last used value, which we increment. The macro then works out the path of the example file (the structure of our directory tree is very strict) and <code>INCLUDE</code>s a template called <code>example</code>, passing it various information about the example file. After processing the example, we store the number that is associated with this example by storing it in the hash <code>global.exref.$file</code>.</p>

<p>The <code>example</code> template looks like this:</p>

<p>[% IF publishing -%] =begin example [% title %]</p>

<pre><code>      Z&lt;[% id %]&gt;[% INSERT $file FILTER indent(4) +%]

  =end
  [% ELSE -%]
  B&lt;Example [% n %]: [% title %]&gt;

  [% INSERT $file FILTER indent(4) +%]</code></pre>

<p>[% END -%]</p>

<p>This template looks at a global flag called <code>publishing</code>, which determines if we are processing this file for submission to O'Reilly or just for our own internal use. The <code>Z&lt; ... &gt;</code> POD escape is an O'Reilly extension used to identify the destination of a link anchor (we'll see the link itself later on). Having worked out how to label the example, the template simply inserts it and indents it by four spaces.</p>

<p>This template is used within our chapter template by adding code like <code>[% example('xpath', 'Processing XML with XPath') %]</code> to your document. That will be expanded to something like, "Example 2: Processing XML with Xpath," followed by the source of the example file, <code>xpath</code>.</p>

<p>All of that gets the example code into that document. We now have to do two other things. We need to be able to reference the code from the text of the chapter ('As example 3 demonstrates...'), and we also need to include the results of running the code.</p>

<p>For the first of these there is a macro called <code>exref</code>, which is shown below:</p>

<pre><code>  MACRO exref(file) BLOCK;
    # may be a forward reference to next example
    SET n = global.example + 1
      UNLESS (n = global.exref.$file);
    INCLUDE exref
      id    = &quot;$chapter.id/example/$file&quot;;
  END;</code></pre>

<p>This works in conjunction with another template, also called <code>exref</code>.</p>

<pre><code>  [% IF publishing -%]
  A&lt;[% id %]&gt;
  [%- ELSE -%]
  example [% n %]
  [%- END -%]</code></pre>

<p>The clever thing about this is that you can use it <i>before</i> you have included the example code. So you can do things like:</p>

<pre><code>  This is demonstrated in [% exref('xpath') %].

  [% example('xpath', 'Processing XML with XPath') %]</code></pre>

<p>As long as you only look at a maximum of one example ahead, it still works. Notice that the <code>A&lt; ... &gt;</code> POD escape is another O'Reilly extension that marks a link anchor. So within the O'Reilly publishing system it's the <code>A&lt;foo&gt;</code> and the associated <code>Z&lt;foo&gt;</code> that make the link between the reference and the actual example code.</p>

<p>The final thing we need is to be able to run the example code and insert the output into the document. For this we defined a macro called <code>output</code>.</p>

<pre><code>  MACRO output(file) BLOCK;
    n = global.example;
    &quot;B&lt;Output of example $n:&gt;\n\n&quot;;
    INCLUDE &quot;example/$file&quot; FILTER indent(4);
  END;</code></pre>

<p>This is pretty simple. The macro is passed the name of the example file. It assumes that this is the most recent example included in the document so it gets the example number from <code>global.example</code>. It then displays a header and <code>INCLUDE</code>s the file. Notice that the major difference between <code>example</code> and <code>output</code> is that <code>example</code> uses <code>INSERT</code> to just insert the file's contents, whereas <code>output</code> uses <code>INCLUDE</code>, which loads the file and processes it.</p>

<p>With all of these macros and templates, we can now have example code in our document and be sure that the output we show really reflects the output that you would get by running that code. So we can put something like this in the document:</p>

<pre><code>  The use of GET and SET is demonstrated in [% exref('get_set') %].

  [% example('get_set', 'GET and SET') %]

  [% output('get_set') %]</code></pre>

<p>And that will be expanded to the following.</p>

<pre><code>  The use of GET and SET is demonstrated in example 1.

  B&lt;Example 1: GET and SET&gt;

      [% SET foo = 'bar -%]
      The variable foo is set to &quot;[% GET foo %]&quot;.

  B&lt;Output of example 1:

      The variable foo is set to &quot;bar&quot;.</code></pre>

<p>As another bonus, all of the example code is neatly packaged away in individual files that can easily be made into a tarball for distribution from the book's web site.</p>

<h4><a name="Other_templates,_blocks_and_macros">Other Templates, Blocks, and Macros</a></h4>

<p>Once we started creating these timesaving templates, we found a huge numbers of areas where we could make our lives easier. We had macros that inserted references to other books in a standard manner, macros for inserting figures and screenshots, as well as templates that ensured that all our chapters had the same standard structure and warned us if any of the necessary sections were missing. I'm convinced that the TT templates we wrote for the project saved us all a tremendous amount of time that would have otherwise been spent organizing and reorganizing the work of the three authors. I would really recommend a similar approach to other authors.</p>

<p>The Template Toolkit is often seen as a tool for building web sites, but we have successfully demonstrated one more non-Web area where the Template Toolkit excels.</p>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/system-administration-applications/">&laquo; System Administration Applications</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/tools/">Tools &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
