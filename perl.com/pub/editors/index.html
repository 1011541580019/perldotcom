<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Editors Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Editors</em> Category</h1>






                            
                            <div id="entry-820" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/08/tools.html" rel="bookmark">Perl Needs Better Tools</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Matisse Enzer</span> on <abbr class="published" title="2005-08-25T00:00:00-08:00">August 25, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />
<p>Perl is in danger of becoming a fading language--new programmers are
learning Java and Python in college, and companies like Google hardly use Perl
at all.  If you are afraid that Perl may be in danger of becoming irrelevant
for medium-to-large projects, then read on.</p>

<h3>The Scary Part</h3>

<p>I have discussed the future of Perl with managers from companies that
currently use it and find that they worry about the future of Perl. One company
I spoke with here in San Francisco is rewriting their core application in Java.
Another company worries they will not be able to find new Perl programmers down
the road.  Yet another uses Perl for major projects, but suffers from
difficulty in refactoring their extensive code base.</p>

<p>There are many reasons why companies care about the future of Perl. I offer
a part of a solution: better tools for Perl can be a major part of keeping Perl
relevant and effective as the primary language for medium and large
projects.</p>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1795" template="b/article_sidebar.view">
<!-- sidebar ends -->
<p>When measuring the effectiveness of a development environment (people,
language, tools, processes, etc.), a key measure is how expensive and painful it
is to make changes to existing code. Once a project or system has grown to
thousands of lines of code in dozens (or hundreds) of modules, the cost of
making changes can escalate to the point where the team is afraid to make any
significant change. Excellent tools are one of the ways to avoid this unhappy
situation, or at least reduce its impact.  Other factors are excellent
processes and, of course, excellent people.</p>

<h3>21st-Century Integrated Development Environments for Perl</h3>

<p>I propose that more, high-quality development tools will help keep Perl
relevant and alive in medium and large project environments.  My focus in this
article is on IDEs, or Integrated Development Environments, and primarily those
with a graphical interface.</p>

<p>An IDE is an integrated set of tools for programming, combining a source
code editor with a variety of other tools into a single package. Common
features of modern IDEs include refactoring support, version control,
real-time syntax checking, and auto-completion of code while typing.</p>

<p>I want to make it clear right at the outset that a team of highly skilled
Perl programmers, using only tools that have been around for years (such as
<code>emacs</code>, <code>vi</code>, <code>cvs</code>, and <code>make</code>)
can and do build large, sophisticated, and successful projects.  I am not
worried about those programmers. I am worried about the larger population of
programmers with one to five years of experience, and those who have not yet begun to
program: the next generation of Perl programmers.</p>

<p>Great tools will not make a bad programmer into a good programmer, but they
will certainly make a good programmer better.  Unfortunately, the tools for
Perl are years behind what is available for other languages, particularly
Java.</p>

<p>One powerful example is the lack of graphical IDEs for Perl with excellent
support for refactoring.  Several IDEs for Java have extensive refactoring
support.  Only one for Perl, the <a href="http://e-p-i-c.sf.net/">EPIC plugin
for Eclipse</a>, supports even a single refactoring action.</p>

<p>For an example of how good IDEs have inspired at least one Perl developer,
see <a href="/pub/au/Kennedy_Adam">Adam Kennedy</a>'s <a
href="/pub/a/2005/06/09/ppi.html">Perl.com article on his
new PPI module</a> and <a
href="http://search.cpan.org/dist/Devel-Refactor/">Scott Sotka's
Devel::Refactor module</a> (used in EPIC).</p>

<p>I acknowledge that a graphical IDE is not the be-all of good tools.  Just as
some writers reject word processors in favor of typewriters or hand-written
manuscripts, some programmers reject graphical IDEs and would refuse a job that
required them to use one.  Not everyone has (nor should have) the same tool
set, and there are things a pencil can do that <code>vi</code> and
<code>emacs</code> will never do. That said, IDEs have wide use in businesses
doing larger projects, and for many programmers and teams they provide major
increases in productivity.</p>

<p>Another important point is that while this article discusses over a dozen
specific tools or features, having all the tools in a single package produces
the biggest value. An IDE that provides all of these features in a single
package that people can easily install, easily extend, and easily maintain
across an entire development team has far more value than the sum of its
parts.</p>

<p>There is a big win when the features provided by an IDE immediately upon
installation include all or almost all of the tools and features discussed here
and where the features "know" about each other. For example, it is good if you
enter the name of a non-existent subroutine and the real-time syntax checker
catches this. It is much better if the code-assist feature then pops up a
context menu offering to create a stub for the subroutine or to correct the
name to that of an existing similar subroutine or method from another class that is
available to the current file. (This is standard behavior for some Java
IDEs.)</p>

<h3>What Would a 21st-Century Perl Tool Set Contain?</h3>

<p>Perl needs a few great IDEs--not just one, but more than one so that
people have a diverse set to choose from.  Perl deserves and needs a few great
IDEs that lead the pack and set the standard for IDEs in other languages.</p>














<p>I am well aware that the dynamic nature of Perl makes it harder to have a
program that can read and understand a Perl program, especially a large and
complex one, but the difficulty in comprehending a Perl program makes the value
of such a tool all the greater, and I have faith that the Perl community can
overcome some of the built-in challenges of Perl. Indeed, it is among the
greatest strengths of Perl that Perl users can adapt the language to their
needs.</p>

<p>A great Perl IDE will contain at least the following, plus other features I
haven't thought of. (And, of course, there must be many of those!)</p>

<ul>

<li>A <a href="#Syntax-coloring_text_editor">syntax-coloring text
editor.</a></li>

<li><a href="#Syntax-checking">Real-time syntax-checking</a> to catch and
display syntax errors as you type.</li>

<li><a href="#Version_control_integration">Version control integration</a> to
check out and compare code using CVS, Subversion, etc.</li>

<li>A <a href="?page=3#Code-assist">code-assist editor</a>, to provide a list of
methods when you type in an object reference, for example.</li>

<li><a href="?page=3#refactoring_support">Excellent refactoring
support</a>.</li>

<li>A <a href="?page=4#Tree_view_of_source">tree view of source files and
resources</a>.</li>

<li><a href="?page=4#support_for_unit_tests">Support for creating and running unit
tests</a>.</li>

<li><a href="?page=5#Language-specific_help">Language-specific help</a>.</li>

<li><a href="?page=5#Debugger">Real-time display of debugging results</a>.</li>

<li><a href="?page=5#Automatic_reformatting">Automatic code reformatting</a>.</li>

<li>Seamless <a href="?page=5#handling_of_multiple_languages">handling of multiple
languages</a> (such as Perl and C, Perl and Java, Perl and PHP, or Perl and
Python).</li>

<li><a href="?page=5#Automated_build_and_test">Automated build and test
support</a>.</li>

</ul>

<p>Most of the screen shot examples in this article use the EPIC Perl IDE.  At
present, it has the largest amount of the features on my list (although it
certainly doesn't have all of them).</p>

<h4><a id="Syntax-coloring_text_editor" />Syntax-Coloring Text Editor</h4>

<p>Most of you have probably seen this. It is available under <code>vim</code>, <code>emacs</code>,
BBEdit, and TextPad. Just about every decent text editor will colorize source
code so that keywords, operators, variables, etc., each have their own
color, making it easier to spot syntax errors such as forgetting to close a
quote pair.</p>

<h4><a id="Syntax-checking" />Real-Time Syntax Checking</h4>

<p><img src="/pub/2005/08/25/graphics/syntax_check.gif" width="309" height="135" alt="real-time syntax check example"
/><br />
<em>Figure 1. Real-time syntax checking</em></p>

<p>The IDE in Figure 1 shows that line 4 has an error because of the missing
<code>)</code> and that line 5 has an error because there is no declaration of
<code>$naame</code> (and <code>use strict</code> is in effect).</p>

<p>A key point here is that the IDE shows these errors right away, before you
save and compile the code. (In this example, the EPIC IDE lets you specify how
often to run the syntax check, from 0.01 to 10.00 seconds of idle time, or only
on demand.)</p>

<p>As nice as this is, it would be even better if the IDE also offered ways to
fix the problem, for example, offering to change <code>$naame</code> to
<code>$name</code>. Figure 2 shows an IDE that does exactly that; unfortunately,
for Java, not Perl.</p>

<p><img src="/pub/2005/08/25/graphics/syntax_help.gif" width="427" height="150" alt="syntax help from the IDE" /><br
/><em>Figure 2. Syntax help from the IDE</em></p>

<p>It would be great if Perl IDEs offered this kind of help.</p>

<h4><a id="Version_control_integration" />Version Control Integration</h4>

<p>All non-insane large projects use version control software. The most common
version control software systems are probably CVS, Perforce, Subversion, and
Visual SourceSafe.  Figure 3 shows an IDE comparing the local version of a file
to an older version from the CVS repository.</p>

<table width="250" cellspacing="0" cellpadding="0" border="0">
<tr>
<td>
<p class="secondary">
<a href="/2005/08/25/graphics/cvs_compare.gif" onclick="window.open('/2005/08/25/graphics/cvs_compare.gif','fullsize','toolbar=no,width=910,height=593,status=no,location=no,scrollbars=yes,resizable=yes,menubar=yes');return false"><img src="/pub/2005/08/25/graphics/cvs_compare_sm.gif" vspace="4" alt="Figure 3" width="220" height="143" border="0" /></a><br />
Figure 3. Comparing a local file to an older version in
CVS--click image for full-size screen shot</p>
</td>
</tr>
</table>

<p>CVS integration is available in many modern code editors, including <code>emacs</code>,
<code>vim</code>, and BBEdit, as well as graphical IDEs such as Eclipse and Komodo Pro.
Subversion integration is available as a plugin for Eclipse; Komodo Pro
supports Perforce and Subversion.</p>













<h4><a id="Code-assist" />A Code-Assist Editor</h4>

<p>Suppose that you have just typed in an object reference and want to call a
method on the object, but you are not sure what the method name is. Wouldn't it
be nice if the editor popped up a menu listing all of the methods available for
that object? It might look something like Figure 4.</p>

<p><img src="/pub/2005/08/25/graphics/auto_completion.gif" width="399" height="335" alt="automatic code completion" /><br
/><em>Figure 4. Automatic code completion</em></p>

<p>In this example, the IDE is able to figure out which class the object
<code>$q</code> is an instance of and lists the names of the available methods.
If you type a <code>p</code>, then the list shows only the method names
beginning with <code>p</code>. If you type <code>pa</code>, then the list shows
only the <code>param()</code> and <code>parse_params()</code> methods.</p>

<h4><a id="refactoring_support" />Excellent Refactoring Support</h4>

<p>The easier it is to do refactoring, the more often people will do it. The
following list contains the most common refactorings.  Your personal list will
probably be a little different. All of these are things you can do "manually,"
but the idea is to make them into one or two-click operations so that you will
do them much more often. (For a extensive list of refactoring operations, see
<a href="http://www.refactoring.com/catalog/">Martin Fowler's alphabetical list
of refactorings</a>.)</p>

<h5><a id="Extract_SubroutineMethod" />Extract Subroutine/Method</h5>

<p>The IDE should create a new subroutine using the selected code and replace
the selected code with a call to the new subroutine, with the proper
parameters. Here's an example of using the Extract Subroutine refactoring from
Eclipse/EPIC (which uses the <a
href="http://search.cpan.org/dist/Devel-Refactor/">Devel::Refactor</a>
module).</p>

<p>First, you select a chunk of code to turn into a new subroutine, and then
select Extract Subroutine from a context menu. You then get the a dialog box
asking for the name of the new subroutine (shown in Figure 5).</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_before.gif" width="500" height="329" alt="code before Extract
Subroutine refactoring" /><br /><em>Figure 5. Code before Extract Subroutine
refactoring</em></p>

<p>The IDE replaces the selected code with a call to the new subroutine, making
reasonable guesses about the parameters and return values (Figure 6). You may
need to clean up the result manually.</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_after.gif" width="500" height="45" alt="code after Extract
Subroutine refactoring" /><br /><em>Figure 6. Code after Extract
Subroutine</em></p>

<p>Figure 7 shows the new subroutine created by the IDE.  In this case, it needs
no changes, but sometimes you will need to adjust the parameters and/or return
value(s).</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_newsub.gif" width="314" height="241" alt="the new subroutine
created by Extract Subroutine" /><br /><em>Figure 7. The new subroutine created
by Extract Subroutine</em></p>

<p>Ideally, the editor should prompt you to replace similar chunks of code with
calls to the new subroutine.</p>













<h5><a id="Rename_SubroutineMethod" />Rename Subroutine/Method</h5>

<p>The IDE should find all the calls to the subroutine throughout your project
and offer to change them for you. You should be able to see a preview of all of 
the places a change could occur, and to accept or reject each one on a case-by-case
basis. The action should be undoable.</p>

<h5><a id="Rename_Variable" />Rename Variable</h5>

<p>Like Rename Subroutine, this feature should find all occurrences throughout
the project and offer to make the changes for you.</p>

<h5><a id="Change_SubroutineMethod_signature" />Change Subroutine/Method
Signature</h5>

<p>The IDE should be able to make reasonable guesses about whether each
subroutine or method call is supplying the proper parameters. Partly this is to
enable the <a href="?page=2#Syntax-checking">real-time syntax checking mentioned
above</a>,  and partly this is to enable you to select a subroutine declaration
and tell the IDE you want to refactor it by adding or removing a parameter. The
IDE should then prompt you for the change(s) you want to make, do its best
to find all of the existing calls to the subroutine, and offer to correct the
subroutine calls to supply the new parameters.</p>

<p>Obviously, this is an especially tricky thing to do in Perl, where
subroutines fish their parameters out of <code>@_</code>. So the IDE would have
to look carefully at how the code uses <code>shift</code>, <code>@_</code>, and
<code>$_[]</code> in order to have a reasonable guess about the parameters the
subroutine is expecting. In many common cases, though, a Perl IDE could make a
reasonable guess about the parameters, such as in the following two examples,
so that if you added or removed one, it could immediately prompt you about
making corrections throughout the project:</p>

<pre><code>sub doSomething {
    my $gender = shift;
    my $age    = shift;
    # Not too terribly hard to guess that $gender and $age are params
}

sub anotherThing {
    my ($speed,$direction) = @_;
    # No magic needed to guess $speed and $direction are params.
}</code></pre>

<h5><a id="Move_SubroutineMethod_to_different" />Move Subroutine/Method</h5>

<p>This refactoring operation should give you a list or dialog box to choose
the destination file in your project. The IDE should allow you to preview all
of the changes that it would make to accomplish the move, which will include
updating a call to the subroutine/method to use the proper class. At a minimum,
the IDE should show you or list all of the calls to the subroutine so you can make
the appropriate changes yourself. Ideally, the IDE should make a guess about
possible destinations; for example, if <code>$self</code> is a parameter to the
method being moved, then the IDE might try assuming the method is an object
(instance) method and initially only list destination classes that inherit from
the source class, or from which the source class inherits.</p>

<h5><a id="Change_package_name" />Change a Package Name</h5>

<p>As with Rename Subroutine and Rename Variable, when changing a package name,
the IDE should offer to update all existing references throughout your
project.</p>

<h4><a id="Tree_view_of_source" />Tree View and Navigation of Source Files
and Resources</h4>

<p>Another useful feature of good IDEs is being able to view all of the code
for a project, or multiple projects, in a tree format, where you can "fold" and
"unfold" the contents of folders. All of the modern graphical IDEs support this,
even with multiple projects in different languages.</p>

<p>Being able to view your project in this manner gives you both a high-level
overview and the ability to drill down into specific files, and to mix levels
of detail by having some folders show their contents and some not.</p>

<p>For example, Figure 8 shows a partial screen shot from ActiveState's Komodo
IDE.</p>

<p><img src="/pub/2005/08/25/graphics/komodo_code_tree.gif" width="204" height="318" alt="tree view of code in Komodo"
/><br /><em>Figure 8. Tree view of code in Komodo</em></p>

<h4><a id="support_for_unit_tests" />Support for Creating and Running Unit
Tests</h4>

<p>Anyone who has installed Perl modules from CPAN has seen unit tests--these
are the various, often copious, tests that run when you execute the <code>make
test</code> part of the installation process. The vast majority of CPAN modules
include a suite of tests, often using the <a
href="http://search.cpan.org/dist/Test-Harness">Test::Harness</a> and/or <a
href="http://search.cpan.org/dist/Test-Simple">Test::More</a> modules. A good
IDE will make it very easy to both create and run unit tests as you develop
your project.</p>













<p>The most basic form of support for unit tests in an IDE is simply to make it
easy to execute arbitrary scripts from within the IDE.  Create a
<em>test.pl</em> for your project and keep adding tests to it or to a
<em>t/</em> subdirectory as you develop, and keep running the script as you
make changes. All modern IDEs provide at least this minimal capability.</p>

<p>A more sophisticated level of support for unit tests might resemble the Java
IDE feature for tests written in JUnit, where you can select an existing class
file (a <em>.pm</em> file in Perl) and ask the IDE to create a set of stub
tests for every subroutine in the file. (See <a
href="http://www.junit.org/">JUnit</a> and the Perl module <code><a
href="http://search.cpan.org/dist/Test-Unit/">Test::Unit</a></code> for more on
unit tests.) Furthermore, the IDE should support running a set of tests and
giving simple visual feedback on what passed/failed. The standard approach in
the JUnit world is to show either a "green bar" (all passed) or "red bar"
(something failed) and then allow you to see details on failures. Other
nice-to-have features include calculating code-coverage, providing statistical
summaries of tests, etc.</p>

<p>Figure 9 shows a successful run of a Java test suite with Eclipse.</p>

<p><img src="/pub/2005/08/25/graphics/unit_tests_success.gif" width="339" height="199" alt="JUnit test run, success" /><br
/><em>Figure 9. A successful JUnit test run</em></p>

<p>Figure 10 shows the same test run, this time with a failure.</p>

<p><img src="/pub/2005/08/25/graphics/unit_tests_failure.gif" width="339" height="222" alt="JUnit test run, with a failure." /><br />
<em>Figure 10. A JUnit test run with a failure</em></p>

<p>A stack trace of the failure message appears in another part of the window
(cropped out here to save space).  If you double-click on the test that failed
(<code>testInflate</code>), the IDE will open the file
(<code>BalloonTest</code>, in this case) and navigate to the test function.</p>

<p>The central idea is that the IDE should make it as painless as possible to
add and modify and run tests, so you will do more of it during development.</p>

<h4><a id="Language-specific_help" />Language-Specific Help</h4>

<p>This is a fairly straightforward idea--the IDE should be able to find and
display the appropriate documentation for any keyword in your code, so if you
highlight <code>push</code> and ask for help, you should see the
<code>push</code> entry from the Perl documentation. If you highlight a method
or subroutine or other symbol name from an imported module, the IDE should
display the module's documentation for the selected item. Of course, this
requires that the documentation be available in a consistent, machine-readable
form, which is only sometimes true.</p>

<h4><a id="Debugger" />Debugger with Real-Time Display of Results</h4>

<p>All modern IDEs offer support for running your code under a debugger,
usually with visual display of what's going on, including the state of
variables. The <a
href="http://aspn.activestate.com/ASPN/docs/Komodo/3.1/komodo-doc-debugperl.html#debugperl_top">Komodo
IDE supports debugging Perl that is running either locally or remotely</a>.</p>

<p>Typical support for debugging in an IDE includes the ability to set
breakpoints, monitor the state of variables, etc.  Basically, the IDE should
provide support for all of the features of the debugger itself.  Graphical IDEs
should provide a visual display of what is going on.</p>

<h4><a id="Automatic_reformatting" />Automatic Code Reformatting</h4>

<p>This means automatically or on-demand re-indenting and other reformatting of
code. For example, when you cut and paste a chunk of code, the IDE should
support reformatting the chunk to match the indentation of its new location. If you change the number of spaces or tabs for each level of indentation, or
your convention for the placement of curly braces, then the IDE should support
adjusting an entire file or all files in your project.</p>

<h4><a id="handling_of_multiple_languages" />Seamless Handling of Multiple
Languages</h4>

<p>Many large software projects involve multiple languages. This is almost
universally true in the case of web applications, where the user interface
typically uses HTML, CSS, and JavaScript, and the back end uses one or more of
Perl, PHP, Java, Python, Ruby, etc. It is very helpful to have development
tools that seamlessly integrate work done in all of the languages.  This is
becoming quite common. For example, both Komodo and Eclipse support multiple
languages.</p>

<h4><a id="Automated_build_and_test" />Automated Building and Testing</h4>

<p>This feature can be very basic by making it easy to run an arbitrary script
from within the IDE and to see its output. This could be as simple as having
the IDE configured to have a one-click way of running the traditional Perl
module build-and-test commands:</p>

<pre><code>$ perl Makefile.PL
$ make
$ make test</code></pre>

<p>A more advanced version of this feature might involve having the IDE create
stub code to test all of the subroutines in an existing file, or to run all of the
scripts in a specified directory under <code>Test::Harness</code>, or to run a
set of tests using <a
href="http://search.cpan.org/perldoc/Test::Unit::TestRunner">Test::Unit::TestRunner</a>
or <a
href="http://search.cpan.org/perldoc/Test::Unit::TkTestRunner">Test::Unit::TkTestRunner</a>.
(The latter provides a GUI testing framework.)</p>













<h3>Conclusion and Recommendations</h3>

<p>While there are many tools for helping Perl development, the current state
of the Perl toolbox is still years behind those of other languages--perhaps three to five years
behind, when compared to Java tools. While there are several tools for Java that
have all the features described above, virtually none for Perl have all of them.
On the other hand, things are looking up; they are better now than a year ago.
It's possible to close that gap in a year or two.</p>

<p>A couple of obvious areas where improvements could be somewhat easy are
adding more features to EPIC and Komodo.  EPIC is open source, so there is
potentially a wider pool of talent that could contribute. On the other hand,
Komodo has a company with money behind it, so people actually get paid to
improve it. Hopefully both tools will get better with time.</p>

<p>Another interesting possibility is the development of new IDEs or adding to
existing ones by using <a
href="/pub/a/2005/06/09/ppi.html">Adam Kennedy's PPI
module</a>, which provides the ability to parse Perl documents into a
reasonable abstract syntax tree and to manipulate the elements and re-compose
the document. There is a <a
href="http://search.cpan.org/dist/Text-Editor-Vip/">new Perl editor project,
VIP, that is in the design stages</a> and is intended to be "pluggable" and to have
special features to support pair programming.</p>

<p>Finally, I've gathered a couple of lists of links for related material. The
first list below consist of IDEs and graphical editors for Perl, and the second
list consists of various related articles and websites. I hope this is all
inspirational and helpful.</p>

<h3>Current IDEs for Perl</h3>

<p>The listed IDEs support Perl. The list is undoubtedly
incomplete, but should form a good starting point for anyone wishing
to look into this further.</p>

<ul>
<li><p><a href="http://www.latenightsw.com/affrus/">Affrus</a></p>

<p>Perl only, Mac OS X only. Closed source (and hence not extensible by
users). Primarily designed for CGI and standalone scripts. Free demo
available. $99 to purchase.  (See the <a
href="/pub/a/2004/05/14/affrus.html">Perl.com review of
Affrus</a> to learn more.)</p></li>

<li><p><a href="http://e-p-i-c.sf.net/">Eclipse/EPIC</a></p>

<p>EPIC is a plugin for the <a href="http://www.eclipse.org/">Eclipse
platform</a>. Eclipse is open-source and cross platform
(Windows/Mac/Linux/Solaris, etc.). Once you have Eclipse installed, <a
href="http://e-p-i-c.sf.net/updates">install the EPIC plugin from within the
Eclipse application</a> using the <a href="http://e-p-i-c.sf.net/updates/">EPIC
update URL</a>.  Eclipse supports Java, and with plugins, C/C++, COBOL, Perl,
PHP, UML2, Python, Ruby, XML, and more. There is a large and active community
around Eclipse.</p></li>

<li>Emacs is the mother of all
text-editor/development-environment/adventure-game/all-in-one tools. Expert
programmers use it widely and there are numerous enhancements for working with
particular languages, including, of course, Perl. <a
href="http://www.emacswiki.org/cgi-bin/wiki/CPerlMode">Emacs, with
CPerlMode</a>,  is a richly featured IDE for Perl, albeit a non-GUI IDE (which,
for some people, makes it even better). <a
href="http://groups.yahoo.com/group/extremeperl/files/">A set of extensions for
CPerlMode are available</a> but you need to join the Yahoo Extreme Perl group
to get to them.</li>

<li><p><a href="http://www.activestate.com/Products/Komodo/">Komodo</a></p>

<p>This runs on Linux, Solaris, and Windows. Free demo; $29.95 for personal and
student use, $295 for commercial use.  It supports Perl, PHP, Python, Tcl, and
XSLT.</p></li>

<li><p><a href="http://www.elora.hostings.com/SOFTWARE/page/">PAGE</a></p>

<p>PAGE runs only on Windows (9x/ME/NT/2000/XP). It is a Rapid
Application Development tool for Perl and comes in three versions: Free,
Standard ($10), and Enterprise ($50). PAGE provides a several "wizards" for
creating scripts, modules (packages), web forms, and even database
applications.</p></li>

<li><p><a href="http://www.enginsite.com/Perl.htm">Perl Editor</a></p>

<p>This closed source program runs only on Windows (9x/NT/2000/XP). It has a GUI
code profiler, and the Pro version has a regular expression tester and built-in
web server (for CGI testing, etc.). Perl Editor claims to have the best
debugger on the market. It also comes with GUI tools for managing MySQL
databases. $69.95 to purchase.</p></li>

<li><p><a href="http://vim.sourceforge.net/"><code>vim</code></a></p>

<p>The well-known descendent of <code>vi</code> is a powerful and flexible text
editor with many plugins and extensions. Have a look at the
<a href="http://vim.sourceforge.net/"><code>vim</code> scripts </a>; for
example, <a href="http://vim.sourceforge.net/scripts/script.php?script_id=556">vim.sourceforge.net/scripts/script.php?script_id=556</a>
and <a href="http://vim.sourceforge.net/scripts/script.php?script_id=281">vim.sourceforge.net/scripts/script.php?script_id=281</a>.</p></li>

<li><p><a href="http://www.helpconsulting.net/visiperl/">visiPerl</a></p>

<p>This is a closed source application that runs on Win9x/NT/2000.  It handles
Perl and HTML and has code templates, being designed for website building.
visiPerl includes a built-in web server for testing and an FTP client for code
deployment.  There is a free demo, or you can purchase it for $59.</p></li>

</ul>

<h3>Related Topics</h3>

<ul>

<li><a href="http://www.artima.com/intv/testdriven.html">A conversation about
Test-Driven Development</a></li>

<li>"<a href="http://www.petdance.com/perl/automated-testing/">Automated Testing
With Perl</a>," Andy Lester's presentation on doing automated testing in
Perl</li>

<li><a href="http://www.extremeperl.org/bk/home">Extreme Perl book</a></li>

<li><a href="http://groups.yahoo.com/group/extremeperl/">Extreme Perl mailing
list</a></li>

<li><a href="http://www.jera.com/techinfo/xpfaq.html">eXtreme Programming FAQ</a></li>

<li><a href="http://agilemanifesto.org/">Manifesto for Agile Software Development</a></li>

<li>"<a href="/pub/a/2005/06/09/ppi.html">Parse Perl Independently</a>," an article about Adam Kennedy's PPI module</li>

<li><a href="http://www.testdriven.com/">testdriven.com</a></li>

<li><a href="http://www.junit.org/">JUnit</a></li>

<li>Jon Udell's article on "<a
href="http://weblog.infoworld.com/udell/2005/05/23.html#a1236">Tools for
Dynamic Languages</a>"</li>

<li><a href="http://www.refactoring.com/">Refactoring home page</a></li>

<li><a href="http://www.xprogramming.com/">XProgramming.com</a>: Resources for
and about Agile Software Development</li>

</ul>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-780" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/06/ppi.html" rel="bookmark">Independently Parsing Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Adam Kennedy</span> on <abbr class="published" title="2005-06-09T00:00:00-08:00">June  9, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />
<p>A few years into my programming career, I found myself involved in a
somewhat unusual web project for an enormous global IT company. Due to some odd
platform issues, we could  write the intranet half of the project
<em>only</em> in Perl and the almost-identical public internet half <em>only</em> in
Java.</p>

<p>In my efforts to pick up enough Java to help my Perl code interoperate with
the code from the Java guys, I stumbled on a relatively new editor with the
rather expansive name of JetBrains IntelliJ IDEA.</p>

<p>What a joy! It quite simply made learning Java an absolute pleasure, with
comprehensive tab completion, light and simple API docs, easy exploration of
the mountain of Java classes, and unobtrusive indicators showing me my mistakes
and offering to fix them. In short, it had lots of brains and a fast, clean
user interface.</p>

<h3>Where Is IntelliPerl?</h3>

<p>Although I only needed it heavily for a few months, it's been my gold
standard ever since, and my definition of what a &quot;great&quot; editor should be. I
install every new Perl editor and IDE I come across in the hope that Perl might
one day get an editor half as good as what Java has had for years.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1714" template="b/article_sidebar.view">
<!-- sidebar ends -->

<p>These great editors are spreading. Java is now up to one and a half (Eclipse
is nearly great but still seems not quite &quot;effortless&quot; enough about what it
does). Dreamweaver gave HTML people their great editor years ago, and I've
heard that Python may now have something that qualifies.</p>

<p>Interestingly, these great editors seem to share one major thing in
common.</p>

<h3>How to Build a Great Editor</h3>

<p>Rather than relying on the language's parser to examine code, great editors
seem to implement special parsers of their own. These parsers treat a file less
like code and more like a generic document (that just also happens to be
code).</p>

<p>It's a key distinction, and one that provides two critical capabilities.</p>

<p>First, it creates a &quot;round-trip&quot; capability, parsing a file into an internal
model and back out again without moving a single white space character out of
place. Even if parts of a file are broken or badly formatted, you can still
change other parts of the file and save it correctly without it changing
anything you don't alter.</p>

<p>Second, it makes the parser extremely safe and error-tolerant. Any code open
in an editor is there for a reason--generally because it isn't finished yet,
is broken, or needs changing. A document parser can hit a problem, flag it,
stumble for a character or so until it finds something it recognizes, and then
continue on.</p>

<p>Parsing as code is an entirely different task, and one often unsuited to
these type of faults.</p>

<p>For example, take the following.</p>

<pre><code>print &quot;Hello World!\n&quot;;
  
}
  
MyModule-&gt;foobar;</code></pre>

<p>For an editor using Perl itself to understand this code, it's game over once
it hits the naked closing brace, because the code is invalid. Without knowledge
of what is below the brace, you lose all of the intelligence that needs the parser:
syntax highlighting, module checking, helpful tips, the lot.</p>

<p>It's just simply not a reasonable way to build an editor, where a file can
be both unfinished and have dozens of bugs.</p>

<h3>Building a Document Parser for Perl</h3>

<p>Even without an editor to put it in (yet), a document parser for Perl would
be extraordinarily useful for all sorts of tasks. At the time, though, all I
really wanted was a really accurate HTML syntax highlighter.</p>

<p>Some time in early 2002, I was bored one afternoon and had a first stab at
the problem. The result was pretty predictable, given patterns I've seen in
others trying the same thing. It was A) based on regular expressions, and B)
useless for anything even remotely interesting.</p>

<p>Between then and the start of The Perl Foundation grant in December 2004,
I've spent a day or so a month on the problem, rewriting and throwing away
code. I've junked two tokenizers, one lexer, an analysis package, three syntax
highlighters, an obfuscation package, a quote engine, and half of the classes
in the current object tree.</p>

<p>Now, finally, <a href="http://search.cpan.org/perldoc?PPI">PPI</a> is
complete, bar some minor features and testing. It is 100 percent round-trip safe, and
it's been stress tested against the 38,000 (non-Acme) modules in CPAN, handling
all but 28 of the most broken and bizarre.</p>

<h3>What Does It Do?</h3>

<p>PPI should be the basis for any task where you need to parse, analyze or
manipulate Perl, and it finally provides a platform for doing these tasks to
their full potential. This covers a huge range of possible tasks; far too many
to cover in any depth here.</p>

<p>For this article, I want to demonstrate how PPI can improve existing tools
that currently only do a very basic job, when there is the potential for so
much more.</p>

<p>One of these is part of the PAR application-packaging module. When PAR
bundles a module into the internal include directory, it tries to reduce the
size of the modules by stripping out POD. Of course, what would be better would
be to strip out <em>everything</em> that is excess and cut PAR file sizes even
more.</p>

<p>This is a form of compression, but given the potential confusion in using
something like "Compress::Perl" as a name, I'm picking my own term.
I hereby anoint the term &quot;Squish&quot;. A squished module occupies as little space
as possible, having had redundant characters removed. It will be extremely
small, although it might look a little &quot;squished&quot; to look at :)</p>

<h3>Perl::Squish</h3>

<p>Rather than showing you the final project, I prefer to show the process of
squishing a single module.</p>

<pre><code># Where is File::Spec on our system?
use Class::Inspector;
my $filename = Class::Inspector-&gt;resolved_filename( 'File::Spec' );

# Load File::Spec as a document
use PPI;
my $Document = PPI::Document-&gt;new( $filename );
</code></pre>

<p>Everything you do with PPI starts and finishes with <a
href="http://search.cpan.org/perldoc?PPI::Document">PPI::Document</a> objects.
If you find yourself using the lexer directly, you are probably doing
something wrong.</p>

<p>Where can I start cutting out the fat? For starters, many core modules
have an <code>__END__</code> section.</p>

<pre><code># Get the (one and only) __END__ section
my $End = $Document-&gt;find_first( 'Statement::End' );
  
# Delete it from the document
$End-&gt;delete if $End;</code></pre>

<p>PPI provides a set of search methods that you can use on any element that
has children. <code>find_first</code> is a safe guess, because there can only
be one <code>__END__</code> section. The search methods actually take
<code>&amp;wanted</code> functions like <a
href="http://search.cpan.org/perldoc?File::Find">File::Find</a>, so
<code>'Statement::End'</code> is really syntactic sugar for:</p>

<pre><code>sub wanted {
    my ($Document, $Element) = @_;
    $Element-&gt;isa('PPI::Statement::End');
}</code></pre>

<p>Of course, there's a faster way to do the same thing.  The
<code>prune</code> method finds and immediately deletes all elements that match
a particular condition.</p>

<pre><code># Delete all comments and POD
$Document-&gt;prune( 'Token::Pod' );
$Document-&gt;prune( 'Token::Comment' );</code></pre>

<p>For a more serious example, here's how to  strip the non-compulsory braces
from <code>-&gt;method()</code>:</p>

<pre><code># Remove useless braces
$Document-&gt;prune( sub {
    my $Braces = $_[1];
    $Braces-&gt;isa('PPI::Structure::List')      or return '';
    $Braces-&gt;children == 0                    or return '';
    my $Method = $Braces-&gt;sprevious_sibling   or return '';
    $Method-&gt;isa('PPI::Token::Word')          or return '';
    $Method-&gt;content !~ /:/                   or return '';
    my $Operator = $Method-&gt;sprevious_sibling or return '';
    $Operator-&gt;isa('PPI::Token::Operator')    or return '';
    $Operator-&gt;content eq '-&gt;'                or return '';
    return 1;
    } );</code></pre>

<p>It's a little bit wordy, but is relatively straightforward to write.  Just
add conditions and discard as you go. You can get other elements, calculate
anything or call sub-searches.</p>

<p>When you have finished, be sure to save the file.</p>

<pre><code># Save the file
$Document-&gt;save( &quot;$filename.squish&quot; );</code></pre>

<h3>Wrapping It All Up</h3>

<p>All you need to do now is is wrap it all up in some typical module
boilerplate.</p>

<pre><code>package Perl::Squish;
  
use strict;
use PPI;
  
our $VERSION = '0.01';
  
# Squish a file in place
# Perl::Squish-&gt;file( $filename )
sub file {
    my ($class, $file) = @_;
    my $Document = PPI::Document-&gt;new( $file ) or return undef;
    $class-&gt;document( $Document ) or return undef;
    $Document-&gt;save( $file );
}
  
# Squish a document object
# Perl::Squish-&gt;document( $Document );
sub document {
    my ($squish, $Document) = @_;
      
    # Remove the stuff we did earlier
    $Document-&gt;prune('Statement::End');
    $Document-&gt;prune('Token::Comment');
    $Document-&gt;prune('Token::Pod');
      
    $Document-&gt;prune( sub {
        my $Braces = $_[1];
        $Braces-&gt;isa('PPI::Structure::List')      or return '';
        $Braces-&gt;elements == 0                    or return '';
        my $Method = $Braces-&gt;sprevious_sibling   or return '';
        $Method-&gt;isa('PPI::Token::Word')          or return '';
        $Method-&gt;content !~ /:/                   or return '';
        my $Operator = $Method-&gt;sprevious_sibling or return '';
        $Operator-&gt;isa('PPI::Token::Operator')    or return '';
        $Operator-&gt;content eq '-&gt;'                or return '';
        return 1;
        } );

    # Let's also do some whitespace cleanup
    my @whitespace = $Document-&gt;find('Token::Whitespace');
    foreach ( @whitespace ) {
        $_-&gt;{content} = $_-&gt;{content} =~ /\n/ ? &quot;\n&quot; : &quot; &quot;;
    }
      
    1;
}
  
1;</code></pre>

<p>Finally, the last step is to wrap it all up as a proper module.  You can see
the finished product prettied up with PPI's syntax highlighter at <a
href="http://ali.as/CPAN/Squish.html">CPAN::Squish</a>.  I've added a few
additional small features to the basic code described above, but you get the
idea.  See also <a
href="http://search.cpan.org/perldoc?Perl::Squish">Perl::Squish</a> for more
details.</p>

<p>In 15 minutes, I've knocked together a pretty simple module that
dramatically improves on what you could do <em>without</em> something like PPI.
Now imagine the hard things it makes possible.</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-742" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/03/lightning2.html" rel="bookmark">More Lightning Articles</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">chromatic</span> on <abbr class="published" title="2005-03-31T00:00:00-08:00">March 31, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<h3><a name="emacsperl">Customizing Emacs with Perl</a></h3>

<p>by Bob DuCharme</p>

<p>Over time, I've accumulated a list of Emacs customizations I wanted to
implement when I got the chance. For example, I'd like macros to perform
certain global replaces just within a marked block, and I'd like a macro to
reformat an Outlook formatted date to an ISO 8609 formatted date. I'm not
overly intimidated by the elisp language used to customize Emacs behavior; I've
copied elisp code and modified it to make some tweaks before, I had a healthy
dose of Scheme and LISP programming in school, and I've done extensive work
with XSLT, a descendant of these grand old languages. Still, as with a lot of
postponed editor customization work, I knew I'd have to use these macros many,
many times before they earned back the time invested in creating them, because
I wasn't that familiar with string manipulation and other basic operations in a
LISP-based language. I kept thinking to myself, "This would be so easy if I
could just do the string manipulation in Perl!"</p>

<p>Then, I figured out how I could write Emacs functions that called Perl to
operate on a marked block (or, in Emacs parlance, a "region"). Many Emacs users
are familiar with the <code>Escape+|</code> keystroke, which invokes the
<code>shell-command-on-region</code> function. It brings up a prompt in the
minibuffer where you enter the command to run on the marked region, and after
you press the Enter key Emacs puts the command's output in the minibuffer if it
will fit, or into a new "*Shell Command Output*" buffer if not. For example,
after you mark part of an HTML file you're editing as the region, pressing
<code>Escape+|</code> and entering <code>wc</code> (for "word count") at the
minibuffer's "Shell command on region:" prompt will feed the text to this
command line utility if you have it in your path, and then display the number of
lines, words, and characters in the region at the minibuffer. If you enter
<code>sort</code> at the same prompt, Emacs will run that command instead of
<code>wc</code> and display the result in a buffer.</p>

<p>Entering <code>perl /some/path/foo.pl</code> at the same prompt will run the
named Perl script on the marked region and display the output appropriately.
This may seem like a lot of keystrokes if you just want to do a global replace
in a few paragraphs, but remember: <code>Ctrl+|</code> calls Emacs's built-in
<code>shell-command-on-region</code> function, and you can call this same
function from a new function that you define yourself. My recent great
discovery was that along with parameters identifying the region boundaries and
the command to run on the region, <code>shell-command-on-region</code> takes an
optional parameter that lets you tell it to replace the input region with the
output region. When you're editing a document with Emacs, this allows you to
pass a marked region outside of Emacs to a Perl script, let the Perl script do
whatever you like to the text, and then Emacs will replace the original text
with the processed version. (If your Perl script mangled the text, Emacs'
excellent <code>undo</code> command can come to the rescue.)</p>

<p>Consider an example. When I take notes about a project at work, I might
write that Joe R. sent an e-mail telling me that a certain system won't need any
revisions to handle the new data. I want to make a note of when he told me
this, so I copy and paste the date from the e-mail he sent. We use Microsoft
Outlook at work, and the dates have a format following the model "Tue 2/22/2005
6:05 PM". I already have an Emacs macro bound to <code>alt+d</code> to insert
the current date and time (also handy when taking notes) and I wanted the date
format that refers to e-mails to be the same format as the ones inserted with
my <code>alt+d</code> macro: an ISO 8609 format of the form
"2005-02-22T18:05".</p>

<p>The <em>.emacs</em> startup file holds customized functions that you want
available during your Emacs session. The following shows a bit of code that I
put in mine so that I could convert these dates:</p>

<pre><code>(defun OLDate2ISO ()
  (interactive)
  (shell-command-on-region (point)
         (mark) "perl c:/util/OLDate2ISO.pl" nil t))</code></pre>

<p>The <code>(interactive)</code> declaration tells Emacs that the function
being defined can be invoked interactively as a command. For example, I can
enter "OLDate2ISO" at the Emacs minibuffer command prompt, or I can press a
keystroke or select a menu choice bound to this function. The
<code>point</code> and <code>mark</code> functions are built into Emacs to
identify the boundaries of the currently marked region, so they're handy for
the first and second arguments to <code>shell-command-on-region</code>, which
tell it which text is the region to act on. The third argument is the actual
command to execute on the region; enter any command available on your operating
system that can accept standard input. To define your own Emacs functions that
call Perl functions, just change the script name in this argument from
<code>OLDate2ISO</code> to anything you like and then change this third
argument to <code>shell-command-on-region</code> to call your own Perl
script.</p>

<p>Leave the last two arguments as <code>nil</code> and <code>t</code>.  Don't
worry about the fourth parameter, which controls the buffer where the shell
output appears. (Setting it to <code>nil</code> means "don't bother.") The
fifth parameter is the key to the whole trick: when non-nil, it tells Emacs to
replace the marked text in the editing buffer with the output of the command
described in the third argument instead of sending the output to a buffer.</p>

<p>If you're familiar with Perl, there's nothing particularly interesting about
the <em>OLDate2ISO.pl</em> script. It does some regular expression matching to
split up the string, converts the time to a 24 hour clock, and rearranges the
pieces:</p>

<pre><code># Convert Outlook format date to ISO 8309 date 
#(e.g. Wed 2/16/2005 5:27 PM to 2005-02-16T17:27)
while (&lt;&gt;) {
  if (/\w+ (\d+)\/(\d+)\/(\d{4}) (\d+):(\d+) ([AP])M/) {
     $AorP = $6;
     $minutes = $5;
     $hour = $4;
     $year = $3;
     $month = $1;
     $day = $2;
     $day = '0' . $day if ($day &lt; 10);
     $month = '0' . $month if ($month &lt; 10);
     $hour = $hour + 12 if ($6 eq 'P');
     $hour = '0' . $hour if ($hour &lt; 10);
     $_ = "$year-$month-$day" . "T$hour:$minutes";
  }
  print;
}</code></pre>

<p>When you start up Emacs with a function definition like the <code>defun
OLDate2ISO</code> one shown above in your <em>.emacs</em> file, the function is
available to you like any other in Emacs. Press <code>Escape+x</code> to bring
up the Emacs minibuffer command line and enter "OLDate2ISO" there to execute it
on the currently marked buffer. Like any other interactive command, you can
also assign it to a keystroke or a menu choice.</p>

<p>There might be a more efficient way to do the Perl coding shown above, but I
didn't spend too much time on it. That's the beauty of it: with five minutes of
Perl coding and one minute of elisp coding, I had a new menu choice to quickly
do the transformation I had always wished for.</p>

<p>Another example of something I always wanted is the following
<em>txt2htmlp.pl</em> script, which is useful after plugging a few paragraphs
of plain text into an HTML document:</p>

<pre><code># Turn lines of plain text into HTML p elements.
while (&lt;&gt;) {
  chop($_);
  # Turn ampersands and &lt; into entity references.
  s/\&amp;/\&amp;amp\;/g;
  s/&lt;/\&amp;lt\;/g;
  # Wrap each non-blank line in a "p" element.
  print "&lt;p&gt;$_&lt;/p&gt;\n\n" if (!(/^\s*$/));
}</code></pre>

<p>Again, it's not a particularly innovative Perl script, but with the
following bit of elisp in my <em>.emacs</em> file, I have something that
greatly speeds up the addition of hastily written notes into a web page,
especially when I create an Emacs menu choice to call this function:</p>

<pre><code>(defun txt2htmlp ()
  (interactive)
  (shell-command-on-region (point) 
         (mark) "perl c:/util/txt2htmlp.pl" nil t))</code></pre>

<p>Sometimes when I hear about hot new editors, I wonder whether they'll ever
take the place of Emacs in my daily routine. Now that I can so easily add the
power of Perl to my use of Emacs, it's going to be a lot more difficult for any
other editor to compete with Emacs on my computer.</p>













<h3><a name="linetrace">Debug Your Programs with Devel::LineTrace</a></h3>

<p>by Shlomi Fish</p>

<p>Often, programmers find a need to use print statements to output information
to the screen, in order to help them analyze what went wrong in running the
script. However, including these statements verbatim in the script is not such
a good idea. If not promptly removed, these statements can have all kinds of
side-effects: slowing down the script, destroying the correct format of its
output (possibly ruining test-cases), littering the code, and confusing the
user. It would be a better idea not to place them within the code in the first
place. How, though, can you debug without debugging?</p>

<p>Enter <a
href="http://search.cpan.org/dist/Devel-LineTrace/">Devel::LineTrace</a>, a
Perl module that can assign portions of code to execute at arbitrary lines
within the code. That way, the programmer can add print statements in relevant
places in the code without harming the program's integrity.</p>

<h4>Verifying That <code>use lib</code> Has Taken Effect</h4>

<p>One example I recently encountered was that I wanted to use a module I wrote
from the specialized directory where I placed it, while it was already installed
in the Perl's global include path. I used a <code>use lib "./MyPath"</code>
directive to make sure this was the case, but now had a problem.  What if there
was a typo in the path of the <code>use lib</code> directive, and as a result,
Perl loaded the module from the global path instead? I needed a way to verify
it.</p>

<p>To demonstrate how <code>Devel::LineTrace</code> can do just that, consider
a similar script that tries to use a module named <code>CGI</code> from the
path <em>./MyModules</em> instead of the global Perl path. (It is a bad idea to
name your modules after names of modules from CPAN or from the Perl
distribution, but this is just for the sake of the demonstration.)</p>

<pre><code>#!/usr/bin/perl -w

use strict;
use lib "./MyModules";

use CGI;

my $q = CGI-&gt;new();

print $q-&gt;header();</code></pre>

<p>Name this script <em>good.pl</em>. To test that Perl loaded the <code>CGI</code> module
from the <em>./MyModules</em> directory, direct <code>Devel::LineTrace</code> to print the
relevant entry from the <code>%INC</code> internal variable, at the first line
after the <code>use CGI</code> one.</p>

<p>To do so, prepare this file and call it <em>test-good.txt</em>:</p>

<pre><code>good.pl:8
    print STDERR "\$INC{CGI.pm} == ", $INC{"CGI.pm"}, "\n";</code></pre>

<p>Place the file and the line number at which the trace should be inserted on the first line.
Then comes the code to evaluate, indented from the start of the line. After the
first trace, you can put other traces, by starting the line with the filename
and line number, and putting the code in the following (indented) lines.  This
example is simple enough not to need that though.</p>

<p>After you have prepared <em>test-good.txt</em>, run the script
through <code>Devel::LineTrace</code> by executing the following command:</p>

<pre><code>$ PERL5DB_LT="test-good.txt" perl -d:LineTrace good.pl</code></pre>

<p>(This assumes a Bourne-shell derivative.). The <code>PERL5DB_LT</code>
environment variable contains the path of the file to use for debugging, and
the <code>-d:LineTrace</code> directive to Perl instructs it to debug the
script through the <code>Devel::LineTrace</code> package.</p>

<p>As a result, you should see either the following output to standard
error:</p>

<pre><code>$INC{CGI.pm} == MyModules/CGI.pm</code></pre>

<p>meaning that Perl indeed loaded the module from the <em>MyModules</em>
sub-directory of the current directory. Otherwise, you'll see something
like:</p>

<pre><code>$INC{CGI.pm} == /usr/lib/perl5/vendor_perl/5.8.4/CGI.pm</code></pre>

<p>...which means that it came from the global path and something went wrong.</p>

<h4>Limitations of <code>Devel::LineTrace</code></h4>

<p><code>Devel::LineTrace</code> has two limitations:</p>

<ol>

<li>Because it uses the Perl debugger interface and stops at every line (to
check whether it contains a trace), program execution is considerably slower
when the program is being run under it.</li>

<li>It assigns traces to line numbers, and therefore you must update it if the
line numbering of the file changes.</li>

</ol>

<p>Nevertheless, it is a good solution for keeping those pesky
<code>print</code> statements out of your programs. Happy LineTracing!</p>

<h3><a name="mockdbi">Using Test::MockDBI</a></h3>

<p>by Mark Leighton Fisher</p>

<p>What if you could test your program's use of the DBI just by creating a set
of rules to guide the DBI's behavior&#8212;without touching a database (unless you
want to)?  That is the promise of <a
href="http://search.cpan.org/perldoc?Test::MockDBI">Test::MockDBI</a>, which by
mocking-up the entire DBI API gives you unprecedented control over every aspect
of the DBI's interface with your program.</p>

<p><code>Test::MockDBI</code> uses <a
href="http://search.cpan.org/perldoc?Test::MockObject::Extends">Test::MockObject::Extends</a>
to mock all of the DBI transparently.  The rest of the program knows nothing
about using <code>Test::MockDBI</code>, making <code>Test::MockDBI</code> ideal for testing programs that
you are taking over, because you only need to add the <code>Test::MockDBI</code> invocation code&#8212;
you do not have to modify any of the other program code.  (I have found this
very handy as a consultant, as I often work on other people's code.)</p>

<p>Rules are invoked when the current SQL matches the rule's SQL pattern.  For
finer control, there is an optional numeric DBI testing type for each rule, so
that a rule only fires when the SQL matches <em>and</em> the current DBI
testing type is the specified DBI testing type.  You can specify this numeric
DBI testing type (a simple integer matching <code>/^\d+$/</code>) from the
command line or through <code>Test::MockDBI::set_dbi_test_type()</code>.  You
can also set up rules to fail a transaction if a specific
<code>DBI::bind_param()</code> parameter is a specific value.  This means there
are three types of conditions for <code>Test::MockDBI</code> rules:</p>

<ul>

<li>The current SQL</li>
<li>The current DBI testing type</li>
<li>The current <code>bind_param()</code> parameter values</li>

</ul>

<p>Under <code>Test::MockDBI</code>, <code>fetch*()</code> and <code>select*()</code>
methods default to returning nothing (the empty array, the empty hash, or undef
for scalars).  <code>Test::MockDBIM</code> lets you take control of their returned data with
the methods <code>set_retval_scalar()</code> and
<code>set_retval_array()</code>.  You can specify the returned data directly in
the <code>set_retval_*()</code> call, or pass a CODEREF that generates a return
value to use for each call to the matching <code>fetch*()</code> or
<code>select*()</code> method.  CODEREFs let you both simulate DBI's
interaction with the database more accurately (as you can return a few rows,
then stop), and add in any kind of state machine or other processing
needed to precisely test your code.</p>

<p>When you need to test that your code handles database or DBI failures,
<code>bad_method()</code> is your friend.  It can fail any DBI method, with the
failures dependent on the current SQL and (optionally) the current DBI testing
type.  This capability is necessary to test code that handles bad database
<code>UPDATE</code>s, <code>INSERT</code>s, or <code>DELETE</code>s, along with
being handy for testing failing <code>SELECT</code>s.</p>

<p><code>Test::MockDBI</code> extends your testing capabilities to testing code that is
difficult or impossible to test on a live, working database.  <code>Test::MockDBI's</code>
mock-up of the entire DBI API lets you add <code>Test::MockDBI</code> to your programs
without having to modify their current DBI code.  Although it is not finished
(not all of the DBI is mocked-up yet), <code>Test::MockDBI</code> is already a powerful tool
for testing DBI programs.</p>













<h3><a href="#unbuffering">Unnecessary Unbuffering</a></h3>

<p>by chromatic</p>

<p>A great joy in a programmer's life is removing useless code, especially
when its absence improves the program. Often this happens in old codebases
or codebases thrown together hastily. Sometimes it happens in code written
by novice programmers who try several different ideas all together and fail
to undo their changes.</p>

<p>One such persistent idiom is wholesale, program-wide unbuffering, which
can take the form of any of:</p>

<pre><code>local $| = 1;
$|++;
$| = 1;</code></pre>

<p>Sometimes this is valuable. Sometimes it's vital. It's not the default
for very good reason, though, and at best, including one of these lines in
your program is useless code.</p>

<h4>What's Unbuffering?</h4>

<p>By default, modern operating systems don't send information to output
devices directly, one byte at a time, nor do they read information from
input devices directly, one byte at a time. IO is so slow, especially for
networks, compared to processors and memory that adding buffers and trying
to fill them before sending and receiving information can improve
performance.</p>

<p>Think of trying to fill a bathtub from a hand pump. You <em>could</em>
pump a little water into a bucket and walk back and forth to the bathtub,
or you could fill a trough at the pump and fill the bucket from the trough.
If the trough is empty, pumping a little bit of water into the bucket will
give you a faster start, but it'll take longer in between bucket loads than
if you filled the trough at the start and carried water back and forth
between the trough and the bathtub.</p>

<p>Information isn't exactly like water, though. Sometimes it's more
important to deliver a message immediately even if it doesn't fill up a
bucket. "Help, fire!" is a very short message, but waiting to send it when
you have a full load of messages might be the wrong thing.</p>

<p>That's why modern operating systems also let you unbuffer specific
filehandles. When you print to an unbuffered filehandle, the operating
system will handle the message immediately. That doesn't guarantee that
whoever's on the other side of the handle will respond immediately; there
might be a pump and a trough there.</p>

<h4>What's the Damage?</h4>

<p>According to Mark-Jason Dominus' <a
href="http://perl.plover.com/FAQs/Buffering.html">Suffering from
Buffering?</a>, one sample showed that buffered reading was 40% faster than
unbuffered reading, and buffered writing was 60% faster. The latter number may
only improve when considering network communications, where the overhead of
sending and receiving a single packet of information can overwhelm short
messages.</p>

<p>In simple interactive applications though, there may be no benefit. When
attached to a terminal, such as a command line, Perl operates in
line-buffered mode. Run the following program and watch the output
carefully:</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;

# buffer flushed at newline
loop_print( 5, "Line-buffered\n" );

# buffer not flushed until newline
loop_print( 5, "Buffered  " );
print "\n";

# buffer flushed with every print
{
    local $| = 1;
    loop_print( 5, "Unbuffered  " );
}

sub loop_print
{
    my ($times, $message) = @_;

    for (1 .. $times)
    {
        print $message;
        sleep 1;
    }
}</code></pre>

<p>The first five greetings appear individually and immediately.  Perl flushes
the buffer for STDOUT when it sees the newlines.  The second set appears after
five seconds, all at once, when it sees the newline after the loop. The third
set appears individually and immediately because Perl flushes the buffer after
every <code>print</code> statement.</p>

<p>Terminals are different from everything else, though. Consider the case of
writing to a file. In one terminal window, create a file named
<em>buffer.log</em> and run <code>tail -f buffer.log</code> or its equivalent
to watch the growth of the file in real time. Then add the following lines to
the previous program and run it again:</p>

<pre><code>open( my $output, '&gt;', 'buffer.log' ) or die "Can't open buffer.log: $!";
select( $output );
loop_print( 5, "Buffered\n" );
{
      local $| = 1;
      loop_print( 5, "Unbuffered\n" );
}</code></pre>

<p>The first five messages appear in the log in a batch, all at once, even
though they all have newlines.  Five messages aren't enough to fill the buffer.
Perl only flushes it when it unbuffers the filehandle on assignment to
<code>$|</code>.  The second set of messages appear individually, one second
after another.</p>

<p>Finally, the STDERR filehandle is hot by default. Add the following lines to
the previous program and run it yet again:</p>

<pre><code>select( STDERR );
loop_print( 5, "Unbuffered STDERR " );</code></pre>

<p>Though no code disables the buffer on STDERR, the five messages should print
immediately, just as in the other unbuffered cases. (If they don't, your OS is
weird.)</p>

<h4>What's the Solution?</h4>

<p>Buffering exists for a reason; it's almost always the right thing to do.
When it's the wrong thing to do, you can disable it. Here are some rules of
thumb:</p>

<ul>

<li>Never disable buffering by default.</li>

<li>Disable buffering when and while you have multiple sources writing to
the same output and their order matters.</li>

<li>Never disable buffering for network outputs by default.</li>

<li>Disable buffering for network outputs only when the expected time
between full buffers exceeds the expected client timeout length.</li>

<li>Don't disable buffering on terminal outputs. For STDERR, it's useless,
dead code. For STDOUT, you probably don't need it.</li>

<li>Disable buffering if it's more important to print messages regularly
than efficiently.</li>

<li>Don't disable buffering until you know that the buffer is a
problem.</li>

<li>Disable buffering in the smallest scope possible.</li>

</ul>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1518" template="b/article_sidebar2.view">
<!-- sidebar ends -->



        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/dynamic-content/">&laquo; Dynamic Content</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/email/">Email &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
