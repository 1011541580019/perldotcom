<!-- Programming GNOME Applications with Perl, Part One</a> -->

<p><table width="180" cellspacing="0" cellpadding="4" align="right" border="1">
<tr>
<td align="center" valign="top" bgcolor="#6699cc">
<font color="#ffffff">Table of Contents</td>
</tr>

<tr>
<td>
<p class="fine">
&#149;<a href="#architecture introduction">Architecture Introduction</a><br />
&#149;<a href="#hello, world">Hello, World</a><br />
&#149;<a href="#adding a menu bar">Adding a Menu Bar</a><br />
&#149;<a href="#adding an about box">Adding an About Box</a><br />
&#149;<a href="#adding more chrome">Adding More Chrome</a><br />
&#149;<a href="#final program">Final Program</a><br />

</td>
</tr>
</p>
</table>
<p>GNOME is the Unix desktop. It's a framework for writing graphical
applications with Unix, providing drag-and-drop, interapplication
communication, CORBA components (what's called ``OLE'' in the Windows
world) a standard, good-looking interface, and all the other features
that you'd expect from modern graphical applications.</p>
<p>And it's available for Perl, which means Perl programmers can
create really neat applications, too. Except there's one slight
barrier ...</p>
<pre>
    % perldoc GNOME
    No documentation found for &quot;GNOME&quot;.</pre>
<p>I recently needed to write a GNOME application and hit this barrier,
and I had to figure the whole thing out pretty much for myself. So, I
decided to write these tutorials so that you, dear reader, don't have
to. In this first episode, we'll create an extremely simple
application, but one with a full, standard GNOME interface.</p>
<p>

<h3><a name="architecture introduction">Architecture Introduction</a></h3>
<p>The GNOME is a complicated beast and made up of many different
libraries and components. Thankfully, for the purposes of this
tutorial and a reasonable amount of your programming, you only need to
know about two parts: GTK+ and GNOME.</p>
<p>You might have heard about Tk, the ``other'' graphical toolkit Perl
people use. Tk's role in life is to do the laborious job of talking to
the X server and telling it how to draw buttons, menus, controls and
dialog boxes, and then firing off Perl routines in response to the
user's actions. It's an intermediary between the raw power of the X
server and the comfort of Perl.</p>
<p>GTK+ performs a similar job, but it does so with arguably more
beauty. GTK+ will be providing all the windows, the buttons, the text
labels, the text inputs, all of the graphical elements for our
application. It'll also, critically, provide the main event loop that
connects the user's actions with our code.</p>
<p>The Gnome library places another layer of abstraction over GTK+,
providing us with higher level graphical objects, such as main
application windows, about boxes, button panels, dialog boxes, color and font selection boxes, and it also gives us the ``glue'' to
interact with other parts of the GNOME environment - spelling checkers,
calculators and resources from other applications.</p>
<ul>
<li>
It's worth pointing out at this stage that there's a Visual Basic
style drag-and-drop IDE for the GNOME, called Glade. It can produce
Perl code, and some of you may find it a lot easier to construct
applications using that; however, you'd be advised to keep reading so
that you can understand what the code that Glade produces actually
does.
<p></p></ul>
<p>

<h3><a name="hello, world">Hello, World</a></h3>
<p>We'll show two versions of the classic ``Hello, World'' application
here: first, a version which just uses GTK+, and then a GNOME version.</p>
<p>Here's the GTK+ version:</p>
<pre>
   1 #!/usr/bin/perl -w
   2
   3 use strict;
   4 use Gnome;
   5 
   6 my $NAME = 'Hello World';
   7
   8 init Gnome $NAME;
   9
  10 my $w = new Gtk::Window -toplevel;
  11
  12 my $label = new Gtk::Label &quot;Hello, world&quot;;
  13 $w-&gt;add($label);
  14
  15 show_all $w;
  16 
  17 main Gtk;</pre>
<p>On line 4, we load the main Gnome module; this'll load up the GTK+
module for us. Line 8 sets up everything we need in this session and
registers the application. We pass the application's name to the
<code>init</code> method.</p>
<p>On line 10, we create our main window. This is a top level window,
meaning it's not a sub-window of anything else. Next, we need to
create the message label that'll say ``Hello, world''; any text we want
to place on a window has to be in a <code>Gtk::Label</code> object, so we create
an object, and put it in <code>$label</code>. Now, as of line 12, this label
isn't doing anything - it's created, but it doesn't live anywhere. We
want it to appear on our window, so we call the window's <code>add</code>
method and add the label object.</p>
<p>We next decide what we're going to show at the start of the program.
We'll show everything the window and everything attached to it - in our
case, the label. So, we call the window's <code>show_all</code> method. Note
that this doesn't actually put the window on the screen yet; it just
dictates what gets shown initially.</p>
<p>Finally, the statement that kicks off the action is <code>main Gtk;</code> -
this passes control over to GTK+'s main event loop, which first paints
the window and the label on the screen and then waits for something
to happen.</p>
<ul>
<li>
Once we've said <code>main Gtk;</code> our program has given up control -
everything that happens after that occurs in reaction to the user's
actions. Instead of the normal, procedural approach where we, as
programmers, have control over what the program does, we now have to
take a passive, reactive approach, providing responses to what the
user does. The way we do this is through callbacks, and we'll see
examples of this later on. But it's important to note that <code>main
Gtk;</code> is where our job finishes and GTK+'s job begins.
<p></p></ul>
<p>Next, here's the Gnome version:</p>
<p></p>
<pre>

     1  #!/usr/bin/perl -w
     2  
     3  use strict;
     4  use Gnome;
     5  
     6  my $NAME = 'Hello World';
     7  
     8  init Gnome $NAME;
     9  
    10  my $app = new Gnome::App $NAME, $NAME;
    11  
    12  my $label = new Gtk::Label &quot;Hello, world&quot;;
    13  $app-&gt;set_contents($label);
    14  
    15  show_all $app;
    16  
    17  main Gtk;</pre>
<p>It's the same length, and most of it is the same. This is what we've
changed:</p>
<pre>
    10  my $app = new Gnome::App $NAME, $NAME;</pre>
<p>Instead of creating a window, we're now shifting up a level and saying
that we're creating an entire application. We pass the application's
name to the <code>new</code> method twice - once as the window's title, and once
to register it with the GNOME environment.</p>
<p>We've also changed the line which adds the label to the window:</p>
<pre>
    13  $app-&gt;set_contents($label);</pre>
<p>Why is it ``set contents'' here and not add? The answer lies in the way
GTK+ puts graphical elements (``widgets'') inside windows, which is
based on the idea of containers. Simply put, you can only have one
widget in a window; thankfully, some widgets can contain other
widgets. What we're saying above is that the main contents of this
window, the one widget we're allowed, is the label.</p>
<p>Now, one thing you may have noticed if you've been exiting these
examples using the ``Close'' button on your window manager is that the
Perl application doesn't finish; we have to break out of it using
<code>^C</code> or similar. When a GNOME application receives notification from
the window manager that it is to close, GNOME sends us a signal;
not a true Unix signal which is implemented by the kernel, but a GNOME
signal which is purely a feature of GNOME. We need to catch this
signal and install a signal handler which cleanly shuts down the
program. Here's how to do this:</p>
<pre>
    my $app = new Gnome::App $NAME, $NAME;
    signal_connect $app 'delete_event',
                         sub { Gtk-&gt;main_quit; return 0 };</pre>
<p>We're connecting a handler to the ``delete event'' signal, which tells
us to clean up and go home, and we catch it with an anonymous
subroutine. This subroutine calls the <code>main_quit</code> method of GTK+,
which terminates the main loop.</p>
<p>Now our application should cleanly close down. But it still doesn't do
much.</p>
<p>

<h3><a name="adding a menu bar">Adding a Menu Bar</a></h3>
<p>As I mentioned earlier, the benefits of GNOME over GTK+ are that most
of the standard things we expect of an application are ready-made for
us. Let's create some standard menus for our application. Add this
after the <code>signal_connect</code> line:</p>
<pre>
      $app-&gt;create_menus(
        {type =&gt; 'subtree',
         label =&gt; '_File',
         subtree =&gt; [
                {type =&gt; 'item',
                 label =&gt; 'E_xit',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Quit'
                }
                    ]
        },
        {type =&gt; 'subtree',
         label =&gt; '_Help',
         subtree =&gt; [
                {type =&gt; 'item', 
                 label =&gt; '_About...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_About'
                }
                    ]
        }
      );</pre>
<p>We pass to <code>create_menus</code> a series of anonymous hashes, one for each
of the main menu tabs we want to create. The type of <code>subtree</code> for
each tab means that there will be other menus beneath this one. In
the <code>label</code> option, we put an underscore before the character which
is to be the key accelerator for the menu item; <code>Alt-F</code> will open
the File menu. The <code>subtree</code> option is an anonymous array of menu
items; here, we only put one item in each of our two <code>subtree</code>
arrays and each item has an anonymous hash.</p>
<p>For these hashes, the <code>type</code> this time is <code>item</code> - an ordinary menu
item, rather than the start of a submenu. The menu items have little
icons before the names. We use the stock GNOME icon library by saying
that <code>pixmap_type</code> is <code>'stock'</code>, and we use the <code>Menu_Quit</code> and
<code>Menu_About</code> to get standard quit and ``about box'' icons suitable for
display in menus.</p>
<p>If you run your application again, you should see a menu bar. Now,
want to see something really impressive? I said GNOME did all the work
for you. Try this:</p>
<pre>
   LANG=fr_FR perl hello.pl</pre>
<p>If all goes well, the menus should appear - but this time translated
into French. Where was the code for that? GNOME did it. Try a few
others - <code>pt_PT</code> for Portuguese, <code>de_DE</code> for German, <code>el_GR</code> (if
you've got the fonts for it) for Greek. Magical!</p>
<p>There's one small problem, though: Our menu doesn't do
anything. Let us first fix that <code>Exit</code> item since we already know how
to shut down a GTK+ application. Change the item's hash so it looks
like this:</p>
<pre>
                {type =&gt; 'item',
                 label =&gt; 'E_xit',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Quit',
                 callback =&gt; sub {Gtk-&gt;main_quit; return 0 }
                }</pre>
<p>What we've said is that when the menu item gets selected, GNOME should
``call us back'' by executing the code we give it. We specify a
subroutine reference to be called when the user selects the item.</p>
<p>

<h3><a name="adding an about box">Adding an About Box</a></h3>
<p>Now let's fix up the other menu item by adding an about box. Once
again, GNOME has done the work for us. We'll add a callback to the
<code>About...</code> menu option, and we'll make it a subroutine reference:</p>
<pre>
                {type =&gt; 'item',
                 label =&gt; '_About...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_About',
                 callback =&gt; \&amp;about_box
                }</pre>
<p>Our subroutine will create and display the box:</p>
<pre>
           sub about_box {
               my $about = new Gnome::About $NAME, &quot;v1.0&quot;,
                  &quot;(C) Simon Cozens, 2000&quot;, [&quot;Simon Cozens&quot;],
                &quot;This program is released under the same terms as Perl itself&quot;;
             show $about;
         }</pre>
<p>The <code>Gnome::About</code> class gives us a ready-made about box: we just
have to supply the name of our application, its version, copyright
information, an anonymous array of the authors' names and any other
comments. Then we <code>show</code> the box just as we showed the main window
before. When we click the ``OK'' button, the window is automatically
removed.</p>
<p>

<h3><a name="adding more chrome">Adding More Chrome</a></h3>
<p>GNOME applications also have two other distinctive interface features:
a toolbar and a status bar. We'll first add the toolbar. Put this
after the menu code:</p>
<pre>
   $app-&gt;create_toolbar(
    {
        type =&gt; 'item',
        label =&gt; 'Exit',
        pixmap_type =&gt; 'stock',
        pixmap_info =&gt; 'Quit',
        hint =&gt; &quot;Click here to quit&quot;,
        callback =&gt; sub { Gtk-&gt;main_quit },
    }, {
        type =&gt; 'item',
        label =&gt; 'About...',
        pixmap_type =&gt; 'stock',
        pixmap_info =&gt; 'About',
        hint =&gt; &quot;More information about this app&quot;,
        callback =&gt; \&amp;about_box
    }
   );</pre>
<p>Once more, we're passing a series of anonymous hashes, and most of the
entries should be familiar to you now. The <code>hint</code> is what is
displayed when the mouse pointer lingers over the button. Our
callbacks and pixmaps are the same as before.</p>
<p>Next, the status bar:</p>
<pre>
    my $bar = new Gnome::AppBar 0,1,&quot;user&quot; ;
    $bar-&gt;set_status(&quot;   Welcome   &quot;);</pre>
<pre>
    $app-&gt;set_statusbar( $bar );</pre>
<p>First, we create a new <code>AppBar</code> object, an application status
bar. Then we write our initial status onto it using the <code>set_status</code>
method. Again, this bar now exists but it doesn't appear on the screen
as it doesn't have a home. We connect it to the application using the
app's <code>set_statusbar</code> method, and it'll now appear at the bottom of
our main window.</p>
<p>

<h3><a name="final program">Final Program</a></h3>
<p>Here's what you should have ended up with at the end of this tutorial:</p>
<pre>
    #!/usr/bin/perl -w</pre>
<pre>
    use strict;
    use Gnome;</pre>
<pre>
    my $NAME = 'Hello World';</pre>
<pre>
    init Gnome $NAME;</pre>
<pre>
    my $app = new Gnome::App $NAME, $NAME;</pre>
<pre>
    signal_connect $app 'delete_event', sub { Gtk-&gt;main_quit; return 0 };</pre>
<pre>
    $app-&gt;create_menus(
               {type =&gt; 'subtree',
                label =&gt; '_File',
                subtree =&gt; [
                    {type =&gt; 'item',
                     label =&gt; 'E_xit',
                     pixmap_type =&gt; 'stock',
                     pixmap_info =&gt; 'Menu_Quit',
                     callback =&gt; sub { Gtk-&gt;main_quit; return 0 }
                    }
                       ]
               },
               {type =&gt; 'subtree',
                label =&gt; '_Help',
                subtree =&gt; [
                    {type =&gt; 'item', 
                     label =&gt; '_About...',
                     pixmap_type =&gt; 'stock',
                     pixmap_info =&gt; 'Menu_About',
                     callback =&gt; \&amp;about_box
                    }
                       ]
               }
              );</pre>
<pre>
    $app-&gt;create_toolbar(
                 {
                  type =&gt; 'item', 
                  label =&gt; 'Exit', 
                  pixmap_type =&gt; 'stock', 
                  pixmap_info =&gt; 'Quit', 
                  hint =&gt; &quot;Click here to quit&quot;,
                  callback =&gt; sub { Gtk-&gt;main_quit }, 
                 }, {
                 type =&gt; 'item',
                 label =&gt; 'About...', 
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'About',
                 hint =&gt; &quot;More information about this app&quot;,
                 callback =&gt; \&amp;about_box
                }
                );</pre>
<pre>
    my $label = new Gtk::Label &quot;Hello, world&quot;;
    $app-&gt;set_contents($label);</pre>
<pre>
    my $bar = new Gnome::AppBar 0,1,&quot;user&quot; ;
    $bar-&gt;set_status(&quot;   Welcome   &quot;);
    $app-&gt;set_statusbar( $bar );</pre>
<pre>
    show_all $app;</pre>
<pre>
    main Gtk;</pre>
<pre>
    sub about_box {
      my $about = new Gnome::About $NAME, &quot;v1.0&quot;, 
      &quot;(C) Simon Cozens, 2000&quot;, [&quot;Simon Cozens&quot;], 
      &quot;This program is released under the same terms as Perl itself&quot;;
      show $about;
    }</pre>
<p></p>
<pre>

=head1 Summary</pre>
<p>So, we've now created our first application using GNOME/Perl. It
complies with the GNOME interface standards, it's got standard menus,
a toolbar, a status bar and an about box. It looks, feels and acts
like a real GNOME application, and all in about 70 lines of Perl.</p>
<p>Next time, we'll start to create a more useful application, a recipe
organizer, and we'll use some slightly more sophisticated widgets such
as containers, input areas, scroll bars and list boxes.</p>

</body>

</html>
