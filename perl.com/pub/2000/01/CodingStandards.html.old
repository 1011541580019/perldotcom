<!-- In Defense of Coding Standards -->
<h3>How to Create Coding Standards that Work</h3>


<br />
<!::field::date::><p>One of the things that we love most about Perl is its flexibility, itssimilarity to natural language, and the fact that There's More Than One Way
To Do It. Of course, when I say ``we'' I mean Perl hackers; the implicit
``them'' in this case is management, people who prefer other languages, or
people who have to maintain someone else's line noise.
</p>
<p>
<table width="200" cellspacing="12" cellpadding="12" align="right" border="0">
<tr>
<td valign="top">
<font size="+1"><b>"Just because there are bad coding standards out there, doesn't mean that all coding standards are bad."</b></font></td>
</tr>
</table>
</p>
<p>
Perl programmers tend to rebel at the idea of coding standards, or at
having their creativity limited by arbitrary rules -- otherwise, they'd be
coding in Python :). But I think that sometimes a little bit of
consistency can be a good thing.  
</p>

<p>
As Larry himself said in one of his State of the Onion talks, 
three virtues of coding are Diligence, Patience and Humility. Diligence (the opposite
of Laziness, if you're paying attention) is necessary when you're working
with other programmers. You can't afford to name your variables <code>$foo</code>, <code>$bar</code>, and <code>$stimps_is_a_sex_goddess</code> if someone has to come along after you and figure out what the hell you
meant. This is where coding standards come in handy.
</p>

<p>
Let me tell you about my recent experiences writing coding standards.
</p>

<p>
I work in a small company with about half a dozen coders on staff. We code
in languages such as Perl, Python, and C, with occasional excursions into
things like SQL and non-programming-languages like HTML.
</p>

<p>
We'd been working together a few months when it was decided that some
development standards (slightly broader than coding standards, but mostly
related to coding) would be a good idea. The difficulties we wanted to
address were:

<ul>
<li>
program design, 
</li>

<li>
naming conventions, 
</li>

<li>
formatting conventions, 
</li>

<li>
documentation, and
</li>

<li>
licensing. 
</li>
</ul>
</p>

<p>
All these issues had popped up already in our few short months of working
with each other, especially when one person handed a project over to
another. We needed to create some standards to ensure that all our work was
consistent enough for other people to follow, but we didn't want to do this
at the expense of individuality or creativity. And we didn't want to insult
our coders' intelligence by dictating every little thing to them.
</p>

<p>
Being the person who tends to write things in our company, I took it upon
myself to put together some standards with the help of the developers. From
the beginning, my plan was to set some general ground rules, then to expand
on them language by language where necessary. I wanted the standards to be
as brief as possible, while still conveying enough information for a
hypothetical new hire to read and understand without having to guess at
anything.
</p>

<p>
Here's what we came up with as our general rules:

<ol>
<li>
The verbosity of all names should be proportional to the scope of their use

<li>
The plurality of a variable name should reflect the plurality of the data
it contains. In Perl, <code>$name</code> is a single name, while <code>@names</code> is an array of names

<li>
In general, follow the language's conventions in variable naming and other
things. If the language uses <code>variable_names_like_this</code>, you should too. If it uses <code>ThisKindOfName</code>, follow that.

<li>
Failing that, use <code>UPPER_CASE</code> for globals, <code>StudlyCaps</code> for classes, and
<code>lower_case</code> for most other things. Note the distinction between words by using either
underscores or StudlyCaps.

<li>
Function or subroutine names should be verbs or verb clauses. It is
unnecessary to start a function name with <code>do_</code>.

<li>
Filenames should contain underscores between words, except where they are
executables in <code>$PATH</code>. Filenames should be all lower case, except for class files which maybe in
StudlyCaps if the language's common usage dictates it.
</ol>
</p>

<p>
That's it. That's the core of our coding standards.
</p>

<p>
Those rules were developed during a one-hour meeting with all development
staff. There's nothing there that anyone disagrees on at all, and I think
that's because the rules are basically common sense.
</p>

<p>
Our standards then go on to give a few extra guidelines for each language.
For Perl, we have the following standards:
</p>

<p>
1. Read 
<a href="http://www.perl.com/pub/doc/manual/html/pod/perlstyle.html"><code>perldoc perlstyle</code></a>
 and follow all suggestions contained therein, except where they disagree
with the general coding standards, which take precedence.
</p>

<p>
2. Use the <code>-w</code> command line flag and the <code>strict</code> pragma at all times, and <code>-T</code> (taint checking) where appropriate.
</p>

<p>
3. Name Perl scripts with a <code>.pl</code> extension, and CGI scripts with a
<code>.cgi</code> extension. One exception: Perl scripts in <code>$PATH</code> may omit the <code>.pl</code>.
</p>

<p>
... and a few more, about one printed page in total. For instance, we have
a couple of regexp-related guidelines, a couple of points about references
and complex data structures (including when not to use them), and a list of
our favourite modules that we recommend developers use 
(<code>CGI</code>, <code>DBI</code>, <code>Text::Template</code>, etc.).
</p>

<p>
Our documentation standards say to include at least a <code>README</code>,
<code>INSTALL</code> and <code>LICENSE</code> file with each piece of software; that each source code file should include
the name, author, description, version and copyright information; that any
function that needs more than two lines of comments to explain what it does
needs to be written more clearly; and that any more detailed documentation
should be handed to professional technical writers.
</p>

<p>
Coding standards needn't be onerous. Just because there are bad coding
standards out there, doesn't mean that all coding standards are bad.
</p>

<p>
I think the way to a good coding standard is to be as minimalist as
possible. Anything more than a couple of pages long, or which deviates too
far from common practice, will frustrate developers and won't be followed.
And standards that are too detailed may obscure the fact that the code has deeper problems.
</p>

<p>
Here's a second rule: standardise early! Don't try to impose complex
standards on a project or team that's been going for a long time -- the
effort to bring existing code up to standard will be too great. If your
standards are minimal and based on common sense, there's no reason to wait
for the project to take shape or the team's preferences to become known.
</p>

<p>
If you do set standards late, don't set out on a
crusade to bring existing code up to scratch. Either fix things as you come
to them, or (better) rewrite from scratch. Chances are that what you had
was pretty messy anyway, and could do with reworking.
</p>

<p>
Third rule? I suppose three rules is a good number. The third rule is to
encourage a culture in which standards are followed, not because Standards
Must Be Obeyed, but because everyone realises that things work better that
way. Imagine what would happen if, for instance, mail transport agents
didn't follow RFC822. MTAs don't follow RFC822 because they're forced to,
but because Internet email just wouldn't work without it. The thought of
writing an MTA which was non-compliant is perverse (or Microsoft policy,
one or the other).
</p>

<p>
If your development team understands that standards do make things
easier and result in higher quality, more maintainable code, then the
effort of enforcement will be small.
</p>

<p>
Damn, I seem to have found a fourth rule. Oh well.
</p>

<p>
Fourth rule: don't expect coders to document. Don't expect coders to do
architecture or high-level design. Don't expect coders to have an eye for
user interface. If they do, that's great, but no matter how many standards
or methodologies you lay down, there's no way to change the fact that
coding skill is not necessarily related to, and in fact may be inversely
proportional to, those other necessary skills. Don't let a set of standards
be your crutch when you really need to hire designers or documentors.
</p>
