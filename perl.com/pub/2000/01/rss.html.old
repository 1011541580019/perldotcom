<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!-- RSS and You -->

<br />
<!::field::date::><br />
<H3><A NAME="RSS_is_Born">RSS is Born</A></H3>
<P>
<!-- INDEX BEGIN -->

<table width="175" cellspacing="0" cellpadding="6" align="right" bgcolor="#cccccc">
<tr>
<td valign="top">
<b>Contents:</b><br />
&#149; <A HREF="#RSS_is_Born">RSS is Born</A><br />
&#149; <A HREF="#XML_RSS">XML::RSS</A><br />
&#149; <A HREF="#My_Portal">my_portal</A><br />
&#149; <A HREF="#Future_of_My_Portal">Future of my_portal</A><br /><br /></td>
</tr>
</table>
<!-- INDEX END -->
Netscape had one of the first "portals" on the Web, a place where users could go to get most of their information needs fulfilled: search engines, news, email, and more.  But Netscape soon wanted a portal that was more customizable by the user and contained content from any site that wanted to contribute. Hence 
<a href="http://my.netscape.com/">My Netscape
Network</a> (MNN) was born.

<P>
At MNN, the user can choose what content to put on their own
page&#151;the latest headlines on
<A HREF="http://slashdot.org/">Slashdot</A>,
recently uploaded files at
<A HREF="http://www.freshmeat.net/">freshmeat</A>,
or the most recent posts to a bulletin board at
<A HREF="http://network54.com/">Network54</A>.
Each <em>channel</em>, as Netscape calls
them, can also include information to display an image for that channel and a text input box for searching the channel's site.


<P>
The channels are described with formatted text files that are updated either at regular intervals, or whenever the site's content changes.  The Netscape servers periodically download the updated channel files from the various sites providing them, and that information is then made immediately available to the users.

<P>
In addition to the list of items and associated hyperlinks,
the channel files can also contain information to display a text box for a form, 
and an image link, as well as metadata about the site.

<P>
In order to do all this, a universal way for developers to describe their sites was needed. 
Netscape developed the RDF Site Summary (RSS) format, which uses XML and the 
<a href="http://www.w3.org/RDF/">Resource Description Framework</a> (RDF), 
a hierarchical data model used primarily for describing web-based metadata.
<A HREF="http://my.netscape.com/publish/help/quickstart.html">RSS 0.90</A>
was the first version, released in March 1999.  
RSS is very simple to work with, and because it is XML, it is both human-readable and 
easily parsed by many different languages and programs.

<P>
The fundamental container for the RSS data is the
<em>channel</em>. Properties within the channel include
<em>title</em>, <em>link</em>, and <em>description</em>, most of which are optional. Optional containers inside the channel are <em>image</em> and <em>textinput</em>, each with their own properties. At least one (and up to 15) <em>item</em> is included in the channel.  

<a
href="http://www.news.perl.org/perl-news-short.rdf">The Perl News RSS
file</a> is a typical example:
<p>

<TABLE width="450" CELLPADDING="8" BORDER="1" CELLSPACING="0">
<tr>
<TD valign="top" ALIGN="CENTER" >
<P><A HREF="http://www.news.perl.org/"><IMG SRC="http://www.news.perl.org/perl-news-small.gif" BORDER="0" ALT="Perl News" HEIGHT="30" WIDTH="119"></A></P>
</td>

 <td valign="top" rowspan="2">
<pre>

...

&lt;channel&gt;
&lt;title&gt;Perl News&lt;/title&gt;
&lt;link&gt;http://www.news.perl.org/&lt;/link&gt;
&lt;description&gt;News for the Perl Community&lt;/description&gt;
&lt;language&gt;en&lt;/language&gt;
&lt;copyright&gt;Copyright 1999, Chris Nandor&lt;/copyright&gt;
&lt;pubDate&gt;Sun, 02 Jan 2000 10:58:39 EST&lt;/pubDate&gt;
&lt;lastBuildDate&gt;Sun, 02 Jan 2000 10:58:39 EST&lt;/lastBuildDate&gt;
&lt;managingEditor&gt;news@perl.org&lt;/managingEditor&gt;
&lt;webMaster&gt;news@perl.org&lt;/webMaster&gt;

...

&lt;item&gt;
&lt;title&gt;Perl Conference Papers Deadline Extended Two Days&lt;/title&gt;
&lt;link&gt;http://www.news.perl.org/perl-news.cgi?item=947976240|9809&lt;/link&gt;
&lt;/item&gt;

&lt;item&gt;
&lt;title&gt;Robert Writes in Defense of Coding Standards&lt;/title&gt;
&lt;link&gt;http://www.news.perl.org/perl-news.cgi?item=947976265|9810&lt;/link&gt;
&lt;/item&gt;

...

&lt;textinput&gt;
&lt;title&gt;Search Perl News&lt;/title&gt;
&lt;description&gt;Search the Perl News database&lt;/description&gt;
&lt;name&gt;text&lt;/name&gt;
&lt;link&gt;http://www.news.perl.org/perl-news.cgi&lt;/link&gt;
&lt;/textinput&gt;

&lt;/channel&gt;
&lt;/rss&gt;
</pre>
</td>

<tr>
<td valign="top" bgcolor="#cccccc">
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947976240|9809">Perl Conference Papers Deadline Extended Two Days</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947976265|9810">Robert Writes in Defense of Coding Standards</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947976272|9812">Netizen Releases Training Materials</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947976279|9813">New Modules 10-14 January 2000</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947555023|5039">PerlMonth Issue 8 Now Available</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947555033|5040">New Modules  5-9 January 2000</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947093003|13831">Linux Magazine Publishes Wall's Uncultured Perl</A><BR>
<IMG SRC="http://www.news.perl.org/my_portal/bullet.gif" ALIGN="top" HEIGHT="10" WIDTH="10" ALT=" * "><A HREF="http://www.news.perl.org/perl-news.cgi?item=947093012|13833">New Modules  4 January 2000</A><BR>
<FORM ACTION="http://www.news.perl.org/perl-news.cgi" METHOD="GET"><P>
Search Perl News <INPUT TYPE="text" NAME="text">
</P></FORM>
</p>
<P><EM CLASS="small" STYLE="font-size: small; text-align: left">January 15, 2000, 17:45 EST</EM></P></TD>
</tr>
</table>
</p>

<P>

RSS files like this are now used by thousands of sites on
the Web.  And Netscape is not the only one providing all of this content. UserLand, which had been using its own channel description format (called <i>scriptingNews</i>) since late 1997, was one of the early adopters of RSS for 
<a href="http://my.userland.com/">My UserLand</a>. The
important features of its scriptingNews format were integrated into
<A HREF="http://my.netscape.com/publish/help/mnn20/quickstart.html">RSS 0.91</A>.

<P>
The distribution of content via channels resembles the distribution of content via cable TV in that not 
all channels are carried by all providers.  A site that
carries RSS channels related to freedom of speech might not carry the Perl News channel.  
Netscape carries any type of
channel.  UserLand carries news channels only. Slashdot (which has its own RSS channel) also allows users to customize their personal Slashdot page with other channels, which they call <em>Slashboxes</em>. But Slashdot has a much narrower focus than My UserLand and MNN, carrying
only channels that relate to free software and hackers.
<a href="http://www.xmltree.com/">xmlTree</a> attempts to categorize as much of the XML content available on the Web as possible, much of which is RSS content.


<P>
<HR>
<H3><A NAME="XML_RSS">XML::RSS</A></H3>
<P>
Jonathan Eisenzopf, who has worked on a lot of XML projects for Perl and who runs 
<a href="http://perlxml.com/">the <CODE>perlxml.com</CODE> web site</a>, wrote 
<a href="http://search.cpan.org/search?module=XML::RSS">the <CODE>XML::RSS</CODE>
module</a>. It is based on <CODE>XML::Parser</CODE>, as most XML modules are, and uses an object-oriented
syntax. It makes creation and parsing of RSS files easy.

<P>
To create an RSS channel, you first create an <CODE>XML::RSS</CODE> object:

<P>
<PRE>
    use XML::RSS;
    my $rss = new XML::RSS;
</PRE>
<P>
Then call any of the four primary methods: <CODE>channel(),</CODE>
<CODE>image(),</CODE> <CODE>textinput(),</CODE> or <CODE>add_item().</CODE>
The <CODE>channel()</CODE> method sets up information about the channel (not all the options are included here):

<P>
<PRE>
    $rss-&gt;channel(
        title           =&gt; 'Perl News',
        'link'          =&gt; 'http://www.news.perl.org/',
        description     =&gt; 'News for the Perl Community',
    );
</PRE>
<P>
Then you can call the optional <CODE>textinput()</CODE> and <CODE>image()</CODE> methods.  The image data will tell the site that uses the channel where to get the image and what to link it to.  The textinput data describes the action, the
submit button value, and the name of the text input box so that a form can be presented to the user.

<P>
<PRE>
    $rss-&gt;image(
        title   =&gt; 'Perl News',
        url     =&gt; 'http://www.news.perl.org/perl-news-small.gif',
    );
</PRE>
<P>
<PRE>
    $rdf-&gt;textinput(
        title       =&gt; 'Search Perl News',
        description =&gt; 'Search the Perl News database',
        name        =&gt; 'text',
        'link'      =&gt; 'http://www.news.perl.org/perl-news.cgi',
    );
</PRE>
<P>
And then, for each item to add to the channel, call the
<CODE>add_item()</CODE> method:

<P>
<PRE>
    for my $i (keys %items) {
        $rss-&gt;add_item(
            title   =&gt; $items{$i},
            'link'  =&gt; &quot;http://www.news.perl.org/perl-news.cgi?item=$i&quot;,
        );
    }
</PRE>
<P>
The final step is to save it. You can either get the data with the <CODE>as_string()</CODE> method and then save it, or just save it directly with the <CODE>save()</CODE> method.

<P>
<PRE>
    my $data = $rss-&gt;as_string;             # or ...
    $rss-&gt;save(&quot;$dir/$channel.rss&quot;);
</PRE>
<P>

For an example of using <CODE>XML::RSS</CODE> to create RSS, see 
<a href="http://www.news.perl.org/perl-news.plx">the source for the program that generates Perl News</a>.  The program that generates the HTML for the Perl News main page generates the RSS file at the same time.

<P>
It seems that, as with HTML, many (if not most) RSS files are created by hand, or at least using a 
template from a program. That is fine to do, but using <CODE>XML::RSS</CODE> has the advantage 
of creating valid, well-formed data (which is exceedingly important with XML); and, of course, as the 
RSS format evolves,the module can evolve with it. 
It's simply easier, in many cases.

<P>
<HR>
<H3><A NAME="My_Portal">my_portal</A></H3>
<P>
While it was pretty cool that RSS channels were being created for most of the sites I frequented, I was getting frustrated that the content providers out there did not provide all of the channels I wanted, or they weren't in the
layout I wanted, or they just did something I didn't like. I wanted to control the content myself. That's the whole point, right? So I finally got around to doing something about it, and wrote a program for a new site I call
<a href="http://www.news.perl.org/my_portal/"><CODE>my_portal</CODE></a>.

<P>
The purpose of the project was to let me view the content 
I wanted from the sites I wanted in the format I wanted. And, of course, I wanted others to be able to do the same thing, because I was pretty sure that I was not the only one with this dilemma (and the feedback I've received confirms this).
So I made a basic, lightweight program using
Eisenzopf's <CODE>XML::RSS</CODE>. The program only does a few things: it fetches RSS channels, and it displays them on the Web.


<P>
To display the RSS channels, I need to parse them.  <CODE>XML::RSS</CODE>
and <CODE>XML::Parser</CODE> come to the rescue again, with the
<CODE>parse()</CODE> and <CODE>parse_file() methods:</CODE>

<P>
<PRE>
    $rss-&gt;parse($data);                     # or ...
    $rss-&gt;parsefile(&quot;$dir/$channel.rss&quot;);
</PRE>
<P>
<CODE>$rss</CODE> is a hashref, and I extract the elements as with any complex data structure:

<P>
<PRE>
    print qq{&lt;A HREF=&quot;$rss-&gt;{channel}{'link'}&quot;&gt;$rss-&gt;{channel}{title}&lt;/A&gt;};
</PRE>
<P>
<PRE>
    for my $i (@{$rss-&gt;{items}}) {
        print qq{&lt;A HREF="$i-&gt;{'link'}"&gt;$i-&gt;{title}&lt;/A&gt;};
    }
</PRE>
<P>
<PRE>
    print qq{&lt;FORM METHOD="GET" ACTION="$rss-&gt;{textinput}{'link'}"&gt;
             &lt;INPUT TYPE="TEXT" NAME="$rss-&gt;{textinput}{name}"&gt;
             &lt;/FORM&gt;};
</PRE>


<P>
When the data structure gets confusing, I'll often print it out with <CODE>Data::Dumper</CODE> to get a good look at it:

<P>
<PRE>
    use Data::Dumper;
    print Dumper $rss;
</PRE>



<P>
The program's interface is fairly simple. From the command line, I can add a channel by typing its name and the URL of the RSS file. The channel is added to a DBM file, and then its RSS file is downloaded (and so is the image from the RSS file, if available). I can update each channel
individually, or all at once. I set a cron job to download new data every time the big hand is on the twelve or the six, so the content is updated all day long. Using the LWP::Simple module's <CODE>mirror()</CODE> function, a new RSS file and image are only downloaded if the remote server
says they have been modified.

<P>
The fact that <CODE>my_portal</CODE> was designed primarily for my own use has not dissuaded people from requesting features for it, or me from trying to provide some of them. First, there was user configurability. A configure screen presents a form where a user can choose which channels to view, and in what order. Just for kicks, the user can also select the colors of the page. All of these things have my personal choices as the default, but the user can change them at will. The data for these preferences is stored in another DBM, and remembered through cookies. Because some users wanted to use more than one computer or browser, I went ahead and added usernames and passwords so that they
could log in and use the same configuration from anywhere.

<P>
I also worked to make sure that <code>my_portal</code> constructs valid HTML. I am really annoyed by sites that don't work in certain browsers, or look bad in some, so I made sure to use valid HTML 4.0 for the entire site. It looks just fine in all browsers from Lynx to Mozilla. However, because the program pulls in content from other sources, it is possible that a page will be produced containing invalid HTML. Someone may try to embed
incorrect HTML tags or entities in their RSS, or neglect to encode entities that need to be encoded.

<P>
Normally, <CODE>XML::Parser</CODE> will croak on many of these common problems, so they will never get to your HTML page anyway. If an item's title is <em>Amazon.com
Sues Barnes &amp; Noble</em>, the ampersand will cause an exception, because it needs to be turned into an encoded entity (such as <CODE>&amp;amp;</CODE>).
Another problem I've run into is RSS files in Mac OS text format (using CRs instead of LFs or CRLFs), which for some odd reason were making the parser choke. So I wrote some filters that process the RSS files after <CODE>LWP::Simple::mirror()</CODE>
downloads them, before they are passed to <CODE>XML::RSS</CODE>.
A simple regex converts CRs and CRLFs to LFs, and then any ampersand that is not followed by
<CODE>[a-zA-Z0-9]+;</CODE> or <CODE>#\d+;</CODE> is converted into <CODE>&amp;amp;</CODE>.

<P>
<PRE>
    {
        my @time = (stat $file)[8,9];
        local $^I = '.bak';
        local @ARGV = $file;
        while (&lt;&gt;) {
            s/\015\012?/\012/g;
            s/&amp;(?!(?:[a-zA-Z0-9]+|#\d+);))/&amp;amp;/g;
            print;
        }
        # continued below 
        ...
    }
</PRE>

<P>
I need to do one more thing before I am done with the filtered file.  An optional property in the channel data notes the time when the channel was published (lastBuildDate), and <CODE>my_portal</CODE> prints it on the web page, so users have some idea of how recently updated the channel is. If that optional data is not in the RSS file, the program uses the modification time of the RSS file on disk, which <CODE>LWP::Simple::mirror()</CODE> sets to whatever the remote server says the modification time of the remote file is. So before touching the original file, we use <CODE>stat()</CODE> to get the access and modification time. After saving the new file, we use
<CODE>utime()</CODE> to set those values to the newly saved file, so the modification time of the file is preserved.

<P>
<PRE>
    {
        ...
        # continued from above
        utime @time, $file;
        unlink &quot;$file.bak&quot;;
    }
</PRE>
<P>
You probably won't be able to construct filters to fix all potential problems with the RSS files&#151;if they are totally broken, and your computer doesn't happen to have artificial intelligence, then there is nothing you can do&#151;so make sure you catch exceptions when parsing XML:

<P>
<PRE>
    for my $channel (@channels) {
        eval { $rss-&gt;parse(&quot;$dir/$channel.rss&quot;) }
        warn &quot;XML for channel $channel not well formed:\n$@&quot;
            and last if $@;
</PRE>
<P>
<PRE>
        # do something with $rss data ...
    }
</PRE>
<P>
<HR>
<H3><A NAME="Future_of_My_Portal">Future of <CODE>my_portal</CODE></A></H3>
<P>
There are some features that <CODE>my_portal</CODE>, because of its limited design scope, won't accommodate in its current form. One suggestion was that users be able to add arbitrary RSS channels to their personal page through
an external link ("click here to add Foo News to Your Portal!"). This is a fine idea, but it doesn't fit the scheme and scope of the project; the interface and backend would need to be rethunk to do something like this. It may happen in the future, though.

<P>
Also, <CODE>my_portal</CODE> currently does not support locking for the user's or channel DBMs. For the channel DBM, this is not a serious problem, since only one person would likely be changing that DBM anyway. 
<p>

For the user's DBM, this could be a problem. Moving the data to MySQL first would solve the problem. Otherwise, locking may be added eventually. My bet is on moving
to MySQL first.

<P>
The <CODE>my_portal</CODE> program is also a little bit slow; each time it displays the channel, it executes, reads in the user database to find the user, and then reads in all of the appropriate channels. If <CODE>my_portal</CODE> were to be extended for widespread use, the best thing to do would probably be to make it into a mod_perl process that uses MySQL. That would solve or significantly
alleviate the speed problems and the data problems, since it would always be loaded in, have persistence to the database connection, handle simultaneous accesses, and so on. 

<P>
Since it suits my personal purposes fine as it is, and since I don't get paid to work on it, I may or may not get to these and other changes in the near future. But the program is, after all, open source and available at
<a href="http://www.news.perl.org/my_portal/my_portal.plx"
><CODE>http://www.news.perl.org/my_portal/my_portal.plx</CODE></a>. Patches welcome!

<P>


