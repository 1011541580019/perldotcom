<P>
<!-- <A NAME="My_Life_with_Spam">My Life with Spam</A> -->

<H3><A NAME="How_I_Caught_the_Spam_and_What_I">How I Caught the Spam and What I Did With it When I Caught it</A></H3>


<br />
<!::field::date::><P>This article is the third in a series; you may want to read <ahref="http://www.plover.com/~mjd/perl/lp/Spam.html">Part 1</a> and <a
href="http://www.perl.com/pub/2000/02/spamfilter.html">Part 2</a>
if you haven't yet. Here's a short summary to refresh your memory:

<P>
I get a lot of spam mail, and I don't like that. I used to get upset every
time I read my mail and had to throw out a bunch of spam, so I decided to
put some effort into writing a program that would filter my email and
discard spam automatically. Then my blood pressure would stay low.

<P>
I decided that it was most important that nothing be thrown away for good,
because I knew that no filter was perfect, and I was afraid that important
business mail from a client might be silently discarded and I would lose my
job. I also decided I wasn't smart enough to filter on the actual content
of messages---the touchstone example is that if someone sends me a letter <EM>complaining</EM> about spam, and they say ``Gosh, these Green Card Lottery messages are
driving me crazy!'' I don't want to reject the message just because it
mentions green card lotteries. I couldn't figure out how to avoid that, so
I resolved that I would filter on header lines only.

<P>
My main strategy is to maintain a blacklist of `bad domains' that send a
lot of spam, such as <CODE>eastmail.com</CODE>. Mail from these domains is presumed to be spam. Mail from anyone I don't
know in one of these domains is returned to the sender, with an apology,
requesting them to re-send the message to a different address. Mail to that
address is forwarded directly into my mailbox, and also into a program that
adds their `From' address to the list of `people I know', so that next time
they send me mail, it gets through the filter. The `people I know' list is
called a `whitelist', and it's just a DBM file. The code is very simple.
After reading the message and parsing the header, as I described in Part 1,
I look to see if the subject contains a secret password. If so, I add the
message senders to my whitelist. Senders can also get on the whitelist by
sending a message to a special address; this address invokes the program
with a command-line argument that automatically enables whitelisting. The
code looks something like this:

<P>
<PRE>
        if ($ARGV{Mode} eq 'Whitelist'
         || $H{Subject} =~ /$PASSWORD/) {
          foreach $s (senders()) {
            $db{lc $s} = time;
          }
        }
</PRE>
<P>
<HR>
<H1><A NAME="Drawbacks_of_This_Approach">Drawbacks of This Approach</A></H1>
<P>
People occasionally ask what would happen if the spammers added the special
whitelisting address to their mailing lists. This has never happened, but
if they did, I would deal with it easily enough; I'd just change the
address. Nobody ever needs to send more than one message to the
whitelisting address, because once you're on the whitelist, you're on
forever. So I wouldn't be inconveniencing anyone by changing this address.

<P>
Of course, in the meantime, the spammer is still on the whitelist, and even
if they don't add the whitelist address to their address list, they might
get the apology back in the mail and just add themselves to the whitelist.
This has only happened a few times since I first started in late
1996---most spammers don't provide valid return addresses, and those that
do don't read the replies to their mail.

<P>
For the couple of dedicated spammers who <EM>did</EM> try to add themselves to my whitelist, I have a special super-blacklist
called the `losers list'. The filter rejects mail from losers no matter
what address it comes to. It returns the message to the sender, with a note
that says

<P>
<PRE>
        Hello.  I am an automatic reply.

        Your message is not welcome at this address.
        The recipient is not interested in hearing what
        you have to say.  Your mail being returned unread.

        Please do not send mail to this address in the future.

                Sincerely,

                The answering machine.
</PRE>
<P>
This has a side benefit: If I get really sick of someone I can add them to
my loser list even if they're not a spammer. It would probably be more
mature to just have the filter throw away the message, rather than
returning a note that says `I am ingoring you', but I'm a spiteful guy.

<P>
So the logic in the filter program looks something like this:

<dl>
<dt>        if the message is from a loser
<dd>            send it back with an `I am ignoring you' note

<dt>        else if the message is from someone on the whitelist
<dd>            accept it

<dt>        else if the message is from someone in a blacklisted domain
<dd>            send it back with instructions about how to get whitelisted

<dt>        else
<dd>            accept it
</dl>
<P>
The first two tests, for loserhood or whitelisting, are fast. The filter
program keeps one big DBM file for both lists. The keys are `From:'
addresses, and the value is <CODE>loser</CODE> if the user is a loser, and the date of whitelisting if they user is on the
whitelist. I keep the dates as an ASCII-formatted number of seconds since
1970, so the actual code looks something like this:

<P>
<PRE>
        if ($DB{$from} eq 'loser') {
          # they are a loser; reject mail
        } elsif ($DB{$from} &gt; 0) {
          # they are on the whitelist; accept
        } elsif (domain_is_bad()) {
          # reject
        } else { 
          # accept
        }
</PRE>
<P>
<CODE>domain_is_bad()</CODE> takes longer, because it does many pattern matches. I discussed it in 
<a href="http://www.perl.com/pub/2000/02/spamfilter.html">Part
2.</a>

<P>
<HR>
<H1><A NAME="A_Few_More_Heuristics">A Few More Heuristics</A></H1>
<P>
Checking the <CODE>From:</CODE>, <CODE>Reply-To:</CODE>, and <CODE>Received:</CODE> lines for the presence of domains that are `bad' is the main part of the
program. But there are a few extra miscellaneous rules I've put in that
have worked really well. The function <CODE>misc_bad_header</CODE> checks these rules, returning true if it sees something bad, and false
otherwise. For example:

<P>
<PRE>
  return 'Addressed To: &quot;you&quot; or &quot;friend&quot;' 
    if $H{To} =~ /(you|friend)/i;
</PRE>
<P>
This line looks at the <CODE>To:</CODE> line; if it's addressed to <CODE>you</CODE> or to
<CODE>friend</CODE>, it's bad.  <CODE>Friend@public.com</CODE> was particularly common in Spam for a while. The string returned by <CODE>misc_bad_header</CODE> is eventually entered in the log file as the reason for rejection.

<P>
At the end of the previous article, I asked what was wrong with the
following <CODE>Received:</CODE> line:

<P>
<PRE>
        Received: from login_2961.sayme2.net (mail.sayme2.net[103.12.210.92])
          by sayme2.net (8.8.5/8.7.3) with SMTP id XAA02040
          for creditc@aoI.net;  Thu, 28 August 1997 15:51:23 -0700 (EDT)
</PRE>
<P>
People found all sorts of things wrong that hadn't occurred to me! For
example, underscores are not allowed in domain names, so the name
<CODE>login_2961.sayme2.net</CODE> is illegal. However, many hosts do have illegal characters in their names,
so this is probably not a good reason to reject the message.  

<P>
Some people pointed out that the <CODE>Received:</CODE> line contains the dubious host name <CODE>aoI.net</CODE>, perhaps in hopes of fooling me into thinking that it actually said <CODE>aol.net</CODE>. Of course, they don't look similar to the computer at all.  

<P>
Jan-Pieter Cornet pointed out that the date is in the wrong format: It's
illegal to spell out <CODE>August</CODE>. It would be interesting to correlate the incidence of this sort of error
with the incidence of Spam, but I haven't done the analysis. 

<P>
For me, the really interesting thing about this line is the time zone.
<CODE>EDT</CODE> usually stands for `Eastern Daylight Time', and the -0700 means that it's
the time zone seven hours behind Universal Coordinated Time. Guess what?
EDT is <EM>four</EM> hours behind UTC, not seven. Similarly,
<CODE>EST</CODE> is `Eastern Standard Time', which is -0500. When messages like this started
to show up, I added these lines to <CODE>misc_bad_header()</CODE>:

<P>
<PRE>
  return 'Mangled time zone' if $H{Received} =~ /-0600 \(EST\)/
           || $H{Received} =~ /-0[57]00 \(EDT\)/;
</PRE>
<P>
I don't know what caused the errors in the first place, but for a long time
they were extremely reliable spam detectors. Neither one has come by in
almost a year though, which is a shame; I miss them.

<P>
<HR>
<H1><A NAME="Yet_More_Heuristics">Yet More Heuristics</A></H1>
<P>
Here are some good ones:

<P>
<PRE>
          return 'X-PMFLAGS header' if exists $H{'X-PMFLAGS'};
</PRE>
<P>
I don't know what an <CODE>X-PMFLAGS</CODE> line is, but it only seems to appear in spam. 

<P>
<PRE>
          return 'Message was handled by bulk.mail' 
            if $H{Received} =~ /bulk.mail/i ;
</PRE>
<P>
There's a bulk mailing program called <CODE>bulk_mailer</CODE> that identifies itself in the <CODE>Received:</CODE> line. 

<P>
<PRE>
          return 'Subject contains &quot;ad&quot;/&quot;adv&quot;'
            if $H{Subject} =~ /\badv?\b/i;
</PRE>
<P>
Some spammers actually put a string like <CODE>ADV:</CODE> into the subject line of their message. Of course, the law of evolution by
natural selection says that this trait will be selected against, and the
next generation of spammers won't do it as much. In the meantime, it works
well.

<P>

The next one is obvious:

<P>
<PRE>
          return 'Subject: line contains $$$ '
            if $H{Subject} =~ /\${3}/;
</PRE>
<P>
The next one isn't so obvious:

<P>
<PRE>
          return 'Username is all digits'
            if $H{From} =~ /^\d+\@/;
</PRE>
<P>
You'd be surprised at how often this comes up. Spammers seem to be moving
away from it, though; now I'm more likely to get spam mail from an address
like <CODE>23gfgd4@iperbole.bologna.it</CODE>. I'd like to add a heuristic to throw away messages from unlikely-sounding
usernames, but I don't feel confident that I will be able to identify them
reliably.

<P>
Finally, here's a big heuristic that works well: Make a list of `bad'
words, and reject any message that includes any of the `bad' words in any
of the X-headers:

<P>
<PRE>
          my $pat = join '|', @bad_words;
          foreach $h (keys %H) {
            next unless $h =~ /^X-/;
            return &quot;Header `$h' contains bad word $1&quot;
              if $H{$h} =~ /($pat)/io;
          }
</PRE>
<P>
What words are `bad'? Oh, the usual naughtiness. `Cyberpromo' heads the
list. (Am I allowed to say that on a public web site?) `stealth' is a good
one.

<P>
There's a trick here that you might not have seen before. You have a bunch
of patterns, in this case the items in <CODE>@bad_words</CODE>, and a bunch of strings, in this case the values of <CODE>%H</CODE>, and you want to see if any of the strings match any of the patterns. The
obvious technique is to use:

<P>
<PRE>
        foreach $string (values %H) { 
          foreach $pattern (@bad_words) {
            if ($string =~ /$pattern/) {
              return &quot;String $string matches pattern $pattern&quot;
            }
          }
        }
</PRE>
<P>
This is a mistake. Why? Because a regex ie like a little computer program:
It must to be compiled, and then it can be executed and given an input,
which is the string that you want to match against it. Compiling a regex is
relatively slow, but you only need to do it once, and then you can give it
many strings and see if any of them match, without recompiling.  

<P>
Perl normally compiles your regexes at the same time as it compiles the
rest of your program. But if the regexes change at run time, it can't do
that. Instead, it compiles each one just as it is about to be used. If
there are 42 strings in the string list, each regex gets compiled 42 times.  

<P>
Just reversing the order of the <CODE>foreach</CODE> loops speeds this
up by a factor of 18, because each pattern is compiled 
only once, and then used for all the strings:

<P>
<PRE>
        foreach $pattern (@bad_words) {
          foreach $string (values %H) { 
            if ($string =~ /$pattern/) {
              return &quot;String $string matches pattern $pattern&quot;
            }
          }
        }
</PRE>
<P>
(I ran a simple test with 16 strings and nine patterns.  If there were
more patterns, the speedup would be greater.)

<P>
If <CODE>misc_bad_header()</CODE> is called only once, then compiling each pattern once is the best you can
do. But if the loop just above is run twice, then all the patterns have to
be compiled again the second time around; this is wasteful.

<P>
The solution is to construct <EM>one</EM> pattern that never varies at all, and compile it exactly once. We can
construct one pattern by joining the real patterns together with <CODE>|</CODE>s in between. That's what

<P>
<PRE>
          my $pat = join '|', @bad_words;
</PRE>
<P>
does; it takes a <CODE>@bad_words</CODE> list that looks like <CODE>('cyberpromo',
'stealth', ...)</CODE> and turns it into a pattern that looks like
<CODE>cyberpromo|stealth|...</CODE>. Then we match against this pattern:

<P>
<PRE>
         return &quot;Header `$h' contains bad word $1&quot;
           if $H{$h} =~ /($pat)/io;
</PRE>
<P>
The <CODE>/o</CODE> modifier tells Perl that even though <CODE>$pat</CODE> looks like a variable, we're really using it as a constant. We promise perl
that
<CODE>$pat</CODE> will never change, and in return, Perl compiles the regex once, the first
time it is needed, and never compiles it again.

<P>
In this program, this clever hack is probably not worth doing, because the
filter program gets invoked once to handle one mail message, calls
<CODE>misc_bad_headers()</CODE> exactly once, and then exits. If I were doing it over, I would have left
out the trick---it comes under the heading of `premature optimization', and
premature optimization is the root of all evil. But the trick can be useful
in other contexts.

<P>
<HR>
<H1><A NAME="Heuristics_that_Didn_t_Work">Heuristics that Didn't Work</A></H1>
<P>
I got tired of getting mail titled
<CODE>RE: BIOTECH BARGAIN!</CODE> and <CODE>**LET YOUR COMPUTER MAKE MONEY WHILE YOU
SLEEP!**</CODE>, so I thought I'd try putting in a filter to reject mail whose
<CODE>Subject:</CODE> line was in all capitals:

<P>
<PRE>
             my $s = $H{Subject};
             # subject contains no lowercase letters
             return 'Subject: all capitals' if $s !~ /[a-z]/ ;
</PRE>
<P>
The very next email message I received was titled <CODE>FYI</CODE>. It was from my brother-in-law. The spam filter rejected it. I commented
out the `all capitals' test. 

<P>
A few months later, I was ready for more abuse. I tried this::

<P>
<PRE>
             $s = tr/A-Za-z//cd;
             return 'Subject: all capitals' if $s !~ /[a-z]/ ;
               &amp;&amp; length($s) &gt; 6;  # and at least six capitals
</PRE>
<P>
This removes non-letters from the subject, then rejects the message if
the subject is all capitals and is at least seven letters long. Soon after
I tried this, I got mail from one of my clients titled <CODE>URGENT FIX!!!</CODE>. That was the end of that experiment.

<P>
The all-capitals subject line does not hold the record for the biggest spam
filtering failure. That honor goes to this line:  

<P>
<PRE>
        return 'no To: line' if $H{To} eq '';
</PRE>
<P>
This seemed fairly innoccuous, and still does---In fact, I'm still using it. Last
November, when I was away in London, I received a bulk mail that fell afoul
of this test and was sent to the spam file. All spam goes into a file so
that I can glance over it later, just in case it turns out to be something
important. The subject lines are logged separately. Usually I glance over
the subject line log (which is short) looking for messages that might be
interesting; if I see any, I go look in the spam file to see if it really
is interesting.

<P>
When I got back from London, I glanced over the subject log, and saw that 

<P>
<PRE>
        Subject: A message from VA Linux Systems (Mostly in English)
</PRE>
<P>
had been rejected because there was no <CODE>To:</CODE> line. I peeked at the message in the spam file, but I didn't look at it
closely, because I had a ton of unanswered mail to get to. I forgot about
it until a couple of months later when I ran into Chris DiBona at a
conference. ``Did you get the letter?'' he asked.

<P>
``What letter?''

<P>
My spam filter had discarded VA Linux's extremely lucrative IPO
announcement.

<P>
Oops.

<P>
Why haven't I taken out the <CODE>To:</CODE> line rule? Because it worked! It was supposed to detect bulk mail, and
that's just what it did do. The moral here is that there's some bulk mail
that you actually want to receive.

<P>
<HR>
<H1><A NAME="Notes_From_Last_Time">Notes From Last Time</A></H1>
<P>
I got a lot of interesting mail about the last article in this series.
Several people wrote to me to suggest a different filtering strategy:
Simply throw away mail unless one of your own addresses is in the <CODE>To:</CODE> line.

<P>
A lot of people wrote in about this, so it must work well for some people,
but it won't work for me. 
As I mentioned in <a href="http://www.plover.com/~mjd/perl/lp/Spam.html">Part 1</a>,  I had considered this
back in 1996. I decided
that it would probably result in a lot of false positives, where non-spam
mail was discarded. (For example, the IPO mail would still have been
rejected under this regime.) And then I went through my archive of spam and
discovered that about 20% of it actually <EM>was</EM> addressed to me, so I would have a 20% false negative rate also, where spam
would get through to me because it was addressed to me. With the system I
do use, the false positive rate is well below 10%, and the false negative rate is
much lower.

<P>
Someone also wrote to suggest that whenever I got spam, I could send an
automatic complaint letter to the relevant ISP, demanding revocation of the
sender's account.

<P>
This is a perfectly terrible idea, for several reasons. Most obviously,
most spam I get these days has a fake return address anyway, and
complaining to the owners of <CODE>hapless.com</CODE> isn't going to accomplish anything if the mail wasn't actually sent from
<CODE>hapless.com</CODE>, except to harass the hapless owners. So it's at best useless and at worst
a serious nuisance to people who are already trying to deal with a huge
number of bogus bounced messages.

<P>
But the real reason I hate this idea so much is that it makes even a small
false positive rate into a disaster. I can't reliably identify all the
non-spam messages I get; even with three layers of backup, I still lost out
on the VA Linux IPO because I thought it was spam. But I can live with
that; I knew when I set up the filter that I might one day miss something
important because of it.  I made an informed decision to take that risk.

<P>
But my correspondents, the people who write to me, did not make an informed
decision. They are stuck with my policy whether they like it or not, and I
owe it to them to inconvenience them as little as possible. A legitimate
person who sends me mail and falls afoul of the spam filter has to send
their message to me again, and even though they only have to do it once,
it's inconvenient and annoying. That inconvenience and annoyance to
innocent people who have never done anything wrong other than to try to
communicate with me is the biggest problem with the whole filtering
strategy.

<P>
But if inconveniencing my correspondent by forcing them to re-send a
message is a selfish thing to do, how much more selfish is it to
inconvenience them by mailing their ISP to demand that their account be
shut down? I can apologize to someone for making them send a second
message. How could I apologize for demanding that their internet access be
revoked? I just don't have that much gall.

<P>
<HR>
<H1><A NAME="Notes_From_Next_Time">Notes From Next Time</A></H1>
<P>
Coming next month, the last article in this series: Why I got 85 spam
messages last Wednesday, why I'm not happy with filtering, and what I'm
doing about it. This involves, of all things, a hack to the Apache web
server.  
