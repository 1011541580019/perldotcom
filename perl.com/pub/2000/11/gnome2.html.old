<!-- <a name="programming gnome applications with perl, part two">Programming GNOME Applications with Perl, Part Two</a> -->

<br />
<!::field::date::><a name="__index__"></a><!-- INDEX BEGIN -->
<p><table width="180" cellspacing="0" cellpadding="4" align="right" border="1">
<tr>
<td align="center" valign="top" bgcolor="#6699cc">
<font color="#ffffff">Table of Contents</td>
</tr>

<tr>
<td>
<p class="fine">
&#149;<a href="#the cookbook application">The Cookbook Application</a><br />
&#149;<a href="#the main screen">The Main Screen</a><br />
&#149;<a href="#columned lists">Columned Lists</a><br />
&#149;<a href="#displaying recipes">Displaying Recipes</a><br />
&#149;<a href="#where we are, and where we're going">Where We Are, And Where We're Going</a><br />
&#149;<a href="#notes on the last article">Notes on the Last Article</a><br />

</td>
</tr>
</p>
</table>
	<!-- INDEX END -->

<p>Last month's article examined how to create a simple
``Hello World'' application using Gtk+ and GNOME. This month, we'll
build a more sophisticated application - one to
store and retrieve recipes.</p>
<p>

<h3><a name="the cookbook application">The Cookbook Application</a></h3>
<p>Before we write a single line of code, let's see how we're
going to design this. First, we'll look at the user interface, and then
see what that means for our program design.</p>

<p>When designing user interfaces, we need to consider what provides users with the most useful and intuitive view of
their data, without overcrowding them. What do we need to be able to
get at easily when we're using the application? There are two parts to
this question: actions that we can perform, and data we can see.</p>

<p>In terms of the data, I decided that the best way to organize the
available recipes was as a list, just like the table of contents in a
recipe book; scroll up and down the list to see the recipe titles, and
then click on one title to display the whole recipe. We could also
display some useful information next to each title. I decided that the
most useful things to know would be the cooking time and the date that
the recipe was added.</p>

<p>Now we can look at the actions that will be performed - these will be turned into
the toolbar buttons. One of the most useful features I wanted was
the ability to give the program a list of ingredients that I have and
have it tell me things I could cook with them. I also wanted to be
able to maintain several different cookbooks, so ``Save'' and ``Open''
were natural choices. Of course, you need to be able to add new
recipes, so an ``Add'' button would be useful, too. Note that I didn't
want a ``Delete'' button - deleting a recipe is something that'll
probably happen rarely, and even then, you don't want to make it
<strong>too</strong> easy to do. Finally, you need to be able to exit.</p>

<p>That's the interface for the main screen, and this is
what it would look like:</p>

<img src="/2000/11/gnome-main1.jpg" border="0" width="450"><p>Now we can think about the data we need to store. We'll need
to store recipes with their titles,
dates and cooking times. If we want to search by ingredient, we should
also store what ingredients each recipe needs. It would
also be handy to have a complete list of all the ingredients we know
about, and we'll also have some user configuration settings.</p>
<p>Initially, I considered putting the recipes in an SQL database, but
decided against it for two reasons: first, connecting recipes to
ingredients was unnecessarily complicated, and the whole thing seemed
a little overkill, and second, GNOME applications traditionally
store all their data in XML files so that data can be easily passed
between apps. In the end, I decided to store the configuration
settings plus the list of ingredients we know about in a single XML file,
and have the recipe book in a separate file.</p>

<h3><a name="the main screen">The Main Screen</a></h3>

<p>Now that we know what the interface is going to look like for the main
screen, we can start coding it. We'll start with the menu items and
the toolbar, just like before.</p>
<pre>
        #!/usr/bin/perl -w
        use strict;
        use Gnome;

        my $NAME    = 'gCookBook';
        my $VERSION = '0.1';

        init Gnome $NAME;

        my $app = new Gnome::App $NAME, $NAME;
		
        signal_connect $app 'delete_event', 
          sub { Gtk-&gt;main_quit; return 0 };

        $app-&gt;create_menus(
           {
          type =&gt; 'subtree',
          label =&gt; '_File',
          subtree =&gt; [
                { 
                 type =&gt; 'item',
                 label =&gt; '_New',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_New'
                },
                {
                 type =&gt; 'item',
                 label =&gt; '_Open...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Open'
                },
                {
                 type =&gt; 'item',
                 label =&gt; '_Save',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Save'
                },
                {
                 type =&gt; 'item',
                 label =&gt; 'Save _As...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Save As'
                },
                {
                 type =&gt; 'separator'
                },
                {
                 type =&gt; 'item',
                 label =&gt; 'E_xit',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Quit',
                 callback =&gt; sub { Gtk-&gt;main_quit; return 0 }
                }
                 ]
           },
           { 
          type =&gt; 'subtree',
          label =&gt; '_Edit',
          subtree =&gt; [
                {
                 type =&gt; 'item',
                 label =&gt; 'C_ut',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Cut',
                },
                {
                 type =&gt; 'item',
                 label =&gt; '_Copy',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Copy'
                },
                {
                 type =&gt; 'item',
                 label =&gt; '_Paste',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Paste'
                }
                 ]
           },
           {
          type =&gt; 'subtree',
          label =&gt; '_Settings',
          subtree =&gt; [
                {
                 type =&gt; 'item',
                 label =&gt; '_Preferences...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_Preferences',
                 callback =&gt; \&amp;show_prefs
                }
                 ]
           },
           {
          type   =&gt; 'subtree',
          label  =&gt; '_Help',
          subtree =&gt; [
                {type =&gt; 'item', 
                 label =&gt; '_About...',
                 pixmap_type =&gt; 'stock',
                 pixmap_info =&gt; 'Menu_About',
                 callback =&gt; \&amp;about_box
                }
             ]
           }
          );

    $app-&gt;create_toolbar(
           {
            type     =&gt; 'item',
            label    =&gt; 'Cook',
            pixmap_type =&gt; 'stock',
            pixmap_info =&gt; 'Search',
            hint     =&gt; 'Find a recipe by ingedients'
           },
           {
            type     =&gt; 'item',
            label    =&gt; 'Add',
            pixmap_type =&gt; 'stock',
            pixmap_info =&gt; 'Add',
            hint     =&gt; 'Add a new recipe'
           },
           {
            type     =&gt; 'item',
            label    =&gt; 'Open...', 
            pixmap_type =&gt; 'stock',
            pixmap_info =&gt; 'Open',
            hint     =&gt; &quot;Open a recipe book&quot;
           },
           {
            type     =&gt; 'item',
            label    =&gt; 'Save', 
            pixmap_type =&gt; 'stock',
            pixmap_info =&gt; 'Save',
            hint     =&gt; &quot;Save this recipe book&quot;
           },
           { 
            type     =&gt; 'item',
            label    =&gt; 'Exit',
            pixmap_type =&gt; 'stock',
            pixmap_info =&gt; 'Quit',
            hint     =&gt; &quot;Leave $NAME&quot;,
            callback  =&gt; sub { Gtk-&gt;main_quit;}
           }
          );

    $app-&gt;set_default_size(600,400);

    my $bar = new Gnome::AppBar 0,1,&quot;user&quot; ;
    $bar-&gt;set_status(&quot;&quot;);
    $app-&gt;set_statusbar( $bar );

    show_all $app;

    main Gtk;

    sub about_box {
      my $about = new Gnome::About $NAME, $VERSION,
      &quot;(C) Simon Cozens, 2000&quot;, [&quot;Simon Cozens&quot;], 
      &quot;This program is released under the 
          same terms as Perl itself&quot;;
      show $about;
      }
</pre>

<h3><a name="columned lists">Columned Lists</a></h3>

<p>Next, we have to show the list of recipes. This is usually done with a <code>CList</code>, or ``columned list,'' widget. However, the standard Gtk
<code>CList</code> widget is a little unfriendly to deal with: You can only put
data into it, and you can't find out what is in the list, so you have
to maintain a separate array containing the data; columned lists
usually re-sort themselves when a column title is clicked on, but the
programmer has to handle this case himself; data has to be referenced
by column number, not by column name; and so on.</p>

<p>Since I realized this was going to be unpleasant every time I wanted a
columned list, I wrote a module called <code>Gtk::HandyCList</code> that
encapsulates all these features. (You'll need to download that module
from CPAN if you want to try this. Make sure you get version
0.02, since we use the <code>hide</code> method down below, which is new in that
version.)</p>

<p>To add it to our program, we first need data to display! Let's
create a dummy array of data, like this:</p>
<pre>
        my @cookbook = (
                [ &quot;Frog soup&quot;, &quot;29/08/99&quot;, &quot;12&quot;],
                [ &quot;Chicken scratchings&quot;, &quot;12/12/99&quot;, &quot;40&quot;],
                [ &quot;Pork with beansprouts in a garlic
                    butter sauce and a really really long name
                    that we have to scroll to see&quot;,
                  &quot;1/1/99&quot;, 30],
                [ &quot;Eggy bread&quot;, &quot;10/10/10&quot;, 3]
               );</pre>
<p>Now we need to load the module itself, so:</p>

<pre>    use Gtk::HandyCList;</pre>

<p>Because we want this list to be scrollable, we put it inside a
different widget that handles scroll bars - a 
<code>Gtk::ScrolledWindow</code>.</p>
<pre>
  my $scrolled_window = new Gtk::ScrolledWindow( undef, undef );
  $scrolled_window-&gt;set_policy( 'automatic', 'always' );</pre>
  
<p>Now we create the HandyCList. First, we specify the column names that will be used, then we set up the sizes for each column.</p>
<pre>
  my $list = new Gtk::HandyCList qw(Name Date Time);
  $list-&gt;sizes(350,150,100);</pre>
  
<p>As I mentioned, we want to be able to re-sort the data when we click on the column
headings. To make this work we have to tell
the module <strong>how</strong> to sort each column. It knows about alphabetical
and numeric sorting, but we'll have to tell it about sorting
by date by providing it with a subroutine reference. We also set the
shadow so that it looks pretty.</p>
<pre>
  $list-&gt;sortfuncs(&quot;alpha&quot;, \&amp;sort_date, &quot;number&quot;);
  $list-&gt;set_shadow_type('out');</pre>
  
<p>Now we give the data to the list:</p>
<pre>
  $list-&gt;data(@cookbook);</pre>
  
<p>Next, we add the list to our scrolled window, and tell the application
that its main contents are the scrolled window:</p>
<pre>
  $scrolled_window-&gt;add($list);
  $app-&gt;set_contents($scrolled_window);</pre>
  
<p>Finally, we'll receive the signal sent when a recipe is clicked on,
and use that to display the recipe.</p>
<pre>
  $list-&gt;signal_connect( &quot;select_row&quot;, \&amp;display_recipe);</pre>
  
<p>Of course, we need to write those two subroutines, <code>sort_date</code> and
<code>display_recipe</code>. Let's leave the latter one for now, and polish off
the date sorting. Here's how I'd write it, because I'm British:</p>
<pre>
        sub sort_date {
          my ($ad, $am, $ay) = ($_[0] =~ m|(\d+)/(\d+)/(\d+)|);
          my ($bd, $bm, $by) = ($_[1] =~ m|(\d+)/(\d+)/(\d+)|);
          return $ay &lt;=&gt; $by || $am &lt;=&gt; $bm || $ad &lt;=&gt; $bd;
        }</pre>
		
<p>Exercise for the reader: make this subroutine locale-aware.</p>

<p>By now, you should have an application that displays a
list of recipes along with their dates and cooking times. Play with
it, click on the column headings and watch it re-sort, resize the
windows and the columns, and see what happens.</p>

<h3><a name="displaying recipes">Displaying Recipes</a></h3>
<p>Now let's tackle displaying the recipes. This is where things get more complex. First, we have to store the text for
the recipes. We want to store them, along with the
titles, dates and cooking times, in the <code>@cookbook</code> array. So
let's add another column to that array, like so:</p>
<pre>
    my @cookbook = (
        [ &quot;Frog soup&quot;, &quot;29/08/99&quot;, &quot;12&quot;, 
          &quot;Put frog in water. Slowly raise water temperature 
           until frog is cooked.&quot;],
        [ &quot;Chicken scratchings&quot;, &quot;12/12/99&quot;, &quot;40&quot;, 
          &quot;Remove fat from chicken, and fry 
	   under a medium grill&quot;],
        [ &quot;Pork with beansprouts in a garlic butter sauce 
           and a really really long name that we have to
           scroll to see&quot;,
          &quot;1/1/99&quot;, 30, 
	  &quot;Pour boiling water into packet and stir&quot;],
        [ &quot;Eggy bread&quot;, &quot;10/10/10&quot;, 3, 
	  &quot;Fry bread. Fry eggs. Combine.&quot;]
           );
</pre>

<p>We don't want to display this information on the main
list, so we need to change the data that we're passing to the
<code>Gtk::HandyCList</code>:</p>
<pre>
 - my $list = new Gtk::HandyCList qw(Name Date Time);
 + my $list = new Gtk::HandyCList qw(Name Date Time Recipe);
 + $list-&gt;hide(&quot;Recipe&quot;);</pre>
 
<p>(If you don't remember what that syntax means, it's ``take out the line
starting with the minus, and add in the lines starting with a plus.'')</p>

<p>Now that we have the recipes stored inside our data structure, we want
to be able to see them. We'll use a widget called
<code>Gnome::Less</code>, which is named after the Unix utility <code>less</code>. It's a
file browser, but we can also give it strings to display.</p>

<p>Let's stop and think about what we're going to do. We need to catch
the signal that tells us that the user has double-clicked on a
recipe. Then, we want to pop up a window, create a <code>Gnome::Less</code>
widget inside that window containing the recipe text and allow the
user to dismiss the window. We've already connected the ``mouse click''
signal to a subroutine called <code>display_recipe</code>, so it's time to write
that subroutine.</p>
<pre>
    sub display_recipe {
      my ($clist, $row, $column, $mouse_event) = @_;
      return unless $mouse_event-&gt;{type} eq &quot;2button_press&quot;;</pre>
	  
<p>First, we receive the parameters passed by the signal. The first thing
we get is the object that caused the signal - our <code>HandyCList</code>
widget. That determines what other parameters get sent. In the
case of a <code>HandyCList</code>, it's the row and column in the list that
received the mouse click, and a <code>Gtk::Gdk::MouseEvent</code> object that
tells us what sort of click it was. In our case, we only want to act
on a double click, which is where the type is <code>&quot;2button_press&quot;</code>. If
this isn't the case, we return.</p>
<pre>
      my %recipe = %{($clist-&gt;data)[$row]};</pre>
	  
<p>Given that we know the row that received the signal, we can 
extract that row from the <code>HandyCList</code> via the <code>data</code> method.
<code>Data</code> is a get-set method, which means we can either store data into
the list with it, or we can use it to retrieve the data from the
list. Each row is stored as a hash reference, which we dereference to
a real hash.</p>
<pre>
      my $recipe_str = $recipe{Name}.&quot;\n&quot;;
      $recipe_str .= &quot;-&quot; x length($recipe{Name}).&quot;\n\n&quot;;
      $recipe_str .= &quot;Cooking time : $recipe{Time}\n&quot;;
      $recipe_str .= &quot;Date created : $recipe{Date}\n\n&quot;;
      $recipe_str .= $recipe{Recipe};</pre>

<p>Next, we build the string that we're going to display, using the
hash values we've recovered.</p>
<pre>
      my $db = new Gnome::Dialog($recipe{Name});
      my $gl = new Gnome::Less;
      my $button = new Gtk::Button( &quot;Close&quot; );
      $button-&gt;signal_connect( &quot;clicked&quot;, sub { $db-&gt;destroy } );</pre>
	  
<p>We now create three widgets: the pop-up dialog box window (we pass
the recipe's name as a window title), the pager that will display the
recipe and a close button. We also connect a signal so that when the
button is clicked, the dialog box is destroyed.
</p>
<pre>

      $db-&gt;action_area-&gt;pack_start( $button, 1, 1, 0 );
      $db-&gt;vbox-&gt;pack_start($gl, 1, 1, 0);</pre>

<p>A dialog box consists of two areas: an ``action area'' at the bottom
that should contain the available ``actions,'' or buttons, and a vbox
at the top where we put our messages. Accordingly, we pack our
button into the action area and our <code>Less</code> widget into the vbox</p>
<pre>
      $gl-&gt;show_string($recipe_str);
      show_all $db;
    }</pre>
<p>Finally, we tell the pager what string it should display, and then show
the dialog box. We can now display recipes.</p>
<p>

<h3><a name="where we are, and where we're going">Where We Are, And Where We're Going</a></h3>
The full source of the application so far can be found <a
href="/2000/11/gcookbook.pl">here</a>.

<p>So far, we've only dealt with static data, hard-coded into the
application, which isn't a very real-life scenario. Next time, we'll
look at adding and deleting recipes, as well as saving and restoring
cookbooks to disk using XML. Once that's done, we'll have the core of
a basic cookbook application. In the final part of this tutorial,
we'll add more features, such as searching by ingredients.</p>

<h3><a name="notes on the last article">Notes on the Last Article</a></h3>

<p>Several people wrote me after <a href="http://www.perl.com/pub/2000/10/gnome.html">last month's article</a> saying that they
couldn't get the GNOME versions of the application working; if that's
a problem, you need to be using the latest version of the
Gnome.pm module. The one on CPAN is <em>not</em> the latest - instead,
use the one from the Gnome.pm Web site, at
<a href="http://projects.prosa.it/gtkperl">http://projects.prosa.it/gtkperl</a>.</p>

<p>I also got my knuckles rapped for saying that ``GNOME is the Unix
desktop.'' Fair play - the other project that's providing the same sort
of environment for Unix is KDE, but for a long time it was hampered by
developers' suspicion of TrollTech and their QPL license. At the same
time, big players like Sun and IBM were putting money into
the GNOME Foundation to <em>make</em> GNOME the Unix desktop, so it seemed a
fair thing to say.</p>

<p>Now most people are happy that the same big players have also set up the KDE League. (From
<a href="http://www.kde.org/announcements/gfresponse.html">http://www.kde.org/announcements/gfresponse.html:</a> `Now we have been
asked ``Will KDE ever create a KDE Foundation in the same sense as the
GNOME Foundation?'' The answer to this is no, absolutely not.' You tell
'em, guys.) KDE looks to be a worthy alternative to GNOME. Obviously,
I prefer GNOME, but as <a href="http://segfault.org">http://segfault.org</a> puts it: ``KDE - GNOME War -
Casualties so far: 0''.</p>


