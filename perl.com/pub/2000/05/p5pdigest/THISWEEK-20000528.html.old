</P>

<P>


<!-- This week on perl5-porters (22--28 May 2000) -->

<br />
<!::field::date::><br />

<ul>
  <li><a href="#Notes">Notes</a>
  <li><a href="#Regex_Engine_Enhancements">Regex Engine Enhancements</a>
  <li><a href="#eq_and_UTF8_operator"><code>eq</code> and UTF8 operator</a>
  <li><a href="#Caching_of_the_getby_Functions">Caching of the <code>get</code>*<code>by</code>* Functions</a>
  <li><a href="#Forbidden_Declarations_Continued">Forbidden Declarations Continued</a>
  <li><a href="#Perl_in_the_News">Perl in the News</a>
  <li><a href="#readonly_Pragma_Continues"><code>readonly</code> Pragma Continues</a>
  <li><a href="#Magical_Autoincrement">Magical Autoincrement</a>
  <li><a href="#Doctor_Doctor_it_Hurts_When_I_Do_This">Doctor, Doctor, it Hurts When I Do This!</a>
  <li><a href="#use_strict_formatting"><code>use strict 'formatting'</code></a>
  <li><a href="#Complex_Expressions_in_Formats">Complex Expressions in Formats</a>
  <li><a href="#packU"><code>pack("U")</code></a>
  <li><a href="#Various">Various</a>
</ul>

      <H3><a name="Notes">Notes</a></H3>

</P>

<P>

You can subscribe to an email version of this summary by sending an
empty message to 
<a href="mailto:p5p-digest-subscribe@plover.com"><tt>p5p-digest-subscribe@plover.com</tt>.</a></P>

<P>
Please send corrections and additions to 
<CODE>mjd-perl-thisweek-YYYYMM@plover.com</CODE> where 
<CODE>YYYYMM</CODE> is the current year and month.
</P>

<P>
This week's report is a little early, because tomorrow I have to leave
to go on the Perl Whirl.   Next week's report will be late, for the
same reason.  
</P>

<P>
Quite a lot of discussion this month, much of it rather pointless.
Not one of our better weeks, I'm afraid.  
<H3><a name="Regex_Engine_Enhancements">Regex Engine Enhancements</a></H3>

</P>

<P>

Ben Tilly, Ilya Zakharevich, and 
Fran&ccedil;ois D&eacute;sarm&eacute;nien had a discussion about an alternative implementation of the regex
engine.    I'm going to try to summarize the necessary background as
briefly as possible.
</P>

<P>
The regex engine is a state machine.  The engine looks through the
characters in the target string one at a time and makes a state
transition on each one; at the end of the string it looks to see if it
is in an `accepting state' and if so, the pattern matches.  What regex
you get depends on how the states are arranged and what are the
transitions between them.
</P>

<P>
The basic problem that all regex engines face is that a certain state
might have two different transitions on the same condition.  For
example, suppose you are matching 
<CODE>/foo(b*)bar/</CODE> and you have seen 
<CODE>foo</CODE> already.  You are now in a state that expects to see an upcoming 
<CODE>b</CODE>.  When you see the 
<CODE>b</CODE>, however, you get two choices:  You can go back to the same state and
look for another 
<CODE>b</CODE>, or you can go on to the next state and look for an 
<CODE>a</CODE>.  If the string is 
<CODE>foobbbar</CODE> then the first choice is correct; if the string is 
<CODE>foobar</CODE> then the second choice is correct.
</P>

<P>
There are basically two ways to deal with this.  One way is to use a
representation of the state machine that keeps track of all the states
that the machine could be in at once.  In the example above, it would
note that the machine might be in either of the two possible states.
Future transitions might lead to more uncertainty about the state that
the machine was actually in.  At the end of the string, the engine
just checks to see if 
<em>any</em>  of the possible result states are acceptingstates, and if so, it reports that there is a match.  This is called
the 'DFA' approach.
</P>

<P>
The other approach  is to take
one of the two choices arbitrarily and remember that if the match does
not work out, you can backtrack and try the other alternative
instead.  This is called the 'NFA' approach, and it is what Perl does.
It choses to go back and try the 
current state first, before it tries going on to the next state; that
is what makes Perl's 
<CODE>*</CODE> operator greedy.  For the non-greedy 
<CODE>*?</CODE> operator it just chooses the other alternative first.  
</P>

<P>
Both approaches have upsides and downsides.  Downsides of the NFA
approach: It is generally slower at run-time.  It is more difficult to
handle non-greedy matching and backreferences.  Downsides of the DFA
approach: It is prone to take a very long time for certain regexes,
because of its habit of trying many equivalent alternatives one at a
time.  Also, it is very hard to specify that you want the longest
possible match---consider writing a Perl regex that matches whichever
of 
<CODE>/elsif|\w+/</CODE> is longer.  This is easy to implement if you use an NFA.
</P>

<P>
Ben's idea is that you would start with an NFA and then apply a
well-known transformation to turn it into a DFA.  
The well-known transformation is that each state in the DFA
corresponds to a set of states that the original NFA could have been
in; Ben's idea is that you can retain the information about the order
in which the states would have been visited, and use those ordered
sets of NFA states as single DFA states.
The problem with
this sort of construction is that under some circumstances the number of states
explodes exponentially---if the original NFA had 
<var>n</var> states then the resulting DFA could have up to  2<sup><var>n</var></sup> states.  With Ben's idea this is evenworse, because the resulting DFA might have up to 
<var>(n+1)!</var> states.  But as Ben points out, in practice it is usually well-behaved.
You would be trading off an unusual run-time bad behavior for a
(probably) more unusual  compile-time bad behavior.  On the other
hand, if Ben's scheme went bad at compile time, it would go really bad
and eat all your memory.  Also, it is really unclear how to handle
backreferences with his scheme.  Ben waved his hands over this and
Ilya did not have any ideas about how to do it.
</P>

<P>
There was some discussion of various other regex matters.  Ben had
formerly suggested a 
<CODE>(?\/)</CODE> operator that matches the empty string but
which inhibits backtracking; if the engine tries to backtrack past it,
it fails.  SNOBOL had something like this, called 
<CODE>FENCE</CODE>.  Ilya said he did not want to do this because he thought all the
useful uses were already covered by 
<CODE>(?>...)</CODE> and because he did not want to implement a feature that was only
 explainable in terms of backtracking.  He also said you could get
 this behavior by doing 
</P>

</P><PRE>
        (?:|(?{die}))
</PRE>

<P>
and putting the regex match into an 
<CODE>eval</CODE> block.  (Did you get that?  It first tries to match the empty string,
 to the left of the 
<CODE>|</CODE>, and if that doesn't work, it tries to match 
<CODE>(?{die})</CODE>, which throws an exception.)
</P>

<P>
Ben suggested that the regex engine could have a hook in it that would
call an alternative regex engine, handing it the string to be matched
and the current position, and the subengine would return a value
saying how far it had matched up to; this would facilitate trying out
alternative implementations or new features.
</P>

<P>
Ilya spent some time discussion new features he thought might be
useful.  
<a href="http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-05/msg01056.html">One such message.</a></P>

<P>

When Ilya mentioned SNOBOL is went into SNOBOL-berserk mode and posted a
twelve-page excerpt from the SNOBOL book about SNOBOL pattern-matching
optimizations, which was not particularly relevant to the rest of the
discussion.  
</P>

<P>

<a href="http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-05/msg00853.html">Root of this thread</a><H3><a name="Perl_in_the_News">Perl in the News</a></H3>

</P>

<P>

<a href="http://news.cnet.com/news/0-1007-200-1939586.html?tag=st.ne.1002.tgif.ni">The News</a></P>

<P>
Dick Hardt was quoted out of context.  This led to a really boring and
offtopic advocacy discussion.  
<!-- ``Why is Perl perceived as slow and bloated?''  Duh, maybe because it's slow and bloated? -->Several people
were asked to take the discussion to the advocacy mailing list.  This
meant that they cc'ed the discussion to both lists.  Brilliant.
</P>

<P>
Folks, I love the advocacy list because then people who want to have
interminable discussions about why Perl is considered slow and bloated
have somewhere to do it where I don't have to hear it.  Maybe someday
I will commit a heinous crime and be sentenced to produce a weekly
summary of discussion on the Perl Advocacy mailing list, and I will be
unable to plea-bargain my way to a lesser offense that carries the
death penalty.  Until then, please do me a favor and keep advocacy
discussion out of p5p.
<H3><a name="Doctor_Doctor_it_Hurts_When_I_Do_This">Doctor, Doctor, it Hurts When I Do This!</a></H3>

</P>

<P>

<blockquote><b>Garrett Goebel:</b> <pre>my $val = shift; <br>substr($bitstring,2,4) = pack('p',$val); </pre><p><b>Ilya Zakharevich:</b><p> Do not.<br>Hope this helps,<br>Ilya</p></blockquote></P>

<P>

<H3><a name="eq_and_UTF8_operator"><code>eq</code> and UTF8 operator</a></H3>

</P>

<P>

Clark Cooper asked why a UTF8 string will not compare 
<CODE>eq</CODE> to a non-UTF8 string whose bytes are identical.
</P>

<P>
Ilya replied that the short answer is that they should not compare 
<CODE>eq</CODE> because they represent different sequences of characters. 
</P>

<P>
He then elaborated and said that the internal representation does not
matter; that a string is a sequence of characters, and a character is
just an integer in some range.  In old Perls the range was 0..255; now
the range is 0..(2**64-1), and the details about how these integers
are actually represented is not part of the application's business.
<H3><a name="Caching_of_the_getby_Functions">Caching of the <code>get</code>*<code>by</code>* Functions</a></H3>

</P>

<P>

Last week Steven Parkes complained that when he used the 
<CODE>LWP::UserAgent</CODE> module, each new agent caused a call to one of the 
<CODE>getprotoby</CODE>* functions, which opened the 
<CODE>/etc/protocols</CODE> file and searched it.  Many agents, many searches.  He pointed out
 that there is no way to get 
<CODE>LWP::protocol::http</CODE> or 
<CODE>IO::Socket::inet::_sock_info</CODE>, the culprit functions, to cache the protocol information.
</P>

<P>
Ben Tilly suggested adding a caching layer to those functions, or
having the standard modules use a cached version.  Tom pointed out
that the uncached call only takes 1/6000 second on his machine, so it
is unlikely to be a real problem in practice,  and
that the caching is hard to get right in general.   Russ pointed out
that it is a very bad idea to have application-level caching of 
<CODE>gethostby</CODE>* and 
<CODE>getaddrby</CODE>* calls, because such caching ignores the TTL in the DNS record.
Other points raised:  Caching of DNS information is already done in
the 
<CODE>named</CODE>, and correctly.  Any caching of DNS information done at the 
<CODE>gethostby</CODE>* level is guaranteed to be wrong.
</P>

<P>

<H3><a name="Forbidden_Declarations_Continued">Forbidden Declarations Continued</a></H3>

</P>

<P>

Last week I complained about the error 
</P>

</P><PRE>
        In string, @X::Y must now be written as \@X::Y...
</PRE>

<P>
In the ensuing discussion, I suggested that this error message be
removed.  We have been threatening since 1993 that
<blockquote>Someday it will simply assume that an unbackslashed<code>@</code> interpolates an  array.</blockquote></P>

<P>

Sarathy said that he thought this should have appened two years ago,
so I provided a patch.  Interpolating an undeclared array into a
string is no longer a fatal error; instead, it will raise the warning 
</P>

</P><PRE>
        Array @X::Y will be interpolated in string
</PRE>

<P>
if you have warnings enabled.
</P>

<P>

<a href="http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-05/msg00850.html">The patch.</a></P>

<P>

<a href="http://www.plover.com/~mjd/perl/at-error.html">This article has a detailed explanation of the history of this error message.</a></P>

<P>

<a href="http://www.perl.com/pub/2000/05/p5pdigest/THISWEEK-20000521.html#Forbidden_Declarations">Previous Discussion</a><H3><a name="readonly_Pragma_Continues"><code>readonly</code> Pragma Continues</a></H3>

</P>

<P>

<a href="http://www.perl.com/pub/2000/05/p5pdigest/THISWEEK-20000521.html#readonly_Pragma">Previous Discussion</a></P>

<P>
Mark Summerfield does not like any of the alternatives that were
proposed.  There are several 
<CODE>tie</CODE>-based solutions which are too slow.  He does not like William
Setzer's 
<CODE>Const</CODE> module because at happens at run time so you have to declare the
 readonly variable separately from the place you make it constant.
(I wonder if 
</P>

</P><PRE>
        const my $x = 12;
</PRE>

<P>
would work?)
</P>

<P>
He also complained that even if you mark a scalar as readonly, someone
else can go into the glob and replace the entire scalar, with
</P>

</P><PRE>
        *pi = \3;
</PRE>

<P>
A couple of people replied that if someone wants to change your
read-only value so badly that they are willing to hack the symbol
table to do it, then they should be allowed to do so.
</P>

<P>
Tom posted what I think was a quote from Larry saying that
</P>

</P><PRE>
        my $PI : constant = 4 * atan2(1,1);
</PRE>

<P>
was coming up eventually.
<H3><a name="Magical_Autoincrement">Magical Autoincrement</a></H3>

</P>

<P>

Vadim Konovalov complained that
</P>

</P><PRE>
        $a = 'a';
        $a==5;
        $a++;
</PRE>

<P>
Increments 
<CODE>$a</CODE> to 1 instead of to 
<CODE>b</CODE>.  This is as documented:
</P>

<P>

<blockquote>The auto-increment operator has a little extra builtin magic to it.  If you increment a variable that is numeric, <b>or that has ever been used in a numeric context</b>, you get a normal increment.  </blockquote><H3><a name="use_strict_formatting"><code>use strict 'formatting'</code></a></H3>

</P>

<P>

Ben Tilly suggested a 
<CODE>use strict 'formatting'</CODE> declaration that would tell Perl to issue a diagnostic whenever the
 indentation and the braces were inconsistent.  However, he did not
 provide a patch.
</P>

<P>

</P>

<P>

<H3><a name="Complex_Expressions_in_Formats">Complex Expressions in Formats</a></H3>

</P>

<P>
H. Merijn Brand points out that complex variable references, such as 
<CODE>$e[1]{101}</CODE> seem to be illegal in formats.  However, he did not provide a patch.
<H3><a name="packU"><code>pack("U")</code></a></H3>

</P>

<P>

Meng Wong pointed out that 
<CODE>pack("U")</CODE>, which is documented as
</P>

</P><PRE>
        [pack] A Unicode character number.  Encodes to UTF-8
        internally.  Works even if C<use utf8> is not in effect.
</PRE>

<P>
does not produce a UTF8 string.  Simon provided a patch for that.
Then a discussion between Ilya, Sarathy, and Gisle Aas ensued about
whether this was the right thing to do.  Gidle said it was not, and
asked what 
<CODE>pack("UI")</CODE> should produce.  Sarathy said that 
<CODE>"U"</CODE> packs a character in the UTF-8 encoding, and UTF-8 is encoded with
 bytes; therefore the result of the 
<CODE>pack</CODE> should be bytes, not another UTF-8 string.  Ilya asked then what
 should happen if someone did
</P>

</P><PRE>
        $a = pack "A20 I", $string, $number;
</PRE>

<P>
where 
<CODE>$string</CODE> contained characters with values larger than 255.  Sarathy said that 
<CODE>"A"</CODE> is defined to be ASCII, so it should die.  Then Ilya pointed out that
 if it did that there would be no way to take a UTF8 string and insert
 it into a 20-byte fixed-width field.  Discussion went on, and I was
 not able to discern a clear conclusion.
<H3><a name="Various">Various</a></H3>

</P>

<P>

A large collection of bug reports, bug fixes, non-bug reports,
questions, answers, and a small amount and spam.   No serious flamage
however.
</P>

<P>
Until next week I remain, your humble and obedient servant,
</P>

<hr>

<a href="mailto:mjd-perl-thisweek-200005+@plover.com">Mark-Jason Dominus</a>
