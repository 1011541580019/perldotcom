<!-- <A NAME="What_s_wrong_with_this_picture_">What's wrong with this picture?</A> -->

<br />
<!::field::date::><!-- INDEX BEGIN -->
<UL>

 <LI><A HREF="#What_s_wrong_with_this_picture_">What's wrong with this picture?</A>
 <UL>

  <LI><A HREF="#Reading_the_Input">Reading the Input</A>
  <LI><A HREF="#Computing_Average_and_Total_Time">Computing Average and Total Times</A>
  <LI><A HREF="#Sort_Order">Sort Order</A>
  <LI><A HREF="#Printing_the_Report">Printing the Report</A>
 </UL>

 <LI><A HREF="#Red_Flags">Red Flags</A>
 <UL>

  <LI><A HREF="#Get_Rid_of_Array_Size_Variables">Get Rid of Array Size Variables</A>
  <LI><A HREF="#Use_Compound_Data_Structures_Ins">Use Compound Data Structures Instead of Variable Families</A>
  <LI><A HREF="#Use_C_foreach_to_Loop_Over_Arra">Use <code>foreach</code> to Loop Over Arrays</A>
 </UL>

</UL>
<!-- INDEX END -->

<P>
Someone recently asked me to take a look at his report-generating program
because he wasn't able to get the final report sorted the way he wanted.

<P>
The program turned out to require only a minor change to get the report in
order, but it also turned out to be a trove of common mistakes--which is
wonderful, because I can use one program to show how to identify and fix
all the common mistakes at once!

<P>
First I'll show the program, and then I'll show how to make it better.
Here's the original. (Note: Lines of code may be broken for display purposes.)

<P>
<PRE>
     1  #!/usr/bin/perl
     2  use Getopt::Std;
     3  getopt('dV');
     4  $xferlog=&quot;./xferlog&quot;;
     5  $\ = &quot;\n&quot;;
     6  $i=0;
     7  open XFERLOG, $xferlog or die &quot;Cant't find file $xferlog&quot;;
     8  
     9  foreach $line (&lt;XFERLOG&gt;) {
    10        chomp($line);
    11        if (( $line =~ /$opt_d/i) &amp;&amp; ( $line !~ /_ o r/)) 
    12           {
    13           ($Fld1,$Fld2,$Fld3,$Fld4,$Fld5,$Fld6,$Fld7,$Fld8,
               $Fld9,$Fld10,$Fld11,$Fld12,$Fld13,$Fld14,$Fld15) = split(' ',$line);
 
    14            $uplist[$i] = join ' ',$Fld6, $Fld8, $Fld9, $Fld14, $Fld15;
    15            $time[$i]=$Fld6; $size[$i]=$Fld8; $file[$i]=$Fld9; 
               $user[$i]=$Fld14; $group[$i]=$Fld15;
      
    16            $username= join '@', $user[$i], $group[$i];
    17            push @{$table{$username}}, $uplist[$i];
    18            $i++;     
    19      }
    20  }
    21  close XFERLOG;
    22  
    23  undef %saw;
    24  # @newuser = grep(!$saw{$_}++, @user);
    25  $j=0;
    26  foreach  $username ( sort keys %table )
    27          {
    28          my @mylist = @{$table{$username}};
    29          $m=0;
    30          $totalsize=0;
    31          $totaltime=0;
    32          $gtotal=0;
    33          $x=0;
    34          $x=@mylist;
    35          for ($m = 0 ; $m &lt; ($x); $m++)
    36          {
    37                  ( $seconds, $size, $file, $user, $group) = split(' ', $mylist[$m]);
    38                  $totaltime = ($totaltime + $seconds);
    39                  $totalsize = ($totalsize + $size);
    40          }
    41          if ($totaltime==0) { $totaltime=1; }
    42          if ($totalsize==0) { $totalsize=1; }
    43          $avgtr = (($totalsize/$totaltime)/1024);
    44          $gtotal=($totalsize+$gtotal);
    45          $finale[$j]= join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
    46  #       print $finale[$j];
    47          $j++;
    48  }
    49  @realfinal =  sort @finale;
    50  #print @finale;
    51  $p=0;
    52  $w=0;
    53  $w=@realfinal;
    54  #print $w;
    55  for ($p=($w-1) ; $p&gt;=0; $p--)
    56  {
    57          ($Size, $User, $Files, $Time, $AvgSpeed)= split &quot; &quot;, $realfinal[$p];
    58          $position= ($w-$p);
    59          $percent=(($Size/($gtotal/(1024*1024)))*100);
    60          printf (&quot;$position. $User $Files files &quot;);
    61          printf(&quot;%.2fMB&quot;, $Size) ;
    62          printf &quot; $Time(s) &quot;;
    63          printf (&quot;%.2f% &quot;, $percent);
    64          printf(&quot;%.2fK/s&quot;, $AvgSpeed);
    65          print &quot; &quot;;
    66  }
    67          
</PRE>
<P>
Let's start at the top, with the argument and file handling.

<P>
<PRE>     1  #!/usr/bin/perl
     2  use Getopt::Std;
     3  getopt('dV');
     4  $xferlog=&quot;./xferlog&quot;;
     5  $\ = &quot;\n&quot;;
     6  $i=0;
     7  open XFERLOG, $xferlog or die &quot;Cant't find file $xferlog&quot;;
     8  
     9  foreach $line (&lt;XFERLOG&gt;) {
        ...
    20  }
    21  close XFERLOG;
</PRE>
<P>
The name of the input file is hardwired on line 4. Getting the filename
from the command line is more flexible. We can leave the old filename in
place as a default, retaining compatibility with the original version. I've
also added error handling to the <CODE>getopt</CODE>
argument parsing.

<P>
<PRE> 
       getopt('dV') or die &quot;Usage: $0 [-d] [-V] [filename]\n&quot;;
        @ARGV = ('./xferlog') unless @ARGV;
        while (&lt;&gt;) {
          ...
        }
</PRE>        

<CODE>getopt</CODE> removes the options from
<CODE>@ARGV</CODE>, leaving only the filenames,
if any.  If there weren't any, we put the default filename,
<CODE>/.xferlog</CODE>, into <CODE>@ARGV</CODE> as if the user 
had supplied it themselves.
Since the <code>&lt;&gt;</CODE> operator reads from the files named in 
<CODE>@ARGV</CODE>, it
will read from <CODE>./xferlog</CODE> if no file was specified on the command
line.  Using <CODE>&lt;&gt;</CODE> handles <CODE>open</CODE> errors for us automatically,
and we can omit the <CODE>close</CODE> call because it's already taken care of
for us.  
<P>
Line 5 is superfluous, because <CODE>$\</CODE> already defaults to <CODE>"\n"</CODE>. Line 6 is
superfluous, since <CODE>$i</CODE> would be implicitly initialized to 0,
but it won't matter because we're going to get rid of <CODE>$i</CODE>
anyway.

<P>
I replaced the <CODE>foreach</CODE> loop with a <CODE>while</CODE> loop. The <CODE>foreach</CODE>
loaded the entire file into memory at once, then iterated over the list of
lines.  <CODE>while</CODE> reads one line at a time into <CODE>$_</CODE>, discarding each line after it has been examined. If the input file is
large, this will save a huge amount of memory. If available memory is
small, the original program might have run very slowly because of thrashing
problems; the new program is unlikely to have the same trouble, and might
run many times faster as a result.

<P>
<HR>
<!-- <A NAME="Reading_the_Input">Reading the Input</A> -->
<P>
<PRE>
     9  foreach $line (&lt;XFERLOG&gt;) {
    10        chomp($line);
    11        if (( $line =~ /$opt_d/i) &amp;&amp; ( $line !~ /_ o r/)) 
    12           {
    13           ($Fld1,$Fld2,$Fld3,$Fld4,$Fld5,$Fld6,$Fld7,$Fld8,
               $Fld9,$Fld10,$Fld11,$Fld12,$Fld13,$Fld14,$Fld15) = split(' ',$line);
      
    14            $uplist[$i] = join ' ',$Fld6, $Fld8, $Fld9, $Fld14, $Fld15;
    15            $time[$i]=$Fld6; $size[$i]=$Fld8; $file[$i]=$Fld9; 
               $user[$i]=$Fld14; $group[$i]=$Fld15;
      
    16            $username= join '@', $user[$i], $group[$i];
    17            push @{$table{$username}}, $uplist[$i];
    18            $i++;     
    19      }
    20  }
</PRE>
<P>
Here's my replacement:

<P>
<PRE>        while (&lt;&gt;) {
          chomp;
          if (/$opt_d/oi &amp;&amp;  ! /_ o r/) {
            my @Fld = split;
            my $uplist = {time =&gt; $Fld[5],      size =&gt; $Fld[7],
                          file =&gt; $Fld[8],      user =&gt; $Fld[13],
                          group =&gt; $Fld[14],
                         };
            my $username = &quot;$Fld[13]\@$Fld[14]&quot;;
            push @{$table{$username}}, $uplist;
          }
        }
</PRE>
<P>
Because the current line is in <CODE>$_</CODE> now instead of <CODE>$line</CODE>, we can
use the argumentless versions of <CODE>chomp</CODE> and <CODE>split</CODE> and the unbound version of the pattern match operators, which apply to
<CODE>$_</CODE> by default. I added the <CODE>/o</CODE> option on the first pattern match to tell Perl that <CODE>$opt_d</CODE>
will not change over the lifetime of the program.

<P>
Any time you have a series of variables named <code>$Fld1</code>, <code>$Fld2</code>, etc., it means
you made a mistake, because they should have been in an array. I've
replaced the <code>$Fld1</code>, <code>$Fld2</code>, ... family with a single array, <code>@Fld</code>.

<P>
<CODE>$uplist</CODE> was a problem before. It's a large string continaing
several fields. Later on, the program would have had to split this string
to get at the various fields; this is a waste of time because we have the
fields already split up right here and there's no point in joining them
just to split them up again later. Instead of turning the relevant fields
into a string, I've put them into an anonymous hash, indexed by key, so
that the filename is in $uplist-&gt;{file} instead of the third section of
a whitespace separated string.

<P>
This way of doing things is not only faster, it's more robust. If the input
file format changes so that a filename might contain space characters, we
only need to change the initial <CODE>split</CODE> that parses the input data itself. The original version of the program
would have needed to have the <CODE>join</CODE> changed also, as well as the later <CODE>split</CODE>
the re-separated the data. Storing the fields in a hash eliminates this
problem entirely.

<P>
I also eliminated the superfluous <code>@time</code>, 
<code>@size</code>, <code>@user</code>, <code>@group</code>, and
<CODE>@uplist</CODE> arrays. They were never used. Packaging all the
relevant data into a single hash obviates any possible use of these arrays
anyway. Because all the arrays have gone away, we no longer need the index
variable <code>$i</code>. Such a variable, which exists only to allow data to be added
to the end of an array, is rarely needed in Perl. It is almost always
preferable to use <CODE>push</CODE>. The <CODE>push</CODE> line itself is essentially the same.

<P>
<HR>
<!-- <A NAME="Computing_Average_and_Total_Time">Computing Average and Total Times</A> -->
<P>
This next section is way too long:

<P>
<PRE>
    23  undef %saw;
    24  # @newuser = grep(!$saw{$_}++, @user);
    25  $j=0;
    26  foreach  $username ( sort keys %table )
    27          {
    28          my @mylist = @{$table{$username}};
    29          $m=0;
    30          $totalsize=0;
    31          $totaltime=0;
    32          $gtotal=0;
    33          $x=0;
    34          $x=@mylist;
    35          for ($m = 0 ; $m &lt; ($x); $m++)
    36          {
    37                  ( $seconds, $size, $file, $user, $group) = split(' ', $mylist[$m]);
    38                  $totaltime = ($totaltime + $seconds);
    39                  $totalsize = ($totalsize + $size);
    40          }
    41          if ($totaltime==0) { $totaltime=1; }
    42          if ($totalsize==0) { $totalsize=1; }
    43          $avgtr = (($totalsize/$totaltime)/1024);
    44          $gtotal=($totalsize+$gtotal);
    45          $finale[$j]= join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
    46  #       print $finale[$j];
    47          $j++;
    48  }
</PRE>
<P>
26 lines is too much for one block. A 26-line block should be rewritten if
possible, and if not, its guts should be scooped out and made into a
subroutine.

<P>
We can reduce this to about fifteen lines, so I won't use a subroutine
here. A lot of that reduction is simply elimination of unnecessary code. We
can scrap lines 23 and 24, which are never used. Line 25 is an unnecessary
initialization of <CODE>$j</CODE> whose only purpose is to track the length
of the <CODE>@finale</CODE> array; we can eliminate <code>$j</code>
entirely by changing this:

<P>
<PRE>    45          $finale[$j]= join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
    46  #       print $finale[$j];
    47          $j++;
</PRE>
<P>
to say this instead:

<P>
<PRE>        push @finale, join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
        # print $finale[-1];
</PRE>
<P>
Now let's work on that inner loop:

<P>
<PRE>    35          for ($m = 0 ; $m &lt; ($x); $m++)
    36          {
    37                  ( $seconds, $size, $file, $user, $group) = split(' ', $mylist[$m]);
    38                  $totaltime = ($totaltime + $seconds);
    39                  $totalsize = ($totalsize + $size);
    40          }
</PRE>
<P>
Any time you have a C-like <CODE>for</CODE> loop that loops over the indices of an array, you're probably making a
mistake. Perl has a <CODE>foreach</CODE>
construction that iterates over an array in a much simpler way:

<P>
<PRE>        for $item (@{$table{$username}}) {
          $totaltime += $item-&gt;{time};
          $totalsize += $item-&gt;{size};
        }
</PRE>
<P>
Here we reap the benefit of the anonymous hash introduced above. To get the
time and size we need only extract the hash values <CODE>time</CODE> and
<CODE>size</CODE>. In the original code, we had to do another <CODE>split</CODE>.

<P>
This allows us to eliminate the superfluous variables <code>$m</code>, <CODE>$x</CODE>
and <code>@mylist</code>, so we can remove lines 28, 29, 33, and 34. We've also used the
<code>+=</code> operator here to save extra mentions of the variable names on the
right-hand side of the <code>=</code>.

<P>
The modified code now looks like:

<P>
<PRE>
        foreach  $username ( sort keys %table ) {
          $totalsize=0;
          $totaltime=0;
          $gtotal=0;
          for $item (@{$table{$username}}) {
            $totaltime += $item-&gt;{time};
            $totalsize += $item-&gt;{size};
          }
          if ($totaltime==0) { $totaltime=1; }
          if ($totalsize==0) { $totalsize=1; }
          $avgtr = (($totalsize/$totaltime)/1024);
          $gtotal=($totalsize+$gtotal);

          push @finale, join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
          #     print $finale[-1];
        }
</PRE>
<P>
This is already only half as large. But we can make it smaller and cleaner
yet. <CODE>$totalsize</CODE> and <CODE>$totaltime</CODE> are related, so
they should go on the same line. <CODE>$gtotal</CODE> is incorrectly set to
0 here. It is a grand total size of all the files downloaded, and any
initialization of it should be <EM>outside</EM> the loop. The check for <CODE>$totaltime==0</CODE>
is to prevent a divide-by-zero error in the computation of <code>$avgtr</code>, but no
such computation is performed for <code>$totalsize</code>, so the corresponding check is
wasted and should be eliminated:

<P>
<PRE>
        my  $gtotal=0;

        foreach  $username ( sort keys %table ) {
          my ($totalsize, $totaltime) = (0, 0);
          for $item (@{$table{$username}}) {
            $totaltime += $item-&gt;{time};
            $totalsize += $item-&gt;{size};
          }
          if ($totaltime==0) { $totaltime=1; }
          $avgtr = ($totalsize/$totaltime)/1024;
          $gtotal += $totalsize;
          push @finale, join ' ', ($totalsize/(1024*1024)), $username, ($x), $totaltime, $avgtr;
          #     print $finale[-1];
        }
</PRE>
<P>
For the computation of <code>$avgtr</code>, we can do better. The previous line has a
special case for when <CODE>$totaltime</CODE> is zero and the average is
undefined. In this case, <CODE>$avgtr</CODE> is set to an arbitrary and
bizarre value; if we sort by <CODE>$avgtr</CODE> later, these arbitrary
values will appear scattered throughout the rest of the data. It's better
to handle this exceptional condition explicitly, by replacing

<P>
<PRE>
          if ($totaltime==0) { $totaltime=1; }
          $avgtr = ($totalsize/$totaltime)/1024;
</PRE>
<P>
with

<P>
<PRE>
          if ($totaltime==0) { $avgtr = '---' }
          else { $avgtr = ($totalsize/$totaltime)/1024 }
</PRE>
<P>
Finally, the <CODE>join</CODE> here is committing the same error as the one we eliminated before. There's
no point in <CODE>join</CODE>ing when we're just going to have to <CODE>split</CODE> it again later anyway; the data are separate now so we might as well keep
them separate. The solution is similar; instead of joining the five data
items into a string, we parcel them into an anonymous hash so that we can
extract them by name when we need to. The final version of the loop looks
like this:

<P>
<PRE>
        foreach  $username ( sort keys %table ) {
          my ($totalsize, $totaltime) = (0, 0);
          for $item (@{$table{$username}}) {
            $totaltime += $item-&gt;{time};
            $totalsize += $item-&gt;{size};
          }

          if ($totaltime==0) { $avgtr = '---' } 
          else { $avgtr = ($totalsize/$totaltime)/1024 }
          $gtotal += $totalsize;

          push @finale, {size =&gt; $totalsize/(1024*1024),
                         username =&gt; $username, 
                         num_items =&gt; scalar @{$table{$username}}, 
                         totaltime =&gt; $totaltime,
                         avgtr =&gt; $avgtr,
                        };
          #     print $finale[-1];
        }
</PRE>
<P>
<HR>
<H2><A NAME="Sort_Order">Sort Order</A></H2>
<P>
Line 49 is the one that I was originally asked to change:

<P>
<PRE>    49  @realfinal =  sort @finale;
</PRE>
<P>
Now that <CODE>@finale</CODE> contains structured records, the change is
straightforward:

<P>
<PRE>        @realfinal = sort {$a-&gt;{size} &lt;=&gt; $b-&gt;{size}} @finale;
</PRE>
<P>
If you want to sort the final report by username instead, it's equally
straightforward: <CODE>@realfinal = sort {$a-&gt;{username}
cmp $b-&gt;{username}} @finale;</code>

<P>
<HR>
<H2><A NAME="Printing_the_Report">Printing the Report</A></H2>
<P>
Now we're into the home stretch:

<P>
<PRE>
    51  $p=0;
    52  $w=0;
    53  $w=@realfinal;
    54  #print $w;
    55  for ($p=($w-1) ; $p&gt;=0; $p--)
    56  {
    57          ($Size, $User, $Files, $Time, $AvgSpeed)= split &quot; &quot;, $realfinal[$p];
    58          $position= ($w-$p);
    59          $percent=(($Size/($gtotal/(1024*1024)))*100);
    60          printf (&quot;$position. $User $Files files &quot;);
    61          printf(&quot;%.2fMB&quot;, $Size) ;
    62          printf &quot; $Time(s) &quot;;
    63          printf (&quot;%.2f% &quot;, $percent);
    64          printf(&quot;%.2fK/s&quot;, $AvgSpeed);
    65          print &quot; &quot;;
    66  }
    67          
</PRE>
<P>
Here we have another C-style <CODE>for</CODE> loop that should be replaced by a simple <CODE>foreach</CODE> loop; this allows us to eliminate <CODE>$p</CODE> and <code>$w</code>. We can loop over
the reversed list if we want, or simply adjust the <CODE>sort</CODE> line above so that the items are sorted into the right (reversed) order to
begin with, which is probably better.

<P>
The percentage here is the only place in the program that we use <code>$gtotal</code>,
which needs to be converted to megabytes to match the <CODE>size</CODE>
fields in <code>@realfinal</code>. We may as well do this conversion up front. Making
these changes, and eliminating the <CODE>split</CODE> because the <CODE>@realfinal</CODE> data is structured, yields:

<P>
<PRE>
        $gtotal /= (1024*1024);  # In megabytes
        #print @finale;
        my $position = 1;
        for $user (@realfinal) {
                printf (&quot;$position. $user-&gt;{username} $user-&gt;{num_items} files &quot;);
                printf(&quot;%.2fMB&quot;, $user-&gt;{size}) ;
                printf &quot; $user-&gt;{totaltime}(s) &quot;;
                printf (&quot;%.2f% &quot;, ($user-&gt;{size}/$gtotal)*100); # percentage
                printf(&quot;%.2fK/s&quot;, $user-&gt;{avgtr});
                print &quot;\n&quot;;
                ++$position;
        }
</PRE>
<P>
It's probably a little cleaner to merge the many <CODE>printf</CODE>s into a single print;
another upside of this is that it's easier to see
what the format of the output will be:

<P>
<PRE>
        $gtotal /= (1024*1024);  # In megabytes
        #print @finale;
        my $position = 1;
        for $user (@realfinal) {
          printf (&quot;%d. %s %s files %.2fMB %.2f%% %.2fK/s\n&quot; , 
            $position, $user-&gt;{username}, $user-&gt;{num_items}        
            $user-&gt;{size}, ($user-&gt;{size}/$gtotal)*100, $user-&gt;{avgtr}
          );
          ++$position;
        }
</PRE>
<P>
That's enough. The new program is 33 lines long, not counting comments,
blank lines, and lines that have only a close brace. The original program
was 51 lines, so we've reduced the length of the program by more than
one-third. The original program had 41 scalar variables, 8 arrays, and 2
hashes, for a total of 51 named variables. The new program has 11 scalars,
3 arrays, and 1 hash, for a total of 14; we have eliminated more than
two-thirds of the variables. 15 of these were the silly <CODE>$Fld3</CODE>
variables, and another 22 weren't.

<P>
<HR>
<H1><A NAME="Red_Flags">Red Flags</A></H1>
<P>
A red flag is a warning sign that something is wrong. When you see a red
flag, you should immediately consider whether you have an opportunity to
make the code cleaner. I liked this program because it raised many red
flags:

<P>
<HR>
<H2><A NAME="Get_Rid_of_Array_Size_Variables">Get Rid of Array Size Variables</A></H2>
<P>
A variable whose only purpose is to track the number of items in an array
is a red flag; it should usually be eliminated. For example:

<P>
<PRE>
        while (...) {
          $array[$n] = SOMETHING;
          ++$n;
        }
</PRE>
<P>
should be replaced with

<P>
<PRE>
        while (...) {
          push @array, SOMETHING;
        }
</PRE>
<P>
eliminating <code>$n</code>.  

<P>
Notice that although the <CODE>$position</CODE> variable in the final
version of the program looks like it might be an index variable, it
actually serves a more important purpose than that: It appears in the final
output as a ranking.

<P>
<HR>
<H2><A NAME="Use_Compound_Data_Structures_Ins">Use Compound Data Structures Instead of Variable Families</A></H2>
<P>
A series of variables named <code>$f1</code>, <code>$f2</code>, etc., should always be replaced with
an array. For example:

<P>
<PRE>    ($Fld1,$Fld2,$Fld3,$Fld4,$Fld5,$Fld6) = split(' ',$line);
</PRE>
<P>
should be replaced with

<P>
<PRE>
    @Fld = split(' ',$line);
</PRE>
<P>
A similar statement can be made about hashes. If you have <CODE>$user_name</code>,
<code>$user_weight</code>, and <code>$user_login_date</code>, consider using one structure called
<CODE>%user</CODE> with keys <CODE>name</CODE>, <CODE>weight</CODE>, and <CODE>login_date</CODE>.

<P>
<HR>
<H2><A NAME="Use_C_foreach_to_Loop_Over_Arra">Use <code>foreach</code> to Loop Over Arrays</A></H2>
<P>
C-style <CODE>for</CODE> loops should be avoided. In particular,

<P>
<PRE>
        for ($i=0; $i &lt; @array; $i++) {
          SOMETHING($array[$i]);
        }
</PRE>
<P>
should be replaced with 

<P>
<PRE>
        foreach $item (@array) {
          SOMETHING($item);
        }
</PRE>
</BODY>

</HTML>
