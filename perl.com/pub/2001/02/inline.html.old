<h3>Pathologically Polluting Perl</h3>

<br />
<!::field::date::>
<p><table width="180" cellspacing="0" cellpadding="4" align="right" border="1">
<tr>
<td align="center" valign="top" bgcolor="#6699cc">
<font color="#ffffff">Table of Contents</td>
</tr>

<tr>
<td>
<p class="fine">
&#149;<a href="#inline in action  simple examples in c">Inline in Action - Simple examples in C</a><br />
&#149;<a href="#hello, world">Hello, world</a><br />
&#149;<a href="#just another ____ hacker">Just Another ____ Hacker</a><br />
&#149;<a href="#what about xs and swig">What about XS and SWIG?</a><br />
&#149;<a href="#oneliners">One-Liners</a><br />
&#149;<a href="#supported platforms for c">Supported Platforms for C</a><br />
&#149;<a href="#the inline syntax">The Inline Syntax</a><br />
&#149;<a href="#fine dining  a glimpse at the c cookbook">Fine Dining - A Glimpse at the C Cookbook</a><br />
&#149;<a href="#external libraries">External Libraries</a><br />
&#149;<a href="#it takes all types">It Takes All Types</a><br />
&#149;<a href="#some ware beyond the c">Some Ware Beyond the C</a><br />
&#149;<a href="#see perl run. run perl, run!">See Perl Run. Run, Perl, Run!</a><br />
&#149;<a href="#the future of inline">The Future of Inline</a><br />
&#149;<a href="#conclusion">Conclusion</a><br />
</td>
</tr>
</p>
</table>

<p>No programming language is Perfect. Perl comes very close. <strong>P</strong>! <strong>e</strong>! <strong>r</strong>! <em>l</em>? :-( Not quite ``Perfect''. Sometimes it just makes sense to use another language for part of your work. You might have a stable, pre-existing code base to take advantage of. Perhaps maximum performance is the issue. Maybe you just ``know how to do it'' that way. Or very likely, it's a project requirement forced upon you by management. Whatever the reason, wouldn't it be great to use Perl most of the time, but be able to invoke something else when you had to?</p>

<p><code>Inline.pm</code> is a new module that glues other programming languages to Perl. It allows you to write C, C++, and Python code directly inside your Perl scripts and modules. This is conceptually similar to the way you can write inline assembly language in C programs. Thus the name: <code>Inline.pm</code>.</p>

<p>The basic philosophy behind Inline is this: ``make it as easy as possible to use Perl with other programming languages, while ensuring that the user's experience retains the DWIMity of Perl''. To accomplish this, Inline must do away with nuisances such as interface definition languages, makefiles, build directories and compiling. You simply write your code and run it. Just like Perl.</p>

<p>Inline will silently take care of all the messy implementation details and ``do the right thing''. It analyzes your code, compiles it if necessary, creates the correct Perl bindings, loads everything up, and runs the whole schmear. The net effect of this is you can now write functions, subroutines, classes, and methods in another language and call them as if they were Perl.</p>

<h3><a name="inline in action  simple examples in c">Inline in Action - Simple examples in C</a></h3>
<p>Inline addresses an old problem in a completely revolutionary way. Just describing Inline doesn't really do it justice. It should be <em>seen</em> to be fully appreciated. Here are a couple examples to give you a feel for the module.</p>
<p>
<h3><a name="hello, world">Hello, world</a></h3>
<p>It seems that the first thing any programmer wants to do when he learns a new programming technique is to use it to greet the Earth. In keeping with that tradition, here is the ``Hello, world'' program using Inline.</p>
<pre>
    use Inline C =&gt; &lt;&lt;'END_C';
    void greet() {
        printf(&quot;Hello, world\n&quot;);
    }
    END_C</pre>
<pre>
    greet;</pre>
<p>Simply run this script from the command line and it will print (you guessed it):</p>
<pre>
    Hello, world</pre>
<p>In this example, <code>Inline.pm</code> is instantiated with the name of a programming language, ``C'', and a string containing a piece of that language's source code. This C code defines a function called <code>greet()</code> which gets bound to the Perl subroutine <code>&amp;main::greet</code>. Therefore, when we call the <code>greet()</code> subroutine, the program prints our message on the screen.</p>
<p>You may be wondering why there are no <code>#include</code> statements for things like <code>stdio.h</code>? That's because Inline::C automatically prepends the following lines to the top of your code:</p>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #include &quot;INLINE.h&quot;</pre>
<p>These header files include all of the standard system header files, so you almost never need to use <code>#include</code> unless you are dealing with a non-standard library. This is in keeping with Inline's philosophy of making easy things easy. (Where have I heard that before?)</p>
<p>
<h3><a name="just another ____ hacker">Just Another ____ Hacker</a></h3>
<p>The next logical question is, ``How do I pass data back and forth between Perl and C?'' In this example we'll pass a string to a C function and have it pass back a brand new Perl scalar.</p>
<pre>
    use Inline C;
    print JAxH('Perl');
</pre>
<pre>

    __END__
    __C__
    SV* JAxH(char* x) {
        return newSVpvf(&quot;Just Another %s Hacker\n&quot;, x);
    }</pre>
<p>When you run this program, it prints:</p>
<pre>
    Just Another Perl Hacker</pre>
<p>You've probably noticed that this example is coded differently then the last one. The <code>use Inline</code> statement specifies the language being used, but not the source code. This is an indicator for Inline to look for the source at the end of the program, after the special marker '<code>__C__</code>'.</p>
<p>The concept being demonstrated is that we can pass Perl data in and out of a C function. Using the default Perl type conversions, Inline can easily convert all of the basic Perl data types to C and vice-versa.</p>
<p>This example uses a couple of the more advanced concepts of Inlining. Its return value is of the type <code>SV*</code> (or Scalar Value). The Scalar Value is the most common Perl internal type. Also, the Perl internal function <code>newSVpfv()</code> is called to create a new Scalar Value from a string, using the familiar <code>sprintf()</code> syntax. You can learn more about simple Perl internals by reading the <code>perlguts</code> and <code>perlapi</code> documentation distributed with Perl.</p>

<h3><a name="what about xs and swig">What about XS and SWIG?</a></h3>
<p>Let's detour momentarily to ponder ``Why Inline?''</p>
<p>There are already two major facilities for extending Perl with C. They are XS and SWIG. Both are similar in their capabilities, at least as far as Perl is concerned. And both of them are quite difficult to learn compared to Inline. Since SWIG isn't used in practice to nearly the degree that XS is, I'll only address XS.</p>
<p>There is a big fat learning curve involved with setting up and using the XS environment. You need to get quite intimate with the following docs:</p>
<pre>
 * perlxs
 * perlxstut
 * perlapi
 * perlguts
 * perlcall
 * perlmod
 * h2xs
 * xsubpp
 * ExtUtils::MakeMaker</pre>
<p>With Inline you can be up and running in minutes. There is a C Cookbook with lots of short but complete programs that you can extend to your real-life problems. No need to learn about the complicated build process going on in the background. You don't even need to compile the code yourself. Perl programmers cannot be bothered with silly things like compiling. ``Tweak, Run, Tweak, Run'' is our way of life. Inline takes care of every last detail except writing the C code.</p>
<p>Another advantage of Inline is that you can use it directly in a script. As we'll soon see, you can even use it in a Perl one-liner. With XS and SWIG, you always set up an entirely separate module, even if you only have one or two functions. Inline makes easy things easy, and hard things possible. Just like Perl.</p>
<p>Finally, Inline supports several programming languages (not just C and C++). As of this writing, Inline has support for C, C++, Python, and CPR. There are plans to add many more.</p>

<h3><a name="oneliners">One-Liners</a></h3>
<p>Perl is famous for its one-liners. A Perl one-liner is short piece of Perl code that can accomplish a task that would take much longer in another language. It is one of the popular techniques that Perl hackers use to flex their programming muscles.</p>
<p>So you may wonder: ``Is Inline powerful enough to produce a one-liner that is also bonifide C extension?'' Of course it is! Here you go:</p>
<pre>
    perl -e 'use Inline C=&gt;
	q{void J(){printf(&quot;Just Another Perl Hacker\n&quot;);}};J'</pre>
<p>Try doing that with XS! We can even write the more complex Inline <code>JAxH()</code> discussed earlier as a one-liner:</p>
<pre>
    perl -le 'use Inline C=&gt;
	q{SV*JAxH(char*x){return newSVpvf(&quot;Just Another %s Hacker&quot;,x);}};print JAxH+Perl'</pre>
<p>I have been using this one-liner as my email signature for the past couple months. I thought it was pretty cool until Bernhard Muenzer posted this gem to <code>comp.lang.perl.modules</code>:</p>
<pre>
    #!/usr/bin/perl -- -* Nie wieder Nachtschicht! *- -- lrep\nib\rsu\!#
    use Inline C=&gt;'void C(){int m,u,e=0;float l,_,I;for(;1840-e;putchar((++e&gt;907
     &amp;&amp;942&gt;e?61-m:u)[&quot;\n)moc.isc@rezneumb(rezneuM drahnreB&quot;]))for(u=_=l=0;79-(m
      =e%80)&amp;&amp;I*l+_*_&lt;6&amp;&amp;26-++u;_=2*l*_+e/80*.09-1,l=I)I=l*l-_*_-2+m/27.;}';&amp;C</pre>

<h3><a name="supported platforms for c">Supported Platforms for C</a></h3>
<p>Inline C works on all of the Perl platforms that I have tested it with so far. This includes all common Unixes and recent versions of Microsoft Windows. The only catch is that you must have the same compiler and <code>make</code> utility that was used to build your <code>perl</code> binary.</p>
<p>Inline has been successfully used on Linux, Solaris, AIX, HPUX, and all the recent BSD's.</p>
<p>There are two common ways to use Inline on MS Windows. The first one is with ActiveState's ActivePerl for MSWin32. In order to use Inline in that environment, you'll need a copy of MS Visual C++ 6.0. This comes with the <code>cl.exe</code> compiler and the <code>nmake</code> make utility. Actually these are the only parts you need. The visual components aren't necessary for Inline.</p>
<p>The other alternative is to use the Cygwin utilities. This is an actual Unix porting layer for Windows. It includes all of the most common Unix utilities, such as <code>bash</code>, <code>less</code>, <code>make</code>, <code>gcc</code> and of course <code>perl</code>.</p>

<h3><a name="the inline syntax">The Inline Syntax</a></h3>
<p>Inline is a little bit different than most of the Perl modules that you are used to. It doesn't import any functions into your namespace and it doesn't have any object oriented methods. Its entire interface is specified through <code>'use Inline ...'</code> commands. The general Inline usage is:</p>
<pre>
    use Inline C =&gt; source-code,
               config_option =&gt; value,
               config_option =&gt; value;</pre>
<p>Where <code>C</code> is the programming language, and <code>source-code</code> is a string, filename, or the keyword '<code>DATA</code>'. You can follow that with any number of optional '<code>keyword =&gt; value</code>' configuration pairs. If you are using the 'DATA' option, with no configuration parameters, you can just say:</p>
<pre>
    use Inline C;</pre>

<h3><a name="fine dining  a glimpse at the c cookbook">Fine Dining - A Glimpse at the C Cookbook</a></h3>
<p>In the spirit of the O'Reilly book ``Perl Cookbook'', Inline provides a manpage called C-Cookbook. In it you will find the recipes you need to help satisfy your Inline cravings. Here are a couple of tasty morsels that you can whip up in no time. Bon Appetit!</p>
<p>
<h3><a name="external libraries">External Libraries</a></h3>
<p>The most common real world need for Inline is probably using it to access existing compiled C code from Perl. This is easy to do. The secret is to write a wrapper function for each function you want to expose in Perl space. The wrapper calls the real function. It also handles how the arguments get passed in and out. Here is a short Windows example that displays a text box with a message, a caption and an ``OK'' button:</p>
<pre>
    use Inline C =&gt; DATA =&gt;
               LIBS =&gt; '-luser32',
               PREFIX =&gt; 'my_';</pre>
<pre>
    MessageBoxA('Inline Message Box', 'Just Another Perl Hacker');
</pre>
<pre>

    __END__
    __C__
    #include &lt;windows.h&gt;
    int my_MessageBoxA(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }</pre>
<p>This program calls a function from the MSWin32 <code>user32.dll</code> library. The wrapper determines the type and order of arguments to be passed from Perl. Even though the real <code>MessageBoxA()</code> needs four arguments, we can expose it to Perl with only two, and we can change the order. In order to avoid namespace conflicts in C, the wrapper must have a different name. But by using the <code>PREFIX</code> option (same as the XS <code>PREFIX</code> option) we can bind it to the original name in Perl.</p>

<h3><a name="it takes all types">It Takes All Types</a></h3>
<p>Older versions of Inline only supported five C data types. These were: <code>int</code>, <code>long</code>, <code>double</code>, <code>char*</code> and <code>SV*</code>. This was all you needed. All the basic Perl scalar types are represented by these. Fancier things like references could be handled by using the generic <code>SV*</code> (scalar value) type, and then doing the mapping code yourself, inside the C function.</p>
<p>The process of converting between Perl's <code>SV*</code> and C types is called <strong>typemapping</strong>. In XS, you normally do this by using <code>typemap</code> files. A default <code>typemap</code> file exists in every Perl installation in a file called <code>/usr/lib/perl5/5.6.0/ExtUtils/typemap</code> or something similar. This file contains conversion code for over 20 different C types, including all of the Inline defaults.</p>
<p>As of version 0.30, Inline no longer has <em>any</em> built in types. It gets all of its types exclusively from <code>typemap</code> files. Since it uses Perl's default <code>typemap</code> file for its own defaults, it actually has many more types available automatically.</p>
<p>This setup provides a lot of flexibility. You can specify your own <code>typemap</code> files through the use of the <code>TYPEMAPS</code> configuration option. This not only allows you to override the defaults with your own conversion code, but it also means that you can add new types to Inline as well. The major advantage to extending the Inline syntax this way is that there are already many typemaps available for various APIs. And if you've done your own XS coding in the past, you can use your existing <code>typemap</code> files as is. No changes are required.</p>
<p>Let's look at a small example of writing your own typemaps. For some reason, the C type <code>float</code> is not represented in the default Perl <code>typemap</code> file. I suppose it's because Perl's floating point numbers are always stored as type <code>double</code>, which is higher precision than <code>float</code>. But if we wanted it anyway, writing a <code>typemap</code> file to support <code>float</code> is trivial.</p>
<p>Here is what the file would look like:</p>
<pre>
    float                   T_FLOAT
</pre>
<pre>

    INPUT
    T_FLOAT
            $var = (float)SvNV($arg)</pre>
<pre>

    OUTPUT
    T_FLOAT
            sv_setnv($arg, (double)$var);</pre>
<p>Without going into details, this file provides two snippets of code. One for converting a <code>SV*</code> to a float, and one for the opposite. Now we can write the following script:</p>
<pre>
    use Inline C =&gt; DATA =&gt;
               TYPEMAPS =&gt; './typemap';
</pre>
<pre>

    print '1.2 + 3.4 = ', fadd(1.2, 3.4), &quot;\n&quot;;</pre>
<pre>

    __END__
    __C__
    float fadd(float x, float y) {
        return x + y;
    }</pre>

<h3><a name="some ware beyond the c">Some Ware Beyond the C</a></h3>
<p>The primary goal of Inline is to make it easy to use other programming languages with Perl. This is not limited to C. The initial implementations of Inline only supported C, and the language support was built directly into <code>Inline.pm</code>. Since then things have changed considerably. Inline now supports multiple languages of both compiled and interpreted nature. And it keeps the implementations in an object oriented type structure, whereby each language has its own separate module, but they can inherit behavior from the base Inline module.</p>
<p>On my second day working at ActiveState, a young man approached me. ``Hi, my name is Neil Watkiss. I just hacked your Inline module to work with C++.''</p>
<p>Neil, I soon found out, was a computer science student at a local university. He was working part-time for ActiveState then, and had somehow stumbled across Inline. I was thrilled! I had wanted to pursue new languages, but didn't know how I'd find the time. Now I was sitting 15 feet away from my answer!</p>
<p>Over the next couple months, Neil and I spent our spare time turning Inline into a generic environment for gluing new languages to Perl. I ripped all the C specific code out of Inline and put it into Inline::C. Neil started putting together Inline::CPP and Inline::Python. Together we came up with a new syntax that allowed multiple languages and easier configuration.</p>
<p>Here is a sample program that makes uses of Inline Python:</p>
<pre>
    use Inline Python;
    my $language = shift;
    print $language, 
          (match($language, 'Perl') ? ' rules' : ' sucks'),
          &quot;!\n&quot;;
    __END__
    __Python__
    import sys
    import re
    def match(str, regex):
        f = re.compile(regex);
        if f.match(str): return 1
        return 0</pre>
<p>This program uses a Python regex to show that ``Perl rules!''.</p>
<p>Since Python supports its own versions of Perl scalars, arrays, and hashes, Inline::Python can flip-flop between them easily and logically. If you pass a hash reference to python, it will turn it into a dictionary, and vice-versa. Neil even has mechanisms for calling back to Perl from Python code. See the Inline::Python docs for more info.</p>

<h3><a name="see perl run. run perl, run!">See Perl Run. Run Perl, Run!</a></h3>
<p>Inline is a great way to write C extensions for Perl. But is there an equally simple way to embed a Perl interpreter in a C program? I pondered this question myself one day. Writing Inline functionality for C would not be my cup of tea.</p>
<p>The normal way to embed Perl into C involves jumping through a lot of hoops to bootstrap a perl interpreter. Too messy for one-liners. And you need to compile the C. Not very Inlinish. But what if you could pass your C program to a perl program that could pass it to Inline? Then you could write this program:</p>
<pre>
    #!/usr/bin/cpr
    int main(void) {
        printf(&quot;Hello, world\n&quot;);
    }</pre>
<p>and just run it from the command line. Interpreted C!</p>
<p>And thus, a new programming language was born. <strong>CPR</strong>. ``C Perl Run''. The Perl module that gives it life is called <code>Inline::CPR</code>.</p>
<p>Of course, CPR is not really its own language, in the strict sense. But you can think of it that way. CPR is just like C except that you can call out to the Perl5 API at any time, without any extra code. In fact, CPR redefines this API with its own CPR wrapper API.</p>
<p>There are several ways to think of CPR: ``a new language'', ``an easy way to embed Perl in C'', or just ``a cute hack''. I lean towards the latter. CPR is probably a far stretch from meeting most peoples embedding needs. But at the same time its a very easy way to play around with, and perhaps redefine, the Perl5 internal API. The best compliment I've gotten for CPR is when my ActiveState coworker Adam Turoff said, ``I feel like my head has just been wrapped around a brick''. I hope this next example makes you feel that way too:</p>
<pre>
    #!/usr/bin/cpr
    int main(void) {
        CPR_eval(&quot;use Inline (C =&gt; q{
            char* greet() {
                return \&quot;Hello world\&quot;;
            }
        })&quot;);</pre>
<pre>
        printf(&quot;%s, I'm running under Perl version %s\n&quot;,
               CPR_eval(&quot;&amp;greet&quot;),
               CPR_eval(&quot;use Config; $Config{version}&quot;));
        return 0;
    }</pre>
<p>Running this program prints:</p>
<pre>
    Hello world, I'm running under Perl version 5.6.0</pre>
<p>Using the <code>eval()</code> call this CPR program calls Perl and tells it to use Inline C to add a new function, which the CPR program subsequently calls. I think I have a headache myself.</p>

<h3><a name="the future of inline">The Future of Inline</a></h3>
<p>Inline version 0.30 was written specifically so that it would be easy for other people in the Perl community to contribute new language bindings for Perl. On the day of that release, I announced the birth of the Inline mailing list, <a href="mailto:inline@perl.org.">inline@perl.org.</a> This is intended to be the primary forum for discussion on all Inline issues, including the proposal of new features, and the authoring of new ILSMs.</p>
<p>In the year 2001, I would like to see bindings for Java, Ruby, Fortran and Bash. I don't plan on authoring all of these myself. But I may kickstart some of them, and see if anyone's interested in taking over. If <em>you</em> have a desire to get involved with Inline development, please join the mailing list (<a href="mailto:inline-subscribe@perl.org">inline-subscribe@perl.org</a>) and speak up.</p>
<p>My primary focus at the present time, is to make the base Inline module as simple, flexible, and stable as possible. Also I want to see Inline::C become an acceptable replacement for XS; at least for most situations.</p>

<h3><a name="conclusion">Conclusion</a></h3>
<p>Using XS is just too hard. At least when you compare it to the rest of the Perl we know and love. Inline takes advantage of the existing frameworks for combining Perl and C, and packages it all up into one easy to swallow pill. As an added bonus, it provides a great framework for binding other programming languages to Perl. You might say, ``It's a 'Perl-fect' solution!''</p>


