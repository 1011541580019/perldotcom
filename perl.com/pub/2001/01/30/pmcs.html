<!--CS_PAGE_BREAK-->

<p>One of the best things about Parrot is that it's not just for Perl
implementors. Parrot 0.0.3 came with support for extensible data types
that can be used to implement the types used in your favorite language.
The mechanism by which these types are extensible is called the <b>PMC</b>.</p>
<p>The PMC, or Parrot Magic Cookie, type is a special data container for
user-defined data types. Because these user-defined types are
essentially implementations of a set of methods, we refer to them as PMC
classes. Currently, the legal PMC classes are the <code>PerlInt</code>,
<code>PerlNum</code>, <code>PerlString</code>, <code>PerlArray</code>, and <code>PerlHash</code> types. The
<code>PerlInt</code>, <code>PerlNum</code> and <code>PerlString</code> data types combine to form the
PerlScalar data type.</p>



<p>PMC registers, unlike the basic Integer, Number, and String registers,
must be specially allocated with the <code>new P0, PMCType</code> instruction.
Other operations like <code>set P0,5</code> are handled by special functions that are implemented by the PMC class. The rest of this article is about how
to create your own PMC class implementation, alongside the <code>PerlInt</code> and
<code>PerlHash</code> data types.</p>

<p>For our example, we're going to implement a simple queue data
structure. Our queue will be a set of integers; the queue will grow when
an integer is assigned to it, and will shrink when an integer is read
from it. We'll use the <code>PerlInt</code> class as a basis, so it may be helpful
to look at some examples of operations that use it:</p>
<pre>
  new P0, PerlInt  # Create a new PMC in the 'PerlInt' class
  set P0, 1234     # Set the value of the PMC to 1234
  set P0, &quot;4567&quot;   # Set the value of the PMC to 4567
  set P0, 12.34    # Set the value of the PMC to 12
  set I0, P0       # Set I0 to the current value of the PMC
  print P0
  print &quot;n&quot;</pre>
<p>Note that no special instructions like <code>set_string</code> or <code>set_float</code>
were required to assign data of different types to the PMC. Each
instruction does the Right Thing given the initial type of the PMC. This
has several important consequences when designing new data types, the
largest of which is that it generally isn't necessary to add special
instructions to access data contained within a PMC.</p>
<p>On the other side, this means that PMCs should attempt to behave
rationally in all situations. It's not an onerous requirement, but in
some cases, rational behavior is hard to define. Queues are fairly
simple to define though, in terms of behavior. A queue has one way to
get data in and one way to get data out.</p>
<p>Since we can use one instruction for multiple classes, we'll use <code>set Pn,In</code> 
to add an integer to the queue, and <code>set In,Pn</code> to get an
element out of the queue. The last operation we need to perform on a
queue is to determine whether the queue is empty. The PerlArray class uses
<code>set In,Pn</code> to return the length of the array into <code>In</code>, but we've
already decided to use that to get an integer out of the queue.</p>
<p>Instead of <code>set In,Pn</code> to determine how many elements are in the queue,
all we really need to know is whether the queue is empty or in use. For that,
we can use the handy boolean operator, <code>if Pn,In</code>. Here, the integer
register is actually the number of instructions to skip over if the
condition is true. We'll have it branch if the queue is empty.</p>
<p>So, our <code>IntQueue</code> data type will implement three instructions. First, the <code>set Pn,In</code> instruction will add an integer to the queue.
Second, when the queue is empty, <code>if Pn,In</code> will branch to the appropriate
offset. Finally, <code>set In,Pn</code> will dequeue the last integer in the queue
and place it into the appropriate integer register.</p>
<p>Some sample source using <code>IntQueue</code> may come in handy at this time:</p>
<pre>
  new P0, IntQueue   # Create the queue
  set P0, 7          # Enqueue 7
  set P0, -43        # Enqueue -43
  set I0, P0         # Dequeue 7
  print I0           # Should print '7'.
  if P0, QUEUE_emPTY # Goto label 'QUEUE_emPTY'</pre>


<h3>Core Operations</a></h3>

<p>Before forging ahead with the <code>IntQueue</code>, let's take a look at the core
operations file.  Within your CVS tarball, open <em>parrot/core.ops</em> and
search for the <code>set</code> operations. While there are files such as
<em>parrot/core_ops.c</em> and <em>parrot/Parrot/OpLib/core_ops.pm</em>, this is the
master file. Changes in <em>parrot/core_ops.c</em> will be overwritten the
next time you build, so make your edits to <em>parrot/core.ops</em>.</p>
<p>Having said that, let's look at a sample PMC operation.</p>
<pre>
  inline op set(out PMC, in NUM) {
    $1-&gt;vtable-&gt;set_number(interpreter,$1,$2);
    goto NEXT();
  }</pre>
<p>Since <em>core.ops</em> is split into a Perl and C source file, the syntax is,
of necessity, a mixture of Perl and C. The 'inline' declaration is a
hint to the JIT compiler, which is beyond the scope of the article.
Parameters also have hints for the JIT compiler, but the most important
bits here are the <code>PMC</code> and <code>NUM</code> tags, because these let the compiler
know what types this operation can take.</p>
<p>When preprocessing into Perl, the prototype is the only piece of
interest, as the assembler only needs to know the name and parameter
list in order to build the assembly code.</p>
<p>C preprocessing is a bit more complicated, but still fairly
straightforward. Tokens like <code>$2</code> are replaced with the appropriate
code to access the declared parameter, and a few keywords like <code>NEXT()</code>
are replaced with code to return the next instruction in the stream.</p>
<p>With the exception of those tags, the rest of the code is pure C, with
access to all of the Parrot internals. Of course, you shouldn't access
such things as the register internals, but the rest of the C API is
available, the most common APIs being located in
<em>parrot/include/parrot/string.h</em> and <em>parrot/include/parrot/key.h</em>,
the latter primarily being used for aggregate data structures.</p>
<p>The preprocessor, while slightly confusing, is much more flexible than
the current system of nested <code>CPP</code> macros that Perl currently uses, and
hopefully easier to understand.</p>

<csinclude template="a/multipage_bottom.view">
<!--CS_PAGE_INDEX-->
<csinclude template="a/multipage_bottomb.view">
<a href="<!--CS_NEXT_REF-->">
<csinclude template="a/multipage_bottomc.view">

<!--CS_PAGE_BREAK-->

<csinclude template="a/multipage_top.view">
<!--CS_PAGE_INDEX-->
<csinclude template="a/multipage_topb.view">

<h3>Virtual Tables</h3>
<p>The code above used a curious construct:</p>
<pre>
  $1-&gt;vtable-&gt;set_number(INTERP,$1,$2);</pre>
<p>Parameter <code>$1</code> is a PMC, and since these are user-defined types, the
code simply can't assign <code>$2</code> to <code>$1</code>, as the non-PMC operations would
do. Instead, each PMC has a table of function pointers assigned to it,
and the interpreter calls the appropriate function.</p>
<p>For example, assuming that the <code>P0</code> register is being initialized by the
<code>new P0,IntQueue</code> instruction, the above code would run the <code>set_number</code>
member of the <code>IntQueue</code> class. Since the type of <code>P0</code> is decided on at
runtime, the dispatch mechanism is completely independent of the parameter type.
What this means in the case of the <code>IntQueue</code> type is that no modifications
need to be made to the <em>parrot/core.ops</em> file.</p>
<p>
<H3><A NAME="parrot class files">Parrot Class Files</A></H3>
<p><em>parrot/classes</em> contains all of the PMC classes used by Parrot. Like
the <em>parrot/core.ops</em> file, this too is preprocessed before final
compilation, so all edits should be made to the <em>parrot/classes/*.pmc</em>
files.</p>
<p>Creating a new class file from scratch is somewhat daunting, so we'll use an
existing class file to base <code>IntQueue</code> on. While <code>IntQueue</code> is an aggregate
type like <code>PerlHash</code>, the interface matches <code>PerlInt</code> closest, in that it
only deals with one element at a time.</p>
<p>Start by copying <em>parrot/classes/PerlInt.pmc</em> to
<em>parrot/classes/IntQueue.pmc</em>, and replace all instances of <code>PerlInt</code>
with <code>IntQueue</code>. There will be some additional C code necessary that
will be available in the sample source at the end of the article, but
not discussed beyond the API.</p>
<p>Registering the <em>parrot/classes/IntQueue.pmc</em> is done in two files. Add
the appropriate lines to <em>parrot/global_setup.c</em> to initialize the new
PMC type, and add the new vtable entry to
<em>parrot/include/parrot/pmc.h</em>. This is only done in the case of types
that are intended to be part of Parrot itself; when Parrot has the
ability to dynamically load PMC classes at runtime, a more flexible
mechanism will be derived for registering classes, but for now, we'll
pretend that <code>IntQueue</code> is going to be a core interpreter data type.</p>
<p>Within <em>parrot/core.ops</em>, the instructions the <code>IntQueue</code> type uses look like
this:</p>
<pre>
  op new(out PMC, in INT) {
    PMC* newpmc;
    if ($2 &lt;0 || $2 &gt;= enum_class_max) {
      abort(); /* Deserve to lose */
    }
    newpmc = pmc_new(interpreter, $2);
    $1 = newpmc;
    goto NEXT();
  }
  
  inline op set(out PMC, in INT) {
    $1-&gt;vtable-&gt;set_integer_native(interpreter, $1, $2);
    goto NEXT();
  }
  
  inline op set(out INT, in PMC) {
    $1 = $2-&gt;vtable-&gt;get_integer(interpreter, $2);
    goto NEXT();
  }
  
  op if(in PMC, in INT) {
    if ($1-&gt;vtable-&gt;get_bool(interpreter, $1)) {
      goto OFFSET($2);
    }
    goto NEXT();
  }</pre>
<p>Naturally, each of these call PMC vtable entries, and each one of these
has to be implemented. As of this writing, the appropriate vtable
entries as they are in <em>parrot/classes/perlint.pmc</em> look like this:</p>
<pre>
    void init () { /* This is called from pmc_new() */
        SELF-&gt;cache.int_val = 0;
    }</pre>
<pre>
    void set_integer_native (INTVAL value) {
        SELF-&gt;cache.int_val = value;
    }</pre>
<pre>
    INTVAL get_integer () {
        return SELF-&gt;cache.int_val;
    }</pre>
<pre>
    BOOLVAL get_bool () {
        return pmc-&gt;cache.int_val != 0;
    }</pre>
<p>Any code before the <code>pmclass</code> declaration in a <em>parrot/classes/*.pmc</em> file
is literally copied into the C source, so we'll use this area to store our data
structures and APIs. In order to make matters simple, we'll assume that the
following API is available for our use:</p>
<pre>
  static CONTAINER* new_container ( void );
  static void enqueue ( CONTAINER* container, INTVAL value );
  static INTVAL dequeue ( CONTAINER* container );
  static INTVAL queue_length ( CONTAINER* container );</pre>
<p>The API should be fairly straightforward to use. Initializing the container is
done with <code>new_container</code>, which returns a pointer to our new queue data type.
Adding a new queue element is done with <code>enqueue</code>, and deleting an element is
done with <code>dequeue</code>. The queue's length can be found with <code>queue_length</code>.</p>
<p>The <code>CONTAINER</code> data type has to be stored somewhere, and we look into
<em>parrot/include/parrot/pmc.h</em> to find out where to store it. We find
the definition of the PMC structure to be:</p>
<pre>
    struct PMC {
      VTABLE *vtable;
      INTVAL flags;
      DPOINTER *data;
      union {
        INTVAL int_val;
        FLOATVAL num_val;
        DPOINTER *struct_val;
      } cache;
      SYNC *synchronize;
    };</pre>
<p>There are two areas we can store data: <code>data</code> is used as a general
dumping ground for a data type's internal data structures, and the
<code>cache</code> union is used for fast access to simpler data structures.
<code>data</code> is the right place to hang our <code>CONTAINER</code> structure.</p>
<p>Like most of the other files within Parrot, the <code>IntQueue</code> class is
also preprocessed. The major preprocessing done here is to replace the
<code>SELF</code> tag with a reference to the current PMC. In the rare case that
you need a reference to the current interpreter, that tag is <code>INTERP</code>.</p>
<p>Initializing the <code>IntQueue</code> class is done with the <code>init</code> member. Since we're
storing our queue in the <code>data</code>, we'll let the <code>new_container</code>
function hand us a pointer to our new queue, and save that.</p>
<pre>
    void init () {
        SELF-&gt;data = new_container();
    }</pre>
<p>Getting an integer out of the queue is done with the <code>get_integer</code> member.
This isn't meant to be production-quality, so we won't worry about error
checking. So, we'll simply return the integer from the container.</p>
<pre>
    INTVAL get_integer () {
        return dequeue((CONTAINER*)SELF-&gt;data);
    }</pre>
<p>Adding an integer to the queue is done with the <code>set_integer_native</code> member.
We'll simply use the <code>enqueue</code> function to place the integer onto the queue
like so:</p>
<pre>
    void set_integer_native (INTVAL value) {
        enqueue(SELF-&gt;data,value);
    }</pre>
<p>The final function we need to support is being able to determine whether the queue
is empty, and we use the <code>queue_length</code> function for that. The PMC member
function that does this is <code>get_bool</code>, and the code to access this is pretty
straightforward:</p>
<pre>
    BOOLVAL get_bool () {
        return queue_length(SELF-&gt;data) != 0;
    }</pre>
<p>This code has been checked in to the Parrot CVS, so feel free to look at
the full version there. We've now walked through the major files needed
to implement a Parrot Magic Cookie. Next time, we'll explore the
functions needed to implement aggregate data types like hashes and
arrays, and learn about the new garbage collection system.</p>
<p>In the meantime, if you want to play with implementing your own data
types for Parrot, then take a look at <em>docs/vtables.pod</em> in the Parrot
source tree for more information about the members that you can
implement and how to design your own classes from scratch.</p>


