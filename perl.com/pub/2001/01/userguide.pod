=head1 Quick Start with SOAP

SOAP (Simple Object Access Protocol) is a way for you to remotely make
method calls upon classes and objects on a remote server.  It's the
latest in a long series of similar projects like CORBA, DCOM, and
XML-RPC.

SOAP specifies a standard way to encode parameters and return values
in XML, and standard ways to pass them through HTTP requests and
responses.  This is not about those meaty technical aspects of
SOAP, though, it's a very quick guide to writing SOAP servers and
clients.  We will hardly scratch the surface of what's possible.

We'll be using the B<SOAP::Lite> module from CPAN. Don't pay big
attention to Lite suffix in the name: it's about calories you spend 
using this module. 

=head2 Writing a CGI-based Server

Here's a simple CGI-based SOAP server:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;1.a.&nbspserver&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibye.cgi_">hibye.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

=for html
<DIV CLASS="server-highlight">

  use SOAP::Transport::HTTP;   

  SOAP::Transport::HTTP::CGI   
    -> dispatch_to('Demo')     
    -> handle;                 

=for html
</DIV>

=for html
<DIV CLASS="server-highlight">

  package Demo;                

  sub hi {                     
    return "hello, world";     
  }                            

  sub bye {                    
    return "goodbye, cruel world";
  }                               

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

There are basically two parts to this: the first four lines set up a
SOAP wrapper around a class.  Everything from 'package Demo' onward is
the class being wrapped.

In previous version of specification (1.0), SOAP over HTTP was 
supposed to use a new HTTP method, M-POST. In practice, there are many web 
servers that don't understand the M-POST method so this requirement was weakened
and now you can use usual POST first and then run M-POST if server requires 
M-POST and returns '510 Not Extended' error code.

=head2 Client

This program prints the results of the hi() method call:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;1.a.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="hibye.pl_">hibye.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;                                              

  print SOAP::Lite                                             
    -> uri('http://www.soaplite.com/Demo')                                             
    -> proxy('http://services.soaplite.com/hibye.cgi')
    -> hi()                                                    
    -> result;                                                 

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

The uri() is the class on the server, and the proxy() is the CGI
script's URL. Since both are look like URL I'll take couple of minutes of
your time and explain the difference. It's B<quite important>. 

=over 4

=item proxy()

proxy() is easier to explains, it specifies address of service (server) you 
want to call to get your result. It may start from C<http://> for services 
you can access with HTTP protocol, or may start with C<mailto:>, or may look 
like C<ftp://something.somewhere/path/file> for FTP protocol. 
Shortly, B<proxy() represents an address of your service, and specifies how 
you can get to it>. Better name could be server() or something like that.

=item uri()

uri() is little bit more difficult. 
We have two explanation, short and long: 

=over 4

=item Short explanation

B<URI is just a string> and should be treated as such. Period. 
Forget that it looks like URL. B<It points to nowhere>. 
Even if it does point to somewhere, it's accidental. It binds your call
to something (class in our case) that will execute it on server side.

=item Long explanation

SOAP message is XML message. And XML messages use namespaces to 
provide desired extensibility. For example, you created service C<add> and I
did the same thing. How two messages that will call our services should
be distinguished? Namespaces are in help here. You specify that for your
method namespace is 'http://your.private.server/something' and I specify for
my 'http://my.personal.server/Class/That/Will/Handle/Request'. Namespace 
should be unique and URIs work great here, because if you have some
'personal.server' this name is globally unique. In addition to that, SOAP::Lite
uses PATH of this URI ('Class/That/Will/Handle/Request' in our case) as name
of class that will handle requests and that allows you to avoid (almost) any
configuration on server side. However, other SOAP toolkits may have different
view on URIs, so see the short explanation and B<treat URI as a string>.

=back

=back

Run your client and you should see:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="result-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="result-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="result-header">&nbsp;1.a.&nbsp;result&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  hello, world

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

That's it (I suppose you are connected to Internet, because if not, you'll 
see the different picture, but I'd rather be optimistic).

If your method returns multiple values:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;1.b.&nbsp;server&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibye.cgi_">hibye.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;      

  SOAP::Transport::HTTP::CGI      
    -> dispatch_to('Demo')        
    -> handle;                    

  package Demo;                   

  sub hi {                        
    return "hello, world";        
  }                               

  sub bye {                       
    return "goodbye, cruel world";
  }                               

=for html
<DIV CLASS="server-highlight">

  sub languages {                 
    return ("Perl", "C", "sh");   
  }                               

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Then the result() method will only return the first.  To access
the rest, use the paramsout() method:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;1.b.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="hibyeout.pl_">hibyeout.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;                                              

  $soap_response = SOAP::Lite                                  
    -> uri('http://www.soaplite.com/Demo')                                             
    -> proxy('http://services.soaplite.com/hibye.cgi')
    -> languages();                                            

=for html
<DIV CLASS="client-highlight">

  @res = $soap_response->paramsout;                            

=for html
</DIV>

  $res = $soap_response->result;                               
  print "Result is $res, outparams are @res\n";                

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

This code will produce:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="result-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="result-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="result-header">&nbsp;1.b.&nbsp;result&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  Result is Perl, outparams are C sh

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=head2 Passing Values

Methods can take arguments.  Here's a SOAP server that translates
between Fahrenheit and Celsius:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;2.a.&nbsp;server&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="temper.cgi_">temper.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -> dispatch_to('Temperatures')
    -> handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5/9*($f-32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32+$c*9/5;
  }

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

And here's a sample query:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.a.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temp.pl_">temp.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;                                             

  print SOAP::Lite                                            
    -> uri('http://www.soaplite.com/Temperatures')                                    
    -> proxy('http://services.soaplite.com/temper.cgi')
    -> c2f(37.5)                                              
    -> result;                                                

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

You may also create the soap object and then run soap calls:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.b.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="tempmod.pl_">tempmod.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;                                              

  my $soap = SOAP::Lite                                        
    -> uri('http://www.soaplite.com/Temperatures')                                     
    -> proxy('http://services.soaplite.com/temper.cgi');

  print $soap                                                  
    -> c2f(37.5)                                               
    -> result;                                                 

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Check your math, it should give you:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="result-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="result-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="result-header">&nbsp;2.&nbsp;result&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  99.5

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=head2 Autodispatching

Following TIMTOWTDI ('There Is More Than One Way To Do It') motto SOAP::Lite
provides an alternative client syntax.

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.c.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="tempauto.pl_">tempauto.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

=for html
<DIV CLASS="client-highlight">

  use SOAP::Lite +autodispatch =>                              

=for html
</DIV>

    uri => 'http://www.soaplite.com/Temperatures',
    proxy => 'http://services.soaplite.com/temper.cgi'; 

  print c2f(37.5);                                             

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

After you specify the uri and proxy parameters, you are
able to call remote functions with the same syntax as local ones
(e.g., c2f).  This is done with UNIVERSAL::AUTOLOAD, which catches
all unknown method calls.  Be warned that B<all> calls to undefined
methods will result in an attempt to use SOAP.

=head2 Objects access (it's 'simple OBJECT access protocol', isn't it?)

Methods can also return real objects. Let's extend our C<Temperatures> class 
with an object-oriented interface.

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;2.b.&nbsp;server&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="temper.cgi_">temper.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -> dispatch_to('Temperatures')
    -> handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5/9*($f-32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32+$c*9/5;
  }

=for html
<DIV CLASS="server-highlight">

  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
      bless {_temperature => shift} => $class;
  }

  sub as_fahrenheit {
      return shift->{_temperature};
  }

  sub as_celsius {
      return 5/9*(shift->{_temperature}-32);
  }

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

And here is a client to accesses this class:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.d.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="tempobj.pl_">tempobj.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi');

  my $temperatures = $soap
    -> call(new => 100) # accept Fahrenheits 
    -> result;

  print $soap
    -> as_celsius($temperatures)
    -> result;

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Similar code with autodispatch is shorter and easier to read.

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.e.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="tempobja.pl_">tempobja.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite +autodispatch =>
    uri => 'http://www.soaplite.com/Temperatures',
    proxy => 'http://services.soaplite.com/temper.cgi';

  my $temperatures = Temperatures->new(100);
  print $temperatures->as_fahrenheit($object);

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=head2 Error handling

A SOAP call may fail for numerous reasons, such as: transport
error, incorrect parameters, an error on the server.  Transport
errors (which may occur if, for example, there is a network break
between the client and the server) are dealt with below.  
All other errors are indicated by the fault() method:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.f.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temperr.pl_">temperr.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi');

  my $result = $soap->c2f(37.5);

=for html
<DIV CLASS="client-highlight">

  unless ($result->fault) {
    print $result->result();
  } else {
    print join ', ', 
      $result->faultcode, 
      $result->faultstring, 
      $result->faultdetail;
  }

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

faultcode() gives you information about the main reason for the error.  
Possible values may be:

=over 4

=item Client: you provided incorrect information in the request.

This error may occur when parameters for remote call are incorrect, 
for example, for service that returns name of state in US based on number 
of this state you provide negative or too big number. Or type of parameter 
is incorrect (specified C<int> instead of C<string>), or likewise.

=item Server: something is wrong on the server side.

This means that provided information is correct, but server couldn't handle
the request because of temporary difficulties, for example, unavailable 
database. 

=item MustUnderstand: Header elements has mustUnderstand attribute, but wasn't 
understood by server. 

Basically that means that the server was able to parse the request but that 
the client is requesting functionality that can't be provided.
For example, request requires execution of SQL statement and client wants
to be sure that several requests will be executed in one transaction. It 
could be implemented as three differents calls with common TransactionID.

In this case, the SOAP header may be extended with a new header element
'TransactionID' which carries the transaction ID across the 3 separate
invocations.  However, the server may not understand what a 'TransactionID'.
If the server does not have this understanding and tries to process the
request anyway, problems may arise if there is a problem with processing the
3 invocations together, as the server will not maintain transactional
integrity across the group of 3.  To guard against this, the client may
indicate that the server 'mustUnderstand' the element 'TransactionID'. If
the server sees this and does NOT understand the meaning of the element, it
will not try and process the requests in the first place.

This functionality makes services more reliable and distributed 
system more robast.

=item VersionMismatch: the server can't understand the version of SOAP used 
by the client.

This is provided for (possible) future extensions, when new versions of SOAP
will have different functionality and only clients that are knowledgeable 
about it will be able to use it.

=item Other errors

The server is allowed to create its own errors, like B<Client.Authentication>.

=back

faultstring() provides a readable explanation, whereas faultdetail()
gives access to more detailed information, which may be a string,
object, or more complex structure.

For example, if you change B<uri> to something else (let's try with C<'Test'> instead 
of C<'Temperatures'>), this code will generate:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="result-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="result-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="result-header">&nbsp;2.f.&nbsp;result&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  Client, Bad Class Name, Failed to access class (Test)

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

By default client will B<die with diagnostic> on I<transport errors> and B<do 
nothing> for I<faulted calls>, so, you'll be able to get fault info from result. 
You can alter this behavior with on_fault() handler either per object (will 
die on both transport errors and SOAP faults):

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.g.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temperrh.pl_">temperrh.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi')

=for html
<DIV CLASS="client-highlight">

    -> on_fault(sub { my($soap, $res) = @_; 
         die ref $res ? $res->faultdetail : $soap->transport->status, "\n";
       });

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

or globally:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.h.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temperrg.pl_">temperrg.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite

=for html
<DIV CLASS="client-highlight">

    on_fault => sub { my($soap, $res) = @_; 
      die ref $res ? $res->faultdetail : $soap->transport->status, "\n";
    };

=for html
</DIV>

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi');

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Now you wrap your SOAP call into C<eval {}> block and catch both transport 
errors and SOAP faults:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.j.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temperrg.pl_">temperrg.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite

    on_fault => sub { my($soap, $res) = @_; 
      die ref $res ? $res->faultdetail : $soap->transport->status, "\n";
    };

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi');

=for html
<DIV CLASS="client-highlight">

  eval { 
    print $soap->c2f(37.5)->result; 
  1 } or die;

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

You may also consider this variant that will return C<undef> and setup C<$!> 
on failure, just like many Perl functions do:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.k.&nbsp;client&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="client-link">&nbsp;(<A HREF="temperrv.pl_">temperrv.pl</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Lite
    on_fault => sub { my($soap, $res) = @_; 
      eval { die ref $res ? $res->faultdetail : $soap->transport->status };
      return ref $res ? $res : new SOAP::SOM;
    };

  my $soap = SOAP::Lite
    -> uri('http://www.soaplite.com/Temperatures')
    -> proxy('http://services.soaplite.com/temper.cgi');

  defined (my $temp = $soap->c2f(37.5)->result) or die;

  print $temp;

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

And finally, if you want to ignore errors (however, you can still check for 
them with the fault() method call):

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.&nbsp;fragment&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  use SOAP::Lite
    on_fault => sub {};

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

or

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="client-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="client-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="client-header">&nbsp;2.&nbsp;fragment&nbsp;</TD><TD><TT>&nbsp;</TT></TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  my $soap = SOAP::Lite
    -> on_fault(sub{})
    ..... other parameters

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=head2 Service dispatch (different services on one server)

So far our CGI programs have had a single class to handle incoming
SOAP calls.  But we might have one CGI program that dispatches SOAP
calls to many classes.  This section shows you how to do that.

Static dispatch is when you hard-code the name of the module that
the SOAP requests go to.  That module can be defined by your program
or loaded when needed.

First, what is this B<dispatch>? When server gets SOAP request it binds
it to class specified in request. This class could be already loaded on
server side (on server startup or as result of previous calls) or will be 
loaded on demand according to server configuration. Dispatch is the process
of determining of what class should handle this request and loading of this 
class. B<Static> means that name of the class is specified in configuration
and B<dynamic> means that only directory is specified and ANY class from
this particular directory can be accessed.

Now imagine you want to give access to two different classes on server
side, and want to provide the same address for both. What should you do? 
Several options are available (surprised?):

=over 4

=item Static internal 

That is something you already are familiar with:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.a.&nbsp;server&nbsp;(Static&nbsp;internal)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibye.cgi_">hibye.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

=for html
<DIV CLASS="server-highlight">

  use SOAP::Transport::HTTP;   

  SOAP::Transport::HTTP::CGI   
    -> dispatch_to('Demo')     
    -> handle;                 

=for html
</DIV>

=for html
<DIV CLASS="server-highlight">

  package Demo;                

  sub hi {                     
    return "hello, world";     
  }                            

  sub bye {                    
    return "goodbye, cruel world";
  }                               

  1;

=for html
</DIV>

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=item Static external

Similar to C<Static internal>, but module is somewhere outside of server code:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.b.&nbsp;server&nbsp;(Static&nbsp;external)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibyeout.cgi_">hibyeout.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;   

=for html
<DIV CLASS="server-highlight">

  use Demo;

=for html
</DIV>

  SOAP::Transport::HTTP::CGI   
    -> dispatch_to('Demo')     
    -> handle;                 

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Following file should be somewhere in @INC directory:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.b.&nbsp;module&nbsp;(Static&nbsp;external)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="Demo.pm_">Demo.pm</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  package Demo;                

  sub hi {                     
    return "hello, world";     
  }                            

  sub bye {                    
    return "goodbye, cruel world";
  }                               

  1;

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

=item Dynamic 

As you can see in both C<Static internal> and C<Static external> modes name of
module is hardcoded in server's code. But what if you want to be able to add
new modules dynamically without changing the code? Dynamic dispatch allows 
you to do it. Specify directory and any module in this directory becomes
available for dispatching:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.c.&nbsp;server&nbsp;(Dynamic)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibyedyn.cgi_">hibyedyn.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;   

  SOAP::Transport::HTTP::CGI   

=for html
<DIV CLASS="server-highlight">

    -> dispatch_to('/home/soaplite/modules')

=for html
</DIV>

    -> handle;                 

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Then put C<Demo.pm> in C</home/soaplite/modules> directory:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.c.&nbsp;module&nbsp;(Dynamic)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="Demo.pm_">Demo.pm</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  package Demo;                

  sub hi {                     
    return "hello, world";     
  }                            

  sub bye {                    
    return "goodbye, cruel world";
  }                               

  1;

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

That's it. B<Any> module you put in C</home/soaplite/modules> is available now, but
don't forget that URI on client side should match module/class name you
want to dispatch your call to. 

=item Mixed

Why do we need this? Unfortunately, both dynamic and static dispatch have
disadvantages. During dynamic dispatch access to @INC is disabled (due to
security reasons) and static dispatch loads modules on startup, but it
could be not what we want if we have bunch of modules we want to access.
To avoid this, you can combine dynamic and static approaches. 

Let's assume you have 10 modules in C</home/soaplite/modules> directory, and 
want to provide access, but don't want to load all of them on startup. 
All you need to do is this:

=for html
<TABLE CELLPADDING="1" CELLSPACING="0" CLASS="server-border"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0" CLASS="server-body"><TR><TD><TABLE CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="1" 
CLASS="server-header">&nbsp;3.d.&nbsp;server&nbsp;(Mixed)&nbsp;</TD><TD><TT>&nbsp;</TT></TD><TD WIDTH="1%" 
CLASS="server-link">&nbsp;(<A HREF="hibyemix.cgi_">hibyemix.cgi</A>)&nbsp;</TD></TR></TABLE></TD></TR><TR><TD><TABLE CELLPADDING="12" CELLSPACING="0"><TR><TD>

  #!/usr/bin/env perl

  use SOAP::Transport::HTTP;   

  SOAP::Transport::HTTP::CGI   

=for html
<DIV CLASS="server-highlight">

    -> dispatch_to('/home/soaplite/modules', 'Demo', 'Demo1', 'Demo2')

=for html
</DIV>

    -> handle;                 

=for html
</TD></TR></TABLE></TD></TR></TABLE></TD></TR></TABLE>

Now access to all these modules is enabled and they'll be loaded on demand 
basis, only when needed.

=back

=head2 More complex server (daemon and mod_perl). Installation. Configuration

=head2 Types and Names

So far as Perl is typeless language (in a sence that there is no difference 
between integer C<123> and string C<'123'>) it greatly simplifies 
transformation process from SOAP message to Perl data. For most simple types 
we can just ignore types during this stage. However it has drawbacks also: we 
need to provide additional information during generation of our SOAP message, 
because another side (server) may expect to get type information. SOAP::Lite 
tries hard to make this job for you and doesn't force you to type every 
parameter explicitely. It tries to guess datatype based on actual value 
that stored in variable and behave appropriately (according to another Perl's 
motto, DWIM, 'Do What I Mean'). 

For example, variable that has value C<123> becomes element with type C<int> 
in SOAP message, and variable that has value C<'abc'> gets type C<string>. 
There are several more complex cases, for example, variable that has value 
with binary zeroes C<"\0"> will be encoded and get type C<base64> and 
objects (blessed references) will have type and name (unless specified) 
according to their types.

It may not work in all cases though. There is no way to make (by default) 
element with type C<string> or type C<long> from value C<123>, because 
autotyping will always make type C<int> for this variable.

You may alter this behavior in several ways. You may disable it completely 
(with C<autotype(0)>), you may change autotyping for different types, or you 
may explicitely specify type for your variable: 

  my $var = SOAP::Data->type(string => 123);

and it becomes element with type C<string> and value C<123>. You may use this
variable in ANY place where you use usual variables in SOAP calls and it also
allows you to provide not only specific B<data types>, but also B<name> and 
B<attributes>.

Since many services count on B<names> of parameters (instead of B<positions>) 
you may specify name for your parameters through the same syntax. To add name 
to C<$var> variable you may use C<$var-E<gt>name('myvar')>, or make it in one 
line:

  my $var = SOAP::Data->type(string => 123)->name('myvar');

  # -- OR --
  my $var = SOAP::Data->type('string')->name(myvar => 123);

  # -- OR --
  my $var = SOAP::Data->type('string')->name('myvar')->value(123);

You may always get/set value of this variable with value() method:

  $var->value(321);            # set new value
  my $realvalue = $var->value; # store it in variable

=head2 Access to Remote Services  

=head2 Service packages (stubmaker)

=head2 In/Out parameters

=head2 Headers and attributes

=head2 Parameters by name

=head2 Custom data types

=head2 Custom serializer and deserializer

=head2 Debugging

=head2 Global settings

=head2 Security

=head2 Access with service description (WSDL)

=head2 SOAP shell

=head2 XML processing

=head2 UDDI requests

=head2 Oneliners

=head2 Troubleshooting

=head2 Perl tricks

  UNIVERSAL::AUTOLOAD
  mapping in/out (assign to @_)
  keep-alive hack
  function/class/object method
  implicit new (CLASS->method instead of CLASS->new->method)
  SOAP:: prefix
  die with blessed ref
  stringified overloading and overload::StrVal (object in numeric context)

=head2 Glossary

=head2 References

=head1 Copyright

Copyright (C) 2001 Paul Kulchenko. All rights reserved.

=head1 Author and contributors

Paul Kulchenko (paulclinger@yahoo.com)

Major contributors:

=over 4

=item Nathan Torkington

Basically started this work and pushed the whole process.

=item Tony Hong

Invaluable comments and input help me keep this material fresh and simple.

=back

=cut
