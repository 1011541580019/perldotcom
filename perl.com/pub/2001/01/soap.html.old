<!-- <a name="quick start with soap">Quick Start with SOAP</a> -->

<br />
<!::field::date::> <p> 
<table align="right" border="1" cellpadding="4" cellspacing="0" width="180"> <tbody> <tr> 
<td align="middle" bgcolor="#6699cc" valign=top><font color=#ffffff>Table of Contents</font></td></tr> 
<tr> 
<td> 
<p class="fine">&#149;<a href="#quick start with soap">Quick Start with SOAP</a><br />&#149;<a href="#writing a cgibased server">Writing a CGI-based 
      Server</a><br />&#149;<a href="#client">Client</a><br />&#149;<a 
      href="#passing values">Passing Values</a><br />&#149;<a 
      href="#autodispatching">Autodispatching</a><br />&#149;<a 
      href="#objects access">Objects access</a><br />&#149;<a 
      href="#error handling">Error handling</a><br />&#149;<a 
      href="#service dispatch (different services on one server)">Service 
      dispatch (different services on one server)</a><br />&#149;<a 
      href="#types and names">Types and Names</a><br />&#149;<a 
      href="#conclusion">Conclusion</a><br /><br />
	  
	  <b><a href="http://www.perl.com/pub/2001/04/24/soap.html">Part 2 of this series</b></p></td></tr> 
	  </table> <p>SOAP (Simple Object Access Protocol) is a way for you to remotely make method 
calls upon classes and objects that exist on a remote server. It's the latest in 
a long series of similar projects like CORBA, DCOM, and XML-RPC.</p> <p>SOAP specifies a standard way to encode parameters and return values in XML, 
and standard ways to pass them over some common network protocols like HTTP 
(web) and SMTP (email). This article, however, is merely intended as a quick 
guide to writing SOAP servers and clients. We will hardly scratch the surface of 
what's possible.</p> <p>We'll be using the <strong>SOAP::Lite</strong> module from CPAN. Don't be 
mislead by the "Lite" suffix--this refers to the effort it takes to use the 
module, not its capabilities. </p>
<h3><a name="writing a cgibased server">Writing a CGI-based Server</a></h3>

<p><a href="/2001/01/files/SOAP-Lite-guide.tar.gz">Download source files mentioned in this article here.</a>
 <p>Here's a simple CGI-based SOAP server (hibye.cgi):</p>
<pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI   
    -&gt; dispatch_to('Demo')     
    -&gt; handle;

  package Demo;

  sub hi {                     
    return "hello, world";     
  }

  sub bye {                    
    return "goodbye, cruel world";
  }
</pre> 

<table width="170" border="0" cellspacing="0" cellpadding="20" align="right">
<tr>
<td width="170" valign="top" bgcolor="#ffffff">
<hr size="1" color="#6699cc"><br />
<font size="-1" color="#6699cc"><b><p>
<a href="http://www.perl.com/pub/au/Kulchenko_Paul">Paul Kulchenko</a></b> is a featured speaker at the upcoming O'Reilly Open
Source Convention in San Diego, CA, July 23 - 27, 2001. Take this
opportunity to rub elbows with open source leaders while relaxing in the
beautiful setting of the beach-front Sheraton San Diego Hotel and Marina.
For more information, visit our <a
href="http://conferences.oreilly.com/oscon/">conference home page</a>. You
can register online.</p></b></font><hr size="1" color="#6699cc"><br /></td>
</tr>
</table>

<p>There are basically two parts to this: the first four lines set up a SOAP 
wrapper around a class. Everything from 'package Demo' onward is the class being 
wrapped.</p> <p>In the previous version of specification (1.0), SOAP over HTTP was supposed 
to use a new HTTP method, M-POST. Now it's common to try a normal POST first, 
and then use M-POST if the server needs it. If you don't understand the 
difference between POST and M-POST, don't worry, you don't need to know all the 
specific details to be able to use the module.</p> <p> <h3><a name=client>Client</a></h3> <p>This client prints the results of the <code>hi()</code> method call (hibye.pl):</p><pre> #!perl -w
  
  use SOAP::Lite;

  print SOAP::Lite                                             
    -&gt; uri('<a href="http://www.soaplite.com/Demo">http://www.soaplite.com/Demo</a>')                                             
    -&gt; proxy('<a href="http://services.soaplite.com/hibye.cgi">http://services.soaplite.com/hibye.cgi</a>')
    -&gt; hi()                                                    
    -&gt; result;</pre> <p>The <a href="#item_uri"><code>uri()</code></a> identifies the class to the 
server, and the <a href="#item_proxy"><code>proxy()</code></a> identifies the 
location of the server itself. Since both look like URLs, I'll take a minute to 
explain the difference, as it's <strong>quite important</strong>.</p> <dl> <dt><strong><a name=item_proxy><code>proxy()</code></a></strong><br /> <dd><a href="#item_proxy"><code>proxy()</code></a> is simply the address of 
  the server to contact that provides the methods. You can use http:, mailto:, 
  even ftp: URLs here. 
  <p></p> <dt><strong><a name=item_uri><code>uri()</code></a></strong><br /> <dd>Each server can offer many different services through the one proxy() URL. 
  Each service has a unique URI-like identifier, which you specify to SOAP::Lite 
  through the uri() method. If you get caught up in the gripping saga of the 
  SOAP documentation, the "namespace" corresponds to the uri() method. 
  <p></p></dd></dl> <dl></dl> <p>If you're connected to the Internet, you can run your client, and you should 
see:</p><pre> hello, world

</pre> <p>That's it!</p> <p>If your method returns multiple values (hibye.cgi):</p><pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI      
    -&gt; dispatch_to('Demo')        
    -&gt; handle;

  package Demo;

  sub hi {                        
    return "hello, world";        
  }

  sub bye {                       
    return "goodbye, cruel world";
  }

  sub languages {                 
    return ("Perl", "C", "sh");   
  }</pre> <p>Then the <code>result()</code> method will only return the first. To access 
the rest, use the <code>paramsout()</code> method (hibyeout.pl):&gt;</p><pre> #!perl -w

  use SOAP::Lite;

  $soap_response = SOAP::Lite                                  
    -&gt; uri('<a href="http://www.soaplite.com/Demo">http://www.soaplite.com/Demo</a>')                                             
    -&gt; proxy('<a href="http://services.soaplite.com/hibye.cgi">http://services.soaplite.com/hibye.cgi</a>')
    -&gt; languages();

  @res = $soap_response-&gt;paramsout;

  $res = $soap_response-&gt;result;                               
  print "Result is $res, outparams are @res\n";</pre> <p>This code will produce:</p><pre> Result is Perl, outparams are Perl C sh

</pre> <h3><a name="passing values">Passing Values</a></h3> <p>Methods can take arguments. Here's a SOAP server that translates between 
Fahrenheit and Celsius (temper.cgi):</p><pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -&gt; dispatch_to('Temperatures')
    -&gt; handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5 / 9 * ($f - 32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32 + $c * 9 / 5;
  }</pre> <p>And here's a sample query (temp.pl):</p><pre> #!perl -w

  use SOAP::Lite;

  print SOAP::Lite                                            
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')                                    
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>')
    -&gt; c2f(37.5)                                              
    -&gt; result;

</pre> <p>You can also create an object representing the remote class, and then make 
method calls on it (tempmod.pl):</p><pre> #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite                                        
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')                                     
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');

  print $soap                                                  
    -&gt; c2f(37.5)                                               
    -&gt; result;

</pre> <h3><a name=autodispatching>Autodispatching</a></h3> <p>This being Perl, there's more than one way to do it: SOAP::Lite provides an 
alternative client syntax (tempauto.pl).</p><pre> #!perl -w

  use SOAP::Lite +autodispatch =&gt;

    uri =&gt; '<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>',
    proxy =&gt; '<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>';

  print c2f(37.5);

</pre> <p>After you specify the uri and proxy parameters, you are able to call remote 
functions with the same syntax as local ones (e.g., c2f). This is done with 
UNIVERSAL::AUTOLOAD, which catches all unknown method calls. Be warned that 
<strong>all</strong> calls to undefined methods will result in an attempt to use 
SOAP.</p> <h3><a name="objects access">Objects access (it's 'Simple <b>Object</b> access 
protocol', isn't it?)</a></h3> <p>Methods can also return real objects. Let's extend our 
<code>Temperatures</code> class with an object-oriented interface (temper.cgi):</p><pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -&gt; dispatch_to('Temperatures')
    -&gt; handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5/9*($f-32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32+$c*9/5;
  }

  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
      bless {_temperature =&gt; shift} =&gt; $class;
  }

  sub as_fahrenheit {
      return shift-&gt;{_temperature};
  }

  sub as_celsius {
      my $self = $shift;
      return $self-&gt;f2c( $self-&gt;{_temperature} );
  }

</pre> <p>Here is a client that accesses this class (tempobj.pl):</p><pre> #!perl -w
  
  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');

  my $temperatures = $soap
    -&gt; call(new =&gt; 100) # accept Fahrenheit  
    -&gt; result;

  print $soap
    -&gt; as_celsius($temperatures)
    -&gt; result;</pre> <p>Similar code with autodispatch is shorter and easier to read (tempobja.pl):</p><pre> #!perl -w

  use SOAP::Lite +autodispatch =&gt;
    uri =&gt; '<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>',
    proxy =&gt; '<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>';

  my $temperatures = Temperatures-&gt;new(100);
  print $temperatures-&gt;as_fahrenheit();
</pre> <h3><a name="error handling">Error handling</a></h3> <p>A SOAP call may fail for numerous reasons, such as transport error, incorrect 
parameters, or an error on the server. Transport errors (which may occur if, for 
example, there is a network break between the client and the server) are dealt 
with below. All other errors are indicated by the <code>fault()</code> method 
(temperr.pl):</p><pre> #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');</pre><pre> my $result = $soap-&gt;c2f(37.5);

  unless ($result-&gt;fault) {
    print $result-&gt;result();
  } else {
    print join ', ', 
      $result-&gt;faultcode, 
      $result-&gt;faultstring, 
      $result-&gt;faultdetail;
  }

</pre> <p><code>faultcode()</code> gives you information about the main reason for the 
error. Possible values may be:</p> <dl> <dt><strong><a 
  name=item_client%3a_you_provided_incorrect_information_in_th>Client: you 
  provided incorrect information in the request.</a></strong><br /> <dd>This error may occur when parameters for the remote call are incorrect. 
  Parameters may be out-of-bounds, such as negative numbers, when positive 
  integers are expected; or of an incorrect type, for example, a string is 
  provided where a number was expected. 
  <p></p> <dt><strong><a 
  name=item_server%3a_something_is_wrong_on_the_server_side%2e>Server: something 
  is wrong on the server side.</a></strong><br /> <dd>This means that provided information is correct, but the server couldn't 
  handle the request because of temporary difficulties, for example, an 
  unavailable database. 
  <p></p> <dt><strong><a 
  name=item_mustunderstand%3a_header_elements_has_mustundersta>MustUnderstand: 
  Header elements has mustUnderstand attribute, but wasn't understood by 
  server.</a></strong><br /> <dd>The server was able to parse the request, but the client is requesting 
  functionality that can't be provided. For example, suppose that a request 
  requires execution of SQL statement, and the client wants to be sure that 
  several requests will be executed in one database transaction. This could be 
  implemented as three different calls with one common TransactionID. 
  <p>In this case, the SOAP header may be extended with a new header element 
  called, say, 'TransactionID', which carries a common identifier across the 3 
  separate invocations. However, if server does not understand the provided 
  TransactionID header, it probably won't be able to maintain transactional 
  integrity across invocations. To guard against this, the client may indicate 
  that the server 'mustUnderstand' the element 'TransactionID'. If the server 
  sees this and does NOT understand the meaning of the element, it will not try 
  and process the requests in the first place. 
  <p>This functionality makes services more reliable and distributed systems 
  more robust.</p> <dt><strong><a 
  name=item_versionmismatch%3a_the_server_can%27t_understand_t>VersionMismatch: 
  the server can't understand the version of SOAP used by the 
  client.</a></strong><br /> <dd>This is provided for (possible) future extensions, when new versions of 
  SOAP may have different functionality, and only clients that are knowledgeable 
  about it will be able to properly use it. 
  <p></p> <dt><strong><a name=item_other_errors>Other errors</a></strong><br /> <dd>The server is allowed to create its own errors, like 
  <strong>Client.Authentication</strong>. 
  <p></p></dd></dl> <p><code>faultstring()</code> provides a readable explanation, whereas 
<code>faultdetail()</code> gives access to more detailed information, which may 
be a string, object, or more complex structure.</p> <p>For example, if you change <strong>uri</strong> to something else (let's try 
with <code>'Test'</code> instead of <code>'Temperatures'</code>), this code will 
generate:</p><pre> Client, Bad Class Name, Failed to access class (Test)

</pre> <p>By default client will <strong>die with diagnostic</strong> on <em>transport 
errors</em> and <strong>do nothing</strong> for <em>faulted calls</em>, so, 
you'll be able to get fault info from result. You can alter this behavior with 
<code>on_fault()</code> handler either per object, so it will die on both 
transport errors and SOAP faults (temperrh.pl):</p><pre> #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>')

    -&gt; on_fault(sub { my($soap, $res) = @_; 
         die ref $res ? $res-&gt;faultdetail : $soap-&gt;transport-&gt;status, "\n";
       });</pre> <p>Or you can set it globally (temperrg.pl):</p><pre> #!perl -w

  use SOAP::Lite

    on_fault =&gt; sub { my($soap, $res) = @_; 
      die ref $res ? $res-&gt;faultdetail : $soap-&gt;transport-&gt;status, "\n";
    };

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');</pre> <p>Now, wrap your SOAP call into an <code>eval {}</code> block, and catch both 
transport errors and SOAP faults (temperrg.pl):</p><pre> #!perl -w

  use SOAP::Lite

    on_fault =&gt; sub { my($soap, $res) = @_; 
      die ref $res ? $res-&gt;faultdetail : $soap-&gt;transport-&gt;status, "\n";
    };

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');

  eval { 
    print $soap-&gt;c2f(37.5)-&gt;result; 
  1 } or die;

</pre> <p>You may also consider this variant that will return <code>undef</code> and 
setup <code>$!</code> on failure, just like many Perl functions do (temperrv.pl):</p><pre> #!perl -w

  use SOAP::Lite
    on_fault =&gt; sub { my($soap, $res) = @_; 
      eval { die ref $res ? $res-&gt;faultdetail : $soap-&gt;transport-&gt;status };
      return ref $res ? $res : new SOAP::SOM;
    };

  my $soap = SOAP::Lite
    -&gt; uri('<a href="http://www.soaplite.com/Temperatures">http://www.soaplite.com/Temperatures</a>')
    -&gt; proxy('<a href="http://services.soaplite.com/temper.cgi">http://services.soaplite.com/temper.cgi</a>');

  defined (my $temp = $soap-&gt;c2f(37.5)-&gt;result) or die;

  print $temp;

</pre> <p>And finally, if you want to ignore errors (however, you can still check for 
them with the <code>fault()</code> method call):</p><pre> use SOAP::Lite
    on_fault =&gt; sub {};

</pre> <p>or</p><pre> my $soap = SOAP::Lite
    -&gt; on_fault(sub{})
    ..... other parameters

</pre> <h3><a name="service dispatch (different services on one server)">Service 
dispatch (different services on one server)</a></h3> <p>So far our CGI programs have had a single class to handle incoming SOAP 
calls. But we might have one CGI program that dispatches SOAP calls to many 
classes. </p> <p>What exactly is <strong>SOAP dispatch</strong>? When a SOAP request is 
recieved by a server, it gets bound to the class specified in the request. The 
class could be already loaded on server side (on server startup, or as a result 
of previous calls), or might be loaded on demand, according to server 
configuration. <strong>Dispatching</strong> is the process of determining of 
which class should handle a given request, and loading that class, if necessary. 
<strong>Static</strong> dispatch means that name of the class is specified in 
configuration, whereas <strong>dynamic</strong> means that only a pool of 
classes is specified, in, say, a particular directory, and that any class from 
this directory can be accessed.</p> <p>Imagine that you want to give access to two different classes on the server 
side, and want to provide the same 'proxy' address for both. What should you do? 
Several options are available:</p> <dl> <dt><strong><a name=item_static_internal>Static internal</a></strong><br /> <dd>... Which you are already familiar with (hibye.cgi): <pre>  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI   
    -&gt; dispatch_to('Demo')     
    -&gt; handle;

  package Demo;

  sub hi {                     
    return "hello, world";     
  }

  sub bye {                    
    return "goodbye, cruel world";
  }

  1;

</pre> <p></p> <dt><strong><a name=item_static_external>Static external</a></strong><br /> <dd>Similar to <a href="#item_Static_internal"><code>Static 
  internal</code></a>, but the module is somewhere outside of server code (hibyeout.cgi): <pre>  use SOAP::Transport::HTTP;

  use Demo;

  SOAP::Transport::HTTP::CGI   
    -&gt; dispatch_to('Demo')     
    -&gt; handle;

</pre> <p>The following module should, of course, be somewhere in a directory listed 
  in @INC (Demo.pm):</p><pre> package Demo;

  sub hi {                     
    return "hello, world";     
  }

  sub bye {                    
    return "goodbye, cruel world";
  }

  1;
</pre> <dt><strong><a name=item_dynamic>Dynamic</a></strong><br /> <dd>As you can see in both <a href="#item_Static_internal"><code>Static 
  internal</code></a> and <a href="#item_Static_external"><code>Static 
  external</code></a> modes, the module name is hardcoded in the server code. 
  But what if you want to be able to add new modules dynamically without 
  altering the server? Dynamic dispatch allows you to do it. Specify a 
  directory, and any module in this directory becomes available for dispatching 
  (hibyedyn.cgi): <pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI

    -&gt; dispatch_to('/home/soaplite/modules')

    -&gt; handle;

</pre> <p>Then put <code>Demo.pm</code> in <code>/home/soaplite/modules</code> directory (Demo.pm):</p><pre> package Demo;

  sub hi {                     
    return "hello, world";     
  }

  sub bye {                    
    return "goodbye, cruel world";
  }

  1;

</pre> <p>That's it. <strong>Any</strong> module you put in 
  <code>/home/soaplite/modules</code> is available now, but don't forget that 
  the URI specified on the client side should match module/class name you want 
  to dispatch your call to.</p> <dt><strong><a name=item_mixed>Mixed</a></strong><br /> <dd>What do we need this for? Unfortunately, dynamic dispatch also has a 
  significant disadvantage: Access to @INC is disabled for the purposes of 
  dynamic dispatch, for security reasons. To work around this, you can combine 
  dynamic and static approaches. All you need to do is this (hibyemix.cgi):
  <p></p><pre> #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI

    -&gt; dispatch_to('/home/soaplite/modules', 'Demo', 'Demo1', 'Demo2')

    -&gt; handle;

</pre> <p>Now Demo, Demo1, and Demo2 are pre-loaded from anywhere in @INC, but 
  dynamic access is enabled for any modules in 
  <code>/home/soaplite/modules</code>, and they'll be loaded on 
demand.</p></dd></dl> <h3><a name="types and names">Types and Names</a></h3> <p>So far as Perl is typeless language (in a sense that there is no difference 
between integer <code>123</code> and string <code>'123'</code>), it greatly 
simplifies the transformation process from SOAP message to Perl data. For most 
simple data, we can just ignore typing at this stage. However, this approach has 
drawbacks also: we need to provide additional information during generation of 
our SOAP message, because the other server or client may expect type 
information. SOAP::Lite doesn't force you to type every parameter explicitly, 
but instead tries to guess each data type based on actual values in question 
(according to another of Perl's mottos, DWIM, or 'Do What I Mean').</p> <p>For example, a variable that has the value <code>123</code> becomes an 
element of type <code>int</code> in a SOAP message, and a variable that has the 
value <code>'abc'</code> becomes type <code>string</code>. However, there are 
more complex cases, such as variables that contain binary data, which must be 
Base64-encoded, or objects (blessed references), as another example, which are 
given type and name (unless specified) according to their Perl package.</p> <p>The autotyping may not work in all cases, though. There is no default way to 
make an element with type <code>string</code> or type <code>long</code> from a 
value of <code>123</code>, for example. You may alter this behavior in several 
ways. First, you may disable autotyping completely (by calling the 
<code>autotype()</code> with a value of 0), or change autotyping for different 
types.</p> <p>Alternately, you may use objects from the SOAP::Data class to explicitly 
specify a type for a particular variable:</p><pre> my $var = SOAP::Data-&gt;type( string =&gt; 123 );

</pre> <p><code>$var</code> becomes an element with type <code>string</code> and value 
<code>123</code>. You may use this variable in ANY place where you use ordinary 
Perl variables in SOAP calls. This also allows you to provide not only specific 
<strong>data types</strong>, but also specific <strong>name</strong> and 
<strong>attributes</strong>.</p> <p>Since many services count on <strong>names</strong> of parameters (instead of 
<strong>positions</strong>) you may specify names for request parameters using 
the same syntax. To add a name to <code>$var</code> variable, call 
<code>$var-&gt;name('myvar')</code>, or even chain calls with the 
<code>type()</code> method: <pre> my $var = SOAP::Data-&gt;type(string =&gt; 123)-&gt;name('myvar');

  # -- OR --
  my $var = SOAP::Data-&gt;type('string')-&gt;name(myvar =&gt; 123);

  # -- OR --
  my $var = SOAP::Data-&gt;type('string')-&gt;name('myvar')-&gt;value(123);

</pre> <p>You may always get or set the value of a variable with <code>value()</code> method:</p><pre> $var-&gt;value(321);            # set new value

  my $realvalue = $var-&gt;value; # store it in variable

</pre> <h3><a name=conclusion>Conclusion</a></h3> 

<p>This should be enough to get you started building SOAP applications. 
You can read the manpages (or even the source, if you're brave!) to
learn more, and don't forget to keep checking <a
href="http://www.soaplite.com/">www.soaplite.com</a> for more
documentation, examples, and SOAP-y fun.</p>

<p><b>Part 2 of this article can be found <a href="http://www.perl.com/pub/2001/04/24/soap.html">here</a></b>

<hr noshade size=1>  <p>Major contributors:</p> <dl> <dt><strong><a name=item_nathan_torkington>Nathan Torkington</a></strong><br /> <dd>Basically started this work and pushed the whole process. 
  <p></p> <dt><strong><a name=item_tony_hong>Tony Hong</a></strong><br /> <dd>Invaluable comments and input help me keep this material fresh and simple. 

<p>This piece continues <a href="http://www.perl.com/pub/2001/04/24/soap.html">here</a>
