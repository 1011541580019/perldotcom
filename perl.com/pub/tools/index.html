<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Tools Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Tools</em> Category</h1>






                            
                            <div id="entry-820" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/08/tools.html" rel="bookmark">Perl Needs Better Tools</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Matisse Enzer</span> on <abbr class="published" title="2005-08-25T00:00:00-08:00">August 25, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />
<p>Perl is in danger of becoming a fading language--new programmers are
learning Java and Python in college, and companies like Google hardly use Perl
at all.  If you are afraid that Perl may be in danger of becoming irrelevant
for medium-to-large projects, then read on.</p>

<h3>The Scary Part</h3>

<p>I have discussed the future of Perl with managers from companies that
currently use it and find that they worry about the future of Perl. One company
I spoke with here in San Francisco is rewriting their core application in Java.
Another company worries they will not be able to find new Perl programmers down
the road.  Yet another uses Perl for major projects, but suffers from
difficulty in refactoring their extensive code base.</p>

<p>There are many reasons why companies care about the future of Perl. I offer
a part of a solution: better tools for Perl can be a major part of keeping Perl
relevant and effective as the primary language for medium and large
projects.</p>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1795" template="b/article_sidebar.view">
<!-- sidebar ends -->
<p>When measuring the effectiveness of a development environment (people,
language, tools, processes, etc.), a key measure is how expensive and painful it
is to make changes to existing code. Once a project or system has grown to
thousands of lines of code in dozens (or hundreds) of modules, the cost of
making changes can escalate to the point where the team is afraid to make any
significant change. Excellent tools are one of the ways to avoid this unhappy
situation, or at least reduce its impact.  Other factors are excellent
processes and, of course, excellent people.</p>

<h3>21st-Century Integrated Development Environments for Perl</h3>

<p>I propose that more, high-quality development tools will help keep Perl
relevant and alive in medium and large project environments.  My focus in this
article is on IDEs, or Integrated Development Environments, and primarily those
with a graphical interface.</p>

<p>An IDE is an integrated set of tools for programming, combining a source
code editor with a variety of other tools into a single package. Common
features of modern IDEs include refactoring support, version control,
real-time syntax checking, and auto-completion of code while typing.</p>

<p>I want to make it clear right at the outset that a team of highly skilled
Perl programmers, using only tools that have been around for years (such as
<code>emacs</code>, <code>vi</code>, <code>cvs</code>, and <code>make</code>)
can and do build large, sophisticated, and successful projects.  I am not
worried about those programmers. I am worried about the larger population of
programmers with one to five years of experience, and those who have not yet begun to
program: the next generation of Perl programmers.</p>

<p>Great tools will not make a bad programmer into a good programmer, but they
will certainly make a good programmer better.  Unfortunately, the tools for
Perl are years behind what is available for other languages, particularly
Java.</p>

<p>One powerful example is the lack of graphical IDEs for Perl with excellent
support for refactoring.  Several IDEs for Java have extensive refactoring
support.  Only one for Perl, the <a href="http://e-p-i-c.sf.net/">EPIC plugin
for Eclipse</a>, supports even a single refactoring action.</p>

<p>For an example of how good IDEs have inspired at least one Perl developer,
see <a href="/pub/au/Kennedy_Adam">Adam Kennedy</a>'s <a
href="/pub/a/2005/06/09/ppi.html">Perl.com article on his
new PPI module</a> and <a
href="http://search.cpan.org/dist/Devel-Refactor/">Scott Sotka's
Devel::Refactor module</a> (used in EPIC).</p>

<p>I acknowledge that a graphical IDE is not the be-all of good tools.  Just as
some writers reject word processors in favor of typewriters or hand-written
manuscripts, some programmers reject graphical IDEs and would refuse a job that
required them to use one.  Not everyone has (nor should have) the same tool
set, and there are things a pencil can do that <code>vi</code> and
<code>emacs</code> will never do. That said, IDEs have wide use in businesses
doing larger projects, and for many programmers and teams they provide major
increases in productivity.</p>

<p>Another important point is that while this article discusses over a dozen
specific tools or features, having all the tools in a single package produces
the biggest value. An IDE that provides all of these features in a single
package that people can easily install, easily extend, and easily maintain
across an entire development team has far more value than the sum of its
parts.</p>

<p>There is a big win when the features provided by an IDE immediately upon
installation include all or almost all of the tools and features discussed here
and where the features "know" about each other. For example, it is good if you
enter the name of a non-existent subroutine and the real-time syntax checker
catches this. It is much better if the code-assist feature then pops up a
context menu offering to create a stub for the subroutine or to correct the
name to that of an existing similar subroutine or method from another class that is
available to the current file. (This is standard behavior for some Java
IDEs.)</p>

<h3>What Would a 21st-Century Perl Tool Set Contain?</h3>

<p>Perl needs a few great IDEs--not just one, but more than one so that
people have a diverse set to choose from.  Perl deserves and needs a few great
IDEs that lead the pack and set the standard for IDEs in other languages.</p>














<p>I am well aware that the dynamic nature of Perl makes it harder to have a
program that can read and understand a Perl program, especially a large and
complex one, but the difficulty in comprehending a Perl program makes the value
of such a tool all the greater, and I have faith that the Perl community can
overcome some of the built-in challenges of Perl. Indeed, it is among the
greatest strengths of Perl that Perl users can adapt the language to their
needs.</p>

<p>A great Perl IDE will contain at least the following, plus other features I
haven't thought of. (And, of course, there must be many of those!)</p>

<ul>

<li>A <a href="#Syntax-coloring_text_editor">syntax-coloring text
editor.</a></li>

<li><a href="#Syntax-checking">Real-time syntax-checking</a> to catch and
display syntax errors as you type.</li>

<li><a href="#Version_control_integration">Version control integration</a> to
check out and compare code using CVS, Subversion, etc.</li>

<li>A <a href="?page=3#Code-assist">code-assist editor</a>, to provide a list of
methods when you type in an object reference, for example.</li>

<li><a href="?page=3#refactoring_support">Excellent refactoring
support</a>.</li>

<li>A <a href="?page=4#Tree_view_of_source">tree view of source files and
resources</a>.</li>

<li><a href="?page=4#support_for_unit_tests">Support for creating and running unit
tests</a>.</li>

<li><a href="?page=5#Language-specific_help">Language-specific help</a>.</li>

<li><a href="?page=5#Debugger">Real-time display of debugging results</a>.</li>

<li><a href="?page=5#Automatic_reformatting">Automatic code reformatting</a>.</li>

<li>Seamless <a href="?page=5#handling_of_multiple_languages">handling of multiple
languages</a> (such as Perl and C, Perl and Java, Perl and PHP, or Perl and
Python).</li>

<li><a href="?page=5#Automated_build_and_test">Automated build and test
support</a>.</li>

</ul>

<p>Most of the screen shot examples in this article use the EPIC Perl IDE.  At
present, it has the largest amount of the features on my list (although it
certainly doesn't have all of them).</p>

<h4><a id="Syntax-coloring_text_editor" />Syntax-Coloring Text Editor</h4>

<p>Most of you have probably seen this. It is available under <code>vim</code>, <code>emacs</code>,
BBEdit, and TextPad. Just about every decent text editor will colorize source
code so that keywords, operators, variables, etc., each have their own
color, making it easier to spot syntax errors such as forgetting to close a
quote pair.</p>

<h4><a id="Syntax-checking" />Real-Time Syntax Checking</h4>

<p><img src="/pub/2005/08/25/graphics/syntax_check.gif" width="309" height="135" alt="real-time syntax check example"
/><br />
<em>Figure 1. Real-time syntax checking</em></p>

<p>The IDE in Figure 1 shows that line 4 has an error because of the missing
<code>)</code> and that line 5 has an error because there is no declaration of
<code>$naame</code> (and <code>use strict</code> is in effect).</p>

<p>A key point here is that the IDE shows these errors right away, before you
save and compile the code. (In this example, the EPIC IDE lets you specify how
often to run the syntax check, from 0.01 to 10.00 seconds of idle time, or only
on demand.)</p>

<p>As nice as this is, it would be even better if the IDE also offered ways to
fix the problem, for example, offering to change <code>$naame</code> to
<code>$name</code>. Figure 2 shows an IDE that does exactly that; unfortunately,
for Java, not Perl.</p>

<p><img src="/pub/2005/08/25/graphics/syntax_help.gif" width="427" height="150" alt="syntax help from the IDE" /><br
/><em>Figure 2. Syntax help from the IDE</em></p>

<p>It would be great if Perl IDEs offered this kind of help.</p>

<h4><a id="Version_control_integration" />Version Control Integration</h4>

<p>All non-insane large projects use version control software. The most common
version control software systems are probably CVS, Perforce, Subversion, and
Visual SourceSafe.  Figure 3 shows an IDE comparing the local version of a file
to an older version from the CVS repository.</p>

<table width="250" cellspacing="0" cellpadding="0" border="0">
<tr>
<td>
<p class="secondary">
<a href="/2005/08/25/graphics/cvs_compare.gif" onclick="window.open('/2005/08/25/graphics/cvs_compare.gif','fullsize','toolbar=no,width=910,height=593,status=no,location=no,scrollbars=yes,resizable=yes,menubar=yes');return false"><img src="/pub/2005/08/25/graphics/cvs_compare_sm.gif" vspace="4" alt="Figure 3" width="220" height="143" border="0" /></a><br />
Figure 3. Comparing a local file to an older version in
CVS--click image for full-size screen shot</p>
</td>
</tr>
</table>

<p>CVS integration is available in many modern code editors, including <code>emacs</code>,
<code>vim</code>, and BBEdit, as well as graphical IDEs such as Eclipse and Komodo Pro.
Subversion integration is available as a plugin for Eclipse; Komodo Pro
supports Perforce and Subversion.</p>













<h4><a id="Code-assist" />A Code-Assist Editor</h4>

<p>Suppose that you have just typed in an object reference and want to call a
method on the object, but you are not sure what the method name is. Wouldn't it
be nice if the editor popped up a menu listing all of the methods available for
that object? It might look something like Figure 4.</p>

<p><img src="/pub/2005/08/25/graphics/auto_completion.gif" width="399" height="335" alt="automatic code completion" /><br
/><em>Figure 4. Automatic code completion</em></p>

<p>In this example, the IDE is able to figure out which class the object
<code>$q</code> is an instance of and lists the names of the available methods.
If you type a <code>p</code>, then the list shows only the method names
beginning with <code>p</code>. If you type <code>pa</code>, then the list shows
only the <code>param()</code> and <code>parse_params()</code> methods.</p>

<h4><a id="refactoring_support" />Excellent Refactoring Support</h4>

<p>The easier it is to do refactoring, the more often people will do it. The
following list contains the most common refactorings.  Your personal list will
probably be a little different. All of these are things you can do "manually,"
but the idea is to make them into one or two-click operations so that you will
do them much more often. (For a extensive list of refactoring operations, see
<a href="http://www.refactoring.com/catalog/">Martin Fowler's alphabetical list
of refactorings</a>.)</p>

<h5><a id="Extract_SubroutineMethod" />Extract Subroutine/Method</h5>

<p>The IDE should create a new subroutine using the selected code and replace
the selected code with a call to the new subroutine, with the proper
parameters. Here's an example of using the Extract Subroutine refactoring from
Eclipse/EPIC (which uses the <a
href="http://search.cpan.org/dist/Devel-Refactor/">Devel::Refactor</a>
module).</p>

<p>First, you select a chunk of code to turn into a new subroutine, and then
select Extract Subroutine from a context menu. You then get the a dialog box
asking for the name of the new subroutine (shown in Figure 5).</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_before.gif" width="500" height="329" alt="code before Extract
Subroutine refactoring" /><br /><em>Figure 5. Code before Extract Subroutine
refactoring</em></p>

<p>The IDE replaces the selected code with a call to the new subroutine, making
reasonable guesses about the parameters and return values (Figure 6). You may
need to clean up the result manually.</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_after.gif" width="500" height="45" alt="code after Extract
Subroutine refactoring" /><br /><em>Figure 6. Code after Extract
Subroutine</em></p>

<p>Figure 7 shows the new subroutine created by the IDE.  In this case, it needs
no changes, but sometimes you will need to adjust the parameters and/or return
value(s).</p>

<p><img src="/pub/2005/08/25/graphics/extract_subroutine_newsub.gif" width="314" height="241" alt="the new subroutine
created by Extract Subroutine" /><br /><em>Figure 7. The new subroutine created
by Extract Subroutine</em></p>

<p>Ideally, the editor should prompt you to replace similar chunks of code with
calls to the new subroutine.</p>













<h5><a id="Rename_SubroutineMethod" />Rename Subroutine/Method</h5>

<p>The IDE should find all the calls to the subroutine throughout your project
and offer to change them for you. You should be able to see a preview of all of 
the places a change could occur, and to accept or reject each one on a case-by-case
basis. The action should be undoable.</p>

<h5><a id="Rename_Variable" />Rename Variable</h5>

<p>Like Rename Subroutine, this feature should find all occurrences throughout
the project and offer to make the changes for you.</p>

<h5><a id="Change_SubroutineMethod_signature" />Change Subroutine/Method
Signature</h5>

<p>The IDE should be able to make reasonable guesses about whether each
subroutine or method call is supplying the proper parameters. Partly this is to
enable the <a href="?page=2#Syntax-checking">real-time syntax checking mentioned
above</a>,  and partly this is to enable you to select a subroutine declaration
and tell the IDE you want to refactor it by adding or removing a parameter. The
IDE should then prompt you for the change(s) you want to make, do its best
to find all of the existing calls to the subroutine, and offer to correct the
subroutine calls to supply the new parameters.</p>

<p>Obviously, this is an especially tricky thing to do in Perl, where
subroutines fish their parameters out of <code>@_</code>. So the IDE would have
to look carefully at how the code uses <code>shift</code>, <code>@_</code>, and
<code>$_[]</code> in order to have a reasonable guess about the parameters the
subroutine is expecting. In many common cases, though, a Perl IDE could make a
reasonable guess about the parameters, such as in the following two examples,
so that if you added or removed one, it could immediately prompt you about
making corrections throughout the project:</p>

<pre><code>sub doSomething {
    my $gender = shift;
    my $age    = shift;
    # Not too terribly hard to guess that $gender and $age are params
}

sub anotherThing {
    my ($speed,$direction) = @_;
    # No magic needed to guess $speed and $direction are params.
}</code></pre>

<h5><a id="Move_SubroutineMethod_to_different" />Move Subroutine/Method</h5>

<p>This refactoring operation should give you a list or dialog box to choose
the destination file in your project. The IDE should allow you to preview all
of the changes that it would make to accomplish the move, which will include
updating a call to the subroutine/method to use the proper class. At a minimum,
the IDE should show you or list all of the calls to the subroutine so you can make
the appropriate changes yourself. Ideally, the IDE should make a guess about
possible destinations; for example, if <code>$self</code> is a parameter to the
method being moved, then the IDE might try assuming the method is an object
(instance) method and initially only list destination classes that inherit from
the source class, or from which the source class inherits.</p>

<h5><a id="Change_package_name" />Change a Package Name</h5>

<p>As with Rename Subroutine and Rename Variable, when changing a package name,
the IDE should offer to update all existing references throughout your
project.</p>

<h4><a id="Tree_view_of_source" />Tree View and Navigation of Source Files
and Resources</h4>

<p>Another useful feature of good IDEs is being able to view all of the code
for a project, or multiple projects, in a tree format, where you can "fold" and
"unfold" the contents of folders. All of the modern graphical IDEs support this,
even with multiple projects in different languages.</p>

<p>Being able to view your project in this manner gives you both a high-level
overview and the ability to drill down into specific files, and to mix levels
of detail by having some folders show their contents and some not.</p>

<p>For example, Figure 8 shows a partial screen shot from ActiveState's Komodo
IDE.</p>

<p><img src="/pub/2005/08/25/graphics/komodo_code_tree.gif" width="204" height="318" alt="tree view of code in Komodo"
/><br /><em>Figure 8. Tree view of code in Komodo</em></p>

<h4><a id="support_for_unit_tests" />Support for Creating and Running Unit
Tests</h4>

<p>Anyone who has installed Perl modules from CPAN has seen unit tests--these
are the various, often copious, tests that run when you execute the <code>make
test</code> part of the installation process. The vast majority of CPAN modules
include a suite of tests, often using the <a
href="http://search.cpan.org/dist/Test-Harness">Test::Harness</a> and/or <a
href="http://search.cpan.org/dist/Test-Simple">Test::More</a> modules. A good
IDE will make it very easy to both create and run unit tests as you develop
your project.</p>













<p>The most basic form of support for unit tests in an IDE is simply to make it
easy to execute arbitrary scripts from within the IDE.  Create a
<em>test.pl</em> for your project and keep adding tests to it or to a
<em>t/</em> subdirectory as you develop, and keep running the script as you
make changes. All modern IDEs provide at least this minimal capability.</p>

<p>A more sophisticated level of support for unit tests might resemble the Java
IDE feature for tests written in JUnit, where you can select an existing class
file (a <em>.pm</em> file in Perl) and ask the IDE to create a set of stub
tests for every subroutine in the file. (See <a
href="http://www.junit.org/">JUnit</a> and the Perl module <code><a
href="http://search.cpan.org/dist/Test-Unit/">Test::Unit</a></code> for more on
unit tests.) Furthermore, the IDE should support running a set of tests and
giving simple visual feedback on what passed/failed. The standard approach in
the JUnit world is to show either a "green bar" (all passed) or "red bar"
(something failed) and then allow you to see details on failures. Other
nice-to-have features include calculating code-coverage, providing statistical
summaries of tests, etc.</p>

<p>Figure 9 shows a successful run of a Java test suite with Eclipse.</p>

<p><img src="/pub/2005/08/25/graphics/unit_tests_success.gif" width="339" height="199" alt="JUnit test run, success" /><br
/><em>Figure 9. A successful JUnit test run</em></p>

<p>Figure 10 shows the same test run, this time with a failure.</p>

<p><img src="/pub/2005/08/25/graphics/unit_tests_failure.gif" width="339" height="222" alt="JUnit test run, with a failure." /><br />
<em>Figure 10. A JUnit test run with a failure</em></p>

<p>A stack trace of the failure message appears in another part of the window
(cropped out here to save space).  If you double-click on the test that failed
(<code>testInflate</code>), the IDE will open the file
(<code>BalloonTest</code>, in this case) and navigate to the test function.</p>

<p>The central idea is that the IDE should make it as painless as possible to
add and modify and run tests, so you will do more of it during development.</p>

<h4><a id="Language-specific_help" />Language-Specific Help</h4>

<p>This is a fairly straightforward idea--the IDE should be able to find and
display the appropriate documentation for any keyword in your code, so if you
highlight <code>push</code> and ask for help, you should see the
<code>push</code> entry from the Perl documentation. If you highlight a method
or subroutine or other symbol name from an imported module, the IDE should
display the module's documentation for the selected item. Of course, this
requires that the documentation be available in a consistent, machine-readable
form, which is only sometimes true.</p>

<h4><a id="Debugger" />Debugger with Real-Time Display of Results</h4>

<p>All modern IDEs offer support for running your code under a debugger,
usually with visual display of what's going on, including the state of
variables. The <a
href="http://aspn.activestate.com/ASPN/docs/Komodo/3.1/komodo-doc-debugperl.html#debugperl_top">Komodo
IDE supports debugging Perl that is running either locally or remotely</a>.</p>

<p>Typical support for debugging in an IDE includes the ability to set
breakpoints, monitor the state of variables, etc.  Basically, the IDE should
provide support for all of the features of the debugger itself.  Graphical IDEs
should provide a visual display of what is going on.</p>

<h4><a id="Automatic_reformatting" />Automatic Code Reformatting</h4>

<p>This means automatically or on-demand re-indenting and other reformatting of
code. For example, when you cut and paste a chunk of code, the IDE should
support reformatting the chunk to match the indentation of its new location. If you change the number of spaces or tabs for each level of indentation, or
your convention for the placement of curly braces, then the IDE should support
adjusting an entire file or all files in your project.</p>

<h4><a id="handling_of_multiple_languages" />Seamless Handling of Multiple
Languages</h4>

<p>Many large software projects involve multiple languages. This is almost
universally true in the case of web applications, where the user interface
typically uses HTML, CSS, and JavaScript, and the back end uses one or more of
Perl, PHP, Java, Python, Ruby, etc. It is very helpful to have development
tools that seamlessly integrate work done in all of the languages.  This is
becoming quite common. For example, both Komodo and Eclipse support multiple
languages.</p>

<h4><a id="Automated_build_and_test" />Automated Building and Testing</h4>

<p>This feature can be very basic by making it easy to run an arbitrary script
from within the IDE and to see its output. This could be as simple as having
the IDE configured to have a one-click way of running the traditional Perl
module build-and-test commands:</p>

<pre><code>$ perl Makefile.PL
$ make
$ make test</code></pre>

<p>A more advanced version of this feature might involve having the IDE create
stub code to test all of the subroutines in an existing file, or to run all of the
scripts in a specified directory under <code>Test::Harness</code>, or to run a
set of tests using <a
href="http://search.cpan.org/perldoc/Test::Unit::TestRunner">Test::Unit::TestRunner</a>
or <a
href="http://search.cpan.org/perldoc/Test::Unit::TkTestRunner">Test::Unit::TkTestRunner</a>.
(The latter provides a GUI testing framework.)</p>













<h3>Conclusion and Recommendations</h3>

<p>While there are many tools for helping Perl development, the current state
of the Perl toolbox is still years behind those of other languages--perhaps three to five years
behind, when compared to Java tools. While there are several tools for Java that
have all the features described above, virtually none for Perl have all of them.
On the other hand, things are looking up; they are better now than a year ago.
It's possible to close that gap in a year or two.</p>

<p>A couple of obvious areas where improvements could be somewhat easy are
adding more features to EPIC and Komodo.  EPIC is open source, so there is
potentially a wider pool of talent that could contribute. On the other hand,
Komodo has a company with money behind it, so people actually get paid to
improve it. Hopefully both tools will get better with time.</p>

<p>Another interesting possibility is the development of new IDEs or adding to
existing ones by using <a
href="/pub/a/2005/06/09/ppi.html">Adam Kennedy's PPI
module</a>, which provides the ability to parse Perl documents into a
reasonable abstract syntax tree and to manipulate the elements and re-compose
the document. There is a <a
href="http://search.cpan.org/dist/Text-Editor-Vip/">new Perl editor project,
VIP, that is in the design stages</a> and is intended to be "pluggable" and to have
special features to support pair programming.</p>

<p>Finally, I've gathered a couple of lists of links for related material. The
first list below consist of IDEs and graphical editors for Perl, and the second
list consists of various related articles and websites. I hope this is all
inspirational and helpful.</p>

<h3>Current IDEs for Perl</h3>

<p>The listed IDEs support Perl. The list is undoubtedly
incomplete, but should form a good starting point for anyone wishing
to look into this further.</p>

<ul>
<li><p><a href="http://www.latenightsw.com/affrus/">Affrus</a></p>

<p>Perl only, Mac OS X only. Closed source (and hence not extensible by
users). Primarily designed for CGI and standalone scripts. Free demo
available. $99 to purchase.  (See the <a
href="/pub/a/2004/05/14/affrus.html">Perl.com review of
Affrus</a> to learn more.)</p></li>

<li><p><a href="http://e-p-i-c.sf.net/">Eclipse/EPIC</a></p>

<p>EPIC is a plugin for the <a href="http://www.eclipse.org/">Eclipse
platform</a>. Eclipse is open-source and cross platform
(Windows/Mac/Linux/Solaris, etc.). Once you have Eclipse installed, <a
href="http://e-p-i-c.sf.net/updates">install the EPIC plugin from within the
Eclipse application</a> using the <a href="http://e-p-i-c.sf.net/updates/">EPIC
update URL</a>.  Eclipse supports Java, and with plugins, C/C++, COBOL, Perl,
PHP, UML2, Python, Ruby, XML, and more. There is a large and active community
around Eclipse.</p></li>

<li>Emacs is the mother of all
text-editor/development-environment/adventure-game/all-in-one tools. Expert
programmers use it widely and there are numerous enhancements for working with
particular languages, including, of course, Perl. <a
href="http://www.emacswiki.org/cgi-bin/wiki/CPerlMode">Emacs, with
CPerlMode</a>,  is a richly featured IDE for Perl, albeit a non-GUI IDE (which,
for some people, makes it even better). <a
href="http://groups.yahoo.com/group/extremeperl/files/">A set of extensions for
CPerlMode are available</a> but you need to join the Yahoo Extreme Perl group
to get to them.</li>

<li><p><a href="http://www.activestate.com/Products/Komodo/">Komodo</a></p>

<p>This runs on Linux, Solaris, and Windows. Free demo; $29.95 for personal and
student use, $295 for commercial use.  It supports Perl, PHP, Python, Tcl, and
XSLT.</p></li>

<li><p><a href="http://www.elora.hostings.com/SOFTWARE/page/">PAGE</a></p>

<p>PAGE runs only on Windows (9x/ME/NT/2000/XP). It is a Rapid
Application Development tool for Perl and comes in three versions: Free,
Standard ($10), and Enterprise ($50). PAGE provides a several "wizards" for
creating scripts, modules (packages), web forms, and even database
applications.</p></li>

<li><p><a href="http://www.enginsite.com/Perl.htm">Perl Editor</a></p>

<p>This closed source program runs only on Windows (9x/NT/2000/XP). It has a GUI
code profiler, and the Pro version has a regular expression tester and built-in
web server (for CGI testing, etc.). Perl Editor claims to have the best
debugger on the market. It also comes with GUI tools for managing MySQL
databases. $69.95 to purchase.</p></li>

<li><p><a href="http://vim.sourceforge.net/"><code>vim</code></a></p>

<p>The well-known descendent of <code>vi</code> is a powerful and flexible text
editor with many plugins and extensions. Have a look at the
<a href="http://vim.sourceforge.net/"><code>vim</code> scripts </a>; for
example, <a href="http://vim.sourceforge.net/scripts/script.php?script_id=556">vim.sourceforge.net/scripts/script.php?script_id=556</a>
and <a href="http://vim.sourceforge.net/scripts/script.php?script_id=281">vim.sourceforge.net/scripts/script.php?script_id=281</a>.</p></li>

<li><p><a href="http://www.helpconsulting.net/visiperl/">visiPerl</a></p>

<p>This is a closed source application that runs on Win9x/NT/2000.  It handles
Perl and HTML and has code templates, being designed for website building.
visiPerl includes a built-in web server for testing and an FTP client for code
deployment.  There is a free demo, or you can purchase it for $59.</p></li>

</ul>

<h3>Related Topics</h3>

<ul>

<li><a href="http://www.artima.com/intv/testdriven.html">A conversation about
Test-Driven Development</a></li>

<li>"<a href="http://www.petdance.com/perl/automated-testing/">Automated Testing
With Perl</a>," Andy Lester's presentation on doing automated testing in
Perl</li>

<li><a href="http://www.extremeperl.org/bk/home">Extreme Perl book</a></li>

<li><a href="http://groups.yahoo.com/group/extremeperl/">Extreme Perl mailing
list</a></li>

<li><a href="http://www.jera.com/techinfo/xpfaq.html">eXtreme Programming FAQ</a></li>

<li><a href="http://agilemanifesto.org/">Manifesto for Agile Software Development</a></li>

<li>"<a href="/pub/a/2005/06/09/ppi.html">Parse Perl Independently</a>," an article about Adam Kennedy's PPI module</li>

<li><a href="http://www.testdriven.com/">testdriven.com</a></li>

<li><a href="http://www.junit.org/">JUnit</a></li>

<li>Jon Udell's article on "<a
href="http://weblog.infoworld.com/udell/2005/05/23.html#a1236">Tools for
Dynamic Languages</a>"</li>

<li><a href="http://www.refactoring.com/">Refactoring home page</a></li>

<li><a href="http://www.xprogramming.com/">XProgramming.com</a>: Resources for
and about Agile Software Development</li>

</ul>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-972" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/08/commandline.html" rel="bookmark">Perl Command-Line Options</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                <abbr class="published" title="2004-08-10T00:00:00-08:00">August 10, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p>Perl has a large number of command-line options that can help to make your programs more concise and open up many new possibilities for one-off command-line scripts using Perl.
In this article we'll look at some of the most useful of these.</p>

<h3><a name="Safety_Net_Options">Safety Net Options</a></h3>

<p>There are three options I like to think of as a &quot;safety net,&quot; as they can stop you from making a fool of yourself when you're doing something particularly clever (or stupid!). And while they aren't ever necessary,
it's rare that you'll find an experienced Perl programmer working without them.</p>

<p>The first of these is <code>-c</code>.
This option compiles your program without running it.
This is a great way to ensure that you haven't introduced any syntax errors while you've been editing a program.
When I'm working on a program I never go more than a few minutes without saving the file and running:</p>

<pre><code>  $ perl -c &lt;program&gt;</code></pre>

<csperl file="grab" domain="on" record="b/718" template="b/article_sidebar.view">

<p>This makes sure that the program still compiles. It's far easier to fix problems when you've only made a few changes than it is to type in a couple of hundred of lines of code and then try to debug that.</p>

<p>The next safety net is the <code>-w</code> option. This turns on warnings that Perl will then give you if it finds any of a number of problems in your code. Each of these warnings is a potential bug in your program and should be investigated. In modern versions of Perl (since 5.6.0) the <code>-w</code> option has been replaced by the <code>use warnings</code> pragma, which is more flexible than the command-line option so you shouldn't use <code>-w</code> in new code.</p>

<p>The final safety net is the <code>-T</code> option. This option puts Perl into &quot;taint mode.&quot; In this mode, Perl inherently distrusts any data that it receives from outside the program's source -- for example, data passed in on the command line, read from a file, or taken from CGI parameters.</p>

<p>Tainted data cannot be used in an expression that interacts with the outside world -- for example, you can't use it in a call to <code>system</code> or as the name of a file to open. The full list of restrictions is given in the <code>perlsec</code> manual page.</p>

<p>In order to use this data in any of these potentially dangerous operations you need to untaint it. You do this by checking it against a regular expression. A detailed discussion of taint mode would fill an article all by itself so I won't go into any more details here, but using taint mode is a very good habit to get into -- particularly if you are writing programs (like CGI programs) that take unknown input from users.</p>

<p>Actually there's one other option that belongs in this set and that's <code>-d</code>. This option puts you into the Perl debugger. This is also a subject that's too big for this article, but I recommend you look at &quot;perldoc perldebug&quot; or Richard Foley's <i>Perl Debugger Pocket Reference</i>.</p>

<h3><a name="Command_Line_Programs">Command-Line Programs</a></h3>

<p>The next few options I want to look at make it easy to run short Perl programs on the command line. The first one, <code>-e</code>, allows you to define Perl code to be executed by the compiler. For example, it's not necessary to write a &quot;Hello World&quot; program in Perl when you can just type this at the command line.</p>

<pre><code>  $ perl -e 'print &quot;Hello World\n&quot;'</code></pre>

<p>You can have as many <code>-e</code> options as you like and they will be run in the order that they appear on the command line.</p>

<pre><code>  $ perl -e 'print &quot;Hello &quot;;' -e 'print &quot;World\n&quot;'</code></pre>

<p>Notice that like a normal Perl program, all but the last line of code needs to end with a <code>;</code> character.</p>

<p>Although it is possible to use a <code>-e</code> option to load a module, Perl gives you the <code>-M</code> option to make that easier.</p>

<pre><code>  $ perl -MLWP::Simple -e'print head &quot;http://www.example.com&quot;'</code></pre>

<p>So <code>-Mmodule</code> is the same as <code>use module</code>. If the module has default imports you don't want imported then you can use <code>-m</code> instead. Using <code>-mmodule</code> is the equivalent of <code>use module()</code>, which turns off any default imports. For example, the following command displays nothing as the <code>head</code> function won't have been imported into your <code>main</code> package:</p>

<pre><code>  $ perl -mLWP::Simple -e'print head &quot;http://www.example.com&quot;'</code></pre>

<p>The <code>-M</code> and <code>-m</code> options implement various nice pieces of syntactic sugar to make using them as easy as possible. Any arguments you would normally pass to the <code>use</code> statement can be listed following an <code>=</code> sign.</p>

<pre><code>  $ perl -MCGI=:standard -e'print header'</code></pre>

<p>This command imports the &quot;:standard&quot; export set from CGI.pm and therefore the <code>header</code> function becomes available to your program. Multiple arguments can be listed using quotes and commas as separators.</p>

<pre><code>  $ perl -MCGI='header,start_html' -e'print header, start_html'</code></pre>

<p>In this example we've just imported the two methods <code>header</code> and <code>start_html</code> as those are the only ones we are using.</p>













<h3><a name="Implicit_Loops">Implicit Loops</a></h3>

<p>Two other command-line options, <code>-n</code> and <code>-p</code>, add loops around your <code>-e</code> code. They are both very useful for processing files a line at a time. If you type something like:</p>

<pre><code>  $ perl -n -e 'some code' file1</code></pre>

<p>Then Perl will interpret that as:</p>

<pre><code>  LINE:
    while (&lt;&gt;) {
      # your code goes here
    }</code></pre>

<p>Notice the use of the empty file input operator, which will read all of the files given on the command line a line at a time. Each line of the input files will be put, in turn, into <code>$_</code> so that you can process it. As a example, try:</p>

<pre><code>  $ perl -n -e 'print &quot;$. - $_&quot;' file</code></pre>

<p>This gets converted to:</p>

<pre><code>  LINE:
    while (&lt;&gt;) {
      print &quot;$. - $_&quot;
    }</code></pre>

<p>This code prints each line of the file together with the current line number.</p>

<p>The <code>-p</code> option makes that even easier. This option always prints the contents of <code>$_</code> each time around the loop. It creates code like this:</p>

<pre><code>  LINE:
    while (&lt;&gt;) {
      # your code goes here
    } continue {
      print or die &quot;-p destination: $!\n&quot;;
    }</code></pre>

<p>This uses the little-used <code>continue</code> block on a <code>while</code> loop to ensure that the <code>print</code> statement is always called.</p>

<p>Using this option, our line number generator becomes:</p>

<pre><code>  $ perl -p -e '$_ = &quot;$. - $_&quot;'</code></pre>

<p>In this case there is no need for the explicit call to print as <code>-p</code> calls <code>print</code> for us.</p>

<p>Notice that the <code>LINE:</code> label is there so that you can easily move to the next input record no matter how deep in embedded loops you are. You do this using <code>next LINE</code>.</p>

<pre><code>  $ perl -n -e 'next LINE unless /pattern/; print $_'</code></pre>

<p>Of course, that example would probably be written as:</p>

<pre><code>  $ perl -n -e 'print unless /pattern/'</code></pre>

<p>But in a more complex example, the <code>next LINE</code> construct could potentially make your code easier to understand.</p>

<p>If you need to have processing carried out either before or after the main code loop, you can use a <code>BEGIN</code> or <code>END</code> block. Here's a pretty basic way to count the words in a text file:</p>

<pre><code>  $ perl -ne 'END { print $t } @w = /(\w+)/g; $t += @w' file.txt</code></pre>

<p>Each time round the loop we extract all of the words (defined as contiguous runs of <code>\w</code> characters into <code>@w</code> and add the number of elements in <code>@w</code> to our total variable <code>$t</code>. The <code>END</code> block runs after the loop has completed and prints out the final value in <code>$t</code>.</p>

<p>Of course, people's definition of what constitutes a valid word can vary. The definition used by the Unix <code>wc</code> (word count) program is a string of characters delimited by whitespace. We can simulate that by changing our program slightly, like this:</p>

<pre><code>  $ perl -ne 'END { print $x } @w = split; $x += @w' file.txt</code></pre>

<p>But there are a couple of command-line options that will make that even simpler. Firstly the <code>-a</code> option turns on <i>autosplit</i> mode. In this mode, each input record is split and the resulting list of elements is stored in an array called <code>@F</code>. This means that we can write our word-count program like this:</p>

<pre><code>  $ perl -ane 'END {print $x} $x += @F' file.txt</code></pre>

<p>The default value used to split the record is one or more whitespace characters. It is, of course, possible that you might want to split the input record on another character and you can control this with the <code>-F</code> option. So if we wanted to change our program to split on all non-word characters we could do something like this:</p>

<pre><code>  $ perl -F'\W' -ane 'END {print $x} $x += @F' file.txt</code></pre>

<p>For a more powerful example of what we can do with these options, let's look at the Unix password file. This is a simple, colon-delimited text file with one record per user. The seventh column in this file is the path of the login shell for that user. We can therefore produce a report of the most-used shells on a given system with a command-line script like this:</p>

<pre><code>  $ perl -F':' -ane '$s{$F[6]}++;' \
  &gt; -e 'END { print &quot;$_ : $s{$_}&quot; for keys %s }' /etc/passwd</code></pre>

<p>OK, so it's longer than one line and the output isn't sorted (although it's quite easy to add sorting), but perhaps you can get a sense of the kinds of things that you can do from the command line.</p>

<h3><a name="Record_Separators">Record Separators</a></h3>

<p>In my previous article I talked a lot about <code>$/</code> and <code>$\</code> -- the input and output record separators. <code>$/</code> defines how much data Perl will read every time you ask it for the next record from a filehandle, and <code>$\</code> contains a value that is appended to the end of any data that your program prints. The default value of <code>$/</code> is a new line and the default value of <code>$\</code> is an empty string (which is why you usually explicity add a new line to your calls to <code>print</code>).</p>

<p>Now in the implicit loops set up by <code>-n</code> and <code>-p</code> it can be useful to define the values of <code>$/</code> and <code>$\</code>. You could, of course, do this in a <code>BEGIN</code> block, but Perl gives you an easier option with the <code>-0</code> (that's a zero) and <code>-l</code> (that's an L) command-line options. This can get a little confusing (well, it confuses me) so I'll go slowly.</p>

<p>Using <code>-0</code> and giving it a hexadecimal or octal number sets <code>$/</code> to that value. The special value <code>00</code> puts Perl in paragraph mode and the special value <code>0777</code> puts Perl into file slurp mode. These are the same as setting <code>$/</code> to an empty string and <code>undef</code> respectively.</p>

<p>Using <code>-l</code> and giving it no value has two effects. Firstly, it automatically <code>chomp</code>s the input record, and secondly, it sets <code>$\</code> equal to <code>$/</code>. If you give <code>-l</code> an octal number (and unlike <code>-0</code> it doesn't accept hex numbers) it sets <code>$\</code> to the character represented by that number and also turns on auto-<code>chomp</code>ing.</p>

<p>To be honest, I rarely use the <code>-0</code> option and I usually use the <code>-l</code> option without an argument just to add a new line to the end of each line of output. For example, I'd usually write my original &quot;Hello World&quot; example as:</p>

<pre><code>  $ perl -le 'print &quot;Hello World&quot;'</code></pre>

<p>If I'm doing something that requires changing the values of the input and output record separators then I'm probably out of the realm of command-line scripts.</p>

<h3><a name="In-Place_Editing">In-Place Editing</a></h3>

<p>With the options that we have already seen, it's very easy to build up some powerful command-line programs. It's very common to see command line programs that use Unix I/O redirection like this:</p>

<pre><code>  $ perl -pe 'some code' &lt; input.txt &gt; output.txt</code></pre>

<p>This takes records from <code>input.txt</code>, carries out some kind of transformation, and writes the transformed record to <code>output.txt</code>. In some cases you don't want to write the changed data to a different file, it's often more convenient if the altered data is written back to the same file.</p>

<p>You can get the appearance of this using the <code>-i</code> option. Actually, Perl renames the input file and reads from this renamed version while writing to a new file with the original name. If <code>-i</code> is given a string argument, then that string is appended to the name of the original version of the file. For example, to change all occurrences of &quot;PHP&quot; to &quot;Perl&quot; in a data file you could write something like this:</p>

<pre><code>  $ perl -i -pe 's/\bPHP\b/Perl/g' file.txt</code></pre>

<p>Perl reads the input file a line at a time, making the substitution, and then writing the results back to a new file that has the same name as the original file -- effectively overwriting it. If you're not so confident of your Perl abilities you might take a backup of the original file, like this:</p>

<pre><code>  $perl -i.bak -pe 's/\bPHP\b/Perl/g' file.txt</code></pre>

<p>You'll end up with the transformed data in <code>file.txt</code> and the original file backed up in <code>file.txt.bak</code>. If you're a fan of vi then you might like to use <code>-i~</code> instead.</p>

<h3><a name="Further_Information">Further Information</a></h3>

<p>Perl has a large number of command-line options. This article has simply listed a few of the most useful. For the full list (and for more information on the ones covered here) see the &quot;perlrun&quot; manual page.</p>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-940" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/06/recorder.html" rel="bookmark">Web Testing with HTTP::Recorder</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Linda Julien</span> on <abbr class="published" title="2004-06-04T00:00:00-08:00">June  4, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p><code>HTTP::Recorder</code> is a browser-independent recorder that
records interactions with web sites and produces scripts for
automated playback.  Recorder produces <code>WWW::Mechanize</code>
scripts by default (see <a href="http://search.cpan.org/search?query=www%3A%3Amechanize&mode=all"><code>WWW::Mechanize</code></a> by Andy Lester),
but provides functionality to use your own custom logger.</p>

<h3>Why Use <code>HTTP::Recorder</code>?</h3>

<p>Simply speaking, <code>HTTP::Recorder</code> removes a great deal
of the tedium from writing scripts for web automation.  If you're like
me, you'd rather spend your time writing code that's interesting and
challenging, rather than digging through HTML files, looking for the
names of forms an fields, so that you can write your automation
scripts.  <code>HTTP::Recorder</code> records what you do as you do
it, so that you can focus on the things you care about.</p>

<h4>Automated Testing</h4>

<p>We all know that testing our code is good, and that writing
automated tests that can be run again and again to check for
regressions is even better.  However, writing test scripts by hand can
be tedious and prone to errors.  You're more likely to write tests if
it's easy to do so.  The biggest obstacle to testing shouldn't be the
mechanics of getting the tests written &mdash; it should be figuring
out what needs to be tested, and how best to test it.</p>

<p>Part of your test suite should be devoted to testing things the way
the user uses them, and <code>HTTP::Recorder</code> makes it easy to
produce automation to do that, which allows you to put your energy
into the parts of your code that need your attention and your
expertise.</p>

<h4>Automate Repetitive Tasks</h4>

<p>When you think about web automation, the first thing you think of
may be automated testing, but there are other uses for automation as
well:</p>

<ul>
<li>Check your bank balance.</li>
<li>Check airline fares.</li>
<li>Check movie times.</li>
</ul>

<h3>How to Set It Up</h3>

<h4>Use It with a Web Proxy</h4>

<p>One way to use <code>HTTP::Recorder</code> (as recommended in the
POD) is to set it as the user agent of a web proxy (see <a href="http://search.cpan.org/search?query=http%3A%3Aproxy&mode=all"><code>HTTP::Proxy</code></a>
by Phillipe "BooK" Bruhat).  Start the proxy running like this:</p>

<pre><code>
    #!/usr/bin/perl

    use <code>HTTP::Proxy</code>;
    use <code>HTTP::Recorder</code>;

    my $proxy = HTTP::Proxy->new();

    # create a new HTTP::Recorder object
    my $agent = new HTTP::Recorder;

    # set the log file (optional)
    $agent->file("/tmp/myfile");

    # set HTTP::Recorder as the agent for the proxy
    $proxy->agent( $agent );

    # start the proxy
    $proxy->start();

    1;
</code></pre>

<p>Then, instruct your favorite web browser to use your new proxy for
HTTP traffic.</p>

<h4>Other Ways to Use It</h4>

<p>Since <code>HTTP::Recorder</code> is a subclass of LWP::UserAgent,
so you can use it in any way that you can use its parent class.</p>

<h3>How to Use It</h3>

<p>Once you've set up <code>HTTP::Recorder</code>, just navigate to
web pages, follow links, and fill in forms the way you normally do,
with the web browser of your choice.  <code>HTTP::Recorder</code> will
record your actions and produce a <code>WWW::Mechanize</code> script
that you can use to replay those actions.</p>

<p>The script is written to a logfile.  By default, this file is
<code>/tmp/scriptfile</code>, but you can specify another pathname
when you set things up.  See <a href="#config">Configuration
Options</a> for information about configuring the logfile.</p>

<h4><a name="control_panel"><code>HTTP::Recorder</code> Control Panel</a></h4>

<p>The <code>HTTP::Recorder</code> control panel allows you to use to
view and edit scripts as you create them.  By default, you can access
the control panel by using the <code>HTTP::Recorder</code> UserAgent
to access the control URL.  By default, the control URL is
<code>http://http-recorder/</code>, but this address is configurable.
See <a href="#config">Configuration Options</a> for more information
about setting the control URL.</p>

<p>The control panel won't automatically refresh , but if you create
<code>HTTP::Recorder</code> with <code>showwindow => 1</code>, a
JavaScript popup window will be opened and refreshed every time
something is recorded.</p>

<p><img src="/pub/2004/06/04/graphics/control.jpg" border="0" width="400" height="425" alt="" /></p>

<p><b>Goto Page.</b> You can enter a URL in the control panel to begin
a recording session.  For SSL sessions, the initial URL must be
entered into this field rather than into the browser.</p>

<p><b>Current Script.</b> The current script is displayed in a
textfield, which you can edit as you create it.  Changes you make in
the control panel won't be saved until you click the Update button.</p>

<p><b>Update.</b> Saves changes made the script via the control panel.
If you prefer to edit your script as you create it, you can save your
changes as you make them.</p>

<p><b>Clear.</b> Deletes the current script and clears the text field.</p>

<p><b>Reset.</b> Reverts the text field to the currently saved version
of the script.  Any changes you've made to the script won't be applied
if you haven't clicked Update.</p>

<p><b>Download.</b> Displays a plain text version of the script,
suitable for saving.</p>

<p><b>Close.</b>  Closes the window (using JavaScript).</p>













<h4>Updating Scripts as They're Recorded</h4>

<p>You can record many things, and then turn the recordings into
scripts later, or you can make changes and additions as you go by
editing the script in the <a href="/pub/a/2004/06/04/recorder.html?page=1#control_panel">Control Panel</a>.</p>

<p>For example, if you record filling in this form and clicking the
Submit button:</p>

<p><img src="/pub/2004/06/04/graphics/form1.jpg" width="271" height="36" alt="" /></p>

<p><code>HTTP::Recorder</code> produces the following lines of code:</p>

<pre><code>    $agent->form_name("form1");
    $agent->field("name", "Linda Julien");
    $agent->submit_form(form_name => "form1");
</code></pre>

<p>However, if you're writing automated tests, you probably don't want
to enter hard-coded values into the form.  You may want to re-write
these lines of code so that they'll accept a variable for the value of
the <code>name</code> field.</p>

<p>You can change the code to look like this:</p>

<pre><code>    my $name = "Linda Julien";

    $agent->form_name("form1");
    $agent->field("name", $name);
    $agent->submit_form(form_name => "form1");
</code></pre>

<p>Or even this:</p>

<pre><code>    sub fill_in_name {
      my $name = shift;

      $agent->form_name("form1");
      $agent->field("name", $name);
      $agent->submit_form(form_name => "form1");
    }

    fill_in_name("Linda Julien");
</code></pre>

<p>Then click the Update button.  <code>HTTP::Recorder</code> will
save your changes, and you can continue recording as before.</p>

<p>You may also want to add tests as you go, making sure that the
results of submitting the form were what you expected:</p>

<p><img src="/pub/2004/06/04/graphics/form2.jpg" width="242" height="69" alt="" /></p>

<p>You can add tests to the script like this:</p>

<pre><code>    sub fill_in_name {
      my $name = shift;

      $agent->form_name("form1");
      $agent->field("name", $name);
      $agent->submit_form(form_name => "form1");
    }

    my $entry = "Linda Julien";
    fill_in_name($entry);

    $agent->content =~ /You entered this name: (.*)/;
    is ($1, $entry);
</code></pre>

<h4>Using <code>HTTP::Recorder</code> with SSL</h4>

<p>In order to do what it does, <code>HTTP::Recorder</code> relies on
the ability to see and modify the contents of requests and their
resulting responses...and the whole point of SSL is to make sure you
can't easily do that.  <code>HTTP::Recorder</code> works around this,
however, by handling the SSL connection to the server itself, and and
communicating with your browser via plain HTTP.</p>

<p><i><b>Caution:</b> Keep in mind that communication between your
browser and <code>HTTP::Recorder</code> isn't encrypted, so take care
when recording sensitive information, like passwords or credit card
numbers.  If you're running the Recorder as a proxy on your local
machine, you have less to worry about than if you're running it as a
proxy on a remote machine.  The resulting script for playback
will be encrypted as usual.</i></p>

<p>If you want to record SSL sessions, here's how you do it:</p>

<p>Start at the control panel, and enter the initial URL there rather
than in your browser.  Then interact with the web site as you normally
would.  <code>HTTP::Recorder</code> will record form submissions,
following links, etc.</p>

<h4>Replaying your Scripts</h4>

<p><code>HTTP::Recorder</code> getting pages, following links, filling
in fields and submitting forms, etc., but it doesn't (at this point)
generate a complete perl script.  Remember that you'll need to add
standard script headers and initialize the <code>WWW::Mechanize</code>
agent, with something like this:</p>

<pre><code>#!/usr/bin/perl

    use strict;
    use warnings;
    use WWW::Mechanize;
    use Test::More qw(no_plan);

    my $agent = WWW::Mechanize->new();
</code></pre>

<h4><a name="config">Configuration Options</a></h4>

<p><b>Output file.</b>  You can change the filename for the scripts
that <code>HTTP::Recorder</code> generates with the
<code>$recorder->file([$value])</code> method.  The default output
file is '/tmp/scriptfile'.</p>

<p><b>Prefix.</b> <code>HTTP::Recorder</code> adds parameters to link
URLs and adds fields to forms.  By default, its parameters begin with
"rec-", but you can change this prefix with the
<code>$recorder->prefix([$value])</code> method.</p>

<p><b>Logger.</b> The <code>HTTP::Recorder</code> distribution
includes a default logging module, which outputs
<code>WWW::Mechanize</code> scripts.  You can change the logger with
the <code>$recorder->logger([$value])</code> method, replacing it with
a logger that:</p>

<ul>

<li>subclasses the standard logger to provice special functionality
unique to your site</li>

<li>outputs an entirely different type of script</li>

</ul>

<p>RT (Request Tracker) 3.1 by <a href="http://www.bestpractical.com/">Best Practical Solutions</a> has
a Query Builder that's a good example of a page that benefits from a
custom logger:</p>

<p><img src="/pub/2004/06/04/graphics/BuildQuery.jpg" width="400" height="312" alt="" /></p>













<p>This page has several Field/Operator/Value groupings.  Left to its
own devices, the default <code>HTTP::Recorder::Logger</code> will
record every field for which a value has been set:</p>

<pre><code>    $agent->form_name("BuildQuery");
    $agent->field("ActorOp", "=");
    $agent->field("AndOr", "AND");
    $agent->field("TimeOp", "&lt;");
    $agent->field("WatcherOp", "LIKE");
    $agent->field("QueueOp", "=");
    $agent->field("PriorityOp", "&lt;");
    $agent->field("LinksOp", "=");
    $agent->field("idOp", "&lt;");
    $agent->field("AttachmentField", "Subject");
    $agent->field("ActorField", "Owner");
    $agent->field("PriorityField", "Priority");
    $agent->field("StatusOp", "=");
    $agent->field("DateField", "Created");
    $agent->field("TimeField", "TimeWorked");
    $agent->field("LinksField", "HasMember");
    $agent->field("WatcherField", "Requestor.EmailAddress");
    $agent->field("AttachmentOp", "LIKE");
    $agent->field("ValueOfAttachment", "foo");
    $agent->field("DateOp", "&lt;");
    $agent->submit_form(form_name => "BuildQuery");
</code></pre>

<p>But on this page, there's no need to record setting the values of
fields (XField) and operators (XOp) unless a value (ValueOfX) has
actually been set.  We can do this with a custom logger that checks
for the presence of a value, and only records the value of the
field and operator fields if the value field has been set:</p>

<pre><code>    package HTTP::Recorder::RTLogger;

    use strict;
    use warnings;
    use HTTP::Recorder::Logger;
    our @ISA = qw( HTTP::Recorder::Logger );

    sub SetFieldsAndSubmit {
        my $self = shift;
        my %args = (
		    name => "",
		    number => undef,
		    fields => {},
		    button_name => {},
		    button_value => {},
		    button_number => {},
		    @_
		    );

	$self->SetForm(name => $args{name}, number => $args{number});
	my %fields = %{$args{fields}};
	foreach my $field (sort keys %fields) {
	    if ( $args{name} eq 'BuildQuery' &amp;&amp;
		 ($field =~ /(.*)Op$/ || $field =~ /(.*)Field$/) &amp;&amp;
		 !exists ($fields{'ValueOf' . $1})) {
		next;
	    }
	    $self->SetField(name => $field, 
			    value => $args{fields}->{$field});
	}
	$self->Submit(name => $args{name}, 
		      number => $args{number},
		      button_name => $args{button_name},
		      button_value => $args{button_value},
		      button_number => $args{button_number},
		      );
    }

    1;
</code></pre>

<p>Tell <code>HTTP::Recorder</code> to use the custom logger like
this:</p>

<pre><code>    my $logger = new HTTP::Recorder::RTLogger;
    $agent->logger($logger);
</code></pre>

<p>And it will record a much more reasonable number of things:</p>

<pre><code>    $agent->form_name("BuildQuery");
    $agent->field("AndOr", "AND");
    $agent->field("AttachmentField", "Subject");
    $agent->field("AttachmentOp", "LIKE");
    $agent->field("ValueOfAttachment", "foo");
    $agent->submit_form(form_name => "BuildQuery");
</code></pre>

<p><b>Control panel.</b> By default, you can access the
<code>HTTP::Recorder</code> control panel by using the Recorder to get
<code>http://http-recorder</code>.  You can change this URL with the
<code>$recorder->control([$value])</code> method.</p>

<h5>Logger Options</h5>

<p><b>Agent name.</b> By default, <code>HTTP::Recorder::Logger</code>
outputs scripts with the agent name <code>$agent</code>:</p>

<pre>
     $agent->follow_link(text => "Foo", n => 1);
</pre>

<p>However, if you prefer a different agent name (in order to drop
recorded lines into existing scripts, conform to company conventions,
etc.), you can change that with the
<code>$logger->agentname([value])</code> method:</p>

<pre>
     $recorder->agentname("mech");
</pre>

<p>will produce the following:</p>

<pre>
     $mech->follow_link(text => "Foo", n => 1);
</pre>

<h3>How <code>HTTP::Recorder</code> Works</h3>

<p>The biggest challenge to writing a web recorder is knowing what the
user is doing, so that it can be recorded.  A proxy can watch requests
and responses go by, the only thing you'll learn is the URL that was
requested and its parameters.  <code>HTTP::Recorder</code> solves this
problem by rewriting HTTP responses as they come through, and adding
additional information to the page's links and forms, so that it can
extract that information again when the next request comes through.</p>

<p>As an example, a page might contain a link like this:</p>

<pre><code>    &lt;a href="http://www.cpan.org/"&gt;CPAN&lt;/a&gt;</code></pre>

<p>If the user follows the link, and we want to record it, we need to
know all of the relevant information about the action, so that we can
produce a line of code that will replay the action.  This includes:</p>

<ul>
<li>the fact that a link was followed.</li>
<li>the text of the link.</li>
<li>the URL of the link.</li>
<li>the index (in case there are multiple links on the page of the
same name).</li>
</ul>

<p><code>HTTP::Recorder</code> overloads LWP::UserAgent's
<code>send_request</code> method, so that it can see requests and
responses as they come through, and modify them as needed.</p>

<p><code>HTTP::Recorder</code> rewrites the link so that it looks like this:</p>

<p><code>&lt;a href="http://www.cpan.org/?rec-url=http%3A%2F%2Fwww.cpan.org%2F&amp;rec-action=follow&amp;rec-text=CPAN&amp;rec-index=1"&gt;CPAN&lt;/a&gt;
</code></p>

<p>So, with the rewritten page, if the user follows this link, the
request will contain all of the information needed to record the
action.</p>

<p>Forms are handled likewise, with additional fields being added to
the form so that the information can be extracted later.
<code>HTTP::Recorder</code> then removes the added parameters from the
resulting request, and forwards the request along in something close
to its originally intended state.</p>

<h3>Looking Ahead</h3>

<p><code>HTTP::Recorder</code> won't record 100% of every script you
need to write, and while future versions will undoubtedly have more
features, they still won't write your scripts for you.  However, it
will record the simple things, and it will give you example code that
you can cut, paste, and modify to write the scripts that you need.</p>

<p>Some ideas for the future include:</p>

<ul>

<li>Choosing from a list of simple tests based on the fields on the
page and their current values.</li>

<li>"Threaded" recording, so that multiple sessions won't be recorded
in the same file, overlapped with each other.</li>

<li>"Add script header" feature.</li>

<li>Supporting more configuration options from the control panel.</li>

<li>Other loggers.</li>

<li>JavaScript support.</li>

</ul>

<h3>Where to Get <code>HTTP::Recorder</code></h3>

<p>The latest released version of <code>HTTP::Recorder</code> is available at <a href="http://search.cpan.org/search?query=http%3A%3Arecorder&mode=all">CPAN</a>.</p>

<h3>Contributions, Requests, and Bugs</h3>

<p>Patches, feature requests, and problem reports are welcomed at
<a href="http://rt.cpan.org">http://rt.cpan.org</a>.</p>

<p>You can subscribe to the mailing list for users and developers of
HTTP::Recorder at <a href="http://lists.fsck.com/mailman/listinfo/http-recorder">http://lists.fsck.com/mailman/listinfo/http-recorder</a>,
or by sending email to http-recorder-request@lists.fsck.com with the
subject "subscribe".</p>

<p>The mailing list archives can be found at
<a href="http://lists.fsck.com/piper-mail/http-recorder">http://lists.fsck.com/piper-mail/http-recorder</a>.</p>


<h3>See Also</h3>

<p><a href="http://search.cpan.org/search?query=www%3A%3Amechanize&mode=all"><code>WWW::Mechanize</code></a> by Andy Lester.</p>

<p><a href="http://search.cpan.org/search?query=http%3A%3Aproxy&mode=all"><code>HTTP::Proxy</code></a> by Phillipe "BooK" Bruhat.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/text-tools/">&laquo; Text Tools</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/troubleshooting/">Troubleshooting &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
