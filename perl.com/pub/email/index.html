<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Email Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Email</em> Category</h1>






                            
                            <div id="entry-942" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/06/email.html" rel="bookmark">The Evolution of Perl Email Handling</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Cozens</span> on <abbr class="published" title="2004-06-10T00:00:00-08:00">June 10, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p>I spend the vast majority of my time at a computer working with email, whether it's working through the ones I send and receive each day,
or working on my interest in analyzing,
indexing,
organizing, and mining email content.
Naturally,
Perl helps out with this.</p>

<p>There are many modules on the CPAN for slicing and dicing email,
and we're going to take a whistlestop tour of the major ones. We'll also concentrate on an effort started by myself,
Richard Clamp,
Simon Wistow, and others,
called the Perl Email Project,
to produce simple,
efficient and accurate mail handling modules.</p>

<h3><a name="Message_handling">Message Handling</a></h3>

<p>We'll begin with those modules that represent an individual message,
giving you access to the headers and body,
and usually allowing you to modify these.</p>

<p>The granddaddy of these modules is <a href="http://search.cpan.org/perldoc?Mail::Internet"><code>Mail::Internet</code></a>,
originally created by Graham Barr and now maintained by Mark Overmeer.
This module offers a constructor that takes either an array of lines or a filehandle,
reads a message, and returns a <code>Mail::Internet</code> object representing the message.
Throughout these examples,
we'll use the variable <code>$rfc2822</code> to represent a mail message as a string.</p>

<pre><code>    my $obj = Mail::Internet-&gt;new( [ split /\n/, $rfc2822 ] );</code></pre>

<p><code>Mail::Internet</code> splits a message into a header object in the <a href="http://search.cpan.org/perldoc?Mail::Header"><code>Mail::Header</code></a> class, plus a body. You can get and set individual headers through this object:</p>

<pre><code>    my $subject = $obj-&gt;head-&gt;get(&quot;Subject&quot;);
    $obj-&gt;head-&gt;replace(&quot;Subject&quot;, &quot;New subject&quot;);</code></pre>

<p>Reading and editing the body is done through the <code>body</code> method:</p>

<pre><code>    my $old_body = $obj-&gt;body;
    $obj-&gt;body(&quot;Wasn't worth reading anyway.&quot;);</code></pre>

<p>I've not said anything about MIME yet. <code>Mail::Internet</code> is reasonably handy for simple tasks, but it doesn't handle MIME at all. Thankfully, <a href="http://search.cpan.org/perldoc?MIME::Entity"><code>MIME::Entity</code></a> is a MIME-aware subclass of <code>Mail::Internet</code>; it allows you to read individual parts of a MIME message:</p>

<pre><code>    my $num_parts = $obj-&gt;parts;
    for (0..$num_parts) {
        my $part = $obj-&gt;parts($_);
        ...
    }</code></pre>

<p>If <code>Mail::Internet</code> and <code>MIME::Entity</code> don't cut it for you, you can try Mark Overmeer's own <a href="http://search.cpan.org/perldoc?Mail::Message"><code>Mail::Message</code></a>, part of the impressive <a href="http://search.cpan.org/perldoc?Mail::Box"><code>Mail::Box</code></a> suite. <code>Mail::Message</code> is extremely featureful and comprehensive, but that is not always meant as a compliment.</p>

<p><code>Mail::Message</code> objects are usually constructed by <code>Mail::Box</code> as part of reading in an email folder, but can also be generated from an email using the <code>read</code> method:</p>

<pre><code>    $obj = Mail::Message-&gt;read($rfc2822);</code></pre>

<p>Like <code>Mail::Internet</code>, messages are split into headers and bodies; unlike <code>Mail::Internet</code>, the body of a <code>Mail::Message</code> object is also an object. We read headers like so:</p>

<pre><code>    $obj-&gt;head-&gt;get(&quot;Subject&quot;);</code></pre>

<p>Or, for <code>Subject</code> and other common headers:</p>

<pre><code>    $obj-&gt;subject;</code></pre>

<p>I couldn't find a way to set headers directly, and ended up doing this:</p>

<pre><code>    $obj-&gt;head-&gt;delete($header);
    $obj-&gt;head-&gt;add($header, $_) for @data;</code></pre>

<p>Reading the body as a string is only marginally more difficult:</p>

<pre><code>    $obj-&gt;decoded-&gt;string</code></pre>

<p>While setting the body is an absolute nightmare--we have to create a new <code>Mail::Message::Body</code> object and replace our current one with it.</p>

<pre><code>    $obj-&gt;body(Mail::Message::Body-&gt;new(data =&gt; [split /\n/, $body]));</code></pre>

<p><code>Mail::Message</code> may be slow, but it's certainly hard to use. It's also rather complex; the operations we've looked at so far involved the use of 16 classes (<code>Mail::Address</code>, <code>Mail::Box::Parser</code>, <code>Mail::Box::Parser::Perl</code>, <code>Mail::Message</code>, <code>Mail::Message::Body</code>, <code>Mail::Message::Body::File</code>, <code>Mail::Message::Body::Lines</code>, <code>Mail::Message::Body::Multipart</code>, <code>Mail::Message::Body::Nested</code>, <code>Mail::Message::Construct</code>, <code>Mail::Message::Field</code>, <code>Mail::Message::Field::Fast</code>, <code>Mail::Message::Head</code>, <code>Mail::Message::Head::Complete</code>, <code>Mail::Message::Part</code>, and <code>Mail::Reporter</code>) and 4400 lines of code. It does have a lot of features, though.</p>

<p>Foolishly, I thought that email parsing shouldn't be so complex, and so I sat down to write the simplest possible functional mail handling library. The result is <a href="http://search.cpan.org/perldoc?Email::Simple"><code>Email::Simple</code></a>, and its interface looks like this:</p>

<pre><code>    my $obj = Email::Simple-&gt;new($rfc2822);
    my $subject = $obj-&gt;header(&quot;Subject&quot;);
    $obj-&gt;header_set(&quot;Subject&quot;, &quot;A new subject&quot;);
    my $old_body = $obj-&gt;body;
    $obj-&gt;body_set(&quot;A new body\n&quot;);
    print $obj-&gt;as_string;</code></pre>

<p>It doesn't do a lot, but it does it simply and efficiently. If you need MIME handling, there's a subclass called <a href="http://search.cpan.org/perldoc?Email::MIME"><code>Email::MIME</code></a>, which adds the <code>parts</code> method.</p>

<p>Realistically, the choice of which mail handling library to use ought to be up to you, the end user, but this isn't always true. Auxilliary modules, which mess about with email at a higher level, can ask for the mail to be presented in a particular representation. For instance, until recently, the wonderful <code>Mail::ListDetector</code> module, which we'll examine later, required mails passed in to it to be <code>Mail::Internet</code> objects, since this gave it a known API to work with the objects. I don't want to work with <code>Mail::Internet</code> objects, but I want to use <code>Mail::ListDetector</code>'s functionality. What can I do?</p>

<p>In order to enable the user to have the choice again, I wrote an abstraction layer across all of the above modules, called <a href="http://search.cpan.org/perldoc?Email::Abstract"><code>Email::Abstract</code></a>. Given any of the above objects, we can say:</p>

<pre><code>     my $subject = Email::Abstract-&gt;get_header($obj, &quot;Subject&quot;);
     Email::Abstract-&gt;set_header($obj, &quot;Subject&quot;, &quot;My new subject&quot;);
     my $body = Email::Abstract-&gt;get_body($obj);
     Email::Abstract-&gt;set_body($message, &quot;Hello\nTest message\n&quot;);
     $rfc2822 = Email::Abstract-&gt;as_string($obj);</code></pre>

<p><code>Email::Abstract</code> knows how to perform these operations on the major types of mail representation objects. It also abstracts out the process of constructing a message, and allows you to change the interface of a message using the <code>cast</code> class method:</p>

<pre><code>    my $obj = Email::Abstract-&gt;cast($rfc2822, &quot;Mail::Internet&quot;);
    my $mm = Email::Abstract-&gt;cast($obj, &quot;Mail::Message&quot;);</code></pre>

<p>This allows module authors to write their mail handling libraries in an interface-agnostic way, and I'm grateful to Michael Stevens for taking up <code>Email::Abstract</code> in <code>Mail::ListDetector</code> so quickly. Now I can pass in <code>Email::Simple</code> objects to <code>Mail::ListDetector</code> and it will work fine.</p>

<p><code>Email::Abstract</code> also gives us the opportunity to create some benchmarks for all of the above modules. Here was the benchmarking code I used:</p>

<pre><code>    use Email::Abstract;
    my $message = do { local $/; &lt;DATA&gt;; };
    my @classes =
        qw(Email::MIME Email::Simple MIME::Entity Mail::Internet Mail::Message);

    eval &quot;require $_&quot; or die $@ for @classes;

    use Benchmark;
    my %h;
    for my $class (@classes) {
        $h{$class} = sub {
            my $obj = Email::Abstract-&gt;cast($message, $class);
            Email::Abstract-&gt;get_header($obj, &quot;Subject&quot;);
            Email::Abstract-&gt;get_body($obj);
            Email::Abstract-&gt;set_header($obj, &quot;Subject&quot;, &quot;New Subject&quot;);
            Email::Abstract-&gt;set_body($obj, &quot;A completely new body&quot;);
            Email::Abstract-&gt;as_string($obj);
        }
    }
    timethese(1000, \%h);

    __DATA__
    ...</code></pre>

<p>I put a short email in the <code>DATA</code> section and ran the same simple operations a thousand times: construct a message, read a header, read the body, set the header, set the body, and return the message as a string.</p>

<pre><code>    Benchmark: timing 1000 iterations of Email::MIME, Email::Simple, 
    MIME::Entity, Mail::Internet, Mail::Message...
    Email::MIME: 10 wallclock secs ( 7.97 usr +  0.24 sys =  8.21 CPU) 
        @ 121.80/s (n=1000)
    Email::Simple:  9 wallclock secs ( 7.49 usr +  0.05 sys =  7.54 CPU) 
        @ 132.63/s (n=1000)
    MIME::Entity: 33 wallclock secs (23.76 usr +  0.35 sys = 24.11 CPU) 
        @ 41.48/s (n=1000)
    Mail::Internet: 24 wallclock secs (17.34 usr +  0.30 sys = 17.64 CPU) 
        @ 56.69/s (n=1000)
    Mail::Message: 20 wallclock secs (17.12 usr +  0.27 sys = 17.39 CPU) 
        @ 57.50/s (n=1000)</code></pre>

<p>The Perl Email Project was a success: <code>Email::MIME</code> and <code>Email::Simple</code> were twice as fast as their nearest competitors. However, it should be stressed that they're both very low level; if you're doing anything more complex than the operations we've seen, you might consider one of the older <code>Mail::</code> modules.</p>













<h3><a name="Mailbox_handling">Mailbox Handling</a></h3>

<p>So much for individual messages; let's move on to handling groups of messages, or folders. We've mentioned <code>Mail::Box</code> already, and this is truly the king of folder handling, supporting local and remote folders, editing folders, and all sorts of other things besides. To use it, we first need a <code>Mail::Box::Manager</code>, which is a factory object for creating <code>Mail::Box</code>es.</p>

<pre><code>    use Mail::Box::Manager
    my $mgr = Mail::Box::Manager-&gt;new;</code></pre>

<p>Next, we need to open the folder using the manager:</p>

<pre><code>    my $folder = $mgr-&gt;open(folder =&gt; $folder_file);</code></pre>

<p>And now we can get at the individual messages as <code>Mail::Message</code> objects:</p>

<pre><code>    for ($folder-&gt;messages) {
        print $_-&gt;subject,&quot;\n&quot;;
    }</code></pre>

<p>With its more minimalist approach, my favorite mail box manager until recently was <code>Mail::Util</code>'s <code>read_mbox</code> function, which takes the name of a Unix <code>mbox</code> file, and returns a list of array references; each reference is the array of lines of a message, suitable for feeding to <code>Mail::Internet-&gt;new</code> or similar:</p>

<pre><code>    for (read_mbox($folder_file)) {
        my $obj = Mail::Internet-&gt;new($_);
        print $_-&gt;head-&gt;get(&quot;Subject&quot;),&quot;\n&quot;;
    }</code></pre>

<p>These two are both really handy, but there seemed to be room for something in between the simplicity of <code>Mail::Util</code> and the functionality of <code>Mail::Box</code>, and so the Email Project struck again with <a href="http://search.cpan.org/perldoc?Email::Folder"><code>Email::Folder</code></a> and <a href="http://search.cpan.org/perldoc?Email::LocalDelivery"><code>Email::LocalDelivery</code></a>. <code>Email::Folder</code> handles mbox and maildir folders, with more types planned, and has a reasonably simple interface:</p>

<pre><code>    my $folder = Email::Folder-&gt;new($folder_file);
    for ($folder-&gt;messages) {
        print $_-&gt;header(&quot;Subject&quot;),&quot;\n&quot;;
    }</code></pre>

<p>By default it returns <code>Email::Simple</code> objects for the messages, but this can be changed by subclassing. For instance, if we want raw RFC2822 strings, we can do this:</p>

<pre><code>    package Email::Folder::Raw; use base 'Email::Folder';
    sub bless_message { my ($self, $rfc2822) = @_; return $rfc2822; }</code></pre>

<p>Perhaps in the future, we will change <code>bless_message</code> to use <code>Email::Abstract-&gt;cast</code> to make the representation of messages easier to select without necessarily having to subclass.</p>

<p>The other side of folder handling is writing to a folder, or &quot;local delivery&quot;. <a href="http://search.cpan.org/perldoc?Email::LocalDelivery"><code>Email::LocalDelivery</code></a> was written to assist <code>Email::Filter</code>, of which more later. The problem is harder than it sounds, as it has to deal with locking, escaping mail bodies, and specific problems due to mailbox and maildir formats. <code>LocalDelivery</code> hides all of these things beneath a simple interface:</p>

<pre><code>    Email::LocalDelivery-&gt;deliver($rfc2822, @mailboxes);</code></pre>

<p>Both <code>Email::LocalDelivery</code> and <code>Email::Folder</code> use the <a href="http://search.cpan.org/perldoc?Email::FolderType"><code>Email::FolderType</code></a> helper module to determine the type of a folder based on its filename.</p>

<h3><a name="Address_handling">Address Handling</a></h3>

<p>To come down to a lower level of abstraction again, there are a number of modules for handling email addresses. The old favorite is <a href="http://search.cpan.org/perldoc?Mail::Address"><code>Mail::Address</code></a>. A mail address appearing in the fields of an email can be made up of several elements: the actual address, a phrase or name, and a comment. For instance:</p>

<pre><code>    Example user &lt;example@example.com&gt; (Not a real user)</code></pre>

<p><code>Mail::Address</code> parses these addresses, separating out the phrase and comments, allowing you to get at the individual components:</p>

<pre><code>    for (Mail::Address-&gt;parse($from_line)) {
        print $_-&gt;name, &quot;\t&quot;, $_-&gt;address, &quot;\n&quot;;
    }</code></pre>

<p>Unfortunately, like many of the mail modules, it tries really hard to be helpful.</p>

<pre><code>    my ($addr) = Mail::Address-&gt;parse('&quot;eBay, Inc.&quot; &lt;support@ebay.com&gt;');
    print $addr-&gt;name # Inc. eBay</code></pre>

<p>Which, while better than the &quot;Inc Ebay&quot; that previous versions would produce, isn't really acceptable. Casey West joined our merry band of renegades and produced <a href="http://search.cpan.org/perldoc?Email::Address"><code>Email::Address</code></a>. It has exactly the same interface as <code>Mail::Address</code>, but it works, and is about twice to three times as fast.</p>

<p>One thing we often want to do when handling mail addresses is to make sure that they're valid. If, for instance, a user is registering for content at a web site, we need to check that the address they've given is capable of receiving mail. <a href="http://search.cpan.org/perldoc?Email::Valid"><code>Email::Valid</code></a>, the original inhabitant of the <code>Email::</code> namespace before our bunch of disaffected squatters moved in, does just this. In its most simple use, we can say:</p>

<pre><code>    if (not Email::Valid-&gt;address('test@example.com')) {
        die &quot;Not a valid address&quot;
    }</code></pre>

<p>You can turn on additional checks, such as ensuring there's a valid MX record for the domain, correcting common AOL and Compuserve addressing mistakes, on so on:</p>

<pre><code>    if (not Email::Valid-&gt;address(-address =&gt; 'test@example.com',
                                  -mxcheck =&gt; 1)) {
        die &quot;Not a valid address&quot;
    }</code></pre>

<h3><a name="Mail_munging">Mail Munging</a></h3>

<p>Once we have our emails, what are we going to do with them? A lot of what I've been looking at has been textual analysis of email, and there are three modules that particularly help with this.</p>

<p>This first is <code>Text::Quoted</code>; it takes the body text of an email message, or any other text really, and tries to figure out which parts of the message are quotations from other messages. It then separates these out into a nested data structure. For instance, if we have</p>

<pre><code>    $message = &lt;&lt;EOF
    &gt; foo
    &gt; # Bar
    &gt; baz

    quux
    EOF</code></pre>

<p>Then running <code>extract($message)</code> will return a data structure like this:</p>

<pre><code>    [
      [
        { text =&gt; 'foo', quoter =&gt; '&gt;', raw =&gt; '&gt; foo' },
        [ 
            { text =&gt; 'Bar', quoter =&gt; '&gt; #', raw =&gt; '&gt; # Bar' } 
        ],
        { text =&gt; 'baz', quoter =&gt; '&gt;', raw =&gt; '&gt; baz' }
      ],

      { empty =&gt; 1 },
      { text =&gt; 'quux', quoter =&gt; '', raw =&gt; 'quux' }
    ];</code></pre>

<p>This is extremely useful for highlighting different levels of quoting in different colors when displaying a message. A similar concept is <a href="http://search.cpan.org/perldoc?Text::Original"><code>Text::Original</code></a>, which looks for the start of original, non-quoted content in an email. It knows about many kinds of attribution lines, so with:</p>

<pre><code>    $message = &lt;&lt;EOF
    You wrote:
    &gt; Why are there so many different mail modules?

    There's more than one way to do it! Different modules have different
    focuses, and operate at different levels; some lower, some higher.
    EOF</code></pre>

<p>the <code>first_sentence($message)</code> would be <code>There's more than one way to do it!</code>. The Mariachi mailing list archiver uses this technique to give a &quot;prompt&quot; for each message in a thread.</p>

<p>And speaking of threads, the <a href="http://search.cpan.org/perldoc?Mail::Thread"><code>Mail::Thread</code></a> module is a Perl implementation of Jamie Zawinski's mail threading algorithm, as used by Mozilla as well as many other mail clients since then. It's also used by Mariachi, and has recently been updated to use <code>Email::Abstract</code> to handle any kind of mail object you want to throw at it:</p>

<pre><code>    my $threader = Mail::Thread-&gt;new(@mails);
    $threader-&gt;thread; # Compute threads
    for ($threader-&gt;rootset) { # Original mails in a thread
        dump_thread($_);
    }</code></pre>

<h3><a name="Mail_filtering">Mail Filtering</a></h3>

<p>The classic Perl mail filtering tool is <a href="http://search.cpan.org/perldoc?Mail::Audit"><code>Mail::Audit</code></a>, and I've written articles here about using Mail::Audit on its own (<a href='http://www.perl.com/pub/a/2001/07/17/mailfiltering.html'>http://www.perl.com/pub/a/2001/07/17/mailfiltering.html</a>) and using it in conjunction with <a href="http://search.cpan.org/perldoc?Mail::SpamAssassin"><code>Mail::SpamAssassin</code></a> (<a href='http://www.perl.com/pub/a/2002/03/06/spam.html'>http://www.perl.com/pub/a/2002/03/06/spam.html</a>).</p>

<p>We've mentioned <a href="http://search.cpan.org/perldoc?Mail::ListDetector"><code>Mail::ListDetector</code></a> a couple of times already, and I use this with <code>Mail::Audit</code> to do most of the filtering automatically for me. The <code>Mail::Audit::List</code> plugin uses <code>ListDetector</code> to look for mailing list headers in a message; these are things like <code>List-Id</code>, <code>X-Mailman-Version</code>, and the like, which identify a mail as having come through a mailing list. This means I can filter out all mailing list posts to their own folders, like so:</p>

<pre><code>    my $list = Mail::ListDetector-&gt;new($obj);
    if ($list) {
        my $name = $list-&gt;listname;
        $item-&gt;accept(&quot;mail/$name.-$date&quot;);
    }</code></pre>

<p>However, <code>Mail::Audit</code> itself is getting a little long in the tooth, and so new installations are encouraged to use the Email Project's <a href="http://search.cpan.org/perldoc?Email::Filter"><code>Email::Filter</code></a> instead; it has the same interface for the most part, although not all of the same features, and it uses the new-fangled <code>Email::Simple</code> mail representation for speed and cleanliness.</p>

<h3><a name="Mail_mining">Mail Mining</a></h3>

<p>Finally, the most high-level thing I do with email is develop frameworks to automatically categorize, organize, and index mail into a database, and attempt to analyze it for interesting nuggets of information.</p>

<p>My first module to do this with was <a href="http://search.cpan.org/perldoc?Mail::Miner"><code>Mail::Miner</code></a>, which consists of three major parts. The first part takes an email, removes any attachments, and stores the lot in a database. The second looks over the email and runs a set of &quot;Recogniser&quot; modules on it; these find addresses, phone numbers, keywords and phrases, and so on, and store them in a separate database table. The third part is a command-line tool to query the database for mail and information.</p>

<p>For instance, if I need to find Tim O'Reilly's postal address, I ask the query tool, <code>mm</code>, to find addresses in emails from him:</p>

<pre><code> % mm --from &quot;Tim O&quot; --address              
 Address found in message 1835 from &quot;Tim O'Reilly&quot; &lt;tim@oreilly.com&gt;:
 Tim O'Reilly @ O'Reilly &amp; Associates, Inc.
 1005 Gravenstein Highway North, Sebastopol, CA 95472</code></pre>

<p>To retrieve the whole email, I'd say</p>

<pre><code> % mm --id 1835</code></pre>

<p>And if it originally contained an attachment, we'd see something like this as part of the email:</p>

<pre><code> [ text/xml attachment something.xml detached - use
   mm --detach 208
   to recover ]</code></pre>

<p>I paste that middle line <code>mm --detach 208</code> into a shell, and hey presto, <em>something.xml</em> is written to disk.</p>

<p>Now <code>Mail::Miner</code> is all very well, but having the three ideas in one tight package--filing mail, mining mail, and interfacing to the database--makes it difficult to develop and extend any one of them. And of course, it uses the old-school <code>Mail::</code> modules.</p>

<p>This brings us to our final module on the mail modules tour, and the most recently released: <a href="http://search.cpan.org/perldoc?Email::Store"><code>Email::Store</code></a>. This is a framework, based on <a href="http://search.cpan.org/perldoc?Class::DBI"><code>Class::DBI</code></a>, for storing email in a database and indexing it in various ways:</p>

<pre><code>   use Email::Store 'dbi:SQLite:mail.db';
   Email::Store-&gt;setup;
   Email::Store::Mail-&gt;store($rfc2822);</code></pre>

<p>And then later...</p>

<pre><code>   my ($name) = Email::Store::Name-&gt;search( name =&gt; &quot;Simon Cozens&quot; )
   @mails_from_simon = $name-&gt;addressings( role =&gt; &quot;From&quot; )-&gt;mails;</code></pre>

<p>It can be used to build a mailing list archive tool such as Mariachi, or a data mining setup like <code>Mail::Miner</code>. It's still very much in development, and makes use of a new idea in module extensibility.</p>

<p>I'll be bringing more information when we've written the first mail archiving and searching tool using <code>Email::Store</code>, which I'm going to be doing as a new interface to the Perl mailing lists at <code>perl.org</code>.</p>

<h3><a name="Conclusion">Conclusion</a></h3>

<p>We've looked at the major modules for mail handling on CPAN, and there are many more. I am obviously biased towards those which I wrote, and particularly the Perl Email Project modules in the <code>Email::*</code> namespace. These modules are specifically designed to be simple, efficient, and correct, but may not always be a good substitute for the more thorough <code>Mail::*</code> modules, particularly <code>Mail::Box</code>. However, I hope you're now a little more aware of the diversity of mail handling tools out there, and know where to look next time you need to manipulate email with Perl.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-872" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/02/siesta.html" rel="bookmark">Siesta Mailing List Manager</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Wistow</span> on <abbr class="published" title="2004-02-05T00:00:00-08:00">February  5, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->


<p>Sometime around July 2002 there was another of the seemingly inevitable and interminable threads about mailing list managers that pop up with regrettable frequency on the London Perl Mongers mailing list.</p>

<p>It almost certainly contained references to Reply To munging,
missing features, and why we,
a Perl mailing list,
were running off Python software,
namely Mailman.</p>

<p>It was pointed out that even though Mailman has its limitations,
it's still arguably the best MLM out there.
Of course, rational argument is never something that gets in the way of a good thread and the debate continued until Richard Clamp brought his own unique brand of pragmatism to bear ...</p>

<pre><code> From: Richard Clamp &#60;richardc@unixbeard.net&#62;
 To: london.pm
 Subject: Re: for those who were looking for reason to better mailman in perl
 Date: Tue Jul 30 00:53:03 2002

 On Mon, Jul 29, 2002 at 03:06:44PM +0100, Nicholas Clark wrote:
 &#62; Note that I have no intention of actually finding the time to 
 &#62; actively help anyone re-write mailman (or majordomo) or anything 
 &#62; else,

 I must say that I'm actively bored of this subject now.  I do, however,
 have a short proposal, which will hopefully lead to this recurring
 thread going the fsck away.

 To: Those that care
 From: Someone who doesn&#39;t
 
       Go form a sourceforge/savannah project, which will give you
       suboptimal mailing lists and a CVS repository.
 
       Let the world know you have done this so they can find you. 
 
       Write code and argue it out amongst yourselves.
 
       Let the world know when you get as far as being self-hosting.
 
 I&#39;m sorry it&#39;s not a catchy 3-step plan, but try it out anyway.
 
 -- 
 Richard Clamp &#60;richardc@unixbeard.net&#62;</code></pre>

<p>In response to which, precisely nothing happened. So it goes.</p>

<p>Until mid-August.</p>

<p>By some quirk of fate Greg McCarroll, Richard, and I were all simultaneously &#39;resting&#39; between jobs. Being fun-loving, crazy people we decided that the most constructive use of time was to congregate at Greg&#39;s, drink his booze, and watch Kevin Smith films.</p>

<p>Instead, we wrote a mailing list manager. Well, I say &#34;instead&#34;, but we managed to do the other stuff too, which explains the Jay-and-Bob-themed test suite.</p>

<p>By the end of the day we had a whiteboard full of diagrams, a load of code in a CVS repository, a self-hosting mailing list (with hard-coded subscribers list, natch) and a sense of impending hangovers. Then disaster struck. We all got jobs. And Siesta, as we&#39;d decided to call our nascent MLM, lay dormant.</p>

<p>For about 6 months she lay sleeping.</p>

<p>Then, for whatever reason, in about March the dev team, bolstered by a couple of new member-cum-agitprops, began to churn out the patches again. The project was re-housed from SourceForge to siesta.unixbeard.net -- entailing a move to Subversion along the way.</p>

<p>The code was cleaned up, ported to <code>Class::DBI</code> and the <code>Email::*</code> hierarchy of modules and various <a href='http://www.ai.mit.edu/lab/gsb/gsb-archive/gsb2000%2D02%2D11.html'>yaks were shaved</a> along the way, features were added, and a new <code>Template::Toolkit</code>-based mail archiver (named Mariachi) was written.</p>

<p>The first release of Siesta went onto CPAN on July 24, just in time for Richard to give his talk at YAPC Europe in Paris -- an event that involved, somewhat inexplicably, several members of the audience drinking a shot of tequila whenever the word &#39;Siesta&#39; was mentioned and then giving 50 Euros to YAS. Needless to say, much fun was had by all.</p>

<h3><a name="So_why_should_I_use_Siesta?">So Why Should I Use Siesta?</a></h3>

<p>Good question. Mailman, Majordomo, or a host of other MLMs usually suffice.</p>

<p>On the other hand, competition is always good and Siesta was designed from the ground up to be easily understandable and easily extensible.</p>

<p>In short, Siesta will almost certainly be able to do anything you want, although you may have to write the plug-in in to do it.</p>

<p>Writing something to check whether an incoming email address is valid is a matter of about 10 lines, most of which are boilerplate. A SpamAssassin plug-in would be of similar length. Writing something that required all mails to the list to be PGP-signed and encrypted with the list&#39;s public key, and then which signed and encrypted all outgoing mail, would be relatively trivial.</p>

<p>And with the concept of user preferences you never have to put up with incessant whining about Reply-To munging since the list members can configure it (or any other plug-in you deem fit) however they want.</p>

<p>Bliss.</p>

<p>As an example of how customizable Siesta is, Richard Clamp runs a mailing list called Hates-Software for people who, err, hate software.</p>

<p>Running on subclassed versions of Mariachi (the mailing list
archiver) Hates-Software has archives for the whole list and also
for every single member so my rants are archived at <a href="http://muttley.hates-software.com">http://muttley.hates-software.com/</a>,
but are also part of the seething maelstrom of hate that is <a href="http://we.hates-software.com/">http://we.hates-software.com/</a>.</p>

<h3><a name="Running_a_list">Running a List</a></h3>

<p>There are currently two ways of administering your Siesta installation (not including fiddling around with the DB manually, of course), and these are with the web interface and with the command line tool <i>nacho</i>.</p>

<p>Now, to be frank, the web interface sucks at the moment and needs an overhaul, some prettification, and a whole lot of usability work. But it&#39;s all open source and written in Template Toolkit, so you can fix it up, skin it however you want, and then send us the patches. Ah, the magic of the free software movement.</p>

<p>Instead, we&#39;ll concentrate on <i>nacho</i>; it&#39;s surprisingly powerful and just a shell prompt away.</p>

<p><i>nacho</i> has full documentation embedded as POD, but the version checked into the repository will also, handily, provide a list of commands by doing:</p>

<pre><code>  % nacho help</code></pre>

<p>Or the syntax of a specific command by doing:</p>

<pre><code>  % nacho help &#60;command&#62;</code></pre>

<p>Like this:</p>

<pre><code>  % nacho help set-plugins

  set-plugins list_id queue [ plugin [ plugin... ] ]
  -
  Set the list plugins to be the ones specified.</code></pre>

<p>Anyway ... first things first.</p>

<h4><a name="Setting_up_the_database">Setting up the Database</a></h4>

<p>The first thing you need to do is create a database.</p>

<p>Fortunately this is easy. Running:</p>

<pre><code>    % nacho create-database</code></pre>

<p>should do everything for you (providing the config in your siesta.conf is OK).</p>

<h4><a name="Migrating_a_list_from_Mailman">Migrating a List from Mailman</a></h4>

<p>Use the <i>bandito</i> tool shipped with Siesta to steal the config of your existing Mailman configuration -- given the path to a mailman list config database, it should automatically create a new Siesta list, subscribe any necessary users, set up configs, and generally "just work."</p>

<p>It will even migrate your archives across for you.</p>

<p>How handy.</p>

<h4><a name="Creating_a_list_by_hand">Creating a List by Hand</a></h4>

<p>Run this command:</p>

<pre><code>  % nacho create-list myfirstlist admin@thegestalt.org \
                     myfirstlist@thegestalt.org \ 
             myfirstlist-bounce@thegestalt.org</code></pre>

<p>Which will print out:</p>

<pre><code>  Created the new list &#39;myfirstlist&#39; &#60;myfirstlist@thegestalt.org&#62; </code></pre>

<p>Paste this into your alias file to activate the list:</p>

  <pre><code>  ## myfirstlist mailing list
  ## created: 06-Sep-2002 nacho (the siesta config tool)
  myfirstlist:       &#34;/usr/bin/tequila myfirstlist&#34;
  myfirstlist-sub:   &#34;/usr/bin/tequila myfirstlist sub&#34;
  myfirstlist-unsub: &#34;/usr/bin/tequila myfirstlist unsub&#34;
  myfirstlist-admin:  admin@thegestalt.org 
  myfirstlist-bounce: admin@thegestalt.org</code></pre>

<p>This prints out the appropriate aliases to put in your <code>/etc/alias</code> (or equivalent) file. This can be printed out again at anytime by doing:</p>

<pre><code>  % nacho show-alias myfirstlist

  ## myfirstlist mailing list
  ## created: 06-Sep-2002 nacho (the siesta config tool)
  myfirstlist:       &#34;/usr/bin/tequila myfirstlist&#34;
  myfirstlist-sub:   &#34;/usr/bin/tequila myfirstlist sub&#34;
  myfirstlist-unsub: &#34;/usr/bin/tequila myfirstlist unsub&#34;
  myfirstlist-admin:  admin@thegestalt.orb
  myfirstlist-bounce: admin@thegestalt.orb</code></pre>

<p>At which point you probably want to add some plug-ins.</p>

<pre><code>  % nacho set-plugins myfirstlist post Debounce ListHeaders Send     
  % nacho set-plugins myfirstlist sub Subscribe
  % nacho set-plugins myfirstlist unsub UnSubscribe</code></pre>

<p>This means that for the <code>myfirstlist</code> list, when it sees a post, it should first remove bounces, then add list headers, then call the <code>Send</code> plug-in to send it out. Similarly, subscribes and unsubscribes go through the normal <code>Subscribe</code> and <code>UnSubscribe</code> plug-ins.</p>

<p>If you want to find all the lists on the system you just do:</p>

<pre><code>  % nacho show-lists
  myfirstlist</code></pre>

<p>And then to look at the information for a list, do this:</p>

<pre><code>  % nacho describe-list myfirstlist
  owner = 1
  return_path = myfirstlist-bounce@thegestalt.orb
  post_address = myfirstlist@thegestalt.orb
  name = myfirstlist
  id = 2
  post plugins : MembersOnly ListHeaders Send 
  sub plugins: Subscribe
  unsub plugins: UnSubscribe</code></pre>

<p>Or to modify that information:</p>

<pre><code>  % nacho modify-list myfirstlist name somenewname
  Property &#39;name&#39; set to &#39;somenewname&#39; for list myfirstlist</code></pre>

<p>TIP: If you modify the id then what will actually happen is that a new list will be created with that id, but with information exactly the same as the details for the previous list.</p>

<h4><a name="Creating_Members">Creating Members</a></h4>

<p>You can either subscribe members manually by creating them and inserting them using nacho:</p>

<pre><code>  % nacho create-member simon@thegestalt.orb
  Member simon@thegestalt.orb added    

  % nacho add-member myfirstlist simon@thegestalt.orb
  Member &#39;simon@thegestalt.orb&#39; added to list &#39;myfirstlist&#39;</code></pre>

<p>Or, nacho will automatically create members if they don&#39;t exist.</p>

<pre><code>  % nacho add-member myfirstlist newmember@notexists.orb</code></pre>

<p>You can add multiple people at the same time. Que Conveniente!</p>

<pre><code>  % nacho add-member myfirstlist richardc@unibeard.not greg@mccarroll.demon.com
  Member &#39;richardc@unixbeard.not&#39; added to list &#39;myfirstlist&#39;
  Member &#39;greg@mccarroll.demon.com&#39; added to list &#39;myfirstlist&#39;</code></pre>

<p>Finally a person can subscribe by mailing to the:</p>

<pre><code>    myfirstlist-sub@yourdomainhere.orb </code></pre>

<p>address, or by going through the web interface.</p>

<h4><a name="Managing_members">Managing Members</a></h4>

<p>You can get a list of every member that&#39;s on the system:</p>

<pre><code>  % nacho show-members
  greg@mccarroll.demon.com
  richardc@unixbeard.not
  simon@thegestalt.orb</code></pre>

<p>Or just the members subbed to a particular list:</p>

<pre><code>  % nacho show-members myfirstlist</code></pre>

<p>To find out all about a member, use the describe command:</p>

<pre><code>  % nacho describe-member simon@thegestalt.orb

    email = simon@thegestalt.orb
    lastbounce =
    bouncing =
    password = bar
    nomail =
    id = 36
    Subscribed to : myfirstlist, somerandomlist</code></pre>

<p>To modify information about that information:</p>

<pre><code>  % nacho modify-member simon@thegestalt.orb password foo
  Property &#39;password&#39; set to &#39;foo&#39; for member simon@thegestalt.org</code></pre>

<p>Again, just changing the id will copy the member:</p>

<h4><a name="Managing_Plugins">Managing Plug-ins</a></h4>

<p>You can list all the plug-ins installed on the system:</p>

<pre><code>  % nacho show-plugins
  Archive
   -
   save messages to maildirs
  ...
  UnSubscribe
   -
   A system plugin used for unsubscribing a member to the list.</code></pre>

<p>Since plug-ins are "just" normal Perl modules, you can write your own or download plug-ins other people have written and install them like any other module. Siesta will automatically detect them.</p>

<p>To set the plug-in order explicity, do this:</p>

<pre><code>  % nacho set-plugins myfirstlist post Debounce SimpleSig SubjectTag Send</code></pre>

<p>The "post" part is the queue you want these attached to. By default here are three: "post," "sub," and "unsub," but there can be as many as you want. They serve to differentiate the different modes the list might run in. So, for example, you could have a "help" queue that responds to help requests, or a "FAQ" queue that tries to answer questions.</p>

<p>To delete all the plug-ins, just pass an empty list</p>

<pre><code>  % nacho set-plugins myfirstlist post
  Deleted plugins from siesta-dev</code></pre>

<p>It should be noted that you probably always want to have the Send plug-in (or a replacement plug-in) as the last plug-in.</p>

<p>To get more information about a plug-in, you can either:</p>

<pre><code>  % perldoc Siesta::Plugin::ReplyTo</code></pre>

<p>Or ...</p>

<pre><code>  % nacho describe-plugin ReplyTo
  The plugin ReplyTo has the following options :
  - munge : should we munge the reply-to address of the 
    message to be the list post address</code></pre>

<p>To find out what the current config for a list is, just add the list name.</p>

<pre><code>  % nacho describe-plugin ReplyTo myfirstlist
  Preferences for list myfirstlist
  - munge : 0</code></pre>

<p>And to find out a member's config options, add his or her email address:</p>

<pre><code>  % nacho describe-plugin ReplyTo myfirstlist simon@thegestalt.orb
  Personal preferences for member simon@thegestalt.orb on list myfirstlist
  - munge : 1</code></pre>

<p>To modify configuration for any of these:</p>

<pre><code>  % $ nacho modify-plugin ReplyTo box munge 0                     
  Preferences for list box
  - munge : 0</code></pre>

<p>However, you can also set a preference on a per-member basis:</p>

<pre><code>  % nacho modify-plugin ReplyTo box munge 1 simon@thegestalt.org
  Personal preferences for member simon@thegestalt.org on list box
  - munge : 1</code></pre>

<h4><a name="Removing_Members">Removing Members</a></h4>

<p> Occasionally a member will want to leave (or will need to be pushed) and you&#39;ll need to do this by hand. To remove a member from a list just do this:</p>

<pre><code>  % nacho remove-member myfirstlist greg@mccarroll.demon.com
  Member &#39;greg@mccarroll.demon.com&#39; removed from list &#39;myfirstlist&#39;</code></pre>

<h4><a name="Deleting_Members">Deleting Members</a></h4>

<p>Deleting members from the system will remove them from all the lists they&#39;re subscribed to, and then delete them from the system.</p>

<pre><code>  % nacho delete-member richardc@unixbeard.net 
  Member &#39;richardc@unixbeard.not&#39; deleted.</code></pre>

<h4><a name="Handling_deferred_messages">Handling Deferred Messages</a></h4>

<p>Deferred messages are ones being held for approval, or that contain administrative tasks.</p>

<p>You can see how many deferred messages there are by doing this:</p>

<pre><code>    % nacho show-deferred

    Deferred-Id: 1
    Reason: the hell of it
    Owner: test@foo

     From: simon@thegestalt.org
     To: people@somewhere.org
     Subject: some subject lin
     Date: Wed, 13 Aug 2003 15:49:30 +0100  </code></pre>

<p>Or you can view an individual message by supplying the id:</p>

<pre><code>    % nacho show-deferred 1
    From: simon@thegestalt.org
    To: people@somewhere.org
    Subject: some subject line
    Date: Wed, 13 Aug 2003 15:49:30 +0100  

    Hello people

    Simon</code></pre>

<p>To resume a message simply do this:</p>

<pre><code>    % nacho resume-deferred 1
    Successfully resumed message 1</code></pre>

<p>Alternatively, to delete a deferred message do this:</p>

<pre><code>    % nacho delete-deferred 1
    Message deleted from deferral queue</code></pre>

<h4><a name="Deleting_Lists">Deleting Lists</a></h4>

<p>Similarly deleting a list will unsub all members from that list and then remove it from the system.</p>

<pre><code>  % nacho delete-list myfirstlist
  List &#39;myfirstlist&#39; deleted</code></pre>

<h4><a name="Making_backups">Making Backups </a></h4>

<p>Running the command:</p>

<pre><code>    % nacho create-backup </code></pre>

<p>will print a shell script to STDOUT.</p>

<p>This shell script consists of nacho commands to restore your system to its glorious past should anything go wrong.</p>

<pre><code>    % nacho create-backup myfirstlist</code></pre>

<p>will do the same, but for only one list.</p>

<h4><a name="Upgrading">Upgrading</a></h4>

<p>Upgrading is easy -- simply make a backup as described above, install the latest version from CPAN, and then run the nacho-generated script to restore your system. Most of the time, however, unless the database has changed format, even that won&#39;t be necessary, and simply installing from CPAN should just be OK.</p>

<h3><a name="Writing_a_plugin">Writing a Plug-in</a></h3>

<p>Writing a plug-in for Siesta is easy. Say, for example, we wanted to take any supercited mails to the list and reform them into a less GNUSish format. First off, we start with the standard boilerplate:</p>

<pre><code>    package Siesta::Plugin::DeSupercite;
    use strict;
    use Siesta::Plugin;
    use base &#39;Siesta::Plugin&#39;;
    use Siesta;

    sub description {
        &#39;&#39;;
    } 


    sub process {
        my $self = shift;
        my $mail = shift;
        my $list = $self-&#62;list;

        return 0;
    };


    sub options {
        +{
         }
    };</code></pre>

<p>Add in the existing DeSuperciting module:</p>

<pre><code>    use Text::DeSupercite qw/desupercite/;</code></pre>

<p>Fill in the description:</p>

<pre><code>    sub description {
        &#39;Strip superciting from emails&#39;;
    } </code></pre>

<p>And the options:</p>

<pre><code>    sub options {
        +{
            harsh =&#62;
            {
               description =&#62;
               &#39;should we be draconian about desuperciting?&#39;,
               type    =&#62; &#39;boolean&#39;,
               default =&#62; 0,
            },
        };
    }</code></pre>

<p>And finally, fill in the body of the process method:</p>

<pre><code>    sub process {
        my $self = shift;
        my $mail = shift;
        my $list = $self-&#62;list;

        # automatically works out if this is user 
        # setable or not 
        my $harsh = $self-&#62;pref( &#39;harsh&#39; );

        # get the body text
        my $text = desupercite($mail-&#62;body(), $harsh);

        # set it back again
        $mail-&#62;body_set($text);

        # indicate success
        return 0;
    };</code></pre>

<p><i>Et voila</i>, one plug-in, ready to go. Now all you need to do is package it up and install it in your @INC and it&#39;ll get picked up automagically and will be ready to be added to any list on the system.</p>

<h3><a name="Mariachi">Mariachi</a></h3>

<p>Whilst completely independent of Siesta, our mailing list archiver Mariachi is still entwined with the whole project, if only because it gives us something to noodle around as a distraction from the mailing list manager. As such it deserves at least a quick mention here.</p>

<p>Apart from being easily subclassable, Mariachi has another couple of nice features. For a start, all the output templates are done in Template Toolkit, making it easy to customize to fit in with the look and feel of your site without having to delve around in the code.</p>

<p>It also allows you to display mail in a couple of nifty ways. The first is the classic Jwz-style message threading as used in Netscape and Mutt, complete with indentation, which makes following threads much easier. The second is the so-called Lurker view, named after the <a href="http://lurker.sourceforge.net/">Lurker application</a>, which appears to be the first application to use this chronological view of mail.</p>

<p>These both include the option to extract either the first original sentence or paragraph from a mail, meaning that many threads can be easily skimmed without having to open up individual messages.</p>

<p>In addition, Richard has already written a module that will generate
an SVG of a mail thread in the Arc form described <a href="http://www.research.ibm.com/remail/">here</a>.</p>

<p>Perhaps Mariachi&#39;s only problem is that because it does not split mail up over arbitrary boundaries (although there&#39;s nothing to stop the users from doing this themselves), generating archives from a massive mail box (such as every London.pm mail from the last 5 years) can be slow, even if it is done incrementally.</p>

<p>However, work is being done to overcome this.</p>

<h3><a name="Conclusion">Conclusion</a></h3>

<p>Although unfinished, we believe that Siesta is already a hugely powerful mailing list manager with almost unrivalled extensibility.</p>

<p>Breathless superlatives aside, and irrespective of whether it ever gets widely used, it will forever shut up those who whine on mailing lists that there&#39;s no good Perl MLM or that they wish there was an MLM that had plug-ins. Perhaps most importantly, you have somewhere to point anybody whoever complains about Reply-To munging, since with Siesta, each user can choose whether or not they want Reply-To munging applied.</p>

<p>In a more practical sense, while working on Siesta the team has written or patched nearly 20 modules outside the ones distributed with Mariachi and Siesta. So something for everybody.</p>

<p>If you're interested in getting involved with the project, just install the programs (they should work from your favorite CPAN shell), make notes on anything you find irritating, join the mailing list, and tell us about it. Then start patching, writing plug-ins or, and if you're the kind of person who likes doing web page stuff, fix the web interface. We&#39;ll love you forever. And you&#39;ll get to drink tequila at Perl conferences like all the cool kids.</p>

<h3><a name="References">References</a></h3>

<ul>
<li>
<a href="http://siesta.unixbeard.net">The Siesta home page</a></li>

<li> <a href="http://hates-software.com">Hates-Software</a></li>


<li> <a href="http://london.pm.org/pipermail/london.pm/Week-of-Mon-20020701/011937.html">*That* thread</a></li>

<li>
<a href="http://london.pm.org/pipermail/london.pm/Week-of-Mon-20020729/012366.html">And *again*</a></li>


<li>
<a href="http://simon-cozens.org/draft-articles/email.html">The philosophy of the Email::* project</a></li>
</ul>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/editors/">&laquo; Editors</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/files/">Files &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
