<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Modules Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Modules</em> Category</h1>






                            
                            <div id="entry-664" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/08/making-perl-modules.html" rel="bookmark">Making Perl Reusable with Modules</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Andy Sylvester</span> on <abbr class="published" title="2007-08-07T00:00:00-08:00">August  7, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Perl software development can occur at several levels. When first developing the idea for an application, a Perl developer may start with a short program to flesh out the necessary algorithms. After that, the next step might be to create a package to support object-oriented development. The final work is often to create a Perl module for the package to make the logic available to all parts of the application. Andy Sylvester explores this topic with a simple mathematical function.</p>

<h3>Creating a Perl Subroutine</h3>

<p>I am working on ideas for implementing some mathematical concepts for a method of composing music. The ideas come from the work of <a href="http://en.wikipedia.org/wiki/Joseph_Schillinger">Joseph Schillinger</a>. At the heart of the method is being able to generate patterns using mathematical operations and using those patterns in music composition. One of the basic operations described by Schillinger is creating a "resultant," or series of numbers, based on two integers (or "generators"). Figure 1 shows a diagram of how to create the resultant of the integers 5 and 3.</p>

<p><img src="/pub/2007/08/09/graphics/Figure1.jpg" alt="creating the resultant of 5 and 3" /><br />
<em>Figure 1. Creating the resultant of 5 and 3</em></p>

<p>Figure 1 shows two line patterns with units of 5 and units of 3. The lines continue until both lines come down (or "close") at the same time. The length of each line corresponds to the product of the two generators (5 x 3 = 15). If you draw dotted lines down from where each of the two generator lines change state, you can create a third line that changes state at each of the dotted line points. The lengths of the segments of the third line make up the resultant of the integers 5 and 3 (3, 2, 1, 3, 1, 2, 3).</p>

<p>Schillinger used graph paper to create resultants in his <a href="http://www.schillingersystem.com/whatis.htm">System of Musical Composition</a>. However, another convenient way of creating a resultant is to calculate the modulus of a counter and then calculate a term in the resultant series based on the state of the counter. An algorithm to create the terms in a resultant might resemble:</p>

<pre><code>Read generators from command line
Determine total number of counts for resultant
   (major_generator * minor_generator)
Initialize resultant counter = 0
For MyCounts from 1 to the total number of counts
   Get the modulus of MyCounts to the major and minor generators
   Increment the resultant counter
   If either modulus = 0
     Save the resultant counter to the resultant array
     Re-initialize resultant counter = 0
   End if
End for</code></pre>

<p>From this design, I wrote a short program using the Perl modulus operator (<code>%</code>):</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# FILENAME: result01.pl
#
# USAGE: perl result01.pl major_generator minor_generator
#
# DESCRIPTION:
#    This Perl script will generate a Schillinger resultant
#    based on two integers for the major generator and minor
#    generator.
#
#    In normal usage, the user will input the two integers
#    via the command line. The sequence of numbers representing
#    the resultant will be sent to standard output (the console
#    window).
#
# INPUTS:
#    major_generator - First generator for the resultant, input
#                      as the first calling argument on the
#                      command line.
#
#    minor_generator - Second generator for the resultant, input
#                      as the second calling argument on the
#                      command line.
#
# OUTPUTS:
#    resultant - Sequence of numbers written to the console window
#
#**************************************************************

   use strict;
   use warnings;

   my $major_generator = $ARGV[0];
   my $minor_generator = $ARGV[1];

   my $total_counts   = $major_generator * $minor_generator;
   my $result_counter = 0;
   my $major_mod      = 0;
   my $minor_mod      = 0;
   my $i              = 0;
   my $j              = 0;
   my @resultant;

   print "Generator Total = $total_counts\n";

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $major_generator;
       $minor_mod = $i % $minor_generator;
       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@resultant, $result_counter);
          $result_counter = 0;
       }
       print "$i \n";
       print "Modulus of $major_generator is $major_mod \n";
       print "Modulus of $minor_generator is $minor_mod \n";
   }

   print "\n";
   print "The resultant is @resultant \n";</code></pre>

<p>Run the program with 5 and 3 as the inputs (<code>perl result01.pl 5 3</code>):</p>

<pre><code>Generator Total = 15
1
Modulus of 5 is 1
Modulus of 3 is 1
2
Modulus of 5 is 2
Modulus of 3 is 2
3
Modulus of 5 is 3
Modulus of 3 is 0
4
Modulus of 5 is 4
Modulus of 3 is 1
5
Modulus of 5 is 0
Modulus of 3 is 2
6
Modulus of 5 is 1
Modulus of 3 is 0
7
Modulus of 5 is 2
Modulus of 3 is 1
8
Modulus of 5 is 3
Modulus of 3 is 2
9
Modulus of 5 is 4
Modulus of 3 is 0
10
Modulus of 5 is 0
Modulus of 3 is 1
11
Modulus of 5 is 1
Modulus of 3 is 2
12
Modulus of 5 is 2
Modulus of 3 is 0
13
Modulus of 5 is 3
Modulus of 3 is 1
14
Modulus of 5 is 4
Modulus of 3 is 2
15
Modulus of 5 is 0
Modulus of 3 is 0

The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This result matches the resultant terms as shown in the graph in Figure 1, so it looks like the program generates the correct output.</p>













<h3>Creating a Perl Package from a Program</h3>

<p>With a working program, you can create a Perl package as a step toward being able to reuse code in a larger application. The initial program has two pieces of input data (the major generator and the minor generator). The single output is the list of numbers that make up the resultant. These three pieces of data could be combined in an object. The program could easily become a subroutine to generate the terms in the resultant. This could be a method in the class contained in the package. Creating a class implies adding a constructor method to create a new object. Finally, there should be some methods to get the major generator and minor generator from the object to use in generating the resultant (see the <a href="http://perldoc.perl.org/perlboot.html">perlboot</a> and <a href="http://perldoc.perl.org/perltoot.html">perltoot</a> tutorials for background on object-oriented programming in Perl).</p>

<p>From these requirements, the resulting package might be:</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# Filename: result01a.pl
#
# Description:
#    This Perl script creates a class for a Schillinger resultant
#    based on two integers for the major generator and the
#    minor generator.
#
# Class Name: Resultant
#
# Synopsis:
#
# use Resultant;
#
# Class Methods:
#
#   $seq1 = Resultant -&gt;new(5, 3)
#
#      Creates a new object with a major generator of 5 and
#      a minor generator of 3. These parameters need to be
#      initialized when a new object is created, as there
#      are no methods to set these elements within the object.
#
#   $seq1-&gt;generate()
#
#      Generates a resultant and saves it in the ResultList array
#
# Object Data Methods:
#
#   $major_generator = $seq1-&gt;get_major()
#
#      Returns the major generator
#
#   $minor_generator = $seq1-&gt;get_minor()
#
#      Returns the minor generator
#
#
#**************************************************************

{ package Resultant;
  use strict;
  sub new {
    my $class           = shift;
    my $major_generator = shift;
    my $minor_generator = shift;

    my $self = {Major =&gt; $major_generator,
                Minor =&gt; $minor_generator,
                ResultantList =&gt; []};

    bless $self, $class;
    return $self;
  }

  sub get_major {
    my $self = shift;
    return $self-&gt;{Major};
  }

  sub get_minor {
    my $self = shift;
    return $self-&gt;{Minor};
  }

  sub generate {
    my $self         = shift;
    my $total_counts = $self-&gt;get_major * $self-&gt;get_minor;
    my $i            = 0;
    my $major_mod;
    my $minor_mod;
    my @result;
    my $result_counter = 0;

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $self-&gt;get_major;
       $minor_mod = $i % $self-&gt;get_minor;

       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@result, $result_counter);
          $result_counter = 0;
       }
   }

   @{$self-&gt;{ResultList}} = @result;
  }
}

#
# Test code to check out class methods
#

# Counter declaration
my $j;

# Create new object and initialize major and minor generators
my $seq1 = Resultant-&gt;new(5, 3);

# Print major and minor generators
print "The major generator is ", $seq1-&gt;get_major(), "\n";
print "The minor generator is ", $seq1-&gt;get_minor(), "\n";

# Generate a resultant
$seq1-&gt;generate();

# Print the resultant
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>Execute the file (<code>perl result01a.pl</code>):</p>

<pre><code>The major generator is 5
The minor generator is 3
The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This output text shows the same resultant terms as produced by the first program.</p>

<h3>Creating a Perl Module</h3>

<p>From a package, you can create a Perl module to make the package fully reusable in an application. Also, you can modify our original test code into a series of module tests to show that the module works the same as the standalone package and the original program.</p>

<p>I like to use the Perl module <a href="http://search.cpan.org/perldoc?Module::Starter">Module::Starter</a> to create a skeleton module for the package code. To start, install the <code>Module::Starter</code> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Module::Starter</code> module installed, type <code>perldoc Module::Starter</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Select a working directory to create the module directory. This can be the same directory that you have been using to develop your Perl program. Type the following command (though with your own name and email address):</p>

<pre><code>$ <strong>module-starter --module=Music::Resultant --author="John Doe" \
    --email=john@johndoe.com</strong></code></pre>

<p>Perl should respond with:</p>

<pre><code>Created starter directories and files</code></pre>

<p>In the working directory, you should see a folder or directory called <em>Music-Resultant</em>. Change your current directory to <em>Music-Resultant</em>, then type the commands:</p>

<pre><code>$ <strong>perl Makefile.PL</strong>
$ <strong>make</strong></code></pre>

<p>These commands will create the full directory structure for the module. Now paste the text from the package into the module template at <em>Music-Resultant/lib/Music/Resultant.pm</em>. Open <em>Resultant.pm</em> in a text editor and paste the subroutines from the package after the lines:</p>

<pre><code>=head1 FUNCTIONS

=head2 function1

=cut</code></pre>

<p>When you paste the package source code, remove the opening brace from the package, so that the first lines appear as:</p>

<pre><code> package Resultant;
  sub new {
    use strict;
    my $class = shift;</code></pre>

<p>and the last lines of the source appears without the the final closing brace as:</p>

<pre><code>   @{$self-&gt;{ResultList}} = @result;
  }</code></pre>

<p>After making the above changes, save <em>Resultant.pm</em>. This is all that you need to do to create a module for your own use. If you eventually release your module to the Perl community or upload it to <a href="http://www.cpan.org/">CPAN</a>, you should do some more work to prepare the module and its documentation (see the <a href="http://perldoc.perl.org/perlmod.html">perlmod</a> and <a href="http://perldoc.perl.org/perlmodlib.html">perlmodlib</a> documentation for more information).</p>













<p>After modifying <em>Resultant.pm</em>, you need to install the module to make it available for other Perl applications. To avoid configuration issues, install the module in your home directory, separate from your main Perl installation.</p>

<ol>
<li>
<p>In your home directory, create a <em>lib/</em> directory, then create a <em>perl/</em> directory within the <em>lib/</em> directory. The result should resemble:</p>

<pre><code>/home/myname/lib/perl</code></pre>
</li>

<li>
<p>Go to your module directory (<em>Music-Resultant</em>) and re-run the build process with a directory path to tell Perl where to install the module:</p>

<pre><code>$ <strong>perl Makefile.PL LIB=/home/myname/lib/perl</strong> $
<strong>make install</strong></code></pre>

<p>Once this is complete, the module will be installed in the directory.</p>
</li>
</ol>

<p>The final step in module development is to add tests to the <em>.t</em> file templates created in the module directory. The Perl distribution includes several built-in test modules, such as <a href="http://search.cpan.org/perldoc?Test::Simple">Test::Simple</a> and <a href="http://search.cpan.org/perldoc?Test::More">Test::More</a> to help test Perl subroutines and modules.</p>

<p>To test the module, open the file <em>Music-Resultant/t/00-load.t</em>. The initial text in this file is:</p>

<pre><code>#!perl -T

use Test::More tests =&gt; 1;

BEGIN {
    use_ok( 'Music::Resultant' );
}

diag( "Testing Music::Resultant $Music::Resultant::VERSION, Perl $], $^X" );</code></pre>

<p>You can run this test file from the <em>t/</em> directory using the command:</p>

<pre><code>perl -I/home/myname/lib/perl -T 00-load.t</code></pre>

<p>The <code>-I</code> switch tells the Perl interpreter to look for the module <em>Resultant.pm</em> in your alternate installation directory. The directory path must immediately follow the <code>-I</code> switch, or Perl may not search your alternate directory for your module. The <code>-T</code> switch is necessary because there is a <code>-T</code> switch in the first line of the test script, which turns on taint checking. (Taint checking only works when enabled at Perl startup; <code>perl</code> will exit with an error if you try to enable it later.) Your results should resemble the following(your Perl version may be different).</p>

<pre><code>1..1
ok 1 - use Music::Resultant;
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>The test code from the second listing is easy to convert to the format used by <code>Test::More</code>. Change the number at the end of the tests line from 1 to 4, as you will be adding three more tests to this file. The template file has an initial test to show that the module exists. Next, add tests after the <code>BEGIN</code> block in the file:</p>

<pre><code># Test 2:
my $seq1 = Resultant-&gt;new(5, 3);  # create an object
isa_ok ($seq1, Resultant);        # check object definition

# Test 3: check major generator
my $local_major_generator = $seq1-&gt;get_major();
is ($local_major_generator, 5, 'major generator is correct' );

# Test 4: check minor generator
my $local_minor_generator = $seq1-&gt;get_minor();
is ($local_minor_generator, 3, 'minor generator is correct' );</code></pre>

<p>To run the tests, retype the earlier command line in the <em>Music-Resultant/</em> directory:</p>

<pre><code>$ <strong>perl -I/home/myname/lib/perl -T t/00-load.t</strong></code></pre>

<p>You should see the results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>These tests create a Resultant object with a major generator of 5 and a minor generator of 3 (Test 2), and check to see that the major generator in the object is correct (Test 3), and that the minor generator is correct (Test 4). They do <em>not</em> cover the resultant terms. One way to check the resultant is to add the test code used in the second listing to the <em>.t</em> file:</p>

<pre><code># Generate a resultant
$seq1-&gt;generate();

# Print the resultant
my $j;
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>You should get the following results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
The resultant is 3 2 1 3 1 2 3
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>That's not valid test output, so it needs a little bit of manipulation. To check the elements of a list using a testing function, install the <a href="http://search.cpan.org/perldoc?Test::Differences">Test::Differences</a> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Test::Differences</code> module installed, type <code>perldoc Test::Differences</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Once that module is part of your Perl installation, change the number of tests from 4 to 5 on the <code>Test::More</code> statement line and add a following statement after the <code>use Test::More</code> statement:</p>

<pre><code>use Test::Differences;</code></pre>

<p>Finally, replace the code that prints the resultant with:</p>

<pre><code># Test 5: (uses Test::Differences and associated modules)
$seq1-&gt;generate();
my @result   = @{$seq1-&gt;{ResultList}};
my @expected = (3, 2, 1, 3, 1, 2, 3);
eq_or_diff \@result, \@expected, "resultant terms are correct";</code></pre>

<p>Now when the test file runs, you can confirm that the resultant is correct:</p>

<pre><code>1..5
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
ok 5 - resultant terms are correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<h3>Summary</h3>

<p>There are multiple levels of Perl software development. Once you start to create modules to enable reuse of your Perl code, you will be able to leverage your effort into larger applications. By using Perl testing modules, you can ensure that your code works the way you expect and provide a way to ensure that the modules continue to work as you add more features.</p>

<h3>Resources</h3>

<p>Here are some other good resources on creating Perl modules:</p>

<ul>
<li><a href="http://world.std.com/~swmcd/steven/perl/module_mechanics.html">Perl Module Mechanics</a> goes into detail about the various files created when you create a module directory.</li>

<li><a href="http://mathforum.org/~ken/perl_modules.html">Creating (and Maintaining) Perl Modules</a> includes information on coding, documentation, testing, and installation.</li>

<li><a href="http://www.perlmonks.org/?node_id=431702">Jose's Guide for creating Perl modules</a> gives some helpful tips on getting a module ready for CPAN distribution.</li>
</ul>

<p>Here are some good resources for using Perl testing modules like <code>Test::Simple</code> and <code>Test::More</code>:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?Test::Tutorial">Test::Tutorial</a> gives the basics of using <code>Test:Simple</code> and <code>Test::More</code>.</li>

<li><a href="/pub/a/2001/12/04/testing.html">An Introduction to Testing</a> presents the benefits of developing tests and code at the same time, and provides a variety of examples.</li>
</ul>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-662" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/07/options-and-configuration.html" rel="bookmark">Option and Configuration Processing Made Easy</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Jon Allen</span> on <abbr class="published" title="2007-07-12T00:00:00-08:00">July 12, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>When you first fire up your editor and start writing a program, it's tempting to hardcode any settings or configuration so you can focus on the real task of getting the thing working. But as soon as you have users, even if the user is only yourself, you can bet there will be things they want to choose for themselves.</p>

<p>A search on CPAN reveals almost 200 different modules dedicated to option processing and handling configuration files. By anyone's standards that's quite a lot, certainly too many to evaluate each one.</p>

<p>Luckily, you already have a great module right in front of you for handling options given on the command line: <a href="http://search.cpan.org/perldoc?Getopt::Long"><code>Getopt::Long</code></a>, which is a core module included as standard with Perl. This lets you use the standard double-dash style of option names:</p>

<pre><code>myscript --source-directory "/var/log/httpd" --verbose \ --username=JJ</code></pre>

<h4>Using Getopt::Long</h4>

<p>When your program runs, any command-line arguments will be in the <code>@ARGV</code> array. <code>Getopt::Long</code> exports a function, <code>GetOptions()</code>, which processes <code>@ARGV</code> to do something useful with these arguments, such as set variables or run blocks of code. To allow specific option names, pass a list of option specifiers in the call to <code>GetOptions()</code> together with references to the variables in which you want the option values to be stored.</p>

<p>As an example, the following code defines two options, <code>--run</code> and <code>--verbose</code>. The call to <code>GetOptions()</code> will then assign the value <code>1</code> to the variables <code>$run</code> and <code>$verbose</code> respectively if the relevant option is present on the command line.</p>

<pre><code>use Getopt::Long;
my ($run,$verbose);
GetOptions( 'run'     =&gt; \$run,
             'verbose' =&gt; \$verbose );</code></pre>

<p>When <code>Getopt::Long</code> has finished processing options, any remaining arguments will remain in <code>@ARGV</code> for your script to handle (for example, specified filenames). If you use this example code and call your script as:</p>

<pre><code>myscript --run --verbose file1 file2 file3</code></pre>

<p>then after <code>GetOptions()</code> has been called the <code>@ARGV</code> array will contain the values <code>file1</code>, <code>file2</code>, and <code>file3</code>.</p>

<h4>Types of Command-Line Options</h4>

<p>The option specifier provided to <code>GetOptions()</code> controls not only the option name, but also the option type. <code>Getopt::Long</code> gives a lot of flexibility in the types of option you can use. It supports Boolean switches, incremental switches, options with single values, options with multiple values, and even options with hash values.</p>

<p>Some of the most common specifiers are:</p>

<pre><code>name     # Presence of the option will set $name to 1
name!    # Allows negation, e.g. --name will set $name to 1,
         #    --noname will set $name to 0
name+    # Increments the variable each time the option is found, e.g.
         # if $name = 0 then --name --name --name will set $name to 3
name=s   # String value required
         #    --name JJ or --name=JJ will set $name to JJ
         # Spaces need to be quoted
         #    --name="Jon Allen" or --name "Jon Allen"</code></pre>

<p>So, to create an option that requires a string value, format the call to <code>GetOptions()</code> like this:</p>

<pre><code>my $name;
GetOptions( 'name=s' =&gt; \$name );</code></pre>

<p>The value is required. If the user omits it, as in:</p>

<pre><code>myscript --name</code></pre>

<p>then the call to <code>GetOptions()</code> will <code>die()</code> with an appropriate error message.</p>

<h4>Options with Multiple Values</h4>

<p>The option specifier consists of four components: the option name; data type (Boolean, string, integer, etc.); whether to expect a single value, a list, or a hash; and the minimum and maximum number of values to accept. To require a list of string values, build up the option specifier:</p>

<pre><code>Option name:   name
Option value:  =s    (string)
Option type:   @     (array)
Value counter: {1,}  (at least 1 value required, no upper limit)</code></pre>

<p>Putting these all together gives:</p>

<pre><code>my $name;
GetOptions('name=s@{1,}' =&gt; \$name);</code></pre>

<p>Now invoking the script as:</p>

<pre><code>myscript --name Barbie Brian Steve</code></pre>

<p>will set <code>$name</code> to the array reference <code>['Barbie','Brian','Steve']</code>.</p>

<p>Giving a hash value to an option is very similar. Replace <code>@</code> with <code>%</code> and on the command line give arguments as key=value pairs:</p>

<pre><code>my $name;
GetOptions('name=s%{1,}',\$name);</code></pre>

<p>Running the script as:</p>

<pre><code>myscript --name Barbie=Director JJ=Member</code></pre>

<p>will store the hash reference <code>{ Barbie =&gt; 'Director', JJ =&gt; 'Member' }</code> in <code>$name</code>.</p>

<h4>Storing Options in a Hash</h4>

<p>By passing a hash reference as the first argument to <code>GetOptions</code>, you can store the complete set of option values in a hash instead of defining a separate variable for each one.</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose' );</code></pre>

<p>Option names will be hash keys, so you can refer to the <code>name</code> value as <code>$options{name}</code>. If an option is not present on the command line, then the corresponding hash key will not be present.</p>

<h4>Options that Invoke Subroutines</h4>

<p>A nice feature of <code>Getopt::Long</code> is that, as an alternative to simply setting a variable when an option is found, you can tell the module to run any code of your choosing. Instead of giving <code>GetOptions()</code> a variable reference to store the option value, pass either a subroutine reference or an anonymous code reference. This will then be executed if the relevant option is found.</p>

<pre><code>GetOptions( version =&gt; sub{ print "This is myscript, version 0.01\n"; exit; }
            help    =&gt; \&amp;display_help );</code></pre>

<p>When used in this way, <code>Getopt::Long</code> also passes the option name and value as arguments to the subroutine:</p>

<pre><code>GetOptions( name =&gt; sub{ my ($opt,$value) = @_; print "Hello, $value\n"; } );</code></pre>

<p>You can still include code references in the call to <code>GetOptions()</code> even if you use a hash to store the option values:</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose', 'dest=s',
            'version' =&gt; sub{ print "This is myscript, version 0.01\n"; exit; } );</code></pre>

<h4>Dashes or Underscores?</h4>

<p>If you need to have option names that contain multiple words, such as a setting for "Source directory," you have a few different ways to write them:</p>

<pre><code>--source-directory
--source_directory
--sourcedirectory</code></pre>

<p>To give a better user experience, <code>Getopt::Long</code> allows option aliases to allow either format. Define an alias by using the pipe character (<code>|</code>) in the option specifier:</p>

<pre><code>my %options;
GetOptions( \%options, 'source_directory|source-directory|sourcedirectory=s' );</code></pre>

<p>Note that if you're storing the option values in a hash, the first option name (in this case, <code>source_directory</code>) will be the hash key, even if your user gave an alias on the command line.</p>













<p>If you have a lot of options, it might be helpful to generate the aliases using a function:</p>

<pre><code>use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

my %specifiers = ( 'source-directory' =&gt; '=s',
                   'verbose'          =&gt; '' );
my %options;
GetOptions( \%options, optionspec(%specifiers) );

print Dumper(\%options);

sub optionspec {
  my %option_specs = @_;
  my @getopt_list;

  while (my ($option_name,$spec) = each %option_specs) {
    (my $variable_name = $option_name) =~ tr/-/_/;
    (my $nospace_name  = $option_name) =~ s/-//g;
    my  $getopt_name   = ($variable_name ne $option_name)
        ? "$variable_name|$option_name|$nospace_name" : $option_name;

    push @getopt_list,"$getopt_name$spec";
  }

  return @getopt_list;
}</code></pre>

<p>Running this script with each format in turn shows that they are all valid:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --source-directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --source_directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --sourcedirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<p>Additionally, <code>Getopt::Long</code> is case-insensitive by default (for option names, not values), so your users can also use <code>--SourceDirectory</code>, <code>--sourceDirectory</code>, etc., as well:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --SourceDirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<h4>Configuration Files</h4>

<p>The next stage on from command-line options is to let your users save their settings into config files. After all, if your program expands to have numerous options it's going to be a real pain to type them in every time.</p>

<p>When it comes to the format of a configuration file, there are a lot of choices, such as XML, INI files, and the Apache <em>httpd.conf</em> format. However, all of these formats share a couple of problems. First, your users now have two things to learn: the command-line options and the configuration file syntax. Second, even though many CPAN modules are available to parse the various config file formats, you still must write the code in your program to interact with your chosen module's API to set whatever variables you use internally to store user settings.</p>

<h4>Getopt::ArgvFile to the Rescue</h4>

<p>Fortunately, someone out there in CPAN-land has the answer (you can always count on the Perl community to come up with innovative solutions). <a href="http://search.cpan.org/dist/Getopt-ArgvFile"><code>Getopt::ArgvFile</code></a> tackles both of these problems, simplifying the file format and the programming interface in one fell swoop.</p>

<p>To start with, the file format used by <code>Getopt::ArgvFile</code> is extremely easy for users to understand. Config settings are stored in a plain text file that holds exactly the same directives that a user would type on the command line. Instead of typing:</p>

<pre><code>myscript --source-directory /usr/local/src --verbose --logval=alert</code></pre>

<p>your user can use the config file:</p>

<pre><code>--source-directory /usr/local/src
--verbose
--logval=alert</code></pre>

<p>and then run <code>myscript</code> for instant user gratification with no steep learning curve.</p>

<p>Now to the clever part. <code>Getopt::ArgvFile</code> itself doesn't actually care about the contents of the config file. Instead, it makes it appear to your program that all the settings were actually options typed on the command line--the processing of which you've already covered with <code>Getopt::Long</code>. As well as saving your users time by not making them learn a new syntax, you've also saved yourself time by not needing to code against a different API.</p>

<p>The most straightforward method of using <code>Getopt::ArgvFile</code> involves simply including the module in a <code>use</code> statement:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>A program called <em>myscript</em> that contains this code will search the user's home directory (whatever the environment variable <code>HOME</code> is set to) for a config file called <em>.myscript</em> and extract the contents ready for processing by <code>Getopt::Long</code>.</p>

<p>Here's a complete example:</p>

<pre><code>use strict;
use warnings;
use Getopt::ArgvFile home=&gt;1;
use Getopt::Long;

my %config;
GetOptions( \%config, 'name=s' );

if ($config{name}) {
  print "Hello, $config{name}\n";
} else {
  print "Who am I talking to?\n";
}</code></pre>

<p>Save this as <em>hello</em>, then run the script with and without a command-line option:</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Who am I talking to?

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>

<p>Now, create a settings file called <em>.hello</em> in your home directory containing the <code>--name</code> option. Remember to double quote the value if you want to include spaces.</p>

<pre><code>varos:~/writing/argvfile jj$ cat ~/.hello
--name "Jon Allen"</code></pre>

<p>Running the script without any arguments on the command line will show that it loaded the config file, but you can also override the saved settings by giving the option on the command line as normal.</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>













<h4>Advanced Usage</h4>

<p>In many cases the default behaviour invoked by loading the module will be all you need, but <code>Getopt::ArgvFile</code> can also cater to more specific requirements.</p>

<h4>User-Specified Config Files</h4>

<p>Suppose your users want to save different sets of options and specify which one to use when they run your program. This is possible using the <code>@</code> directive on the command line:</p>

<pre><code>varos:~/writing/argvfile jj$ cat jj.conf
--name JJ

varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello @jj.conf
Hello, JJ</code></pre>

<p>Note that there's no extra programming required to use this feature; handling <code>@</code> options is native to <code>Getopt::ArgvFile</code>.</p>

<h4>Changing the Default Config Filename or Location</h4>

<p>Depending on your target audience, the naming convention offered by <code>Getopt::ArgvFile</code> for config files might not be appropriate. Using a dotfile (<em>.myscript</em>) will render your user's config file invisible in his file manager or when listing files at the command prompt, so you may wish to use a name like <em>myscript.conf</em> instead.</p>

<p>Again, it may also be helpful to allow for default configuration files to appear somewhere other than the user's home directory, for example, if you need to allow system-wide configuration.</p>

<p>A further consideration here is <a href="http://par.perl.org/">PAR</a> , the tool for creating standalone executables from Perl programs. PAR lets you include data files as well as Perl code, so you can bundle a default settings file using a command such as:</p>

<pre><code>pp hello -o hello.exe -a hello.conf</code></pre>

<p>which will be available to your script as <code>$ENV{PAR_TEMP}/inc/hello.conf</code>.</p>

<p>I mentioned earlier that <code>Getopt::ArgvFile</code> can load arbitrary config files if the filename appears with the <code>@</code> directive on the command line. Essentially, what the module does when loaded with:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>is to prepend <code>@ARGV</code> with <code>@$ENV{HOME}/.scriptname</code>, then resolve all <code>@</code> directives, leaving <code>@ARGV</code> with the contents of the files. This means that running the script as:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>is basically equivalent to writing:</p>

<pre><code>myscript @$ENV{HOME}/.myscript --name-JJ</code></pre>

<p>To load other config files, <code>Getopt::ArgvFile</code> supports disabling the automatic <code>@ARGV</code> processing and triggering it later. With a little manipulation of <code>@ARGV</code> first, you can make:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>equivalent to:</p>

<pre><code>myscript @/path/to/default.conf @/path/to/system.conf @/path/to/user.conf \
    --name=JJ</code></pre>

<p>which will load the set of config files in the correct priority order.</p>

<p>All you need to do to enable this feature is change the <code>use</code> statement to read:</p>

<pre><code>use Getopt::ArgvFile qw/argvFile/;</code></pre>

<p>Loading the module in this way tells <code>Getopt::ArgvFile</code> to export the function <code>argvFile()</code>, which your program needs to call to process the <code>@</code> directives, and also prevents any automated processing from occurring.</p>

<p>Here's an example that first loads a config file from the application bundle (if packaged by PAR) and then from the directory containing the application binary:</p>

<pre><code>use File::Basename qw/basename/;
use FindBin qw/$Bin/;
use Getopt::ArgvFile qw/argvFile/;

# Define config filename as &lt;application_name&gt;.conf
(my $configfile = basename($0)) =~ s/^(.*?)(?:\..*)?$/$1.conf/;

# Include config file from the same directory as the application binary
if (-e "$Bin/$configfile") {
  unshift @ARGV,'@'."$Bin/$configfile";
}

# If we have been packaged with PAR, include the config file from the
# application bundle
if ($ENV{PAR_TEMP} and -e "$ENV{PAR_TEMP}/inc/$configfile") {
  unshift @ARGV,'@'."$ENV{PAR_TEMP}/inc/$configfile";
}

argvFile();  # Process @ARGV to load specified config files</code></pre>

<p>You can also use this technique together with <a href="http://search.cpan.org/dist/File-HomeDir"><code>File::HomeDir</code></a> to access the user's application data directory in a cross-platform manner, so that the location of the config file conforms to the conventions set by the user's operating system.</p>

<h4>Summary</h4>

<p><code>Getopt::Long</code> provides an easy to use, extensible system for processing command-line options. With the addition of <code>Getopt::ArgvFile</code>, you can seamlessly handle configuration files with almost no extra coding. Together, these modules should be first on your list when writing scripts that need any amount of configuration.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-660" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/06/better-code-through-destruction.html" rel="bookmark">Better Code Through Destruction</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Igor Gariev</span> on <abbr class="published" title="2007-06-07T00:00:00-08:00">June  7, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Larry Wall said that Perl makes easy things easy and hard things possible. Perl is good both for writing a two-line script that saves the world at the last minute (well, at least it saves you and your project) and for robust projects. However, good Perl programming techniques can be quite different between small and complex applications. Consider, for example, Perl's garbage collector. It frees a programmer from memory management issues most of the time...until the programmer creates circular references.</p>

<p>Perl's garbage collector counts references. When the count reaches zero (which means that no one has a reference), Perl reclaims the entity. The approach is simple and effective. However, circular references (when object A has a reference to object B, and object B has a reference to object A) present a problem. Even if nothing else in the program has a reference to either A or B, the reference count can never reach zero. Objects A and B do not get destroyed. If the code creates them again and again (perhaps in a loop), you get a memory leak. The amount of memory allocated by the program increases without a sensible reason and can never decrease. This effect may be acceptable for simple run-and-exit scripts, but it's not acceptable for programs running 24x365, such as in a mod_perl or FastCGI environment or as standalone servers.</p>

<p>Circular references are sometimes too useful to avoid. A common example is a tree-like data structure. To navigate both directions--from root to leaves and vice versa--a parent node has a list of children and a child node has a reference to its parent. Here are the circular references. Many CPAN modules implement their data models this way, including <a href="http://search.cpan.org/perldoc?HTML::Tree">HTML::Tree</a>, <a href="http://search.cpan.org/perldoc?XML::DOM">XML::DOM</a>, and <a href="http://search.cpan.org/perldoc?Text::PDF::File">Text::PDF::File</a>. All these modules provide a method to release the memory. The client application must call the method when it no longer needs an object. However, the requirement of an explicit call is not very appealing and can result in unsafe code:</p>

<pre><code>    ##
    ## Code with a memory leak
    #
    use HTML::TreeBuilder;

    foreach my $filename (@ARGV) {
        my $tree = HTML::TreeBuilder-&gt;new;
        $tree-&gt;parse_file($filename);

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## Do the actual work (say, extract images) here
        ## ...
        ## and release the memory
        ##
        $tree-&gt;delete;
    }</code></pre>

<p>The problem in the code is the <code>next</code> statement; HTML documents with no <code>&lt;img ...</code> tags will not be released. Actually, any call of <code>next</code>, <code>last</code>, <code>return</code> (inside a subroutine), or <code>die</code> (inside an <code>eval {}</code> block) is unsafe and will lead to a memory leak. Of course, it is possible to move the release code into a <code>continue</code> block for <code>last</code> or <code>next</code>, or to write code to delete the tree before every <code>return</code> or <code>die</code>, but the code easily becomes messy.</p>

<p>There is a better solution--the paradigm of "resource acquisition is initialization (and destruction is resource relinquishment)." (Ironically, the second half of its name is often omitted, even though it's probably the most important part). The idea is simple. Create a special guard object (of another class) whose sole responsibility is to release the resource. When the guard object gets destroyed, its destructor deletes the tree. The code may look like:</p>

<pre><code>    ##
    ## A special sentry object is employed
    ##
    use HTML::TreeBuilder;

    foreach my $filename (@ARGV) {
        my $tree = HTML::TreeBuilder-&gt;new;
        $tree-&gt;parse_file($filename);

        <strong>my $sentry = Sentry-&gt;new($tree);</strong>

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## next, last or return are safe here.
        ## Tree will be deleted automatically.
        ##
    }

    package Sentry;

    sub new {
        my $class = shift;
        my $tree  = shift;
        return bless {tree =&gt; $tree}, $class;
    }

    sub DESTROY {
        my $self = shift;
        $self-&gt;{tree}-&gt;delete;
    }</code></pre>

<p>Note that now there is no need to call <code>$tree-&gt;delete</code> explicitly at the end of the loop. The magic is simple. When program flow leaves the scope, <code>$sentry</code> is reclaimable because it participates in no circular references. The code of <code>DESTROY</code> method of the <code>Sentry</code> package calls, in turn, the method <code>delete</code> of the <code>$tree</code> object. This is one solution for all means; memory will be released however you leave the block.</p>

<p>Finally, there is no need to code your own <code>Sentry</code> class. Use <a href="http://search.cpan.org/perldoc?Object::Destroyer">Object::Destroyer</a>, originally written by Adam Kennedy. As you may guess by its name, it is the object to destroy other objects:</p>

<pre><code>    ##
    ## An of-the-CPAN solution with Object::Destroyer
    ##
    use HTML::TreeBuilder;
    use Object::Destroyer 2.0;

    foreach my $filename (@ARGV) {
        my $tree   = HTML::TreeBuilder-&gt;new;
        <strong>my $sentry = Object::Destroyer-&gt;new($tree, 'delete');</strong>
        $tree-&gt;parse_file($filename);

        next unless $tree-&gt;look_down('_tag', 'img');
        ##
        ## You can safely return, die, next or last here.
        ##
    }</code></pre>

<p>Because the name of the release method may vary between modules, it is the constructor's second argument.</p>













<p>Finally, you can destroy any data structure, not just objects, if you provide code to do so. Pass in a subroutine reference or an anonymous subroutine:</p>

<pre><code>    ##
    ## An unblessed data structure with circular references
    ## that cannot untangle itself.
    ##
    use Object::Destroyer 2.0;
    while (1) {
        my (%a, %b);
        $a{b}      = \%b;
        $b{a}      = \%a;
        my $sentry = Object::Destroyer-&gt;new( sub { undef $a{b} } );
    }</code></pre>

<p>Just for fun, comment out the line with the <code>$sentry</code> object and watch the memory consumption of the running script.</p>

<h3>Using Object::Destroyer As a Wrapper</h3>

<p><code>Object::Destroyer</code> can make life easier for module authors, too.</p>

<p>If you have written a library with circular references, you may ask your clients to explicitly call a disposal method or use a new feature of Perl (stable since 5.8; see <a href="http://search.cpan.org/perldoc?Scalar::Util">Scalar::Util</a>)--weak references. Weak references do not increment reference counts of the objects to which they refer, so the Perl garbage collector can collect the referents. In the tree example, all references from leaves to parents (but not vice versa, or the tree will be lost!) may be weak. When the final reference to the root node goes away, Perl will dispose of it, which will remove its references to all of its children recursively. They will all reach zero, and Perl will reclaim them all down the branches of the tree to every leaf.</p>

<p>Indeed, some CPAN modules use this approach (<a href="http://search.cpan.org/perldoc?XML::Twig">XML::Twig</a>). However, this solution works only if weak refs are available; this is certainly not the case for older Perl. Secondly, this may require quite a bit of rewriting (there are nine calls to <code>weaken</code> throughout the code of <code>XML::Twig</code> 3.26).</p>

<p>Alternatively, you may use <code>Object::Destroyer</code> internally in your library code. It can work as an almost transparent wrapper around your object:</p>

<pre><code>    ##
    ## Object::Destroyer as a wrapper
    ##
    package My::Tree;
    use Object::Destroyer 2.0;

    sub new {
        my $class = shift;
        my $self  = bless {}, $class;
        $self-&gt;populate;

        <strong>return Object::Destroyer-&gt;new( $self, 'release' );</strong>
    }

    sub release{
        ## actual memory release code
    }

    sub say_hello{
        my $self = shift;
        print "Hello, I'm object of class ", ref($self), "\n";
    }

    package main;
    {
        my $tree = My::Tree-&gt;new;
        $tree-&gt;say_hello;
        ##
        ## $tree-&gt;release will be called by Object::Destroyer;
        ##
    }</code></pre>

<p>The object <code>$tree</code> in the client code is actually an <code>Object::Destroyer</code> object that dispatches all invoked methods to the underlying object of class <code>My::Tree</code>. The method <code>say_hello</code> sees no difference at all--it receives an original <code>$self</code> object. Changes to code are minimal and well localized.</p>

<p>The approach has a limitation, too: clients must not access attributes of the object directly (such as <code>$tree-&gt;{age}</code>). This is a bad practice in client code anyway. Additionally, there is a small time penalty for method calls by client-side code. Calls made from the library code itself are not affected.</p>

<h3>Exceptions and Resource Deallocation</h3>

<p><a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource acquisition is initialization</a> is a powerful technique to apply to the management of various critical resources, not only memory. It is most useful when using exceptions to handle errors. This combination makes code quite reliable: exceptions separate normal execution logic and error handling, and RAII sentries guarantee the correct release of every sensitive resource.</p>

<p>Consider alarms as an example. Assume that you have to call some potentially long-running (or even never-ending) code. You don't want your script to hang up, and prefer to break its execution. Alarms are just right for the task. However, the first attempt at good code might be awkward:</p>

<pre><code>    ##
    ## Alarm example 1. Naive.
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        long_running_code();
        ## Cancel the alarm if code returned within 5 sec.
        alarm(0);
    };
    if ($@ &amp;&amp; $@ eq "Timed out\n") {
        ## Process the error here
    }</code></pre>

<p>This code will work fine until <code>long_running_code()</code> dies. In this case, the <code>eval</code> block will catch the <code>die</code>, but not the alarm. If this occurred in a program that must run 24 hours a day, the program would end in 5 seconds.</p>

<p>This next example is much better; actually it is real-world code. It is enough for many applications. However, it's not completely bulletproof either:</p>

<pre><code>    ##
    ## Alarm example 2. A standard solution.
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        long_running_code();
        ## Cancel the alarm if long_running_code() returns within 5 sec.
        alarm(0);
    };
    ## Cancel the alarm if the long_running_code() died.
    alarm(0);</code></pre>

<p>How many times will the alarm be cancelled in the following example?</p>

<pre><code>    ##
    ## Alarm example 3. Malicious code.
    ##
    LOOP:
    foreach my $arg (1..3) {
        eval{
            local $SIG{ALRM} = sub { die "Timed out\n" };
            alarm(5);
            long_running_code($arg);
            alarm(0);
        };
        alarm(0);
    }
    sub long_running_code{ last LOOP; }</code></pre>

<p>Oops, none.</p>

<p>The RAII solution is more reliable:</p>

<pre><code>    ##
    ## Alarm example 4.
    ## Resource is under control of Object::Destroyer
    ##
    eval{
        local $SIG{ALRM} = sub { die "Timed out\n" };
        alarm(5);
        my $sentry = Object::Destroyer-&gt;new( sub {alarm(0)} );
        long_running_code();
    };</code></pre>

<p>No matter how the code exits the <code>eval</code> block, Perl will destroy the <code>$sentry</code> object. That destruction will call <code>alarm(0)</code>.</p>













<p>You can manage many sensitive resources this way, including file locks, semaphores, and even locks of database tables.</p>

<pre><code>    ##
    ## File lock.
    ##
    use Fcntl ':flock';

    open my($fh), "&gt;$filename.lock";
    eval{
        flock($fh, LOCK_EX);
        my $sentry = Object::Destroyer-&gt;new( sub {flock($fh, LOCK_UN)} );
        ##
        ## Actual lock-sensitive code is here.
        ## It is safe to die.
        ##
    };

    ##
    ## Semaphore
    ##
    use Thread::Semaphore;
    use Object::Destroyer;

    my $s = Thread::Semaphore-&gt;new();
    eval{
        $s-&gt;down;
        my $sentry = Object::Destroyer-&gt;new( sub { $s-&gt;up } );
        ##
        ## Critical code is here, die is safe
        ##
    };

    ##
    ## MySQL database table lock.
    ##
    use DBI;

    my $dbh = DBI-&gt;connect("dbi:mysql:...", "", "");
    eval{
        $dbh-&gt;do("LOCK TABLE table1 READ");
        my $sentry = Object::Destroyer-&gt;new(
            sub { $dbh-&gt;do("UNLOCK TABLES"); }
        );
        ##
        ## Again, actual code must be here
        ##
    };</code></pre>

<p>The code is clean, simple, and quite self-explanatory.</p>

<h3>Simple Transactions</h3>

<p>Everyone who works with relational databases knows how useful transactions are. One of the features of transactions is atomicity: either all modifications of data are committed at once, or all of them are ignored. Your data is always consistent; it's not possible to leave it in an inconsistent state. The same effect is possible in Perl code:</p>

<pre><code>    use Object::Destroyer 2.0;

    my ($account1, $account2) = (15, 15);

    printf("Account1=%d, Account2=%d, Total=%d\n",
        $account1, $account2, $account1+$account2);

    eval {
        my $coderef = create_savepoint(\$account1, \$account2);
        my $sentry  = Object::Destroyer-&gt;new($coderef);

        die "before changes" if rand &gt; 0.7;
        $account1 += 3;
        die "after account 1 was modified" if rand &gt; 0.7;
        $account2 -= 3;
        die "after account 2 was modified" if rand &gt; 0.7;

        ##
        ## The transaction is considered to be committed here
        ## and $sentry can be dismissed.
        ## $coderef-&gt;() will not be called.
        ##
        $sentry-&gt;dismiss;

        die "after transaction is committed" if rand &gt; 0.7;
    };
    print "Died $@" if $@;
    printf("Account1=%d, Account2=%d, Total=%d\n",
        $account1, $account2, $account1+$account2);

    sub create_savepoint {
        ## Save references to variables and their current values
        my @vars;
        foreach my $ref (@_) {
            die "Can remember only scalar values" unless ref($ref) eq 'SCALAR';
            push @vars, { ref =&gt; $ref, value =&gt; $$ref };
        }

        ## A closure to restore their values
        return sub {
            foreach my $var (@vars) {
                ${ $var-&gt;{ref} } = $var-&gt;{value};
            }
        };
    }</code></pre>

<p>Run the script several times. Due to <code>rand</code>, it will break on varying lines, but it is not possible to get a Total value other than 30.</p>

<h3>See Also</h3>

<p>RAII is by no means a new technique. It is very popular in the world of C++ programming. If you are not afraid of C++, you may find interesting the standard container <a href="http://en.wikipedia.org/wiki/Auto_ptr">auto_ptr</a> and <a href="http://www.gotw.ca/publications/using_auto_ptr_effectively.htm">effective auto_ptr usage</a>. The non-standard <a href="http://www.ddj.com/dept/cpp/184403758">ScopeGuard</a> class provides lexically scoped resource management in C++.</p>

<p>The <a href="http://search.cpan.org/perldoc?Devel::Monitor">Devel::Monitor</a> module has guidelines on how to design data structures with weak and circular references. Its primary goal, by the way, is to trace the memory consumption of a running script.</p>

<p>There are several modules for lexically scoped resource management on CPAN, but the <a href="http://search.cpan.org/perldoc?Object::Destroyer">Object::Destroyer</a> is my favorite. You may also look at <a href="http://search.cpan.org/perldoc?Hook::Scope">Hook::Scope</a>, <a href="http://search.cpan.org/perldoc?Scope::Guard">Scope::Guard</a> and <a href="http://search.cpan.org/perldoc?Sub::ScopeFinalizer">Sub::ScopeFinalizer</a>.</p>

<p>Finally, <a href="/pub/a/2002/11/14/exception.html">Object Oriented Exception Handling in Perl</a> discusses why exceptions are invaluable for big projects.</p>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/mail-and-usenet-news/">&laquo; Mail and USENET News</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/mod-perl/">mod_perl &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
