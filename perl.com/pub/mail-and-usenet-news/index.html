<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Mail and USENET News Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Mail and USENET News</em> Category</h1>






                            
                            <div id="entry-874" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/02/mbox2wap.html" rel="bookmark">Mail to WAP Gateways</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Pete Sergeant</span> on <abbr class="published" title="2004-02-13T00:00:00-08:00">February 13, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>It's coming up to Valentine&#39;s day again,
and invariably my thoughts turn back to last year&#39;s rather memorable weekend-break to Stockholm,
in which I learned two things:</p>

<ol>
<li>Stockholm makes a great Valentine&#39;s destination.</li>

<li>My girlfriend of the time was not happy with me cracking out my iBook and checking my email halfway into the break.</li>
</ol>

<p>The relationship, predictably,
didn&#39;t last much longer, but it did occur to me that a quick and easy way to check my email when away from my computer would be very useful. One of the items that travels everywhere with me,
and has some limited Internet access is my phone -- although admittedly this has only WAP access. WAP access, it seemed, would have to do...</p>

<p>The tool I ended up building fills <b>my</b> needs very well,
but possibly won&#39;t be such a great match for others. This article looks at considerations when rendering email for display online,
especially when space is very limited.</p>

<h3><a name="Overview_of_messages">Overview of Messages</a></h3>

<p>The first challenge is reading the contents of our target mailbox.
For this,
we turn to the Perl Email Project&#39;s <a href="http://search.cpan.org/perldoc?Email::Folder"><code>Email::Folder</code></a>:</p>

<pre><code> use Email::Folder;
 
 my $folder = Email::Folder&#45;&#62;new( &#39;/home/sheriff/mbox&#39; );
 
 for my $message ( $folder&#45;&#62;messages ) {
 
        ...</code></pre>

<p><a href="http://search.cpan.org/perldoc?Email::Folder"><code>Email::Folder</code></a>&#39;s messages() function returns <a href="http://search.cpan.org/perldoc?Email::Simple"><code>Email::Simple</code></a> objects. For my folder&#45;view, I chose to group messages by date, and use the sender&#39;s "real name" as the subject. Something like:</p>

<pre><code> 30 Jan 2004
    Michael Roberts
  * Paul Makepeace
    Uri Guttman
 29 Jan 2004
    Kate Pugh</code></pre>

<p>Extracting header fields from <a href="http://search.cpan.org/perldoc?Email::Simple"><code>Email::Simple</code></a> objects couldn&#39;t be simpler:</p>

<pre><code> my $from = $message&#45;&#62;header(&#39;from&#39;)</code></pre>

<p>But people familiar with the various email RFCs will know that since email headers have to use only printable US&#45;ASCII, they&#39;re very often encoded: your header field might well look like:</p>

<pre><code>  =?iso&#45;8859&#45;1?q?Pete=20Sergeant?= &#60;pete@clueball.com&#62;</code></pre>

<p>This will not look pretty if you use it literally. Thankfully, <a href="http://search.cpan.org/perldoc?MIME::WordDecoder"><code>MIME::WordDecoder</code></a> exports the function <code lang='und' xml:lang='und'>unmime</code> -- rendering the above as "Pete Sergeant &#60;pete@clueball.com&#62;."</p>

<p>Getting the date from an email is also somewhat nontrivial -- an example "Date" header looks like:</p>

<pre><code> Fri, 30 Jan 2004 14:09:51 &#45;0000</code></pre>

<p>And that&#39;s if you&#39;re lucky, and it&#39;s well-formed, without starting to think about time zones. If we want to do anything useful with dates, we&#39;re going to want the date as an epoch time. Luckily, <a href="http://search.cpan.org/perldoc?DateTime::Format::Mail"><code>DateTime::Format::Mail</code></a> steps in, and not only parses our date, but returns a highly useful <a href="http://search.cpan.org/perldoc?DateTime"><code>DateTime</code></a> object, allowing us to do all kinds of fun date stuff. To simply reformat the date as Day/Month/Year:</p>

<pre><code> my $datetime = DateTime::Format::Mail&#45;&#62;new( loose =&#62; 1 );
 my $time = $datetime&#45;&#62;parse_datetime( $message&#45;&#62;header(&#39;date&#39;) );
 my $day_month_year = $time&#45;&#62;dmy;</code></pre>

<p>Finally, we&#39;re going to want to know if an email is new or not. Luckily, most MUAs will set/edit an email&#39;s status header. Rather than checking if an email is new, we check if it&#39;s been read -- denoted by a <code lang='und' xml:lang='und'>R</code> in the status header:</p>

<pre><code> $new_flag++ if $message&#45;&#62;header(&#39;Status&#39;) !~ m/R/;</code></pre>

<p>Now let&#39;s put this all together to produce a listing of a folder. We&#39;ll use the well-known Schwartzian transform to make the sorting efficient, but unlike the usual practice, we keep the array reference around, as we&#39;ll be using the date as well.</p>

<pre><code> use Email::Folder;
 use MIME::WordDecoder qw( unmime );
 use DateTime::Format::Mail;

 my $folder = Email::Folder&#45;&#62;new( &#39;/home/sheriff/mbox&#39; );
 my @to_sort;
 my $prev_date = &#34;&#34;;
 for (sort { $a&#45;&#62;[1] cmp $b&#45;&#62;[1]    }
      map  { [$_, message2dmy($_) ] } 
      $folder&#45;&#62;messages) {
     my ($message, $date) = @$_;
     if ($date ne $prev_date) { print $date, &#34;\n&#34;; $prev_date = $date; }
     print $message&#45;&#62;header(&#39;Status&#39;) =~ m/R/ ? &#34;   &#34; : &#34; * &#34;;
     print unmime($message&#45;&#62;header(&#39;from&#39;)), &#34;\n&#34;;
 }

 sub message2dmy {
     my $message = shift;
     my $datetime = DateTime::Format::Mail&#45;&#62;new( loose =&#62; 1 );
     my $time = $datetime&#45;&#62;parse_datetime( $message&#45;&#62;header(&#39;date&#39;) );
     my $day_month_year = $time&#45;&#62;dmy;
 }</code></pre>

<h3><a name="Displaying_individual_messages">Displaying Individual Messages</a></h3>

<p>Those are the main challenges of a folder&#45;view. Viewing an individual message presents a different set of challenges.</p>

<p>First and foremost is the appalling habit people have of sending each other HTML-"enriched" emails, with all sorts of attachments. If you&#39;re trying to read the email on a cell phone over a slow connection, you don&#39;t want to be battling with this -- you want a nice plain-text representation of the email. So, <a href="http://search.cpan.org/perldoc?Email::StripMIME"><code>Email::StripMIME</code></a> is your friend. Assuming we have an <a href="http://search.cpan.org/perldoc?Email::Simple"><code>Email::Simple</code></a> object, we can simply:</p>

<pre><code> my $string = $email_simple_object&#45;&#62;as_string();
 $string = Email::StripMIME::strip_mime( $string );
 $email_simple_object = Email::Simple&#45;&#62;new( $string );</code></pre>

<p>Of course, if we really wanted to cut down on the amount of content we&#39;re receiving, and we&#39;re only using this tool to get an overview of our messages, we can cut out quoted text, remnants of the email that the sender was replying to, and so on. <a href="http://search.cpan.org/perldoc?Text::Original"><code>Text::Original</code></a> does just this for us, as well as stripping out attribution lines:</p>

<pre><code> my $body = $email_simple_object&#45;&#62;body();
 $body = first_lines( $body, 20);
 $email_simple_object&#45;&#62;body( $body );</code></pre>

<p>The final problem is in creating actual real WML. Sadly, this is nontrivial, and in the past, I've tended to resort to outputting it by hand. But it doesn&#39;t have to be that way --; <a href="http://search.cpan.org/perldoc?CGI::WML"><code>CGI::WML</code></a> just about handles the task for us. <a href="http://search.cpan.org/perldoc?CGI::WML"><code>CGI::WML</code></a> is a subclass of <a href="http://search.cpan.org/perldoc?CGI"><code>CGI</code></a>, with methods specific to WAP.</p>

<h3><a name="Conclusion">Conclusion</a></h3>

<p>There is no fully working demo at the end of this article. My personal tool works in a way that&#39;s probably a little too specific for most people&#39;s needs. Hopefully however, it's introduced you to one or more modules you didn&#39;t know existed, and given you some inspiration to tinker around with Perl and email-handling.</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1346" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/08/filtering.html" rel="bookmark">Mail Filtering</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Michael Stevens</span> on <abbr class="published" title="2002-08-27T00:00:00-08:00">August 27, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<p>There are many ways to filter your e-mail with Perl. Two of the
more popular and interesting ways are to use <code>PerlMx</code> or <code>Mail::Audit</code>.
I took a long look at both, and this is what I thought of them.</p>

<h3><a name="perlmx"><code>PerlMx</code></a></h3>

<p><code>PerlMx</code> is a server product from ActiveState that uses the milter
support in recent versions of sendmail to hook in at almost every
stage of the mail-handling process.</p>

<p><code>PerlMx</code> comes with its own copy of Perl, and all the supporting modules
it needs - it can't run from a normal Perl, as it needs Perl to be
built with various options such as ithreads support and multiplicity.
This means you need to install any modules you want to use with <code>PerlMx</code>
twice if you already have them installed somewhere else on your system.</p>

<p><code>PerlMx</code> provides a persistent daemon that processes e-mail for an
entire mail-server - it avoids the overhead of starting a Perl
process to handle each e-mail by running forever, and by using threads
to ensure it can service more than one e-mail at a time.</p>



<p><code>PerlMx</code> ships with two main filters - the Spam and Virus filters. The
Virus filtering looks interesting, but ultimately I don't receive that
many viruses in e-mail, so I was unable to test it beyond establishing
that it didn't mangle my e-mail.</p>

<p> The Spam filtering in PerlMX is much more interesting - it seems to
be based on <a href="http://www.spamassassin.org/">Mail::SpamAssassin</a>, a popular
spam filtering module often used with Mail::Audit, procmail, or other
ways of processing e-mail.</p><p>In two weeks of testing with <code>PerlMx</code>, using it to process a copy of
all my personal e-mail, I found a lot useful functionality, and a
few minor problems.</p>

<p>The first hassles were setup - I don't normally use sendmail, but 
<code>PerlMx</code> requires it for the milter API, so I installed sendmail, set
it up, and hooked it into <code>PerlMx</code>.</p>
<p>Once you have sendmail setup, and built with milter support (as
the default build from Debian Linux I used was), it's easy to add
a connection to <code>PerlMx</code> with one line in your sendmail.mc file:</p>

<pre><code>
INPUT_MAIL_FILTER(`C&lt;PerlMx&gt;', `S=inet:3366@localhost, F=T, 
     T=S:3m;R:3m;E:8m'')</code></pre>

<p><code>PerlMx</code> essentially works out of the box - it asks a number of simple
questions when you install and set it up, and assuming you get these
right, no further configuration will be required.</p>

<p>The <code>INPUT_MAIL_FILTER</code> line also sets several key options, including
the timeouts for communication between sendmail and <code>PerlMx</code> - I had to
raise these significantly to deal with a problem I found where 
<code>PerlMx</code> was taking too much time to process spam (it appear to be doing
DNS lookups), sendmail was timing out the connection to <code>PerlMx</code>, and
refusing to accept mail.</p>

<p>In <code>PerlMx</code> 2.1, it even ships with its own sendmail install, pre-configured
for use with <code>PerlMx</code>, but you can choose to ignore this and use an
existing system sendmail.</p>

<p>Once you've done this, suddenly all the mail that goes through your
mail-server is spam filtered, and virus checked. Mail that looks
likely to be spam, or that contains a virus is stopped and held in a
quarantine queue, the rest are sent to the user, possibly with a spam
header added to indicate a score representing how likely to be spam
they are. The quarantine queue is a systemwide collection of messages
which, for one reason or another, weren't appropriate to deliver
to the user - this will be normally as they are either suspected to
contain viruses or spam.</p>

<p>If the filters supplied with <code>PerlMx</code> aren't to your tastes, then it comes
supplied with an extension API, and extensive documentation and samples
to allow you to write your own.</p>

<p>While testing <code>PerlMx</code>, I never managed to bounce or accidentally lose
my e-mail - I made many configuration errors, which meant mail wasn't
processed and a lot of stuff was somewhat over-enthusiastically marked
as spam when it was actually valid. But as far as I can tell, nothing
bounced or disappeared into the system - this is pretty impressive,
as when configuring most new bits of e-mail I usually manage to delete
everything I send to it in the first few attempts, or, worse, make
myself look stupid by sending errors back to random people unfortunate
enough to be on the same mailing list as me.</p>

<h3><a name="mail::audit"><code>Mail::Audit</code></a></h3>

<p><code>Mail::Audit</code> is very different from <code>PerlMx</code>. For starters, once you've 
installed it, by default it doesn't do anything.  <code>Mail::Audit</code> is
just a Perl module - it's a powerful tool for implementing mail
filters, but mostly you have to write them yourself. <code>PerlMx</code> ships
with spam filtering and virus checking configured by default, 
<code>Mail::Audit</code> provides duplicate killing, a mailing list processing
module (based on Mail::ListDetector), and a few simple spam
filtering options based on Realtime Blackhole Lists or Vipul's Razor.</p>

<p><code>Mail::Audit</code> is not designed to be used with an entire mail-server
in the same way as <code>PerlMx</code>. Instead, it allows you to easily write
little e-mail filter programs that can be triggered from the <em>.forward</em>
file of a particular user. <code>Mail::Audit</code> can be easily configured and
used on a per-user basis, whereas <code>PerlMx</code> takes over an entire mail-server
and is an all-or-nothing choice.</p>

<p>The default <code>Mail::Audit</code> configuration starts one Perl process for each
mail handled - normally this won't be a problem, but if you're
processing large volumes of mail, or have a system which is already at
or near capacity, it may be enough to tip the balance and cause
performance problems (Translation: Long ago I installed <code>Mail::Audit</code> on
an old, spare machine I was using as a mail-server, received 200 e-mails
in less than a minute, and spent quite a while waiting for the system to
stop gazing at its navel and start responding to the outside world
again). If your mail comes to you via POP3, or can be made to do so
(possibly by installing a POP3 daemon if you do not have one already),
then a simple script supplied with <code>Mail::Audit</code> called <em>popread</em> provides
a base you can use to feed articles from a POP3 server into
<code>Mail::Audit</code> in a single Perl process, improving performance. I didn't
do this myself, as I wanted to use what appeared to be the
'recommended' approach to <code>Mail::Audit</code> setup - the one that is, if not
actively promoted in the documentation, most strongly suggested by it,
of running a <code>Mail::Audit</code> script from a user's .forward file.</p>

<p>A popular <code>Mail::Audit</code> addition is SpamAssassin (the
same codebase as <code>PerlMx</code>'s mail processing is loosely based on) - this
comes as a <code>Mail::Audit</code> plugin, among other forms.</p>

<p><code>Mail::Audit</code> makes it easy to write mail filters that work on a
per-user basis, whereas <code>PerlMx</code> by default applies to all mail
processed on a given mailserver.</p>

<p>
If you wanted to install <code>Mail::Audit</code> systemwide, then many mail-servers
(such as exim) provide a way to configure a custom local delivery agent
on flexible criteria. For example,
<a href="http://bogmog.sourceforge.net/document_show.php3?doc_id=28">this
article</a> provides
some documentation on how to do this with exim.</p>
















<h3><a name="testing... 1... 2... 3...">Testing ... 1 ... 2 ... 3 ...</a></h3>

<p>I decided to do an extended comparison of both <code>PerlMx</code> and
<code>Mail::Audit</code>. As one of the most common applications of mail filtering
tools is for spam filtering, I set up recent versions of both the tools
on my personal e-mail, by various nefarious means, ran them for
a week, and compared the results on two main criteria:</p>

<ul>
<li>
False positives (legitimate email recognized as spam)</li>

<li>
False negatives (spam not recognized as spam)</li>

</ul>
<p><code>Mail::Audit</code> doesn't come with much spam filtering technology by
default, so I decided to add SpamAssassin (http://www.spamassassin.org/)
to the testing, as it can be used as a <code>Mail::Audit</code> extension.</p>
<p>I used procmail to copy all my incoming e-mail to two pop3 mailboxes
setup for the purposes of testing - one would contain mail to be
processed by <code>Mail::Audit</code>, the other mail to be processed by
<code>PerlMx</code>'s spam filtering. fetchmail was used to pull the mail down
into the domain of <code>Mail::Audit</code> and <code>PerlMx</code>.</p>
<p>Once I had <code>Mail::Audit</code> and SpamAssassin setup, I started feeding mail
into the test box with fetchmail, and was reminded that as the <code>Mail::Audit</code>
approach of setting up a perl program to run from a .forward file
has ... unpleasant effects if you receive more than a few e-mails in
quick succession. As my test mail-server collapsed under the load,
I checked the <code>PerlMx</code> machine, started at roughly the same time, and found that
while it was working through the e-mail more slowly, it hadn't put
any serious load on the machine.</p>
<p>Due to a <code>PerlMx</code> configuration error on my part, of the first 171 messages
processed, 10 were quarantined as spam AND delivered to the inbox of
my test user. <code>PerlMx</code> runs by default in 'training mode' when processing
spam - in this mode, mail is spamchecked as normal, but even if it
is found to be spam and quarantined, it is also delivered to the
user.</p>
<p>I decided to keep track of any mail lost or mislaid during initial
setup problems, so I could see what problems could arise from the
tools being misconfigured. An important aspect of any software is not
only how it behaves when configured right, but how much it punishes
you when you get the configuration wrong.</p>
<p>Waking up the next morning, I found I'd bounced several hundred e-mails
back to the account from which I was forwarding all the test e-mails,
someone of which appeared to have gone back and forth, or found their
way into the <code>PerlMx</code> test mailbox. Most of the problems appeared to be
internal errors from within SpamAssassin. My mail-server still
hadn't recovered.</p>
<p>I later found this was because of an compatibility issue with
SpamAssassin / <code>Mail::Audit</code>, and there was a recommended fix in the
SpamAssassin FAQ involving the <em>nomime</em> option to <code>Mail::Audit</code> (but not,
sadly, in the documentation for the Mail::SpamAssassin module
itself).</p>
<p>The SpamAssassin / <code>Mail::Audit</code> script I ended up using in the end was:</p>
<pre><code>
  #!/usr/local/bin/perl -w</code></pre>
<pre><code>
  use strict;
  use C&lt;Mail::Audit&gt;;
  use Mail::SpamAssassin;</code></pre>
<pre><code>
  # create C&lt;Mail::Audit&gt; object, log to /tmp, disable mime processing
  # for SpamAssassin compatibility, and store mail in ~/emergency_mbox
  # if processing fails
  my $mail = C&lt;Mail::Audit&gt;-&gt;new(emergency=&gt;&quot;~/emergency_mbox&quot;,
                              log =&gt; '/tmp/audit.log',
                              loglevel =&gt; 4, nomime =&gt; 1);</code></pre>
<pre><code>
  my $spamtest = Mail::SpamAssassin-&gt;new;
  
  # check mail with SpamAssassin
  my $status = $spamtest-&gt;check($mail);
  
  # if it was spam, rewrite to indicate what the problem was, and 
  # store in the file ass-spam in our home directory
  if ($status-&gt;is_spam) {
          $status-&gt;rewrite_mail;
          $mail-&gt;accept(&quot;/home/spam1/ass-spam&quot;);
  # if if wasn't spam, accept it as normal mail
  } else {
          $mail-&gt;accept;
  }
  
  exit 0;
</code></pre>

<p>After clearing down all my mail, and losing two days of testing, I
started again. It was only the nature of the testing setup that meant
the bounce mail went to me and not the original sender.  So, at 23:25
on Tuesday, I had another go. This time I knew enough to limit
SpamAssassin to receiving messages in batches of five (using fetchmail) -
something I could do in testing, but wouldn't be an easy option in
most production setups. This meant my test machine could just about
cope with delivering mail using SpamAssassin.</p>
<p>At 10 p.m. Sunday, I declared the testing closed, and examined the
accuracy or otherwise of each system.</p>
<p>During the testing between Aug. 6 and 11, <code>Mail::Audit</code>
marked 16 pieces of e-mail as spam. Seven of these e-mails proved to be
false positives - mail that I had actually solicited and would have
liked to have received. Six spam emails were accepted into my Inbox.
There were 874 e-mails received in all. <code>Mail::Audit</code> appeared to receive
15 pieces of spam mail in total.</p>
<p><code>PerlMx</code> marked 14 e-mails as spam. Two of these e-mails proved to be false
positives - mail that was not spam. Impressively, it received 886
e-mails in the same period that <code>Mail::Audit</code> received 874 e-mails. I
was unable to work out the exact cause of this, although the power-cut
in the middle of the testing period will always be a major suspect.
Eleven spam messages were incorrectly allowws through into my Inbox.
<code>PerlMx</code> appeared to receive 23 pieces of spam mail in total.</p>
<p>The sample was small, as all I had was my own personal e-mail to work
with, and I get what I'm told is surprisingly little spam, but it
shows that <code>Mail::Audit</code> / SpamAssassin seems to decide more mail is
spam than <code>PerlMx</code> does, but is also wrong more of the time. <code>PerlMx</code>
marked slightly less e-mail as spam, and let more spam through,
but when it did claim e-mail was spam it was right more of the time.</p>
<p>These tests would benefit significantly from being re-run during a long
period of time on a larger mail-server, but I had neither the time
nor the mail-server available.</p>
<p>Both tools can be extensively configured in terms of what is
considered spam, and are likely to need regular updating to ensure
they keep up to date with new tricks of the spammers. Here I only
considered the behavior with the default configuration of the latest
release at the time I ran my tests.</p>

<h3><a name="feature comparison">Feature Comparison</a></h3>
<p>To help you choose, I've summarized the basic characteristics of both
systems below. Some of the points are quite subjective and are more
my impressions of the tools rather than hard facts - these are marked
separately.</p>
<table>
	<tr>
		<td></td>
		<th>PerlMX</th>
		<th>Mail::Audit</th>
	</tr>
	<tr>
		<th>Scalable</th>
		<td>Yes - persistent server</td>
		<td>Maybe - depends on config - obvious default configurations scale poorly</td>
	</tr>
	<tr>
		<th>Ships with wide range of existing filtering functionality</th>
		<td>Yes</td>
		<td>Limited range, more available from third-parties</td>
	</tr>
	<tr>
		<th>Target use</th>
		<td>System-wide mail filtering for mailservers</td>
		<td>Per-use mail filtering as a replacement for programs like procmail</td>
	</tr>
	<tr>
		<th>Extensible?</th>
		<td>Yes</td>
		<td>Yes</td>
	</tr>
	<tr>
		<th>Licensing</th>
		<td>Commercial</td>
		<td>Open-source</td>
	</tr>
	<tr>
		<th>Mail Server Compatibility</th>
		<td>Sendmail</td>
		<td>Almost any mail server</td>
	</tr>
	<tr>
		<th>Spam filtering</th>
		<td>Yes</td>
		<td>Third-party extension</td>
	</tr>
	<tr>
		<th>Virus filtering</th>
		<td>Yes</td>
		<td>No</td>
	</tr>
	<tr>
		<th>Easy to setup</th>
		<td>Yes</td>
		<td>Not so easy, requires custom code</td>
	</tr>
	<tr>
		<th>Efficient and Scalable</th>
		<td>Very scalable - easily separated from the mailserver, and no noticable performance impact during testing</td>
		<td>Performance problems during testing in default configuration</td>
	</tr>
</table>

<h3><a name="conclusions">Conclusions</a></h3>

<p>During testing, <code>PerlMx</code> was significantly more reliable, both in terms
of the amount of mail bounced due to configuration problems (none),
and in terms of the load put in the mailserver (minimal) than
<code>Mail::Audit</code>. Although <code>Mail::Audit</code> appears able to be setup for good
performance, the obvious suggested configuration showed extremely poor
scalability during testing. Also, as <code>Mail::Audit</code> requires writing some
filtering code, bugs, mostly in this code, resulted in nontrivial
quantities of mail being bounced during testing due to
code/configuration errors, a problem that simply didn't occur with
<code>PerlMx</code>'s more pre-supplied, configuration file based system.</p>

<p>Both <code>PerlMx</code> and <code>Mail::Audit</code> provide good mail filtering solutions
using Perl, but are targeted at entirely different markets.  <code>PerlMx</code>
is a systemwide solution providing drop-in functionality on
mailservers, with Perl extensibility as well, whereas <code>Mail::Audit</code> is a
more low-level tool, mostly focused on use by individuals, designed to
let users build their own mail processing tools more easily.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1266" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/03/spam.html" rel="bookmark">Stopping Spam with SpamAssassin</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Cozens</span> on <abbr class="published" title="2002-03-06T00:00:00-08:00">March  6, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>
I receive a lot of spam; an absolute massive bucket load of spam. I received more than 100 pieces of spam in the first three days of this month.
I receive so much spam that <a href="http://www.spam.com/">Hormel Foods</a>
sends trucks to take it away. And I'm convinced that things are getting
worse. We're all being bombarded with junk mail more than ever these
days.
</p>
<p>
Well, a couple of days ago, I reached my breaking point, and decided that
the <a
href="/pub/a/2001/07/17/mailfiltering.html">simple
mail filtering</a> I had in place up until now just wasn't up to the
job. It was time to call in an assassin.
</p>
<h3>SpamAssassin</h3>

<p>
<a href="http://www.spamassassin.org">SpamAssassin</a> is a rule-based
spam identification tool. It's written in Perl, and there are several
ways of using it: You can call a client program,
<code>spamassassin</code>, and have it determine whether a given
message is likely to be spam; you can do essentially the same thing but
use a client/server approach so that your client isn't always loading 
and parsing the rules each time mail comes; or, finally, you can use
a Perl module interface to filter spam from a Perl program.
</p>
<p>
SpamAssassin is extremely configurable; you can select which rules you
want to use, change the way the rules contribute to a piece of mail's
"spam score," and add your own rules. We'll look at some of these
features later in the article. First, how do we get SpamAssassin
installed and start using it?
</p>
<p>
If you're using Debian Linux or one of the BSDs, then this couldn't be
easier: just install the appropriate package using <code>apt</code> or
the ports tree respectively. (The BSD port is called
<code>p5-Mail-SpamAssassin</code>)
</p>
<p>
Those less fortunate will have to <a
href="http://www.spamassassin.org/released/Mail-SpamAssassin-2.11.tar.gz">download</a>
the latest version of SpamAssassin, and install it themselves. 
</p>

<h3>Vipul's Razor</h3>


<p>
SpamAssassin uses a variety of ways for testing whether an e-mail is spam, ranging from simple textual checks on the headers
or body and detecting missing or misleading headers to
network-based checks such as <a href="http://www.orbz.org">relay
blackhole lists</a> and an interesting distributed system called <a
href="http://razor.sourceforge.net/">Vipul's Razor</a>.
</p>
<p>
Vipul's Razor takes advantage of the fact that spam is, by its nature,
distributed in bulk. Hence, a lot of the spam that you see, I'm also
going to see at some point. If there were a big clearing-house where you
could report spam and I could see if my incoming mail matches what
you've already reported, then I could have a guaranteed way of
determining whether a given mail is spam. Vipul's Razor is that
clearing-house.
</p>
<p>
Why is it a Razor? Because it's a collaborative system, its strength is
directly derived from the quality of its database, which comes back to
the way it's used by the likes of you and me. If end-users report lots
of real spam, the Razor gets better; if the database gets "poisoned" by
lots of false or misleading reports, then the efficiency of the whole
system drops.
</p>
<p>
Just like any other spam detection mechanism, Razor isn't perfect.
There are two points particularly worth noting. First, while it tries
to completely avoid false positives (saying something's spam when it
isn't) by requiring that spam be reported, it doesn't do anything about
false negatives (saying something's not spam when it is) because it only
knows about the mail in its database.
</p>
<p>
Second, spammers, like all other primitive organisms, are constantly
evolving. Vipul's Razor only works for spam that is delivered in bulk
without modification. Spam that is "personalized" by the addition of
random spaces, letters or the name of the recipient, will produce a
different signature that won't match similar spam messages in the Razor
database.
</p>

<p>
Nevertheless, the Razor is an excellent addition to the spam fighter's
arsenal, since when it marks something as spam, you can be almost
positive it's correct. And just like SpamAssassin, it's all pure Perl.
<code>Mail::Audit</code> has long supported a Razor plugin, but now we
can move to calling Razor as part of a more comprehensive mail filtering
system based on SpamAssasin and <code>Mail::Audit</code>
</p>

<p>
Installing Vipul's Razor is similar to installing SpamAssassin.
Debian and BSD users have packages called "razor" and "razor-clients,"
respectively; and the rest of the world can download and install from
the <a href="http://razor.sourceforge.net">home page</a>. SpamAssassin
will detect whether Razor is available and, by default, use it if so.

<h3>Assassinating Spam With Mail::Audit : The Easy Way </h3>

<p>
So this is the part you've all been waiting for. How do we use these
things to trap spam? For those of you who aren't familiar with
<code>Mail::Audit</code>, the idea is simple: just like with
<code>procmail</code>, you write recipes that determine what happens to
your mail. However, in the case of <code>Mail::Audit</code>, you specify
the recipe in Perl. For instance, here's a recipe to move all mail sent
to <code>perl5-porters@perl.org</code> to another folder:
<pre><code>
    use Mail::Audit;
    my $mail = Mail::Audit-&gt;new();
    if ($mail-&gt;from =~ /perl5-porters\@perl.org/) {
        $mail-&gt;accept("p5p");
    }
    $mail-&gt;accept();</code>
</pre>
For more details on how to construct mail filters with
<code>Mail::Audit</code>, see my 
<a
href="/pub/a/2001/07/17/mailfiltering.html">previous
article</a>.
</p>
<p>
Plugging SpamAssassin into your filters couldn't be simpler. First of
all, you absolutely need the latest version of <code>Mail::Audit</code>,
version 2.1 from <a
href="http://www.cpan.org/authors/id/S/SI/SIMON/">CPAN</a>. Nothing
earlier will do! Now write a filter like this:
<pre><code>
    use Mail::Audit;
    use Mail::SpamAssassin;
    my $mail = Mail::Audit-&gt;new();

    ... the rest of your rules here ...

    my $spamtest = Mail::SpamAssassin-&gt;new();
    my $status = $spamtest-&gt;check($mail);

    if ($status-&gt;is_spam ()) {
        $status-&gt;rewrite_mail() };
        $mail-&gt;accept("spam");
    }
    $mail-&gt;accept();</code>
</pre>

As you might be able to guess, the important thing here is the calls to
<code>check</code> and <code>is_spam</code>. <code>check</code> produces
a "status object" that we can query and use to manipulate the e-mail.
<code>is_spam</code> tells us whether the mail has exceeded the number of
"spam points" required to flag an e-mail as spam.
</p>
<p>
The
<code>rewrite_mail</code> method adds some headers and rewrites the
subject line to include the distinctive string "*****SPAM******". The
additional headers explain why the e-mail was flagged as spam. For
instance:
<pre><code>
X-Spam-Status: Yes, hits=6.1 required=5.0 
tests=SUBJ_HAS_Q_MARK,REPLY_TO_EMPTY,SUBJ_ENDS_IN_Q_MARK version=2.1</code>
</pre>
This message had a question mark in the subject, an empty reply-to, and
the subject ended in a question mark. The mail wasn't actually spam, but
this goes to prove that the technique isn't perfect. Nevertheless, since
installing the spam filter, I've only seen about 10 false positives,
and zero false negatives. I'm happy enough with this solution.
</p>
<p>
One important point to remember, however, is where in the course of your
filtering you should call SpamAssassin's checks. For instance, you want
to do so after your mailing list filtering, because mail sent to mailing
lists may have munged headers that might confuse SpamAssassin. However,
this means that spam sent to mailing lists might slip through the net.
Experiment, and find the best solution for your own e-mail patterns.
</p>
<h3>Assassinating Spam Without Mail::Audit </h3>
<p>

Of course, there are times when it might not be suitable to use
<code>Mail::Audit</code> or you may not want to. Since SpamAssassin is
provided as a command line tool as well as a set of Perl modules, it's
easy enough to integrate it in whatever mail filtering solution you use.
</p>
<p>
For instance, here's a procmail recipe that calls out to
<code>spamassassin</code> to filter out spam:
<pre><code>
:0fw
| spamassassin -P

:0:
* ^X-Spam-Status: Yes
spambox</code>
</pre>
For the speed-conscious, you can run the <code>spamd</code> daemon and
replace calls to <code>spamassassin</code> with <code>spamc</code>; be
aware that this is a TCP/IP daemon that you may want to firewall 
from the rest of the world.
</p>
<p>
Another approach is to call <code>spamassassin</code> in your mail
transport agent, meaning that spam is filtered out before it even
attempts to be delivered to you. There's a Sendmail <a
href="http://savannah.gnu.org/projects/spamass-milt/">milter</a> library
available that allows you to use SpamAssassin, and similar tricks for Exim
and other MTAs are available.
</p>

<h3>Assassinating Spam With Mail::Audit : More Complex Operations </h3>

<p>
The <code>Mail::SpamAssassin</code> module has many other methods
you can use to manipulate e-mail. For instance, if you've identified
something as definitely being spam, then you can use
<pre><code>
    $spamtest-&gt;report_as_spam($mail);</code>
</pre>
to report it to Vipul's Razor. (Take note of this: As we've mentioned
above, the efficiency of the Razor database comes from the fact that
e-mails in it are confirmed as spam by a human. Adding false positives to
the database would degrade its usefulness for everyone. Only submit mail
that you've confirmed personally.)
</p>
<p>
If you're finding that mail checking is taking too long because
SpamAssassin is having to contact the various network-based blacklists
and databases, then you can instruct it to only perform "local" checking:
<pre><code>
    $spamtest = Mail::SpamAssassin-&gt;new({local_tests_only =&gt; 1});</code>
</pre>
</p>
<p>
There is a wealth of other options available. See the
<code>Mail::SpamAssassin</code> documentation for more details, and
happy assassinating!






        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/macintosh/">&laquo; Macintosh</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/modules/">Modules &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
