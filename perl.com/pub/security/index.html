<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Security Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Security</em> Category</h1>






                            
                            <div id="entry-640" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2008/02/elements-of-access-control.html" rel="bookmark">Elements of Access Control</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Vladi Belperchinov-Shabanski</span> on <abbr class="published" title="2008-02-13T00:00:00-08:00">February 13, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<h3>Why Gates?</h3>

<p>In a perfect world we wouldn't do things we should not. However the world is not like this; people do forbidden things sometimes. This also applies to computer systems used by more than one person. Almost everyone has tried to read someone else's email, view accounting department salary reports, or something else, or access otherwise hidden data.</p>

<p>I know <em>you</em> have never done this, but many people have.</p>

<h3>In Construction</h3>

<p>The simplest way to allow or forbid a user account to do something is to check if the account is in a list of permitted accounts somewhere. If you assume that everything is forbidden unless explicitly allowed, the access function can be as simple as:</p>

<pre><code>  # access_check() return 1 or undef
  sub access_check
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    return $quick_allow{ $user_id };
  }

  my @allowed = ( 11, 12, 23, 45 );

  print "User 23 allowed\n" if access_check( 23, @allowed );
  print "User 13 allowed\n" if access_check( 13, @allowed );
  print "User 99 allowed\n" if access_check( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<p>Usually access control can be almost as simple as this function. Using user IDs for access control is simple, but tends to be hard to maintain. The problem appears with systems with many users or with public systems where new users may be created at any point. Access lists may become very large for each operation, which needs access controls.</p>

<p>One solution to this problem is <em>access groups</em>. Each user may be a member of several groups. The access check will pass if the user is a member of a group with permission for the required operation. This middle level in the access check isolates users from the access check directly. It also helps the system's design--you can associate preset access groups with all controlled operations at their point of creation. Subsequently created users only need to be attached to one or more of those groups:</p>

<pre><code>  # mimic real system environment:
  # %ALL_USER_GROUPS represents "storage" that contains all
  # groups that each user is attached to
  my %ALL_USER_GROUPS = (
                    23 =&gt; [ qw( g1  g4 ) ],
                    13 =&gt; [ qw( g3  g5 ) ],
                    );
  # user 23 is in groups g1 and g4
  # user 13 -- in g3 and g5

  # return list of user's groups. read data from storage or
  # from %ALL_USER_GROUPS in this example
  sub get_user_groups
  {
    my $user_id     = shift;

    return @{ $ALL_USER_GROUPS{ $user_id } || [] };
  }

  # access_check_grp() return 1 or 0
  sub access_check_grp
  {
    my $user_id     = shift;
    my @allow_users = @_;

    my %quick_allow = map { $_ =&gt; 1 } @allow_users;

    my @user_groups = get_user_groups( $user_id );

    for my $group ( @user_groups )
    {
      # user groups is listed, allow
      return 1 if $quick_allow{ $group };
    }

    # user group not found, deny
    return 0;
  }

  # this groups list is static and will not be altered
  # when users are added or removed from the system
  my @allowed = qw( g1  g2  g7  g9 );

  print "User 23 allowed\n" if access_check_grp( 23, @allowed );
  print "User 13 allowed\n" if access_check_grp( 13, @allowed );
  print "User 99 allowed\n" if access_check_grp( 99, @allowed );

  # only "User 23 allowed" will be printed</code></pre>

<h3>Storage</h3>

<p>Probably the most popular storage for system data nowadays is the SQL database. Here is a simple example of how to store users, groups, and mapping between them. Three tables are required:</p>

<pre><code>  SQL CREATE statements:

  create table user  ( id integer primary key, name char(64), pass char(64) );
  create table group ( id integer primary key, name char(64) );
  create table map   ( user integer, group integer );

  TABLE USER:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |
   pass   | character(64) |

  TABLE GROUP:

   Column |     Type      | Modifiers
  --------+---------------+-----------
   id     | integer       | not null
   name   | character(64) |

  TABLE MAP:

   Column |  Type   | Modifiers
  --------+---------+-----------
   user   | integer |
   group  | integer |</code></pre>

<p>Let's fill those tables with some data:</p>

<pre><code>  letme=# select id, name from user;
   id |       name
  ----+------------------
    1 | Damian
    2 | Clive
    3 | Lana
  (3 rows)

  letme=# select * from group;
   id |       name
  ----+------------------
    1 | Admin
    2 | Users
    3 | Moderators
  (3 rows)

  letme=# select * from map;
   user | group
  -----+-----
     1 |   1
     1 |   2
     3 |   2
     3 |   3
     2 |   2
  (4 rows)</code></pre>

<p>Users in this example are attached to those groups:</p>

<pre><code>  Damian: Users, Admin
  Clive:  Users
  Lana:   Users, Moderators</code></pre>













<h3>Run-Time</h3>

<p>Applications apply access control after user login. You can combine it with the login procedure--for example to allow only specific group of users to connect on weekends. Even so, the access check occurs only after the login succeeds, that is, when the username and password are correct.</p>

<p>A simple approach for loading required access info is:</p>

<ul>
<li>Login, check username and password</li>

<li>For unsuccessful login, deny access, print message, etc.</li>

<li>For successful login, load group list for the user from database</li>

<li>Check for required group(s) for login

<p>This may deny login, print a message, or continue.</p></li>

<li>User logged in, continue

<p>All access checks for operations happen after this point.</p></li>
</ul>

<p>The run-time storage for a user's groups can be simple hash. It can be either global or inside the user session object, depending on your system design. I've used a global hash here for simplicity of the examples, but if you copy and paste this code, remember that it is <em>mandatory</em> for you to clear and recreate this global hash for every request right after the login or user session changes! You can also use some kind of session object to drop all user data at the end of the session, but this is just an option, not the only correct or possible way.</p>

<p>(Also, a truly robust system would store a well-hashed version of the password, not the literal password, but that's a story for a different article.)</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use DBI;
  use Data::Dumper;

  our $USER_NAME;
  our $USER_ID;
  our %USER_GROUPS;

  my $DBH = DBI-&gt;connect( "dbi:Pg:dbname=letme", "postgres", "",
      { AutoCommit =&gt; 0 } );

  # this is just an example!
  # username and password acquiring depends on the specific application
  user_login( 'Damian', 'secret4' );

  print "User logged in: $USER_NAME\n";
  print "User id:        $USER_ID\n";
  print "User groups:    " . join( ', ', keys %USER_GROUPS ) . "\n";

  sub user_login
  {
    my $user_name = shift;
    my $user_pass = shift;

    $USER_NAME   = undef;
    $USER_ID     = undef;
    %USER_GROUPS = ();

    # both name and password are required
    die "Empty user name"     if $user_name eq '';
    die "Empty user password" if $user_pass eq '';

    eval
    {
      my $ar = $DBH-&gt;selectcol_arrayref(
          'SELECT ID FROM USER WHERE NAME = ? AND PASS = ?',
                                        {},
                                        $user_name, $user_pass );

      $USER_ID   = shift @$ar;

      die "Wrong user name or password" unless $USER_ID &gt; 0;

      $USER_NAME = $user_name;

      # loading groups
      my $ar = $DBH-&gt;selectcol_arrayref( 'SELECT GROUP FROM MAP WHERE USER = ?',
                                        {},
                                        $USER_ID );

      %USER_GROUPS = map { $_ =&gt; 1 } @$ar;
    };
    if( $@ )
    {
      # something failed, it is important to clear user data here
      $USER_NAME   = undef;
      $USER_ID     = undef;
      %USER_GROUPS = ();

      # propagate error
      die $@;
    }
  }</code></pre>

<p>If Damian's password is correct, this code will print:</p>

<pre><code>  User logged in: Damian
  User id:        1
  User groups:    1, 2</code></pre>

<p>The group access check function now is even simpler:</p>

<pre><code>  sub check_access
  {
    my $group = shift;
    return 0 unless $group &gt; 0;
    return $USER_GROUPS{ $group };
  }</code></pre>

<p>Sample code for an access check after login will be something like:</p>

<pre><code>  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_access( 1 );

    # user allowed, group 1 check successful
    ...
  }</code></pre>

<p>or</p>

<pre><code>  if( check_access( 1 ) )
  {
    # user ok
  }
  else
  {
    # access denied
  }</code></pre>

<h3>Access Instructions</h3>

<p>The next problem is how to define which groups can perform specific operations. Where this information is static (most cases), you can store group lists in configuration (text) files:</p>

<pre><code>  LOGIN: 2
  EDIT:  1</code></pre>

<p>That is, the EDIT operation needs group 1 (admin) and LOGIN needs group 2 (all users).</p>

<p>Another example is to allow only administrators to log in during weekends:</p>

<pre><code>  # all users for mon-fri
  LOGIN_WEEKDAYS: 2

  # only admin for sat-sun
  LOGIN_WEEKENDS: 1</code></pre>

<p>Administrators will be in both groups (1, 2), so they will be able to log in anytime. All regular users cannot login on weekends.</p>

<p>This group list includes a moderators group. It could be useful to allow moderators do their job on weekends as well, implying an <code>OR</code> operation:</p>

<pre><code>  # only admin or moderators for sat-sun
  LOGIN_WEEKENDS: 1, 3</code></pre>

<p>This named set of groups is a <em>policy</em>.</p>

<p>For now, there's only one level in the policy and an <code>OR</code> operation between groups in a list. Real-world policies may be more complex. However there is no need to overdesign this. Even large systems may work with just one more level. Here's an <code>AND</code> operation:</p>

<pre><code>  LOGIN_WEEKENDS: 1+3, 4, 1+5+9</code></pre>

<p>This policy will match (allowing login on weekend days) only for users in the following groups:</p>

<pre><code>     1 AND 3
  OR 4
  OR 1 AND 5 AND 9</code></pre>













<p>The login procedure must match the <code>LOGIN_WEEKENDS</code> policy before allowing user to continue with other operations. Thus, you need a procedure for reading policy configuration files:</p>

<pre><code>  our %ACCESS_POLICY;

  sub read_access_config
  {
    my $fn = shift; # config file name

    open( my $f, $fn );
    while( &lt;$f&gt; )
    {
      chomp;
      next unless /\S/; # skip whitespace
      next if  /^[;#]/; # skip comments

      die "Syntax error: $_\n" unless /^\s*(\S+?):\s*(.+)$/;
      my $n = uc $1; # policy name: LOGIN_WEEKENDS
      my $v =    $2; # groups lsit: 1+3, 4, 1+5+9

      # return list of lists:
      # outer list uses comma separator, inner lists use plus sign separator
      $ACCESS_POLICY{ $n } = access_policy_parse( $v );
    }
    close( $f );
  }

  sub access_policy_parse
  {
    my $policy = shift;
    return [ map { [ split /[\s\+]+/ ] } split /[\s,]+/, $policy ];
  }</code></pre>

<p>For the <code>LOGIN_WEEKENDS</code> policy, the resulting value in <code>%ACCESS_POLICY</code> will be:</p>

<pre><code>  $ACCESS_POLICY{ 'LOGIN_WEEKENDS' } =&gt;

                [
                  [ '1', '3' ],
                  [ '4' ],
                  [ '1', '5', '9' ]
                ];</code></pre>

<p>To match this policy, a user must be in every groups listed in any of the inner lists:</p>

<pre><code>  sub check_policy
  {
    my $policy = shift;

    my $out_arr = $ACCESS_POLICY{ $policy };
    die "Invalid policy name; $policy\n" unless $out_arr;

    return check_policy_tree( $out_arr );
  }

  sub check_policy_tree
  {
    my $out_arr = shift;

    for my $in_arr ( @$out_arr )
    {

      my $c = 0; # matching groups count
      for my $group ( @$in_arr )
      {
        $c++ if $USER_GROUPS{ $group };
      }

      # matching groups is equal to all groups count in this list
      # policy match!
      return 1 if $c == @$in_arr;
    }

    # if this code is reached then policy didn't match
    return 0;
  }</code></pre>

<p>The example cases will become:</p>

<pre><code>  sub user_login
  {
      # login checks here
      ...

      # login ok, check weekday policy
      my $wday = (localtime())[6];

      my $policy;
      if( $wday == 0 or $wday == 6 )
      {
        $policy = 'LOGIN_WEEKEND';
      }
      else
      {
        $policy = 'LOGIN_WEEKDAY';
      }

      die "Login denied" unless check_policy( $policy );
  }

  sub edit_data
  {
    # require user to be in group 1 (admin) to edit data...
    die "Access denied" unless check_policy( 'EDIT' );

    # user allowed, 'EDIT' policy match
    ...
  }</code></pre>

<p>Now you have all the parts of a working access control scheme:</p>

<ul>
<li>Policy configuration syntax</li>

<li>Policy parser</li>

<li>User group storage and mapping</li>

<li>User group loading</li>

<li>Policy match function</li>
</ul>

<p>This scheme may seem complete, but it lacks one thing.</p>

<h3>Data Fences</h3>

<p>In a multiuser system there is always some kind of ownership on the data stored in the database. This means that each user must see only those parts of the data that his user groups own.</p>

<p>This ownership problem solution is separate from the policy scheme. Each row must have one or more fields filled with groups that have access to the data. Any SQL statements for reading data must also check for this field:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $ug  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME
             WHERE READ_GROUP IN ( $rg ) AND UPDATE_GROUP IN ( $ug )";</code></pre>

<p>The result set will contain only rows with read and update groups inside the current user's group set. Sometimes you may need all of rows with the same read group for display, even though some of those rows have update restrictions the user does not meet. This case will use only the <code>READ_GROUP</code> field for select and will cut off users when they try to update the record without permission:</p>

<pre><code>  my $rg  = join ',', grep { $USER_GROUPS{ $_ } } keys %USER_GROUPS;
  my $sql = "SELECT * FROM TABLE_NAME WHERE READ_GROUP IN ( $rg )";

  $sth = $dbh-&gt;prepare( $sql );
  $sth-&gt;execute();
  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_access( $hr-&gt;{ 'UPDATE_GROUP' } );</code></pre>

<p>When access checks are explicitly after <code>SELECT</code> statements it is possible to store full policy strings inside <code>CHAR</code> fields:</p>

<pre><code>  $hr = $sth-&gt;fetchrow_hashref();

  die "Edit access denied" unless check_policy_record( $hr, 'UPDATE_GROUP' );

  sub check_policy_record
  {
      my $hr     = shift; # hash with record data
      my $field  = shift; # field containing policy string

      my $policy = $hr-&gt;{ $field };
      my $tree   = access_policy_parse( $policy );

      return check_policy_tree( $tree );
  }</code></pre>

<h3>In the Middle of Nowhere</h3>

<p>This access control scheme is simple and usable as described. It does not cover all possible cases of access control, but every application has its own unique needs. In certain cases, you can push some of these access controls to lower levels -- your database, for example -- depending on your needs. Good luck with building your own great wall!</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1260" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/02/css.html" rel="bookmark">Preventing Cross-site Scripting Attacks</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Paul Lindner</span> on <abbr class="published" title="2002-02-20T00:00:00-08:00">February 20, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
                <h3>Introduction</h3>
    <p>
      The cross-site scripting attack is one of the most common, yet
      overlooked, security problems facing web developers today.  A web
      site is vulnerable if it displays user-submitted content without
      checking for malicious script tags.  
    </p>
    <p>
      Luckily, Perl and mod_perl provide us with easy solutions to
      this problem.  We highlight these built-in solutions and also a
      introduce a new mod_perl module: <i>Apache::TaintRequest</i>.
      This module helps you secure mod_perl applications by applying
      perl's powerful "tainting" rules to HTML output.
    </p>

    <h3>What is "Cross-Site Scripting"?</h3>
    
    <p>
      Lately the news has been full of reports on web site security lapses.
      Some recent headlines include the following grim items:

      <a href="http://news.cnet.com/news/0-1003-200-7764433.html">
	Security problems open Microsoft's Wallet</a>, 
      <a href="http://news.cnet.com/news/0-1007-200-4030388.html">
	Schwab financial site vulnerable to attack</a>, or
      <a href="http://techupdate.zdnet.com/techupdate/stories/main/0,14179,2808729,00.html">
	New hack poses threat to popular Web services</a>.  In all
	these cases the root problem was caused by a <i>Cross-Site
	Scripting</i> attack.  Instead of targeting holes in your
	server's operating system or web server software, the attack
	works directly against the users of your site.  It does this
	by tricking a user into submitting web scripting code
	(JavaScript, Jscript, etc.) to a dynamic form on the targeted
	web site.  If the web site does not check for this scripting
	code it may pass it verbatim back to the user's browser where
	it can cause all kinds of damage.
    </p>
    <p>
      Consider the following URL:</p>

    <blockquote>
      <code>http://www.example.com/search.pl?text=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>
    </blockquote>

    <p>
      If an attacker can get us to select a link like this,and the
      Web application does not validate input, then our browser will
      pop up an alert showing our current set of cookies.This
      particular example is harmless; an attacker can do much more
      damage, including stealing passwords, resetting your home
      page, or redirecting you to another Web site.
    </p>
    <p>
      Even worse, you might not even need to select the link for this to
      happen.  If the attacker can make your application display a 
      chunk of html, you're in trouble.  Both the <b>IMG</b> and
      <b>IFRAME</b> tags allow for a new URL to load when html is displayed.
      For example the following HTML chunk is sent by the 
      <a href="http://www.cert.org/incident_notes/IN-2001-14.html">BadTrans</a>
      Worm.  This worm uses the load-on-view feature provided by the IFRAME tag
      to infect systems running Outlook and Outlook Express.
    </p>
    <pre><code>
  --====_ABC1234567890DEF_====
  Content-Type: multipart/alternative;
           boundary="====_ABC0987654321DEF_===="

  --====_ABC0987654321DEF_====
  Content-Type: text/html;
           charset="iso-8859-1"
  Content-Transfer-Encoding: quoted-printable


  &lt;HTML&gt;&lt;HEAD&gt;&lt;/HEAD&gt;&lt;BODY bgColor=3D#ffffff&gt;
  &lt;iframe src=3Dcid:EA4DMGBP9p height=3D0 width=3D0&gt;
  &lt;/iframe&gt;&lt;/BODY&gt;&lt;/HTML&gt;
  --====_ABC0987654321DEF_====--

  --====_ABC1234567890DEF_====
  Content-Type: audio/x-wav;
           name="filename.ext.ext"
  Content-Transfer-Encoding: base64
  Content-ID: &lt;EA4DMGBP9p&gt;</code>
</pre>

    <p>
      This particular example results in executable code running on the
      target computer.   The attacker could just as easily insert HTML
      using the URL format described earlier, like this:
    </p>
    <blockquote><code>
      &lt;iframe src="http://www.example.com/search.pl?text=&lt;script&gt;alert(document.cookie)&lt;/script&gt;"&gt;</code>
    </blockquote>

    <p>
      The "cross-site" part of "cross-site scripting" comes into
      play when dealing with the web browser's internal restrictions
      on cookies.  The JavaScript interpreter built into modern web
      browsers only allows the originating site to access it's own
      private cookies.  By taking advantage of poorly coded scripts
      the attacker can bypass this restriction.
    </p>
    
    <p>
      Any poorly coded script, written in Perl or otherwise, is a
      potential target.  The key to solving cross-site scripting
      attacks is to never, ever trust data that comes from the web
      browser.  Any input data should be considered guilty unless
      proven innocent.
    </p>
    
    <h3>Solutions</h3>
    
    <p>
      There are a number of ways of solving this problem for Perl and
      mod_perl systems.  All are quite simple, and should be used
      everywhere there might be the potential for user submitted data
      to appear on the resulting web page.
    </p>
    
    <p>
      Consider the following script <i>search.pl</i>.  It is a simple
      CGI script that takes a given parameter named 'text' and prints
      it on the screen.
    </p>

    <pre><code>
        #!/usr/bin/perl
        use CGI;

        my $cgi = CGI->new();
        my $text = $cgi->param('text');

        print $cgi->header();
        print "You entered $text";
</code></pre>

    <p>
      This script is vulnerable to cross-site scripting attacks
      because it blindly prints out submitted form data.  To rid
      ourselves of this vulnerability we can either perform input
      validation, or insure that user-submitted data is always HTML
      escaped before displaying it.</p> 

    <p>We can add input validation to our script by inserting the
    following line of code before any output.  This code eliminates
    everything but letters, numbers, and spaces from the submitted
    input.
    </p>

    <pre><code>
        $text =~ s/[^A-Za-z0-9 ]*/ /g;
</code></pre>

    <p>
      This type of input validation can be quite a chore.  Another
      solution involves escaping any HTML in the submitted data.  We
      can do this by using the HTML::Entities module bundled in the
      libwww-perl CPAN distribution.  The HTML::Entities module
      provides the function HTML::Entities::encode().  It encodes HTML
      characters as HTML entity references.  For example, the character
      <b>&lt;</b> is converted to <b>&amp;lt;</b>, <b>&quot;</b> is
      converted to <b>&amp;quot;</b>, and so on.  Here is a version of
      <i>search.pl</i> that uses this new feature.
    </p>

    <pre><code>
        #!/usr/bin/perl
        use CGI;
        use HTML::Entities;

        my $cgi = CGI->new();
        my $text = $cgi->param('text');

        print $cgi->header();
        print "You entered ", HTML::Entities::encode($text);
</code></pre>


    <h3>Solutions for mod_perl</h3>

    <p>
      All of the previous solutions apply to the mod_perl programmer
      too.  An Apache::Registry script or mod_perl handler can use the
      same techniques to eliminate cross-site scripting holes. For
      higher performance you may want to consider switching calls from
      HTML::Entities::encode() to mod_perl's much faster
      Apache::Util::escape_html() function.  Here's an example of an
      Apache::Registry script equivilant to the preceding
      <I>search.pl</I> script.
    </p>
<pre><code>
        use Apache::Util;
        use Apache::Request;

        my $apr = Apache::Request->new(Apache->request);

        my $text = $apr->param('text');

        $r->content_type("text/html");
        $r->send_http_header;
        $r->print("You entered ", Apache::Util::html_encode($text));
</code></pre>

   <p>
      After a while you may find that typing
      Apache::Util::html_encode() over and over becomes quite tedious,
      especially if you use input validation in some places, but not
      others.  To simplify this situation consider using the
      Apache::TaintRequest module.  This module is available from CPAN
      or from the <a href="http://www.modperlcookbook.org/">mod_perl
      Developer's Cookbook</a> web site.
    </p>

    <p>
      Apache::TaintRequest automates the tedious process of HTML
      escaping data.  It overrides the print mechanism in the mod_perl
      Apache module.  The new <I>print</I> method tests each chunk of text
      for taintedness.  If it is tainted the module assumes the worst and
      html-escapes it before printing.  
    </p>
    <p>
      Perl contains a set of built-in security checks know as <i>taint
      mode</i>.  These checks protect you by insuring that
      <i>tainted</i> data that comes from somewhere outside your
      program is not used directly or indirectly to alter files,
      processes, or directories. Apache::TaintRequest extends this
      list of <i>dangerous</i> operations to include printing HTML to
      a web client. To <i>untaint</i> your data just process it with a
      regular expression.  Tainting is the Perl web developer's most
      powerful defense against security problems.  Consult the
      <b>perlsec</b> man page and use it for every web application you
      write.
    <p>
      To activate Apache::TaintRequest simply add the following
      directive to your httpd.conf.
    </p>
    <pre>       PerlTaintCheck on    </pre>
    <p>
      This activates taint mode for the entire mod_perl server.
    </p>
    <p>
      The next thing we need to do modify our script or handler to use
      Apache::TaintRequest instead of Apache::Request.  The preceding
      script might look like this:
    </p>
    <pre><code>
        use Apache::TaintRequest;

        my $apr = Apache::TaintRequest->new(Apache->request);

        my $text = $apr->param('text');

        $r->content_type("text/html");
        $r->send_http_header;

        $r->print("You entered ", $text);

        $text =~ s/[^A-Za-z0-9 ]//;
        $r->print("You entered ", $text);
</code></pre>

    <p>
      This script starts by storing the tainted form data 'text' in
      $text.  If we print this data we will find that it is
      automatically HTML escaped.  Next we do some input validation on
      the data.  The following print statement does not result in any
      HTML escaping of data.
    </p>

    <h3>Tainting + Apache::Request....  Apache::TaintRequest</h3>

    <p>
      The implementation code for Apache::TaintRequest is quite
      simple. It's a subclass of the Apache::Request module, which
      provides the form field and output handling.  We override the
      <i>print</i> method, because that is where we HTML escape the
      data.  We also override the <i>new</i> method -- this is where
      we use Apache's TIEHANDLE interface to insure that output to
      STDOUT is processed by our print() routine.
    </p>
    <p>
      Once we have output data we need to determine if it is tainted.
      This is where the <i>Taint</i> module (also available from CPAN)
      becomes useful.  We use it in the <i>print</i> method to
      determine if a printable string is tainted and needs to be HTML
      escaped.  If it is tainted we use the mod_perl function
      Apache::Util::html_escape() to escape the html.
    </p>

    <pre><code>
package Apache::TaintRequest;

use strict;
use warnings;

use Apache;
use Apache::Util qw(escape_html);
use Taint qw(tainted);

$Apache::TaintRequest::VERSION = '0.10';
@Apache::TaintRequest::ISA = qw(Apache);

sub new {
  my ($class, $r) = @_;

  $r ||= Apache->request;

  tie *STDOUT, $class, $r;

  return tied *STDOUT;
}


sub print {
  my ($self, @data) = @_;

  foreach my $value (@data) {
    # Dereference scalar references.
    $value = $$value if ref $value eq 'SCALAR';

    # Escape any HTML content if the data is tainted.
    $value = escape_html($value) if tainted($value);
  }

  $self->SUPER::print(@data);
}
</code></pre>

    <p>
      To finish off this module we just need the TIEHANDLE interface
      we specified in our <i>new()</i> method.  The following code
      implements a <i>TIEHANDLE</i> and <i>PRINT</i> method. 
    </p>



<pre><code>
sub TIEHANDLE {
  my ($class, $r) = @_;

  return bless { r => $r }, $class;
}

sub PRINT {
  shift->print(@_);
}
</code></pre>

    <p>
      The end result is that Tainted data is escaped, and untainted
      data is passed unaltererd to the web client.
    </p>

    <h3>Conclusions</h3>
    <p>
      Cross-site scripting is a serious problem.  The solutions, input
      validation and HTML escaping are simple but must be applied
      every single time.  An application with a single overlooked form
      field is just as insecure as one that does no checking whatsoever.
    </p>
    <p>
      To insure that we always check our data Apache::TaintRequest was
      developed.  It builds upon Perl's powerful data tainting feature
      by automatically HTML escaping data that is not input validated
      when it is printed.
    </p>
    <h3>Resources</h3>
    <ul>
      <li><a href="http://www.cert.org/advisories/CA-2000-02.html">CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests</a></li>
      <li><a href="http://www.modperlcookbook.org">The mod_perl Developer's Cookbook</a></li>
      <li><a href="http://www.modperlcookbook.org/code.html">Download Apache::TaintRequest</a></li>
    </ul>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1552" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2001/07/crypto.html" rel="bookmark">Symmetric Cryptography in Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Abhijit Menon-Sen</span> on <abbr class="published" title="2001-07-10T00:00:00-08:00">July 10, 2001 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            

<p>Having purchased the $250 cookie recipe from Neiman-Marcus, Alice wants to
send it to Bob, but keep it away from Eve, who snoops on everyone's
network traffic from the cubicle down the hall.</p>
<p>How can Perl help her?</p>

<h3><a name="ciphers">Ciphers</a></h3>
<p>Cryptographic algorithms, or <em>ciphers</em>, offer Alice one way to protect
her data. By encrypting the recipe before sending it over the network,
she can render it useless to anyone but Bob, who alone possesses the
secret information required to decrypt it.</p>
<p>Ciphers were once closely guarded secrets, but relying on the
secrecy of an algorithm is a risky proposition. If your security were
somehow compromised, adversaries could read all of your past messages,
and (if you ever discovered the breach) you must find an entirely
different algorithm to use in future.</p>
<p>Modern ciphers, usually publicly known and widely studied, rely on the
secrecy of a <em>key</em> instead. They encrypt the same plaintext differently
for each key; to decrypt a ciphertext, you must know the key used to
produce it. New keys are easy to generate, so the compromise of a single
key is a smaller problem. Although messages encrypted with the stolen
key are rendered readable, the algorithm itself can be reused.</p>
<p>Algorithms that use the same key for both encryption and decryption are
called <em>symmetric ciphers</em>. To use such an algorithm, Alice and Bob
must agree on a key to use before they can exchange messages. Since
decryption depends only on the knowledge of this key, they must ensure
that they share the key by a <em>secure channel</em> that Eve cannot access
(Alice could whisper the key into Bob's ear over dinner, for example).</p>
<p>Most well-known symmetric ciphers are <em>block ciphers</em>. The plaintext to
be encrypted must be split into fixed-length blocks (usually 64 or 128
bits long) and fed to the cipher one at a time. The resulting blocks (of
the same length) are concatenated to form the ciphertext.</p>
<p>The ciphers in widespread use today vary in strength, key length, block
size and their approach to encrypting data. Some of the popular ciphers
(IDEA, Twofish, Rijndael) are implemented by eponymous modules in the
Crypt:: namespace on the CPAN (Crypt::IDEA and so on).</p>
<p>To decide which cipher to use for a particular application, one must
consider the strength and speed required, and the computational resources
available. The decision cannot be made without research, but IDEA is
often considered the best practical choice for a general purpose cipher.</p>

<h3><a name="keys">Keys</a></h3>
<p>Symmetric ciphers usually use randomly generated keys (typically between
64 and 256 bits in length), and computers are notoriously bad at truly
random number generation. Fortunately, many modern systems have some
support for the generation of cryptographically secure random numbers,
ranging from expensive hardware to device drivers that gather entropy
from the timing delay between interrupts.</p>
<p>Crypt::Random, available from the CPAN, is a convenient interface to the
<code>/dev/random</code> device on many Unix systems. Once installed, it is 
simple to use:</p>
<pre>
    use Crypt::Random qw( makerandom );</pre>
<pre>
    $key = makerandom( Size =&gt; 128, Strength =&gt; 1);</pre>
<p>For cryptographic key generation, the <code>Strength</code> parameter should
always be 1. The <code>Size</code> in bits of the desired key depends on the
cipher you want to use the key with. Typical symmetric key sizes range
from 128 to 256 bits.</p>

<h3><a name="how can i use these in perl">How Can I Use These in Perl?</a></h3>
<p>The <code>Crypt</code> modules all support the same simple interface: <code>new($key)</code>
creates a cipher object, and the <code>encrypt()</code> and <code>decrypt()</code> methods
operate on single blocks of data. The responsibility for key generation
and sharing, providing suitable blocks, and the transmission of the
ciphertext, lies with the user. In the examples below, we will use the
Crypt::Twofish module. Twofish is a free, unpatented 128-bit block
cipher with a 128, 192, or 256-bit key.</p>
<pre>
    use Crypt::Twofish;</pre>
<pre>
    # Create a new Crypt::Twofish object with the 128-bit key generated
    # above.
    $cipher = Crypt::Twofish-&gt;new($key);</pre>
<pre>
    # Encrypt a block full of 0s...
    $ciphertext = $cipher-&gt;encrypt(pack &quot;H*&quot;, &quot;00&quot;x16);</pre>
<pre>
    # And then decrypt the result.
    print unpack &quot;H*&quot;, $cipher-&gt;decrypt($ciphertext);</pre>
<p>The implementation raises an important issue: What does one do with the
second chunk of an 18-byte file? Twofish cannot operate on anything less
than a 16-byte block, so <em>padding</em> must be added to the end of the last
block to make it 16 bytes long. NULs (\000) are usually used to pad the
block, but the value used doesn't matter, because the padding is removed
after the ciphertext is decrypted.</p>
<p>Alice can now use this code to encrypt her recipe:</p>
<pre>
    # Assume that $key contains a previously-generated key, and that
    # PLAINTEXT and CIPHERTEXT are filehandles opened for reading and
    # writing respectively.</pre>
<pre>
    $cipher = Crypt::Twofish-&gt;new($key);</pre>
<pre>
    while (read(PLAINTEXT, $block, 16)) {
        $len   = length $block;
        $size += $len;</pre>
<pre>
        # Add padding if necessary
        $block .= &quot;\000&quot;x(16-$len) if $len &lt; 16;</pre>
<pre>
        $ciphertext .= $cipher-&gt;encrypt($block);
    }</pre>
<pre>
    # Record the size of the plaintext, so that the recipient knows how
    # much padding to remove.
    print CIPHERTEXT &quot;$size\n&quot;;
    print CIPHERTEXT $ciphertext;</pre>
<p>The output of this program can be safely sent across the network to Bob,
perhaps as an e-mail attachment. Bob, having received the secret key by
some other means, can then use the following code to decrypt the
message:</p>
<pre>
    $cipher = Crypt::Twofish-&gt;new($key);</pre>
<pre>
    $size = &lt;CIPHERTEXT&gt;;</pre>
<pre>
    while (read(CIPHERTEXT, $ct, 16)) {
        $pt .= $cipher-&gt;decrypt($ct);
    }</pre>
<pre>
    # Write only $size bytes of the output; ignore padding.
    print PLAINTEXT substr($pt, 0, $size);</pre>
<p>This is really all we need for symmetric cryptography in Perl. Using a
different cipher is simply a matter of installing another module and
changing the ``Twofish'' above. From a cryptographic perspective, however,
there are still some problems we must consider.</p>




<h3><a name="cipher modes">Cipher Modes</a></h3>
<p>The code above uses the Twofish cipher in Electronic Code Book (ECB)
mode, meaning that <code>n</code>th ciphertext block depends only on the key
and the <code>n</code>th plaintext block. For a particular key, one could build an
exhaustive table (or Code Book) of plaintext blocks and their ciphertext
counterparts. Then, instead of actually encrypting the plaintext, one
could simply look at the relevant entries in the table to find the
ciphertext.</p>
<p>Because of the highly repetitive nature of most texts, plaintext blocks
and their corresponding blocks in the ciphertext tend to be repeated
quite often. Further, it is often possible to make informed guesses
about parts of the plaintext (Eve knows, for example, that Alice's
messages all have a long Tolkien quote in the signature).</p>












<p>Given enough patience and ciphertext, Eve can start to build a code
book that maps ciphertext blocks to plaintext ones. Then, without
knowing either the algorithm or the key, she could simply look up the
relevant blocks in the intercepted ciphertext and write down large
parts of the original plaintext!</p>
<p>Several new cipher modes have been invented to address this problem. One
of the most generally useful ones is Cipher Block Chaining. <em>CBC</em>
starts by generating a random block (called an Initializ,ation Vector, or
<em>IV</em>) and encrypting it. The first plaintext block is XORed with the
encrypted IV before being encrypted. Thereafter, each block is XORed
with the ciphertext of the block preceding it, and then encrypted.</p>
<p>Here, each ciphertext block depends on the preceding ciphertext block,
and the plaintext blocks so far. Thus, the blocks must be decrypted in
order, and none of the patterns displayed by ECB are present. The IV
itself does not need to be kept secret, and is usually transmitted with
the ciphertext like <code>$size</code> above.</p>
<p>Decryption of the ciphertext proceeds in the opposite order. The first
ciphertext block is decrypted and XORed with the IV to form the first
plaintext block, and each ciphertext block thereafter is XORed with the
previous one to form a plaintext block. Other modes are similar in
intent, but vary in detail, including the way errors in transmission
affect the ciphertext, and the amount of feedback or dependency on
previous blocks.</p>
<p>Alice and Bob could alter their code to perform cipher block chaining,
but the handy Crypt::CBC module can save them the trouble. The module,
available from the CPAN, is used in conjunction with a symmetric cipher
module (like Crypt::Twofish). It handles padding, IV generation and all
other details. The user only needs to specify a key, and the data to be
encrypted or decrypted.</p>
<p>Thus, Alice could just do:</p>
<pre>
    use Crypt::CBC;
    $cipher = new Crypt::CBC ($key, 'Twofish');
    undef $/; $plaintext = &lt;PLAINTEXT&gt;;
    print CIPHERTEXT $cipher-&gt;encrypt($plaintext);</pre>
<p>And Bob could do:</p>
<pre>
    use Crypt::CBC;
    $cipher = new Crypt::CBC ($key, 'Twofish');
    undef $/; $ciphertext = &lt;CIPHERTEXT&gt;;
    print PLAINTEXT $cipher-&gt;decrypt($ciphertext);</pre>
<p>Much simpler!</p>
<p>
<hr>
<h1><a name="asymmetric cryptography">Asymmetric Cryptography</a></h1>
<p>Asymmetric (or public-key) ciphers use a pair of mathematically related
keys, and the algorithms are so designed that data encrypted with one
half of the key pair can only be decrypted by the other. Bob can
generate a key pair and keep one half secret, while publishing the other
half. Alice can then encrypt the recipe with Bob's public key, knowing
that it can only be decrypted with the secret half. Although this
eliminates the need to share keys over a secure channel, it has its
problems, too. For one, most public key encryption schemes
require much longer keys (often 2048 bits or more) and are much slower.</p>
<p>The <code>Crypt</code> namespace contains modules for public key cryptography as
well. <code>Crypt::RSA</code> is a portable implementation of the (now free) RSA
algorithm, one of the most widely studied public-key encryption schemes.
There are interfaces to various versions of PGP (<code>Crypt::PGP2</code>,
<code>Crypt::PGP5</code>, <code>Crypt::GPG</code>), as well as implementations of public-key
based signature algorithms (<code>Crypt::DSA</code>).</p>
<p>
<hr>
<h1><a name="cryptanalysis">Cryptanalysis</a></h1>
<p>Unfortunately, our implicit assumption that the ciphertext is useless to
Eve is not always true. Depending on the information and resources that
are available to her, she can try various means to retrieve the recipe.
The simplest strategy is to try and guess the key Alice used. This is
known as a <em>brute-force attack</em>, and involves repeatedly generating
random keys and trying to decrypt the ciphertext with each one.</p>
<p>The effectiveness of this approach depends on the size of the key: the
longer it is, the more possible keys there are, and the more guesses
will be required, on average, to find the right one. Thus, the only
possible defense is to use a key long enough to make a key search computationally impractical.</p>
<p>How long is a safe key? DES with 56-bit keys was recently cracked in a
little less than a day, but the 128-bit keyspace (range of possible
keys) is <code>4 * 10**21</code> times larger still. Although computing power is
becoming cheaper, it seems likely that 128-bit keys will be safe from
brute-force attacks for many years to come.</p>
<p>Of course, there are far more sophisticated attacks that they may be
vulnerable to. As we saw in the description of ECB, cryptanalysts can
often exploit patterns in the plaintext (long signatures, repeated
phrases) or ciphertext (repeated blocks) to great advantage, or they may
look for weaknesses (or exploit known ones) in the algorithm. Often, a
combination of such techniques reduces the potential keyspace enough
that a brute-force attack becomes practical.</p>
<p>Cryptanalysis and cryptographic techniques advanced hand-in-hand; new
ciphers are designed to withstand old attacks, and newer attacks are
attempted all the time. This makes it very important to stay abreast of
current advances in cryptographic technology if you are serious about
protecting your data for long periods of time.</p>
<p>
<hr>
<h1><a name="further resources">Further Resources</a></h1>
<dl>
<dt><strong><a name="item_google%2Ecom">google.com</a></strong><br>
<dd>
The Great God Google knows enough about cryptography-related material to
keep you occupied for a considerable amount of time.
<p></p>
<dt><strong><a name="item_perl%2Dcrypto%2Dsubscribe%40perl%2Eorg"><a href="mailto:perl-crypto-subscribe@perl.org">perl-crypto-subscribe@perl.org</a></a></strong><br>
<dd>
The perl-crypto mailing list, although not very active at the moment, is
intended for discussion of all aspects (both user and developer level)
of cryptography with Perl.
<p></p>
<dt><strong><a name="item_Crypt%3A%3ATwofish">Crypt::Twofish</a></strong><br>
<dd>
The Crypt::Twofish module, which has benefited from the inputs of
several people, is a good example of how to write a portable cipher
implementation.
<p></p></dl>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/screen-io/">&laquo; Screen I/O</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/statistics/">Statistics &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
