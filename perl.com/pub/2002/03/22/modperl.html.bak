<!--CS_PAGE_BREAK-->
<h3><a name="introduction">Introduction</a></h3><p>In the <a href="/pub/a/2002/02/26/whatismodperl.html">previous article</a>, I've shown quite amazing Web performancereports from companies that have deployed mod_perl heavily.  You mightbe surprised but you can quite easily get similarly amazing results ifyou move your service to mod_perl as well. In fact, getting startedwith mod_perl shouldn't take you more than 30 minutes -- the time ittakes to compile and configure the server on a decent machine and getit running.</p><p>In this article I'll show step-by-step installation and configurationscenarios, and chances are you will be able to run the basicstatically compiled mod_perl setup without reading any otherdocuments. Of course, you will want and need to read the documentationlater, but I think you will agree with me that it's ultimately cool tobe able to get your feet wet without knowing much about the newtechnology up-front.</p><p>The mod_perl installation was tested on many mainstream Unixplatforms, so unless you have a nonstandard system, youshouldn't have any problems building the basic mod_perl server.</p><p>If you are a Windows user, then the easiest way is to use the binarypackage available from <a href="http://perl.apache.org/distributions.html.">http://perl.apache.org/distributions.html.</a> Fromthe same location, you can download the Linux RPM version and CVSsnapshots. However, I always recommend to build the mod_perl fromthe source, and as you will see in a moment, it's an easy thing to do.</p><h3><a name="installing mod_perl is easy">Installing mod_perl Is Easy</a></h3><p>So let's start with the installation process. If you are anexperienced Unix user, then you need no explanation for the followingcommands. Just copy and paste them and you will get the serverinstalled.</p><p>I'll use a <code>%</code> sign as the shell program's prompt.</p><pre>  % cd /usr/src  % lwp-download <a href="http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz">http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz</a>  % lwp-download <a href="http://perl.apache.org/dist/mod_perl-1.26.tar.gz">http://perl.apache.org/dist/mod_perl-1.26.tar.gz</a>  % tar -zvxf apache_1.3.20.tar.gz  % tar -zvxf mod_perl-1.26.tar.gz  % cd mod_perl-1.26  % perl Makefile.PL APACHE_SRC=../apache_1.3.20/src \    DO_HTTPD=1 USE_APACI=1 EVERYTHING=1  % make &amp;&amp; make test &amp;&amp; make install  % cd ../apache_1.3.20  % make install</pre><p>That's all!</p><p>What's left is to add a few configuration lines to <em>httpd.conf</em>, anApache configuration file, start the server and enjoy mod_perl.</p><p>If you have stumbled upon a problem at any of the above steps, then don'tdespair -- the next section will explain in detail each step.</p><h3><a name="installing mod_perl detailed">Installing mod_perl Detailed</a></h3><p>If you didn't have the courage to try the steps in the previoussection or you simply want to understand more before you try, then let's gothrough the fine details of the installation process. If you havesuccessfully installed mod_perl following the short scenario in theprevious section, then you can skip this section and move on to the nextone.</p><p>Before we proceed, I should note that you have to become a <em>root</em>user in order to install the files in a protected area. If you don'thave <em>root</em> access, then you can install all the files under your homedirectory. We will talk about the nuances of this approach ina future articles. I'll also assume that you have <em>perl</em> and <em>gcc</em>or an equivalent C compiler installed.</p><p>I assume that all builds are being done in the <em>/home/stas/src</em>directory.  So we go into this directory.</p><pre>  % cd /home/stas/src</pre><p>Now we download the latest source distributions of Apache andmod_perl. If you have the <code>LWP</code> module installed (also known as<em>libwww</em> and available from CPAN), then you should have the<code>lwp-download</code> utility that partly imitates your favorite browser byallowing you to download files from the Internet. You can use anyother method to retrieve these files.  Just make sure that you saveboth files in the <em>/home/stas/src</em> directory, as this will make iteasier for you to follow the example installation process. Of course,you can install both packages anywhere on your file system.</p><pre>  % lwp-download <a href="http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz">http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz</a>  % lwp-download <a href="http://perl.apache.org/dist/mod_perl-1.26.tar.gz">http://perl.apache.org/dist/mod_perl-1.26.tar.gz</a></pre><p>You can make sure that you're downloading the latest stable versionsby visiting the following distribution directories:<em><a href="http://www.apache.org/dist/httpd/">http://www.apache.org/dist/httpd/</a></em> and<em><a href="http://perl.apache.org/dist/">http://perl.apache.org/dist/</a></em>. As you have guessed already, theformer URL is the main Apache distribution directory, the latter isthe same thing for mod_perl.</p><p>Untar both sources. You have to uncompress and untar the files.  Inaddition to its main usage for tarring and untarring files, the GNU<code>tar</code> utility is able to uncompress files compressed by the <code>gzip</code>utility, when the <code>-z</code> option is used.</p><pre>  % tar -zvxf apache_1.3.20.tar.gz  % tar -zvxf mod_perl-1.26.tar.gz</pre><p>If you have a non-GNU <code>tar</code> utility, then chances are that it will beunable to decompress, so you need to do it in two steps. First,uncompress the packages with:</p><pre>  % gzip -d apache_1.3.20.tar.gz  % gzip -d mod_perl-1.26.tar.gz</pre><p>Then untar them with:</p><pre>  % tar -xvf apache_1.3.20.tar  % tar -xvf mod_perl-1.26.tar</pre><p>If you don't have <code>tar</code> or <code>gzip</code> utilities available, then install them or use their equivalents.</p><p>Now go into the mod_perl source distribution directory.</p><pre>  % cd mod_perl-1.26</pre><p>The next step is to create the <em>Makefile</em>.</p><pre>  % perl Makefile.PL APACHE_SRC=../apache_1.3.20/src \    DO_HTTPD=1 USE_APACI=1 EVERYTHING=1</pre>     <csperl file="grab" domain="on" record="b/832" template="b/article_sidebar2.view">   <p>mod_perl accepts a variety of parameters, in this scenario we aregoing to use those that will allow you to do almost everything withmod_perl. Once you learn more about mod_perl, you will be able to fine-tune the list of parameters passed to <em>Makefile.PL</em>.  In futurearticles, I'll go through all the available options.</p><p><code>perl Makefile.PL ...</code> execution will check for prerequisites andtell you which required software packages are missing from yoursystem. If you don't have some of the Perl packages installed, then youwill have to install these before you proceed. They all are availablefrom CPAN and can be easily downloaded and installed.</p><p>If you choose to install mod_perl with help of the <code>CPAN.pm</code> module,then it will install all the missing modules for you. To do so, tell<code>CPAN.pm</code> to install the <code>Bundle::Apache</code> bundle.</p><p>This step also executes the <code>./configure</code> script from Apache's sourcedistribution directory (absolutely transparently for you), whichprepares the Apache build configuration files. If you need to passparameters to Apache's <code>./configure</code> script, then pass them asoptions to <code>perl Makefile.PL ...</code>. In future articles we will talkabout all the available options.</p><p>Now you should build the <em>httpd</em> executable by using the <code>make</code>utility.</p><pre>  % make</pre><p>This command prepares mod_perl extension files, installs them in theApache source tree and builds the <em>httpd</em> executable (the Web serveritself) by compiling all the required files. Upon completion of the<code>make</code> process, you get returned to the mod_perl source distributiondirectory.</p><p><code>make test</code> executes various mod_perl tests on the freshly built<em>httpd</em> executable.</p><pre>  % make test</pre><p>This command starts the server on a nonstandard port (8529) and testswhether all parts of the built server function correctly. If somethinggoes wrong, then the process will report it to you.</p><p><code>make install</code> completes the installation process of mod_perl byinstalling all the Perl files required for mod_perl to run and, ofcourse, the server documentation (man pages).</p><pre>  % make install</pre><p>You can use the following commands concatenation style:</p><pre>  % make &amp;&amp; make test &amp;&amp; make install</pre><p>It simplifies the installation, since you don't have to wait for eachcommand to complete before starting the next one. When installingmod_perl for the first time, it's better to do it step by step.</p><p>If you choose the all-in-one approach, then you should know that if <code>make</code>fails, then neither <code>make test</code> nor <code>make install</code> will be executed. If<code>make test</code> fails, then <code>make install</code> will not be executed.</p><p>Finally, change to the Apache source distribution directory, runmake&nbsp;install to create the Apache directory tree and install Apacheheader files (<em>*.h</em>), default configuration files (<em>*.conf</em>), the<em>httpd</em> executable and a few other programs.</p><pre>  % cd ../apache_1.3.20  % make install</pre><p>Note that, as with a plain Apache installation, any configurationfiles left from a previous installation won't be overwritten by thisprocess. You don't need to back up your previously workingconfiguration files before the installation.</p><p>When the <code>make install</code> process completes, it will tell you how tostart a freshly built Web server (the path to the <code>apachectl</code> utilitythat is being used to control the server) and where the installedconfiguration files are. Remember or, even better, write down both ofthem, since you will need this information. On my machinethe two important paths are:</p><pre>  /usr/local/apache/bin/apachectl  /usr/local/apache/conf/httpd.conf</pre><p>So far, we have completed the building and installation of the mod_perlenabled Apache. The next steps are to configure <em>httpd.conf</em>, write alittle test script, start the server and check that the test script isworking.</p><csinclude template="a/multipage_bottom.view"><!--CS_PAGE_INDEX--><csinclude template="a/multipage_bottomb.view"><a href="<!--CS_NEXT_REF-->"><csinclude template="a/multipage_bottomc.view"><!--CS_PAGE_BREAK--><csinclude template="a/multipage_top.view"><!--CS_PAGE_INDEX--><csinclude template="a/multipage_topb.view"><h3><a name="configuring and starting mod_perl server">Configuring and Starting mod_perl Server</a></h3><p>First things first; we want to make sure that our Apache was built correctlyand that we can serve plain HTML files with it. Why do that? Tominimize the number of possible trouble makers, if we find out thatmod_perl doesn't work. After you know that Apache can serve HTMLfiles, you don't have to worry about it anymore. And if something goeswrong with mod_perl, you have eliminated the possibility that the<em>httpd</em> binary or basic configurations are broken, you know that you areallowed to bind to the port you have configured your server to listento, and that the browser you're testing with is just fine. Again, youshould follow these guidelines when installing mod_perl for the firsttime.</p><p>Configure Apache as you always do. Set <code>Port</code>, <code>User</code>, <code>Group</code>,<code>ErrorLog</code> and other directives in the <em>httpd.conf</em> file (rememberI've asked you to remember the location of this file at the end of theprevious section?). Use the defaults as suggested, customize only whenyou have to. Values that you need to customize are <code>ServerName</code>,<code>Port</code>, <code>User</code>, <code>Group</code>, <code>ServerAdmin</code>, <code>DocumentRoot</code> and a fewothers. You will find helpful hints preceding each directive. Followthem if in doubt.</p><p>When you have edited the configuration file, it's time to start theserver.  One of the ways to start and stop the server is to use the<code>apachectl</code> utility. You start the server with:</p><pre>  % /usr/local/apache/bin/apachectl start</pre><p>And stop it with:</p><pre>  % /usr/local/apache/bin/apachectl stop</pre><p>Note that you have to be <em>root</em> when starting the server if theserver is going to listen on port <code>80</code> or another privileged port(&lt;1024).</p><p>After you start the server, check in the <em>error_log</em> file(<em>/usr/local/apache/logs/error_log</em> is the file's default location)that the server has indeed started. Don't rely on the status<code>apachectl</code> reports.  You should see something like this:</p><pre>  [Thu Jun 22 17:14:07 2000] [notice] Apache/1.3.20 (Unix)   mod_perl/1.26 configured -- resuming normal operations</pre><p>Now point your browser to <em><a href="http://localhost/">http://localhost/</a></em> or<em><a href="http://your.server.name/">http://your.server.name/</a></em> as configured with the <code>ServerName</code>directive. If you have set a <code>Port</code> directive with a value differentfrom <code>80</code>, then apply this port number at the end of the server name. Ifyou have used port 8080, then test the server with<em><a href="http://localhost:8080/">http://localhost:8080/</a></em> or <em><a href="http://your.server.name:8080/">http://your.server.name:8080/</a></em>. Youshould see the infamous <em>``It worked''</em> page, which is an <code>index.html</code>file that <code>make install</code> in the Apache source tree installs for you.If you don't see this page, then something is wrong and you should checkthe contents of the <em>error_log</em> file. You will find the path of theerror log file by looking it up in the <code>ErrorLog</code> directive in<em>httpd.conf</em>.</p><p>If everything works as expected, then shut down the server, open<em>httpd.conf</em> in your favorite editor, and scroll to the end of thefile, where we will add the mod_perl configuration directives (ofcourse you can place them anywhere in the file).</p><p>Assuming that you put all scripts that should be executed by themod_perl enabled server in the <em>/home/httpd/perl/</em> directory, add thefollowing configuration directives:</p><pre>  Alias /perl/ /home/httpd/perl/  PerlModule Apache::Registry  &lt;Location /perl&gt;    SetHandler perl-script    PerlHandler Apache::Registry    Options ExecCGI    PerlSendHeader On    allow from all  &lt;/Location&gt;</pre><p>Save the modified file.</p><p>This configuration causes each URI starting with <em>/perl</em> to behandled by the Apache mod_perl module. It will use the handler fromthe Perl module <code>Apache::Registry</code>.</p><h3><a name="preparing the scripts directory">Preparing the Scripts Directory</a></h3><p>Now create a <em>/home/httpd/perl/</em> directory if it doesn't yet exist.In order for you and Apache to be able to read, write and executefiles we have to set correct permissions. You could get away by simplydoing:</p><pre>  % chmod 0777  /home/httpd/perl</pre><p>This is very, very insecure and you <strong>should not</strong> follow this approachon the production machine. This is good enough when you just want totry things out and want to have as few obstacles as possible. Once youunderstand how things work, you should tighten the permissions offiles served by Apache.  In future articles, we will talk about settingproper file permissions.</p><h3><a name="the mod_perl rules apache::registry script">The ``mod_perl rules'' Apache::Registry Script</a></h3><p>As you probably know, mod_perl allows you to reuse CGI scriptswritten in Perl that were previously used under mod_cgi. Therefore,our first test script can be as simple as:</p><pre>  mod_perl_rules1.pl  ------------------  print &quot;Content-type: text/plain\r\n\r\n&quot;;  print &quot;mod_perl rules!\n&quot;;</pre><p>Save this script in the <em>/home/httpd/perl/mod_perl_rules1.pl</em> file.Notice that the <em>shebang</em> line is not needed with mod_perl, but youcan keep it if you want. So the following script can be used as well:</p><pre>  mod_perl_rules1.pl  ------------------  #!/usr/bin/perl  print &quot;Content-type: text/plain\r\n\r\n&quot;;  print &quot;mod_perl rules!\n&quot;;</pre><p>Of course you can write the same script using the Apache Perl API:</p><pre>  mod_perl_rules2.pl  ------------------  my $r = shift;  $r-&gt;send_http_header('text/plain');  $r-&gt;print(&quot;mod_perl rules!\n&quot;);</pre><p>Save this script in the <em>/home/httpd/perl/mod_perl_rules2.pl</em> file.</p><p>Now make both of the scripts executable and readable by the server.Remember that when you execute scripts from a shell, they are beingexecuted by the user-name you are logged with. When instead you try torun the scripts by issuing requests, Apache needs to be able to readand execute them. So we make the script readable and executable byeverybody:</p><pre>  % chmod 0755   /home/httpd/perl/mod_perl_rules1.pl \                 /home/httpd/perl/mod_perl_rules2.pl</pre><p>If you don't want other users to be able to read your script, then youshould add yourself into the groupname the Web server is running with(as defined by the <code>Group</code> directive) and then make the script ownedby that group and tighten the permissions. For example, onmy machine I run the server under the group <em>httpd</em> and I'm the onlyone who is in the same group, so I can do the following:</p><pre>  % chown stas.httpd /home/httpd/perl/mod_perl_rules1.pl \                 /home/httpd/perl/mod_perl_rules2.pl</pre><pre>  % chmod 0750   /home/httpd/perl/mod_perl_rules1.pl \                 /home/httpd/perl/mod_perl_rules2.pl</pre><p>The first command makes the files belong to group <em>httpd</em>, the secondsets the proper execution and read permissions.</p><p>That's secure, assuming that you have a dedicated groupname for yourserver.</p><p>Also, remember that all the directories that lead to the script shouldbe readable and executable by the server.</p><p>You can test <em>mod_perl_rules1.pl</em> from the command line, since it isessentially a regular Perl script.</p><pre>  % perl /home/httpd/perl/mod_perl_rules1.pl</pre><p>You should see the following output:</p><pre>  mod_perl rules!</pre><p>You cannot test the second script by executing it from the commandline since it uses the mod_perl API that is available only when runfrom within the mod_perl server.</p><p>Make sure the server is running and issue these requests using yourfavorite browser:</p><pre>  <a href="http://localhost/perl/mod_perl_rules1.pl">http://localhost/perl/mod_perl_rules1.pl</a>  <a href="http://localhost/perl/mod_perl_rules2.pl">http://localhost/perl/mod_perl_rules2.pl</a></pre><p>In both cases you will see on the following response:</p><pre>  mod_perl rules!</pre><p>If you see it--<strong>congratulations</strong>! You have a working mod_perl server.</p><p>If you're using port 8080 instead of 80, then you should use this number inthe URL:</p><pre>  <a href="http://localhost:8080/perl/mod_perl_rules1.pl">http://localhost:8080/perl/mod_perl_rules1.pl</a>  <a href="http://localhost:8080/perl/mod_perl_rules2.pl">http://localhost:8080/perl/mod_perl_rules2.pl</a></pre><p>The <code>localhost</code> approach will work only if the browser is running onthe same machine as the server.  If not, then use the real server name forthis test. For example:</p><pre>  <a href="http://your.server.name/perl/mod_perl_rules1.pl">http://your.server.name/perl/mod_perl_rules1.pl</a></pre><p>If there is any problem, then please refer to the <em>error_log</em> file for theerror reports.</p><p>Now it's a time to move your CGI scripts from <em>/somewhere/cgi-bin</em>directory to <em>/home/httpd/perl/</em> and see them running much muchfaster, when requested from the newly configured base URL(<em>/perl/</em>). If you were accessing the script as <em>/cgi-bin/test.pl</em>,then it will now be accessed from <em>/perl/test.pl</em>.</p><p>Some of your scripts might not work immediately and will require someminor tweaking or even a partial rewrite to work properly withmod_perl. Chances are that if you are not practicing sloppyprogramming, then the scripts will work without any modifications.</p><p>If you have a problem with your scripts, then a good approach is to replace<code>Apache::Registry</code> with <code>Apache::PerlRun</code> in <em>httpd.conf</em>, as thelatter can execute really badly written scripts. Put the followingconfiguration directives instead in <em>httpd.conf</em> and restart theserver:</p><pre>  PerlModule Apache::PerlRun  &lt;Location /perl&gt;    SetHandler perl-script    PerlHandler Apache::PerlRun    Options ExecCGI    PerlSendHeader On    allow from all  &lt;/Location&gt;</pre><p>Now your scripts should work, unless there is something inthem mod_perl doesn't accept. We will discuss these nuances in futurearticles.</p><h3><a name="the mod_perl rules apache perl module">The ``mod_perl rules'' Apache Perl Module</a></h3><p>mod_perl is about running both scripts and handlers. Although I havestarted to present mod_perl using scripts, because it's easier if youhave written CGI scripts before, the more advanced use of mod_perl isabout writing handlers. But have no fear. As you will see in a moment,writing handlers is almost as easy as writing scripts.</p><p>To create a mod_perl handler module, all I have to do is to wrap thecode I have used for the script into a <code>handler</code> subroutine, add astatement to return the status to the server when the subroutine hassuccessfully completed, and append a package declaration at the top ofthe code.</p><p>Just as with scripts you can use either the CGI API you are probablyused to:</p><pre>  ModPerl/Rules1.pm  ----------------  package ModPerl::Rules1;  use Apache::Constants qw(:common);  sub handler{    print &quot;Content-type: text/plain\r\n\r\n&quot;;    print &quot;mod_perl rules!\n&quot;;    return OK;  }  1; # satisfy require()</pre><p>or the Apache Perl API that allows you to interact more intimatelywith the Apache core by providing an API unavailable under regularPerl. Of course, in the simple example that I show, using any of theapproaches is fine, but when you need to use the API, this version ofthe code should be used.</p><pre>  ModPerl/Rules2.pm  ----------------  package ModPerl::Rules2;  use Apache::Constants qw(:common);  sub handler{    my $r = shift;    $r-&gt;send_http_header('text/plain');    print &quot;mod_perl rules!\n&quot;;    return OK;  }  1; # satisfy require()</pre><p>Create a directory called <em>ModPerl</em> under one of the directories in<code>@INC</code> (e.g. <em>/usr/lib/perl5/site_perl/5.005</em>), and put <em>Rules1.pm</em><em>Rules2.pm</em> into it, the files should include the code from the aboveexamples.</p><p>To find out what the <code>@INC</code> directories are, execute:</p><pre>  % perl -le 'print join &quot;\n&quot;, @INC'</pre><p>On my machine it reports:</p><pre>  /usr/lib/perl5/5.6.1/i386-linux  /usr/lib/perl5/5.6.1  /usr/lib/perl5/site_perl/5.6.1/i386-linux  /usr/lib/perl5/site_perl/5.6.1  /usr/lib/perl5/site_perl  .</pre><p>Now add the following snippet to <em>httpd.conf</em> to configure mod_perlto execute the <code>ModPerl::Rules::handler</code> subroutine whenever arequest to <em>mod_perl_rules1</em> is made:</p><pre>  PerlModule ModPerl::Rules1  &lt;Location /mod_perl_rules1&gt;    SetHandler perl-script    PerlHandler ModPerl::Rules1  &lt;/Location&gt;</pre><p>Now you can issue a request to:</p><pre>  <a href="http://localhost/mod_perl_rules1">http://localhost/mod_perl_rules1</a></pre><p>and just as with our <em>mod_perl_rules.pl</em> scripts you will see:</p><pre>  mod_perl rules!</pre><p>as the response.</p><p>To test the second module &lt;ModPerl::Rules2&gt; add the sameconfiguration, while replacing all 1's with 2's:</p><pre>  PerlModule ModPerl::Rules2  &lt;Location /mod_perl_rules2&gt;    SetHandler perl-script    PerlHandler ModPerl::Rules2  &lt;/Location&gt;</pre><p>And to test use the URI:</p><pre>  <a href="http://localhost/mod_perl_rules2">http://localhost/mod_perl_rules2</a></pre><h3><a name="is this all i need to know about mod_perl">Is This All I Need to Know About mod_perl?</a></h3><p>Obviously, the next question you'll ask is: <em>``Is this all I need toknow about mod_perl?''</em>.</p><p>The answer is: `yes and no.</p><p>The <em>yes</em> part:</p><ul><li>Just like with Perl, you have to know little about mod_perl to doreally cool stuff. The presented setup allows you to run your visitorcounters and guest book much faster, and amaze your friends, usuallywithout changing a single line of code.<p></p></ul><p>The <em>No</em> part:</p><ul><li>A 50-fold improvement in guest book response times is great, but whenyou deploy a heavy service with thousands of concurrent users,taking into account a high-level competition between similar Webservices, a delay of a few milliseconds might cost you a customer andprobably many of them.<p>Of course, when you test a single script and you are the only user, youdon't really care about squeezing yet another millisecond fromresponse time, but it becomes a real issue when these milliseconds addup at the production site, with hundreds of users concurrentlygenerating requests to various scripts on your site. Users aren'tmerciful nowadays -- if there is another even less fancier site thatprovides the same service but a little bit faster, then chances are thatthey will go over there.</p><p>Testing your scripts on an unloaded machine can be misleading,Everything might seem so perfect. But when you move them into aproduction machine, things don't behave as well as they did on yourdevelopment box. Many times you just run out of memory on busyservices. You need to learn how to optimize your code to use lessmemory and how to make the memory shared.</p><p>Debugging is something people prefer not to talk about, since theprocess can be tedious. Learning how to make thedebugging process simpler and efficient is a must if you consideryourself a Web programmer. This task is especially not sostraightforward when debugging CGI scripts, and even more complicatedwith mod_perl -- unless you know how, and then it suddenly becomes easy.</p><table width="150" border="0" cellspacing="0" cellpadding="4" align="right"><tr> <td width="150" valign="top" height="4" bgcolor="#006699"></td></tr> <tr><td bgcolor="#efefef"><p class="headline" align="center">References</p><p class="smalltext">The Apache site's URL: <a href="http://www.apache.org/">http://www.apache.org/</a><br /><br />The mod_perl site's URL: <a href="http://perl.apache.org/">http://perl.apache.org/</a><br /><br />CPAN is the Comprehensive Perl Archive Network. The Master site's URLis <a href="http://cpan.org/">http://cpan.org/</a>. CPAN is mirrored at more than 100 sitesworldwide. (http://cpan.org/SITES.html)</p></td></tr> <tr><td width="150" valign="top" height="4" bgcolor="#006699"> </td></tr></table><p>mod_perl has many features unavailable under mod_cgi when working withdatabases. Among others the most important are persistent connections.</p><p>You have to know how to keep your service running nonstop and be ableto recover fast if there are any problems.</p><p>Finally, the most important thing is the Apache-Perl API, which allowsyou to do anything with a received request, even intervene in everystage of request processing. This gives you great flexibility and allowsyou to create things you couldn't dream about with plain mod_cgi.</p><p></p></ul><p>There are many more things to learn about mod_perl and Web programmingin general. In future articles, I'll talk in details about all theseissues.</p><h4><a name="acknowledgements">Acknowledgements</a></h4><p>Many thanks to Eric Cholet for reviewing this article.</p>
