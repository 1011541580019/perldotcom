<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.13-en" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>
<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="/pub/">
<dc:title>Perl.com</dc:title>
<dc:description>news and views of the Perl programming language</dc:description>
<license rdf:resource="http://creativecommons.org/licenses/by-nc-nd/3.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-nc-nd/3.0/">
</License>
</rdf:RDF>
-->

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
<script type='text/javascript' src='http://partner.googleadservices.com/gampad/google_service.js'></script>
<script type='text/javascript'>
GS_googleAddAdSenseService("ca-pub-4136420132070439");
GS_googleEnableAllServices();
</script>
<script type='text/javascript'>
GA_googleAddSlot("ca-pub-4136420132070439", "Perl_728x90");
</script>
<script type='text/javascript'>GA_googleFetchAds();</script>
    <title>Perl.com: January 2002 Archives</title>


    <link rel="prev" href="/pub/2001/12/" title="December 2001" />
    <link rel="next" href="/pub/2002/02/" title="February 2002" />

</head>
<body id="perl-com" class="mt-archive-listing mt-datebased-monthly-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <span id="top_advert"> 
<!-- Put any landscape advert in here -->
<!-- Perl_728x90 -->
<script type='text/javascript'>
GA_googleFillSlot("Perl_728x90");
</script>
        </span> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description">news and views of the Perl programming language</div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <h1 id="page-title" class="archive-title">January 2002 Archives</h1>





                            
                            <div id="entry-1246" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/30/pmcs.html" rel="bookmark">Beginning PMCs</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Jeffrey Goff</span> on <abbr class="published" title="2002-01-30T00:00:00-08:00">January 30, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            

<p>One of the best things about Parrot is that it's not just for Perl
implementors. Parrot 0.0.3 came with support for extensible data types
that can be used to implement the types used in your favorite language.
The mechanism by which these types are extensible is called the <b>PMC</b>.</p>
<p>The PMC, or Parrot Magic Cookie, type is a special data container for
user-defined data types. Because these user-defined types are
essentially implementations of a set of methods, we refer to them as PMC
classes. Currently, the legal PMC classes are the <code>PerlInt</code>,
<code>PerlNum</code>, <code>PerlString</code>, <code>PerlArray</code>, and <code>PerlHash</code> types. The
<code>PerlInt</code>, <code>PerlNum</code> and <code>PerlString</code> data types combine to form the
PerlScalar data type.</p>



<p>PMC registers, unlike the basic Integer, Number, and String registers,
must be specially allocated with the <code>new P0, PMCType</code> instruction.
Other operations like <code>set P0,5</code> are handled by special functions that are implemented by the PMC class. The rest of this article is about how
to create your own PMC class implementation, alongside the <code>PerlInt</code> and
<code>PerlHash</code> data types.</p>

<p>For our example, we're going to implement a simple queue data
structure. Our queue will be a set of integers; the queue will grow when
an integer is assigned to it, and will shrink when an integer is read
from it. We'll use the <code>PerlInt</code> class as a basis, so it may be helpful
to look at some examples of operations that use it:</p>
<pre>
  new P0, PerlInt  # Create a new PMC in the 'PerlInt' class
  set P0, 1234     # Set the value of the PMC to 1234
  set P0, &quot;4567&quot;   # Set the value of the PMC to 4567
  set P0, 12.34    # Set the value of the PMC to 12
  set I0, P0       # Set I0 to the current value of the PMC
  print P0
  print &quot;n&quot;</pre>
<p>Note that no special instructions like <code>set_string</code> or <code>set_float</code>
were required to assign data of different types to the PMC. Each
instruction does the Right Thing given the initial type of the PMC. This
has several important consequences when designing new data types, the
largest of which is that it generally isn't necessary to add special
instructions to access data contained within a PMC.</p>
<p>On the other side, this means that PMCs should attempt to behave
rationally in all situations. It's not an onerous requirement, but in
some cases, rational behavior is hard to define. Queues are fairly
simple to define though, in terms of behavior. A queue has one way to
get data in and one way to get data out.</p>
<p>Since we can use one instruction for multiple classes, we'll use <code>set Pn,In</code> 
to add an integer to the queue, and <code>set In,Pn</code> to get an
element out of the queue. The last operation we need to perform on a
queue is to determine whether the queue is empty. The PerlArray class uses
<code>set In,Pn</code> to return the length of the array into <code>In</code>, but we've
already decided to use that to get an integer out of the queue.</p>
<p>Instead of <code>set In,Pn</code> to determine how many elements are in the queue,
all we really need to know is whether the queue is empty or in use. For that,
we can use the handy boolean operator, <code>if Pn,In</code>. Here, the integer
register is actually the number of instructions to skip over if the
condition is true. We'll have it branch if the queue is empty.</p>
<p>So, our <code>IntQueue</code> data type will implement three instructions. First, the <code>set Pn,In</code> instruction will add an integer to the queue.
Second, when the queue is empty, <code>if Pn,In</code> will branch to the appropriate
offset. Finally, <code>set In,Pn</code> will dequeue the last integer in the queue
and place it into the appropriate integer register.</p>
<p>Some sample source using <code>IntQueue</code> may come in handy at this time:</p>
<pre>
  new P0, IntQueue   # Create the queue
  set P0, 7          # Enqueue 7
  set P0, -43        # Enqueue -43
  set I0, P0         # Dequeue 7
  print I0           # Should print '7'.
  if P0, QUEUE_emPTY # Goto label 'QUEUE_emPTY'</pre>


<h3>Core Operations</a></h3>

<p>Before forging ahead with the <code>IntQueue</code>, let's take a look at the core
operations file.  Within your CVS tarball, open <em>parrot/core.ops</em> and
search for the <code>set</code> operations. While there are files such as
<em>parrot/core_ops.c</em> and <em>parrot/Parrot/OpLib/core_ops.pm</em>, this is the
master file. Changes in <em>parrot/core_ops.c</em> will be overwritten the
next time you build, so make your edits to <em>parrot/core.ops</em>.</p>
<p>Having said that, let's look at a sample PMC operation.</p>
<pre>
  inline op set(out PMC, in NUM) {
    $1-&gt;vtable-&gt;set_number(interpreter,$1,$2);
    goto NEXT();
  }</pre>
<p>Since <em>core.ops</em> is split into a Perl and C source file, the syntax is,
of necessity, a mixture of Perl and C. The 'inline' declaration is a
hint to the JIT compiler, which is beyond the scope of the article.
Parameters also have hints for the JIT compiler, but the most important
bits here are the <code>PMC</code> and <code>NUM</code> tags, because these let the compiler
know what types this operation can take.</p>
<p>When preprocessing into Perl, the prototype is the only piece of
interest, as the assembler only needs to know the name and parameter
list in order to build the assembly code.</p>
<p>C preprocessing is a bit more complicated, but still fairly
straightforward. Tokens like <code>$2</code> are replaced with the appropriate
code to access the declared parameter, and a few keywords like <code>NEXT()</code>
are replaced with code to return the next instruction in the stream.</p>
<p>With the exception of those tags, the rest of the code is pure C, with
access to all of the Parrot internals. Of course, you shouldn't access
such things as the register internals, but the rest of the C API is
available, the most common APIs being located in
<em>parrot/include/parrot/string.h</em> and <em>parrot/include/parrot/key.h</em>,
the latter primarily being used for aggregate data structures.</p>
<p>The preprocessor, while slightly confusing, is much more flexible than
the current system of nested <code>CPP</code> macros that Perl currently uses, and
hopefully easier to understand.</p>













<h3>Virtual Tables</h3>
<p>The code above used a curious construct:</p>
<pre>
  $1-&gt;vtable-&gt;set_number(INTERP,$1,$2);</pre>
<p>Parameter <code>$1</code> is a PMC, and since these are user-defined types, the
code simply can't assign <code>$2</code> to <code>$1</code>, as the non-PMC operations would
do. Instead, each PMC has a table of function pointers assigned to it,
and the interpreter calls the appropriate function.</p>
<p>For example, assuming that the <code>P0</code> register is being initialized by the
<code>new P0,IntQueue</code> instruction, the above code would run the <code>set_number</code>
member of the <code>IntQueue</code> class. Since the type of <code>P0</code> is decided on at
runtime, the dispatch mechanism is completely independent of the parameter type.
What this means in the case of the <code>IntQueue</code> type is that no modifications
need to be made to the <em>parrot/core.ops</em> file.</p>
<p>
<H3><A NAME="parrot class files">Parrot Class Files</A></H3>
<p><em>parrot/classes</em> contains all of the PMC classes used by Parrot. Like
the <em>parrot/core.ops</em> file, this too is preprocessed before final
compilation, so all edits should be made to the <em>parrot/classes/*.pmc</em>
files.</p>
<p>Creating a new class file from scratch is somewhat daunting, so we'll use an
existing class file to base <code>IntQueue</code> on. While <code>IntQueue</code> is an aggregate
type like <code>PerlHash</code>, the interface matches <code>PerlInt</code> closest, in that it
only deals with one element at a time.</p>
<p>Start by copying <em>parrot/classes/PerlInt.pmc</em> to
<em>parrot/classes/IntQueue.pmc</em>, and replace all instances of <code>PerlInt</code>
with <code>IntQueue</code>. There will be some additional C code necessary that
will be available in the sample source at the end of the article, but
not discussed beyond the API.</p>
<p>Registering the <em>parrot/classes/IntQueue.pmc</em> is done in two files. Add
the appropriate lines to <em>parrot/global_setup.c</em> to initialize the new
PMC type, and add the new vtable entry to
<em>parrot/include/parrot/pmc.h</em>. This is only done in the case of types
that are intended to be part of Parrot itself; when Parrot has the
ability to dynamically load PMC classes at runtime, a more flexible
mechanism will be derived for registering classes, but for now, we'll
pretend that <code>IntQueue</code> is going to be a core interpreter data type.</p>
<p>Within <em>parrot/core.ops</em>, the instructions the <code>IntQueue</code> type uses look like
this:</p>
<pre>
  op new(out PMC, in INT) {
    PMC* newpmc;
    if ($2 &lt;0 || $2 &gt;= enum_class_max) {
      abort(); /* Deserve to lose */
    }
    newpmc = pmc_new(interpreter, $2);
    $1 = newpmc;
    goto NEXT();
  }
  
  inline op set(out PMC, in INT) {
    $1-&gt;vtable-&gt;set_integer_native(interpreter, $1, $2);
    goto NEXT();
  }
  
  inline op set(out INT, in PMC) {
    $1 = $2-&gt;vtable-&gt;get_integer(interpreter, $2);
    goto NEXT();
  }
  
  op if(in PMC, in INT) {
    if ($1-&gt;vtable-&gt;get_bool(interpreter, $1)) {
      goto OFFSET($2);
    }
    goto NEXT();
  }</pre>
<p>Naturally, each of these call PMC vtable entries, and each one of these
has to be implemented. As of this writing, the appropriate vtable
entries as they are in <em>parrot/classes/perlint.pmc</em> look like this:</p>
<pre>
    void init () { /* This is called from pmc_new() */
        SELF-&gt;cache.int_val = 0;
    }</pre>
<pre>
    void set_integer_native (INTVAL value) {
        SELF-&gt;cache.int_val = value;
    }</pre>
<pre>
    INTVAL get_integer () {
        return SELF-&gt;cache.int_val;
    }</pre>
<pre>
    BOOLVAL get_bool () {
        return pmc-&gt;cache.int_val != 0;
    }</pre>
<p>Any code before the <code>pmclass</code> declaration in a <em>parrot/classes/*.pmc</em> file
is literally copied into the C source, so we'll use this area to store our data
structures and APIs. In order to make matters simple, we'll assume that the
following API is available for our use:</p>
<pre>
  static CONTAINER* new_container ( void );
  static void enqueue ( CONTAINER* container, INTVAL value );
  static INTVAL dequeue ( CONTAINER* container );
  static INTVAL queue_length ( CONTAINER* container );</pre>
<p>The API should be fairly straightforward to use. Initializing the container is
done with <code>new_container</code>, which returns a pointer to our new queue data type.
Adding a new queue element is done with <code>enqueue</code>, and deleting an element is
done with <code>dequeue</code>. The queue's length can be found with <code>queue_length</code>.</p>
<p>The <code>CONTAINER</code> data type has to be stored somewhere, and we look into
<em>parrot/include/parrot/pmc.h</em> to find out where to store it. We find
the definition of the PMC structure to be:</p>
<pre>
    struct PMC {
      VTABLE *vtable;
      INTVAL flags;
      DPOINTER *data;
      union {
        INTVAL int_val;
        FLOATVAL num_val;
        DPOINTER *struct_val;
      } cache;
      SYNC *synchronize;
    };</pre>
<p>There are two areas we can store data: <code>data</code> is used as a general
dumping ground for a data type's internal data structures, and the
<code>cache</code> union is used for fast access to simpler data structures.
<code>data</code> is the right place to hang our <code>CONTAINER</code> structure.</p>
<p>Like most of the other files within Parrot, the <code>IntQueue</code> class is
also preprocessed. The major preprocessing done here is to replace the
<code>SELF</code> tag with a reference to the current PMC. In the rare case that
you need a reference to the current interpreter, that tag is <code>INTERP</code>.</p>
<p>Initializing the <code>IntQueue</code> class is done with the <code>init</code> member. Since we're
storing our queue in the <code>data</code>, we'll let the <code>new_container</code>
function hand us a pointer to our new queue, and save that.</p>
<pre>
    void init () {
        SELF-&gt;data = new_container();
    }</pre>
<p>Getting an integer out of the queue is done with the <code>get_integer</code> member.
This isn't meant to be production-quality, so we won't worry about error
checking. So, we'll simply return the integer from the container.</p>
<pre>
    INTVAL get_integer () {
        return dequeue((CONTAINER*)SELF-&gt;data);
    }</pre>
<p>Adding an integer to the queue is done with the <code>set_integer_native</code> member.
We'll simply use the <code>enqueue</code> function to place the integer onto the queue
like so:</p>
<pre>
    void set_integer_native (INTVAL value) {
        enqueue(SELF-&gt;data,value);
    }</pre>
<p>The final function we need to support is being able to determine whether the queue
is empty, and we use the <code>queue_length</code> function for that. The PMC member
function that does this is <code>get_bool</code>, and the code to access this is pretty
straightforward:</p>
<pre>
    BOOLVAL get_bool () {
        return queue_length(SELF-&gt;data) != 0;
    }</pre>
<p>This code has been checked in to the Parrot CVS, so feel free to look at
the full version there. We've now walked through the major files needed
to implement a Parrot Magic Cookie. Next time, we'll explore the
functions needed to implement aggregate data types like hashes and
arrays, and learn about the new garbage collection system.</p>
<p>In the meantime, if you want to play with implementing your own data
types for Parrot, then take a look at <em>docs/vtables.pod</em> in the Parrot
source tree for more information about the members that you can
implement and how to design your own classes from scratch.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1252" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/p6pdigest/20020119.html" rel="bookmark">This Week on Perl 6 (13 - 19 Jan 2002)</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Bryan Warnock</span> on <abbr class="published" title="2002-01-23T00:00:00-08:00">January 23, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>
This summary, as with past summaries, can be found in
<a href="http://members.home.com/bcwarno/Perl6/digests/">here</a>.  (Note that this is an @Home address, and will change sometime in the
next two months.)  Please send additions, submissions, corrections, kudos, 
and complaints to 
<a href="mailto:bwarnock@capita.com">bwarnock@capita.com</a>.
</p>

<p>
Perl 6 is the major redesign and rewrite of the Perl language.  Parrot is
the virtual machine that Perl 6 (and other languages) will be written for.
For more information on the Perl 6 and Parrot development efforts, visit
<a href="http://dev.perl.org/perl6/">dev.perl.org</a> and
<a href="http://www.parrotcode.org/">parrotcode.org</a>.
</p>

<p>
There were 166 messages across 69 threads, with 38 authors contributing.
Again, most of the messages were patches.
<h3><a name="Apocalypse_4">Apocalypse 4</a></h3>


<p>

Larry Wall released 
<a href="/pub/a/2002/01/15/apo4.html">Apocalypse 4</a>, covering blocks (and scopes and statements).  It's quite weighty, particularly
up front, but here's a quick glossy on what's covered:
<ul>
<li>

<p>
the new
<code>given</code> /
<code>when</code> switch block
</li>
<li>exceptions
</li>
<li>scope changes
</li>
<li>no more required parentheses for expressions in block constructs
</li>
<li>a lot more flow-control blocks
</li>
<li>multiple iterators in looping blocks
</li></ul>
</p>

<p>
There are quite a few other tidbits inside.  The Apocalypse was released late
Thursday night, so little feedback, and no Damian Conway's Exegesis, have
been processed yet.  I'll pick up community reaction next week.
<h3><a name="Parrot_Strings">Parrot Strings</a></h3>

</p>

<p>

Jarkko Hietaniemi, the Perl 5.8.0 pumpking, 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07856.html">posted</a> a developing PDD on string handling in Parrot, largely based on his
experience providing Unicode support for Perl 5.  The main tenets of the
proposal are:
<ul><li></p>

<p>
separate binary data and its API from textual data and its API - at both the 
language and internals level
</li><li>convert all text - string constants, source code, input data - to the internal 
representation: UTF-16, or a
UCS-2 (non-surrogate) and UTF-16 (surrogate) hybrid
</li><li>handle localization as a separate layer
</li></ul></p>

<p>
Most of the following discussion centered around regular expression character
classes, and how to best implement them.  Brent Dax is currently using
UTF-32 within the regex engine, with a 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07859.html">hybrid </a> bitmap, binary lookup
scheme for character classes, similar to the way that Perl 5 does.  Jarkko
suggested using an
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07884.html">inversion list</a>.
</p>

<p>
This discussion is ongoing, so there'll be more to report next week with this, too.
<h3><a name="The_Parrot_Spotlight">The Parrot Spotlight</a></h3>

</p>

<p>

Most folks already have an 
<a href="http://dev.perl.org/perl6/people">inkling </a> of what Larry Wall, 
<a href="http://www.yetanother.org/damian/">Damian Conway</a>,
<a href="http://www.yetanother.org/dan/">Dan Sugalski</a>, and Simon Cozens have been doing for Perl 6 and Parrot, so we're going to
pad space with some brief introductions to some of the other Parrot Troopers
getting things done.
</p>

<p>
Daniel Grunblatt is a 21 year old university student in Argentina.  He's been
working in Perl for several years, but Parrot is his first time working on
Perl internals. He's the creator of Parrot's JIT compiler, and also plays
basketball and role-playing games.
<h3><a name="Parroty_Bits">Parroty Bits</a></h3>

</p>

<p>

The 
<a href="http://donate.perl-foundation.org">Perl Development Grant Fund </a> exceeded $80,000, thanks to sizable contributions from 
<a href="http://www.dyndns.org">DynDNS</a>,
<a href="http://pair.com">pair Networks</a>, and
<a href="http://www.usenix.org/sage/">SAGE</a>.
</p>

<hr>

<a href="http://members.home.com/bcwarno/Perl6/">Bryan C. Warnock</a>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1244" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/23/cgi.html" rel="bookmark">Finding CGI Scripts</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                <abbr class="published" title="2002-01-23T00:00:00-08:00">January 23, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <h3><a name="introduction">Introduction</a></h3>

<p>No matter how much we try to convince people that Perl is a multi-purpose
programming language, we'd be deluding ourselves if we didn't admit that
the majority of programmers first come into contact with Perl through their 
experience with CGI programs. People have a small Web site and one day they 
decide that they need a guest book, a form mail script or a hit counter. 
Because these people aren't programmers, they go out onto the Web to see 
what pre-written scripts they can find.</p>

<p>And there are plenty to choose from. Try searching on ``CGI scripts'' at
Google. I received about 2 million hits. The first two were those well-known
sites - Matt's Script Archive and the CGI Resource Index. Our Web site 
owner will visit one of these sites, find the required scripts and install
them on his site. What could be simpler? See, the Web <em>is</em> as easy as 
people make it out to be.</p>
<p>In this article, I'll take a closer look at this scenario and show that all
is not as rosy as I've portrayed it above.</p>

<h3><a name="cgi script quality">CGI Script Quality</a></h3>

<p>An important factor that Google takes into account when displaying search
results is the number of links to a given site. Google assumes that if there
are a large number of links to a given Web page, then it must be a well-known
page and that Google's visitors will want to visit that site first.</p>
<p>Notice that I said ``well-known'' in that previous paragraph. Not ``useful'' or
``valuable.'' Think about this for a second. The types of people that I
described in the introduction are not programmers. They certainly aren't
Perl programmers. Therefore, they are in no position to make value judgments
on the Perl code that they download from the Internet.</p>

<p>This means that the ``most popular'' site becomes a self-fulfilling prophecy.
The best known site is listed first on the search engines. More people
download scripts from that site, assuming that the most popular site must
have the highest quality scripts and that the popular sites end up becoming more
popular.</p>
<p>At no point does any kind of quality control enter into the process.</p>
<p>OK, so that's not strictly true. If the scripts from a particular site just 
didn't work at all, then word would soon get out and that site's scripts
would become unpopular. But what if the problems were more subtle and
didn't manifest themselves on all sites. Here is a list of some potential
problems:</p>


<ul>
<li>
Not checking the results of an <code>open</code> call. This will work fine if the
expected file exists and has the right permissions. But what happens when
the file doesn't exist? Or it exists but the CGI process doesn't have
permissions to read from it or write to it?
</li>
<li>
Bad CGI parameter parsing code. CGI parameter parsing is one of those things
that is easy to do badly and hard to do well. It's simple enough to write
a parser function that handles most cases, but does it handle both GET and
POST requests? What about keys with multiple associated values? And does it
process file uploads correctly?
</li>
<li>
Lack of security. Installing a CGI program allows anyone with an Internet 
connection to run a program on your server. That's quite a scary thing to
allow. You'd better be well aware of the security implications. Of course,
if people only ever run the script from your HTML form, then everything will
probably be fine, but a cracker won't do that. He'll fire ``interesting''
sets of parameters at your script in an attempt to find its weaknesses.
Suddenly a form mail script is being used to send copies of vital system
files to the cracker.
<p>It's also worth bearing in mind that because these scripts are available
on the Web, crackers can easily get the source code. They can then
work out any insecurities in the scripts and exploit them. Recently, a 
friend's Web site came under attack from crackers and amongst the traces
left in the access log were a large number of calls to well-known CGI
scripts.</p>
<p>For this reason, it is even more important that you are careful about
security when writing CGI scripts that are intended to be used by novice
Webmasters.</p></li>
</ul>
<p>The fact is, unfortunately, that these kinds of problems are commonplace in
the scripts that you can download from many popular CGI script archives.
That's not to say that the authors of these scripts are deliberately trying
to give crackers access to your servers. It's simply evidence that Perl
has moved on a great deal since the introduction of Perl 5 in 1994 and many
of the CGI script authors haven't kept their scripts up to date with 
current practices. In other cases, the authors know only too well how out
of date their scripts are and have produced newer, improved versions, but 
other people are still distributing the older versions.</p>


<h3><a name="setting a good example">Setting a Good Example</a></h3>
<p>Although the people who are downloading these scripts aren't usually
programmers, there often comes a time when they want to start changing the
way a program works and perhaps even writing their own CGI programs. When
this time comes, they will go to the scripts they already have for examples
of how to write them. If the original script contained bad programming 
practices, then these will be copied in the new scripts. This is the way
that many bad programming practices have become so common among Perl
scripts. I, therefore, think that it's a good idea for any publicly distributed
programs to follow best programming practices as much as possible.</p>


<h3><a name="script quality  a checklist">Script Quality - A Checklist</a></h3>
<p>So now we have an obvious problem. I said before that the people who are 
downloading and installing these scripts aren't qualified to make judgments
on the quality of the code. Given that there are some problematic scripts
out there, how are they supposed to know whether they should be using a 
particular script that they find on the Web?</p>
<p>It's a difficult question to answer, but there are some clues that you can
look for that give a idea of how well-written a script is. Here's a 
brief checklist:</p>
<ul>
<li>
<b>Does the script use <code>-w</code> and <code>use strict</code>?</b> The vast majority of Perl
experts recommend using these tools when writing Perl programs of any level
of complexity. They make any Perl program more robust. Anyone distributing
Perl programs without them probably doesn't know as much Perl as they think
they do.
</li>
<li>
<b>Does the script use Perl's taint mode?</b> Accepting external data from a Web
browser is a dangerous business. You can never be sure what you'll get. If
you add <code>-T</code> to a program's shebang line, then Perl goes into taint mode. In
this mode Perl distrusts any data that it gets from external sources. You
need to explicitly check this data before using it. Using <code>-T</code> is a sign
that the author is at least thinking about CGI security issues.
</li>
<li>
<b>Does the script use CGI.pm?</b> Since Perl 5.004, CGI.pm has been a part of the
standard Perl distribution. This module contains a number of functions for
handling various parts of the CGI protocol. The most important one is 
probably <code>param</code>, which deals with the parsing of the query string to extract
the CGI parameters. Many CGI scripts write their own CGI parameter parsing
routine that is missing features or has bugs. The one in CGI.pm has been
well-tested over many years in thousands of scripts - why attempt to 
reinvent it?
</li>
<li>
<b>How often is the script updated?</b> One reason for a script not to use CGI.pm
might be that it hasn't been updated since the module was added to the Perl
distribution. This is generally a bad sign. You should look for scripts that
are kept up to date. If there hasn't been been a new version of the script
for several years, then you should probably avoid it.
</li>
<li>
<b>How good is the support?</b>  Any program is of limited use if it's unsupported.
How do you get support for the program? Is there an e-mail address for the
author? Or is there a support mailing list? Try dropping an e-mail to either
the author or the mailing list and see how quickly you get a response.
</li></ul>
<p>Of course, these rules will have exceptions, but if a script scores badly
on most of them, then you might have second thoughts on whether you should
be using the script.</p>


<h3><a name="nms  a new cgi program archive"><em>nms</em> - A New CGI Program Archive</a></h3>
<p>Having spent most of this article being quite negative about existing CGI
program archives, let's now get a bit more positive. In the summer of 2001,
a group of London Perl Mongers started to wonder what would be involved in
writing a set of new CGI programs that could act as replacements for the ones
in common use. After some discussion, the <em>nms</em> project was born. The name 
<em>nms</em> originally stood for a disparaging remark about one of the existing 
archives, but we decided that we didn't want the kind of negativity in the
name. By that time, however, the abbreviated name was in common usage so we
decided to keep it - but it no longer stands for anything.</p>
<p>The objectives for <em>nms</em> were quite simple. We wanted to provide a set
of CGI programs which fulfilled the following:</p>
<ul>
<li>
As easy (or easier) to use as existing CGI scripts.
</li>
<li>
Use best programming practices
</li>
<li>
Secure
</li>
<li>
Bug-free (or, at least, well supported)
</li></ul>
<p>We decided that we would base our programs on the ones found in Matt's Script
Archive. This wasn't because Matt Wright's scripts were the worst out there,
but simply that they were the most commonly used. We made a rule that our
scripts would be drop-in replacements for Matt's scripts. That meant that
anyone who had existing data from using one of Matt's scripts would be able
to take our replacement and simply put it in place of the old script. This,
of course, meant that we had to become familiar with the inner workings
of Matt's scripts. This actually turned out not to be a hard as I expected.
The majority of Matt's scripts are simple. It's only really formmail,
guestbook and wwwboard that are complex.</p>
<p>Sometimes our objectives contradicted one anther. We decided early on, that
part of making the scripts as easy to use as possible meant not relying on 
any CPAN modules. We forced ourselves to only use only modules that came as
part of the standard Perl distribution. The reason for this is that our
target audience probably doesn't know anything about CPAN modules and wouldn't
find it easy to install them. A large part of our audience isprobably
operating a Web site on a hosted server where they may not be able to install
new modules and in many cases won't have telnet access to their server. We 
felt that asking them to install extra modules would make them far less likely
to use our programs. This, of course, goes against our objective of using
best programming practices as in many cases there is a CPAN module that
implements functionality that we use. The best example of this is in
formmail where we resort to sending e-mails by talking directly to <code>sendmail</code>
rather than using one of the e-mail modules. In these cases, we decided that
getting people to use the scripts (by not relying on CPAN) was more important
to us than following best practices.</p>
<p><em>nms</em> is a SourceForge project. You can get the latest released versions of 
the scripts from <a href="http://nms-cgi.sourceforge.net">http://nms-cgi.sourceforge.net</a> or, if you're
feeling braver, then you can get the leading edge versions from CVS at the 
project page at <a href="http://sourceforge.net/projects/nms-cgi/">http://sourceforge.net/projects/nms-cgi/</a>. Both
of those pages also have links to the <em>nms</em> mailing lists. We have two lists,
one for developers and one for support questions. There is also a FAQ that will hopefully answer any further questions that you have about the project.</p>
<p>Here is a list of the scripts available from <em>nms</em></p>
<ul>
<li>
<b>Countdown</b>  Count down the time to a certain date
</li>
<li>
<b>Free For All Links</b> A simple Web link database
</li>
<li>
<b>Formmail</b>  Send e-mails from Web forms
</li>
<li>
<b>Guestbook</b>  A simple guest book script
</li>
<li>
<b>Random Image</b>  Display a random image
</li>
<li>
<b>Random Links</b>  Display a link chosen randomly from a list
</li>
<li>
<b>Random Text</b>  Display a randomly chosen piece of text
</li>
<li>
<b>Simple Search</b>  Simple Web site search engine
</li>
<li>
<b>SSI Random Image</b>  Display a random image using SSI
</li>
<li>
<b>Text Clock</b>  Display the time
</li>
<li>
<b>Text Counter</b> Text counter
</li></ul>
<p>I should point out that this is very much a ``work in progress.'' While we're
happy with the way that they work, we can always use more people looking at
the code. The one advantage that Matt's scripts have over ours is that they've
had many years of testing on a large number of Web sites.</p>

<h3><a name="a plea for help">A Plea for Help</a></h3>
<p>So now we have a source of well-written CGI programs that we can point users
to. What more needs to be done? Well, the whole point of writing this article
was to ask more people to help. There's always more work to do :-)</p>
<ul>
<li>
<b>Peer review</b>. We think we've done a pretty good job on the scripts, but
we're not interested in resting on our laurels. The more people that look
at the scripts the more likely we'll catch bugs and insecurities.
Please download the scripts and take a look at them. Pass any bugs on to
the developers mailing.
</li>
<li>
<b>Testing</b>. We test the scripts on as many platforms with as many different
configurations as we can, but we'll always miss one or two. Please try to
install the scripts on your systems and let us know about any problems you have.
</li>
<li>
<b>Documentation</b>. Our documentation isn't any worse than the documentation
for the existing archives, but we think it could be much better. If you'd 
like to help out with this, then please get in touch with us.
</li>
<li>
<b>Advocacy</b>. This is the most important one. Please tell everyone that you
know about <em>nms</em>. Everywhere that you see people using other CGI scripts,
please explain to them the potential problems and show them where to get the
<em>nms</em> scripts. Having written these scripts, we feel it's important that
they get as wide exposure as possible. If you have any ideas for promoting
<em>nms</em>, then please let us know.
</li></ul>
<p>While I don't pretend for a minute that these are the only well-written and
secure CGI programs available, I do think that the Perl community needs a
well-known and trusted set of CGI programs that we can point people to. With
your help, that's what I want <em>nms</em> to become.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1250" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/p6pdigest/20020112.html" rel="bookmark">This Week on Perl 6 (6 - 12 Jan 2002)</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Bryan Warnock</span> on <abbr class="published" title="2002-01-17T00:00:00-08:00">January 17, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
      <H3><a name="Notes">Notes</a></H3>

</P>

<P>

You can subscribe to an email version of this summary by sending an empty
message to 
<a href="mailto:perl6-digest-subscribe@netthink.co.uk">perl6-digest-subscribe@netthink.co.uk</a>.
</P>

<P>
This summary, as with past summaries, can be found in
<a href="http://members.home.com/bcwarno/Perl6/digests/">here</a>.  (Note that this is an @Home address, and will change sometime in the
next two months.)  Please send additions, submissions, corrections, kudos, 
and complaints to 
<a href="mailto:bwarnock@capita.com">bwarnock@capita.com</a>.
</P>

<P>
For more information on the Perl 6 and Parrot development efforts, visit
<a href="http://dev.perl.org/perl6/">dev.perl.org</a> and
<a href="http://www.parrotcode.org/">parrotcode.org</a>.
</P>

<P>
There were 224 messages across 114 threads, with 39 authors contributing.
Most of the messages were patches.  
<H3><a name="Regexes">Regexes</a></H3>

</P>

<P>

Parrot now has 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07641.html">primitive regex support</a>, courtesy of Brent Dax.  It includes
a set of regex op primitives, including hooks for a 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07767.html">generic regex compiler</a>.  Currently, however, there's some 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07738.html">debate </a> over where
<CODE>match</CODE> should be implemented.
<H3><a name="Naming_Conventions">Naming Conventions</a></H3>

</P>

<P>

One of the larger threads discussed getting a handle on the
current naming convention.  Or, more accurately, the
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07696.html">lack of one</a>.  No consensus has been reached.
<H3><a name="Warnings">Warnings </a></H3>

</P>

<P>

The Parrot community received a well-deserved
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07756.html">slap on the wrist</a> from Parrot hacker Nicholas Clark.  A common complaint on checking out our
code is the incessant stream of warnings when compiling.  You're not alone.
<H3><a name="Parroty_Bits">Parroty Bits</a></H3>

</P>

<P>

Dan Sugalski 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07627.html">posted</a> some more random thoughts on Parrot's implementation direction.  He also
started on the new
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07729.html">memory allocator</a>, and modified 
<CODE>life.pasm</CODE> to be a new
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07703.html">benchmark</a>.  
</P>

<P>
David M. Lloyd fixed a some problems that exist when the size of an opcode is 
smaller than the configured size of an integer value.  (A perfectly legal scenario in Parrot.)
</P>

<P>
Simon Glover also did significant hacking on arrays and hashes.
</P>

<P>
The 
<a href="http://donate.perl-foundation.org">Perl Development Grant Fund </a> is holding steady at 26% (and change).
</P>

<hr>

<a href="http://members.home.com/bcwarno/Perl6/">Bryan C. Warnock</a>


<ul>
  <li><a href="#Notes">Notes</a>
  <li><a href="#Regexes">Regexes</a>
  <li><a href="#Naming_Conventions">Naming Conventions</a>
  <li><a href="#Warnings">Warnings </a>
  <li><a href="#Parroty_Bits">Parroty Bits</a>
</ul>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1242" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/15/apo4.html" rel="bookmark">Apocalypse 4</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Larry Wall</span> on <abbr class="published" title="2002-01-15T00:00:00-08:00">January 15, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            

<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

<table border="0" width="260" cellpadding="2" cellspacing="0" align="right">
<tr>
<td bgcolor="#6699cc"><font color="#ffffff"><b><span class="header"><center>
Table of Contents</center></span></b></font></td>
</tr>
<tr><td bgcolor="#efefef">
<b><span class="secondary">
	<li><a href="/pub/a/2002/01/15/apo4.html?page=2#accepted rfcs">Accepted RFCs</a></li></b>
	<ul>
<span class="smalltext">
		<li><a href="/pub/a/2002/01/15/apo4.html?page=2#rfc 022: control flow: builtin switch statement">RFC 022: Control flow: Builtin switch statement</a></li>
		<ul>

			<li><a href="/pub/a/2002/01/15/apo4.html?page=2#table 1: matching a switch value against a case value">Table 1: Matching a switch value against a case value</a></li>
		</ul>

		<li><a href="/pub/a/2002/01/15/apo4.html?page=3#rfc 088: omnibus structured exception/error handling mechanism">RFC 088: Omnibus Structured Exception/Error Handling Mechanism</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=6#rfc 199: shortcircuiting builtin functions and userdefined subroutines">RFC 199: Short-circuiting built-in functions and user-defined subroutines</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=6#rfc 006: lexical variables made default">RFC 006: Lexical variables made default</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=6#rfc 330: global dynamic variables should remain the default">RFC 330: Global dynamic variables should remain the default</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=6#rfc 083: make constants look like variables">RFC 083: Make constants look like variables</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=6#rfc 337: common attribute system to allow userdefined, extensible attributes">RFC 337: Common attribute system to allow user-defined, extensible attributes</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=7#rfc 173: allow multiple loop variables in foreach statements">RFC 173: Allow multiple loop variables in foreach statements</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=7#rfc 019: rename the local operator">RFC 019: Rename the local operator</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=7#rfc 064: new pragma 'scope' to change perl's default scoping">RFC 064: New pragma 'scope' to change Perl's default scoping</a></li>
	</ul>
</span>
<span class="secondary"><b>
	<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rejected rfcs">Rejected RFCs</a></li></b>
</span>
<span class="smalltext">
	<ul>

		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 089: controllable data typing">RFC 089: Controllable Data Typing</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 106: yet another lexical variable proposal: lexical variables made default">RFC 106: Yet another lexical variable proposal: lexical variables made default</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 119: object neutral error handling via exceptions">RFC 119: Object neutral error handling via exceptions</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 120: implicit counter in for statements, possibly $#.">RFC 120: Implicit counter in for statements, possibly $#.</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 262: index attribute">RFC 262: Index Attribute</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 167: simplify do block syntax">RFC 167: Simplify do BLOCK Syntax</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 209: fuller integer support in perl.">RFC 209: Fuller integer support in Perl.</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 279: my() syntax extensions and attribute declarations">RFC 279: <code>my()</code> syntax extensions and attribute declarations</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 297: attributes for compiler hints">RFC 297: Attributes for compiler hints</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 309: allow keywords in sub prototypes">RFC 309: Allow keywords in sub prototypes</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 340: with takes a context">RFC 340: with takes a context</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=8#rfc 342: pascallike with">RFC 342: Pascal-like "with"</a></li>
	</ul>
</span>
<span class="secondary"><b>
	<li><a href="/pub/a/2002/01/15/apo4.html?page=9#withdrawn rfcs">Withdrawn RFCs</a></li></b>
	</span>
	<span class="smalltext">
	<ul>

		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#rfc 063: exception handling syntax">RFC 063: Exception handling syntax</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#rfc 113: better constants and constant folding">RFC 113: Better constants and constant folding</a></li>
	</ul>
</span>
<span class="secondary"><b>
	<li><a href="/pub/a/2002/01/15/apo4.html?page=9#other decisions">Other decisions</a></li></b></span>
<span class="smalltext">
<ul>

		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#cstyle for loop">C-style for loop</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#cstyle do {} while expr no longer supported">C-style do {} while EXPR no longer supported</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#bare blocks">Bare blocks</a></li>
		<li><a href="/pub/a/2002/01/15/apo4.html?page=9#continue block">continue block</a></li>
	</ul>
</span>
</ul>
</td></tr>
<tr>
<td bgcolor="#6699cc">&nbsp;</td>
</tr>
</table>



<p>This Apocalypse is all about syntax in the large.  The corresponding
chapter in the Camel book is entitled "Statements and Declarations",
but it could just as easily have been entitled, "All About Blocks".
The basic underlying question is "What exactly do those curlies
mean?"</p>

<p>For Perl 5 and earlier, the answer to that question was, "Too
many things".  Or rather, too many things with inconsistent rules.
We'll continue to use curlies for much of what we've used them
for up till now, but by making a few critical simplifications,
the rules will be much more consistent.  In particular, built-ins
will parse with the same rules as user-defined constructs.
It should be possible to make user-extensible syntax look just like
built-in syntax.  Perl 5 started down this road, but didn't get all
the way there.  In Perl 6, all blocks operate under the same rules.
Effectively, every block is a kind of closure that can be run by
user-defined constructs as well as built-ins.</p>

<p>Associated with block structure are the various constructs that
make use of block structure.  Compound constructs like loops and
conditionals use blocks explicitly, whereas declarations refer to
their enclosing block implicitly.  This latter feature was also
inconsistently applied in Perl 5.  In Perl 6, the rule is simple:
A lexically scoped declaration is in effect from the declaration to
the end of its enclosing block.  Since blocks are delimited <em>only</em>
by curlies or by the ends of the current compilation unit (file or
string), that implies that we can't allow multi-block constructs in
which lexically scoped variables "leak" or "tunnel" from the end of
one block to the beginning of the next.  A right curly (without an
intervening left curly) absolutely stops the current lexical scope.
This has direct bearing on some of these RFCs.  For instance, RFC
88 proposes to let lexical scope leak from a <code>try</code> block into
its corresponding <code>finally</code> block.  This will not be allowed.
(We'll find a different way to solve that particular issue.)</p>

<p>While lexical declarations may not leak out of a block, control flow
must be able to leak out of blocks in a controlled fashion.  Obviously,
falling off the end of a block is the most "normal" way, but we need to
exit blocks in other "abnormal" ways as well.  Perl 5 has several
different ways of exiting a block: <code>return</code>, <code>next</code>, <code>last</code>,
<code>redo</code>, and <code>die</code>, for instance.  The problem is that these various
keywords are hard-wired to transfer control outward to a particular
built-in construct, such as a subroutine definition, a loop, or an
<code>eval</code>.  That works against our unifying concept that every block is a
closure.  In Perl 6, all these abnormal means of block exit are unified
under the concept of exceptions.  A <code>return</code> is a funny kind of
exception that is trapped by a <code>sub</code> block.  A <code>next</code> is an exception
that is trapped by a loop block.  And of course <code>die</code> creates a
"normal" exception that is trapped by any block that chooses to trap such
exceptions.  Perl 6 does not require that this block be an <code>eval</code> or
<code>try</code> block.</p>

<p>You may think that this generalization implies excessive overhead,
since generally exception handling must work its way up the call stack
looking for an appropriate handler.  But any control flow exception
can be optimized away to a "goto" internally when its target is
obvious and there are no user-defined blocks to be exited in between.
Most subroutine return and loop control operators will know which
subroutine or loop they're exiting from because it'll be obvious from
the surrounding lexical scope.  However, if the current subroutine
contains closures that are being interpreted elsewhere in user-defined
functions, it's good to have the general exception mechanism so that
all needed cleanup can be automatically accomplished and consistent
semantics maintained.  That is, we want user-defined closure handlers
to stay out of the user's face in the same way that built-ins do.
Control flow should pretend to work like the user expects, even when
it doesn't.</p>

<p>Here are the RFCs covered in this Apocalypse.  PSA stands for "problem,
solution, acceptance", my private rating of how this RFC will fit
into Perl 6.  Interestingly, this time I've rejected more RFCs than
I accepted.  I must be getting cruel and callous in my old age.  <code>:-)</code></p>
<pre>
    RFC   PSA    Title
    ---   ---    -----
    006   acc    Lexical variables made default
    019   baa    Rename the C&lt;local&gt; operator
    022   abc    Control flow: Builtin switch statement
    063   rr     Exception handling syntax
    064   bdc    New pragma 'scope' to change Perl's default scoping
    083   aab    Make constants look like variables
    088   bbc    Omnibus Structured Exception/Error Handling Mechanism
    089   cdr    Controllable Data Typing
    106   dbr    Yet another lexical variable proposal: lexical variables made default
    113   rr     Better constants and constant folding
    119   bcr    Object neutral error handling via exceptions
    120   bcr    Implicit counter in for statements, possibly $#   
    167   bcr    Simplify do BLOCK Syntax
    173   bcc    Allow multiple loop variables in foreach statements
    199   abb    Short-circuiting built-in functions and user-defined subroutines
    209   cdr    Fuller integer support in Perl   
    262   cdr    Index Attribute
    279   cdr    my() syntax extensions and attribute declarations
    297   dcr    Attributes for compiler hints
    309   adr    Allow keywords in sub prototypes
    330   acc    Global dynamic variables should remain the default
    337   bcc    Common attribute system to allow user-defined, extensible attributes
    340   dcr    with takes a context
    342   bcr    Pascal-like &quot;with&quot;</pre>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

	
<h3><a name="accepted rfcs">Accepted RFCs</a></h3>

<p>
<table width="150" border="0" cellspacing="0" cellpadding="4" align="right">
<tr> 
<td width="150" valign="top" height="4" bgcolor="#6699cc"></td></tr> 
<tr>
<td bgcolor="#efefef">
<p class="headline" align="center">Previous Apocalypses
</p>
<p class="smalltext">
&#149; <a href="/pub/a/2001/04/02/wall.html">Apocalypse One</a><br /><br />
&#149; <a href="/pub/a/2001/05/03/wall.html">Apocalypse Two</a><br /><br />
&#149; <a href="/pub/a/2001/10/02/apocalypse3.html">Apocalypse Three</a><br /><br />
</td></tr> <tr><td width="150" valign="top" height="4" bgcolor="#6699cc"> </td></tr></table>

<p>Note that, although these RFCs are in the "accepted" category, most
are accepted with major caveats (a "<code>c</code>" acceptance rating), or at
least some "buts" (a "<code>b</code>" rating).  I'll try to list all those caveats
here, but where there are systematic changes, I may indicate these
generally in this document without attempting to rewrite the RFC in
every detail.  Those who implement these features must be sensitive
to these systematic changes and not just uncritically implement
everything the RFC says.</p>
<p>I'd like to talk about exceptions first, but before that I have to
deal with the switch statement, because I think it's silly not to
unify exception handlers with switch statements.</p>

<h3><a href="http://dev.perl.org/rfc/22.html" name="rfc 022: control flow: builtin switch statement">RFC 022: Control flow: Builtin switch statement</a></h3>
<p>Some OO purists say that any time you want to use a switch statement,
you ought to make the discriminant of the switch statement into
a type, and use method dispatch instead.  Fortunately, we are not OO
purists here, so forget that argument.</p>

<p>Another argument against having a switch statement in Perl 6 is that
we never had it in the first five versions of Perl.  But it would be
incorrect to say that we didn't miss it.  What actually happened was
that every time we started discussing how to add a switch statement,
it wasn't obvious how far to go.  A switch statement in Perl ought
to do more than a switch statement in C (or in most any other
language, for that matter).  So the fact that we haven't added a
switch statement so far says more about how hard it is to design a
good one than about how much we wanted a lousy one.  Eventually the
ever inventive Damian Conway came up with his famous design, with a Perl
5 module as proof of concept, and pretty much everyone agreed that he
was on the right track, for some definition of "right" (and "track").
This RFC is essentially that design (not surprisingly, since Damian
wrote it), so it will be accepted, albeit with several tweaks.</p>
<p>In the first place, as a quasi-linguist, I loathe the keywords <code>switch</code>
and <code>case</code>.  I would prefer keywords that read better in English.
Much as I love verbing nouns, they don't work as well as real verbs or
real prepositions when topicalizers are called for.  After thrashing
over several options with Damian and other folks, we've settled on
using <code>given</code> instead of <code>switch</code>, and <code>when</code> instead of <code>case</code>:</p>
<pre>
    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        ...
    }</pre>
<p>The other great advantage of using different words is that people won't
expect it to work exactly like any other switch statement they may
be familiar with.</p>

<p>That being said, I should point out that it is still called "the switch
statement", and the individual components are still "cases".  But you
don't have to put "switch" or "case" into constant-width font, because
they're not keywords.</p>

<p>Because curlies are so extremely overloaded in Perl 5, I was at
first convinced that we would need a separator of some sort between
the expression and the block, maybe a <code>:</code> or <code>=</code><code></code>&gt; or some such.
Otherwise it would be too ambigous to come upon a left curly when
expecting an operator--it would be interpreted as a hash subscript
instead.  Damian's RFC proposes to require parentheses in certain
situations to disambiguate the expression.</p>

<p>But I've come to the conclusion that I'd rather screw around (a
little) with the "insignificant whitespace" rule than to require
an extra unnatural delimiter.  If we observe current practice,
we note that 99% of the time, when people write a hash subscript
they do so without any whitespace before it.  And 99% of the time,
when they write a block, they do put some whitespace in front of it.
So we'll just dwim it using the whitespace.  (No, we're not going
all the way to whole-hog whitespace dwimmery--Python will remain the
best/worst example of that approach.)</p>



<p>Subscripts are the only valid use of curlies when an operator is
expected.  (That is, subscripts are essentially postfix operators.) In
contrast, hash composers and blocks are terms, not operators.
Therefore, we will make the rule that a left curly that has whitespace
in front of it will never be interpreted as a subscript in Perl 6.
(If you think this is totally bizarre thing to do, consider that this
new approach is actually consistent with how Perl 5 already parses
variables within interpolated strings.)  If there is any space before
the curly, we force it to start a term, not an operator, which means
that the curlies in question must delimit either a hash composer or
a block.  And it's a hash composer only if it contains a <code>=</code><code></code>&gt;
pair constructor at the top level (or an explicit <code>hash</code> keyword on
the front.)  Therefore it's possible to unambiguously terminate an
expression by following it with a block, as in the constructs above.</p>
<p>Interestingly, this one tweak to the whitespace rule also means
that we'll be able to simplify the parentheses out of other similar
built-in constructs:</p>
<pre>
    if $foo { ... }
    elsif $bar { ... }
    else { ... }</pre>
<pre>
    while $more { ... }</pre>
<pre>
    for 1..10 { ... }</pre>
<p>I think throwing out two required punctuation characters for one
required whitespace is an excellent trade in terms of readability,
particularly when it already matches common practice.  (You can still
put in the parens if you want them, of course, just for old times'
sake.)  This tweak also allows greater flexibility in how user-defined
constructs are parsed.  If you want to define your own constructs,
they should be able to follow the same syntax rules as built-ins.</p>

<p>By a similar chain of logic (or illogic), I also want to tweak
the whitespace rules for the trailing curly.  There are severe
problems in any C-derived language that allows user-defined constructs
containing curlies (as Perl does).  Even C doesn't entirely escape the
head-scratching puzzle of "When do I put a semicolon after a curly?"
A <code>struct</code> definition requires a terminating semicolon, for instance,
while an <code>if</code> or a <code>while</code> doesn't.</p>

<p>In Perl, this problem comes up most often when people say "Why do I
have to put a semicolon after <code>do {}</code> or <code>eval {}</code> when it looks
like a complete statement?"</p>

<p>Well, in Perl 6, you don't, if the final curly is on a line by itself.
That is, if you use an expression block as if it were a statement
block, it behaves as one. The win is that these rules are
consistent across all expression blocks, whether user-defined or
built-in.  Any expression block construct can be treated as either a
statement or a component of an expression.  Here's a block that is
being treated as a term in an expression:</p>
<pre>
    $x = do {
        ...
    } + 1;</pre>
<p>However, if you write</p>
<pre>
    $x = do {
        ...
    }
    + 1;</pre>
<p>then the + will be taken erroneously as the start of a new statement.
(So don't do that.)</p>
<p>Note that this special rule only applies to constructs that take a
block (that is, a closure) as their last (or only) argument.  Operators
like <code>sort</code> and <code>map</code> are unaffected.  However, certain constructs
that used to be in the statement class may become expression constructs in
Perl 6.  For instance, if we change <code>BEGIN</code> to an expression construct
we can now use a <code>BEGIN</code> block inside an expression to force
compile-time evaluation of a non-static expression:</p>
<pre>
    $value = BEGIN { call_me_once() } + call_me_again();</pre>
<p>On the other hand, a one-line <code>BEGIN</code> would then have to have a semicolon.</p>
<p>Anyway, back to switch statements.  Damian's RFC proposes various
specific kinds of dwimmery, and while some of those dwims are spot on,
others may need adjustment.  In particular, there is an assumption that
the programmer will know when they're dealing with an object reference
and when they're not.  But everything will be an object reference in
Perl 6, at some level or other.  The underlying characteristics of any
object are most generally determined by the answer to the question,
"What methods does this object respond to?"</p>

<p>Unfortunately, that's a run-time question in general.  But in specific,
we'd like to be able to optimize many of these switch statements at
compile time.  So it may be necessary to supply typological hints in
some cases to do the dwimmery efficiently.  Fortunately, most cases
are still fairly straightforward.  A <code>1</code> is obviously a number,
and a <code>&quot;foo&quot;</code> is obviously a string.  But unary <code>+</code> can force
anything to a number, and unary <code>_</code> can force anything to a string.
Unary <code>?</code> can force a boolean, and unary <code>.</code> can force a method call.
More complicated thoughts can be represented with closure blocks.</p>

<p>Another thing that needs adjustment is that the concept of "isa"
matching seems to be missing, or at least difficult to express.  We
need good "isa" matching to implement good exception handling in terms
of the switch mechanism.  This means that we need to be able to say
something like:</p>
<pre>
    given $! {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }</pre>
<p>and expect it to check <code>$!.isa(Error::Overflow)</code> and such, along with
more normal pattern matching.  In the case of the actual exception
mechanism, we won't use the keyword <code>given</code>, but rather <code>CATCH</code>:</p>
<pre>
    CATCH {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }</pre>
<p><code>CATCH</code> is a <code>BEGIN</code>-like block that can turn any block into a
"try" block from the inside out.  But the insides of the <code>CATCH</code> are
an ordinary switch statement, where the discriminant is simply the
current exception object, <code>$!</code>.  More on that later--see RFC 88
below.</p>
<p>Some of you may recall that I've stated that Perl 6 will have no
barewords.  That's still the case.  A token like <code>Error::Overflow</code>
is not a bareword because it's a declared class.  Perl 6 recognizes
package names as symbolic tokens.  So when you call a class method as
<code>Class::Name.method()</code>, the <code>Class::Name</code> is actually a class object
(that just happens to stringify to "<code>Class::Name</code>").  But the class
method can be called without a symbolic lookup on the package name
at run time, unlike in Perl 5.</p>
<p>Since <code>Error::Overflow</code> is just such a class object, it can be
distinguished from other kinds of objects in a switch statement,
and an "isa" can be inferred.  It would be nice if we could go as
far as to say that any object can be called with any class name as
a method name to determine whether it "isa" member of that class,
but that could interfere with use of class name methods to implement
casting or construction.  So instead, since switch statements are
into heavy dwimmery anyway, I think the switch statement will have
to recognize any <code>Class::Name</code> known at compile time, and force it
to call <code>$!.isa(Class::Name)</code>.</p>
<p>Another possible adjustment will involve the use of switch statements
as a means of parallelizing regular expression evaluation.  Specifically,
we want to be able to write parsers easily in Perl, which means that
we need some way of matching a token stream against something like
a set of regular expressions.  You can think of a token stream as a
funny kind of string.  So if the "given" of a switch statement is a
token stream, the regular expressions matched against it may have
special abilities relating to the current parse's data structure.
All the regular expressions of such a switch statement will likely
be implicitly anchored to the current parse location, for instance.
There may be special tokens referring to terminals and non-terminals.
Basically, think of something like a yacc grammar, where alternative
pattern/action grammar rules are most naturally expressed via switch
statement cases.  More on that in the next Apocalypse.</p>
<p>Another possible adjustment is that the proposed <code>else</code> block could be
considered unnecessary.  The code following the final <code>when</code> is
automatically an "else".  Here's a duodecimal digit converter:</p>
<pre>
    $result = given $digit {
        when &quot;T&quot; { 10 }
        when &quot;E&quot; { 11 }
        $digit;
    }</pre>
<p>Nevertheless, it's probably good documentation to line up all the
blocks, which means it would be good to have a keyword.  However, for
reasons that will become clearer when we talk about exception handlers,
I don't want to use <code>else</code>.  Also, because of the identification of
<code>when</code> and <code>if</code>, it would not be clear whether an <code>else</code> should
automatically supply a <code>break</code> at the end of its block as the ordinary
<code>when</code> case does.</p>
<p>So instead of <code>else</code>, I'd like to borrow a bit more from C and
use <code>default</code>:</p>
<pre>
    $result = given $digit {
        when &quot;T&quot; { 10 }
        when &quot;E&quot; { 11 }
        default  { $digit }
    }</pre>
<p>Unlike in C, the <code>default</code> case must come last, since Perl's cases
are evaluated (or at least pretend to be evaluated) in order.  The
optimizer can often determine which cases can be jumped to directly,
but in cases where that can't be determined, the cases are evaluated in
order much like cascaded <code>if</code>/<code>elsif</code>/<code>else</code> conditions.  Also, it's
allowed to intersperse ordinary code between the cases, in which case
the code must be executed only if the cases above it fail to match.
For example, this should work as indicated by the print statements:</p>
<pre>
    given $given {
        print &quot;about to check $first&quot;;
        when $first { ... }
        print &quot;didn't match $first; let's try $next&quot;;
        when $next { ... }
        print &quot;giving up&quot;;
        default { ... }
        die &quot;panic: shouldn't see this&quot;;
    }</pre>
<p>We can still define <code>when</code> as a variant of <code>if</code>, which makes it
possible to intermix the two constructs when (or if) that is
desirable.  So we'll leave that identity in--it always helps people
think about it when you can define a less familiar construct in terms
of a more familiar one.  However, the <code>default</code> isn't quite the same
as an <code>else</code>, since <code>else</code> can't stand on its own.  A <code>default</code> is
more like an <code>if</code> that's always true.  So the above code is equivalent
to:</p>
<pre>
    given $given {
        print &quot;about to check $first&quot;;
        if $given =~ $first { ...; break }
        print &quot;didn't match $first; let's try $next&quot;;
        if $given =~ $next { ...; break }
        print &quot;giving up&quot;;
        if 1 { ...; break; }
        die &quot;panic: shouldn't see this&quot;;
    }</pre>
<p>We do need to rewrite the relationship table in the RFC to handle some
of the tweaks and simplifications we've mentioned.  The comparison of
bare refs goes away.  It wasn't terribly useful in the first place,
since it only worked for scalar refs.   (To match identities we'll
need an explicit <code>.id</code> method in any event.  We won't be relying on the
default numify or stringify methods to produce unique representations.)</p>
<p>I've rearranged the table to be applied in order, so that default
interpretations come later.  Also, the "Matching Code" column in the
RFC gave alternatives that aren't resolved.  In these cases I've chosen
the "true" definition rather than the "exists" or "defined"
definition.  (Except for certain set manipulations with hashes, people
really shouldn't be using the defined/undefined distinction to
represent true and false, since both true and false are considered
defined concepts in Perl.)</p>
<p>Some of the table entries distinguish an array from a list.  Arrays
look like this:</p>
<pre>
    when [1, 3, 5, 7, 9] { &quot;odd digit intersection&quot; }
    when @array          { &quot;array intersection&quot; }</pre>
<p>while a list looks like this:</p>
<pre>
    when 1, 3, 5, 7, 9    { &quot;odd digit&quot; }
    when @foo, @bar, @baz { &quot;intersection with at least one array&quot; }</pre>
<p>Ordinarily lists and arrays would mean the same thing in scalar
context, but <code>when</code> is special in differentiating explicit arrays
from lists.  Within a <code>when</code>, a list is a recursive disjunction.
That is, the comma-separated values are treated as individual cases
OR-ed together.  We could use some other explicit notation for
disjunction such as:</p>
<pre>
    when any(1, 3, 5, 7, 9) { &quot;odd&quot; }</pre>
<p>But that seems a lot of trouble for a very common case of case, as it
were.  We could use vertical bars as some languages do, but I think the
comma reads better.</p>
<p>Anyway, here's another simplification.  The following table will
<em>also</em> define how the Perl 6 <code>=~</code> operator works!  That allows us
to use a recursive definition to handle matching against a disjunctive
list of cases.  (See the first entry in the table below.)  Of course,
for precedence reasons, to match a list of things using <code>=~</code> you'll
have to use parens:</p>
<pre>
    $digit =~ (1, 3, 5, 7, 9) and print &quot;That's odd!&quot;;</pre>
<p>Alternatively, you can look at this table as the definition of the
<code>=~</code> operator, and then say that the switch statement is defined in
terms of <code>=~</code>.  That is, for any switch statement of the form</p>
<pre>
    given EXPR1 {
        when EXPR2 { ... }
    }</pre>
<p>it's equivalent to saying this:</p>
<pre>
    for (scalar(EXPR1)) {
        if ($_ =~ (EXPR2)) { ... }
    }</pre>
<p>
<h4><a name="table 1: matching a switch value against a case value">Table 1: Matching a switch value against a case value</a></h4>
<pre>
    $a      $b        Type of Match Implied    Matching Code
    ======  =====     =====================    =============</pre>
<pre>
    expr    list      recursive disjunction    match if $a =~ any($b)
    list    list      recursive disjunction*   match if any($a) =~ any($b)</pre>
<pre>
    hash    sub(%)    hash sub truth           match if $b(%$a)
    array   sub(@)    array sub truth          match if $b(@$a)
    expr    sub($)    scalar sub truth         match if $b($a)
    expr    sub()     simple closure truth*    match if $b()</pre>
<pre>
    hash    hash      hash key intersection*   match if grep exists $a{$_}, $b.keys
    hash    array     hash value slice truth   match if grep {$a{$_}} @$b
    hash    regex     hash key grep            match if grep /$b/, keys %$a
    hash    scalar    hash entry truth         match if $a{$b}</pre>
<pre>
    array   array     array intersection*      match if any(@$a) =~ any(@$b)
    array   regex     array grep               match if grep /$b/, @$a
    array   number    array entry truth        match if $a[$b]
    array   expr      array as list            match if any($a) =~ $b</pre>
<pre>
    object  class     class membership         match if $a.isa($b)
    object  method    method truth             match if $a.$b()</pre>
<pre>
    expr    regex     pattern match            match if $a =~ /$b/
    expr    subst     substitution match       match if $a =~ subst
    expr    number    numeric equality         match if $a == $b
    expr    string    string equality          match if $a eq $b
    expr    boolean   simple expression truth* match if $b
    expr    undef     undefined                match unless defined $a</pre>
<pre>
    expr    expr      run-time guessing        match if ($a =~ $b) at runtime</pre>
<p>In order to facilitate optimizations, these distinctions are made
syntactically at compile time whenever possible.  For each comparison,
the reverse comparison is also implied, so <code>$a</code>/<code>$b</code> can be thought
of as either given/when or when/given.  (We don't reverse the matches
marked with * are because it doesn't make sense in those casees.)</p>
<p>If type of match cannot be determined at compile time, the default is
to try to apply the very same rules in the very same order at run time,
using the actual types of the arguments, not their compile-time type
appearance.  Note that there are no run-time types corresponding to
"method" or "boolean".  Either of those notions can be expressed at
runtime as a closure, of course.</p>
<p>In fact, whenever the default behavior is not what you intend, there
are ways to force the arguments to be treated as you intend:</p>
<pre>
    Intent      Natural           Forced
    ======      =======           ======
    array       @foo              [list] or @{expr}
    hash        %bar              {pairlist} or %{expr}
    sub(%)      { %^foo.aaa }     sub (%foo) { ... }
    sub(@)      { @^bar.bbb }     sub (@bar) { ... }
    sub($)      { $^baz.ccc }     sub ($baz) { ... }
    number      numeric literal   +expr int(expr) num(expr)
    string      string literal    _expr str(expr)
    regex       //, m//, qr//     /$(expr)/
    method      .foo(args)        { $_.$method(args) }
    boolean     $a == $b          ?expr or true expr or { expr }</pre>
<p>A method must be written with a unary dot to distinguish it from other
forms.  The method may have arguments.  In essence, when you write</p>
<pre>
    .foo(1,2,3)</pre>
<p>it is treated as if you wrote</p>
<pre>
    { $_.foo(1,2,3) }</pre>
<p>and then the closure is evaluated for its truth.</p>
<p>A class match works only if the class name is known at compile time.
Use <code>.isa(&quot;Class&quot;)</code> for more complicated situations.</p>
<p>Boolean expressions are recognized at compile time by the presence of a
top-level operator that is a comparison or logical operator.  As the
table shows, an argumentless closure (a <code>sub ()</code>, that is) also functions
as a boolean.  However, it's probably better documentation to use
the <code>true</code> function, which does the opposite of <code>not</code>.  (Or the unary <code>?</code>
operator, which does the opposite of unary <code>!</code>.)</p>
<p>It might be argued that boolean expressions have no place here at all,
and that you should use <code>if</code> if that's what you mean.  (Or use a
<code>sub()</code> closure to force it to ignore the given.)  However, the "comb"
structure of a switch is an extremely readable way to write even
ordinary boolean expressions, and rather than forcing people to write:</p>
<pre>
    anyblock {
        when { $a == 1 } { ... }
        when { $b == 2 } { ... }
        when { $c == 3 } { ... }
        default          { ... }
    }</pre>
<p>I'd rather they be able to write:</p>
<pre>
    anyblock {
        when $a == 1 { ... }
        when $b == 2 { ... }
        when $c == 3 { ... }
        default      { ... }
    }</pre>
<p>This also fits better into the use of "when" within <code>CATCH</code> blocks:</p>
<pre>
    CATCH {
        when $!.tag eq &quot;foo&quot; { ... }
        when $!.tag eq &quot;bar&quot; { ... }
        default              { die }
    }</pre>
<p>To force all the <code>when</code> clauses to be interpreted as booleans without
using a boolean operator on every case, simply provide an empty given,
to be read as "given nothing...":</p>
<pre>
    given () {
        when $a.isa(Ant) { ... }
        when $b.isa(Bat) { ... }
        when $c.isa(Cat) { ... }
        default          { ... }
    }</pre>
<p>A <code>when</code> can be used by other topicalizers than just <code>given</code>.
Just as <code>CATCH</code> will imply a given of <code>$!</code>, a <code>for</code> loop (the <code>foreach</code>
variety) will also imply a given of the loop variable:</p>
<pre>
    for @foo {
        when 1   { ... }
        when 2   { ... }
        when &quot;x&quot; { ... }
        default  { ... }
    }</pre>
<p>By symmetry, a <code>given</code> will by default alias <code>$_</code> to the "given".
Basically, the only difference between a <code>given</code> and a <code>for</code> is
that a <code>given</code> takes a scalar expression, while a <code>for</code> takes a
pre-flattened list and iterates over it.</p>
<p>Suppose you want to preserve <code>$_</code> and alias <code>$g</code> to the value
instead.  You can say that like this:</p>
<pre>
    given $value -&gt; $g {
        when 1 { /foo/ }
        when 2 { /bar/ }
        when 3 { /baz/ }
    }</pre>
<p>In the same way, a loop's values can be aliased to one or more
loop variables.</p>
<pre>
    for @foo -&gt; $a, $b {  # two at a time
        ...
    }</pre>
<p>That works a lot like the definition of a subroutine call with two
formal parameters, <code>$a</code> and <code>$b</code>.  (In fact, that's precisely what
it is.)  You can use modifiers on the formal paramaters just as you
would in a subroutine type signature.  This implies that the aliases
are automatically declared as <code>my</code> variables.  It also implies
that you can modify the formal parameter with an <code>rw</code> property,
which allows you to modify the original elements of the array through
the variable.  The default loop:</p>
<pre>
    for @foo { ... }</pre>
<p>is really compiled down to this:</p>
<pre>
    for @foo -&gt; $_ is rw { ... }</pre>
<p>Since <code>for</code> and <code>given</code> work by passing arguments to a closure,
it's a small step to generalize that in the other direction.
Any method definition is a topicalizer within the body of the method,
and will assume a "given" of its <code>$self</code> object (or whatever you
have named it).  Bare closures topicalize their first argument,
implicitly aliasing it to <code>$_</code> unless <code>$^a</code> or some such is used.
That is, if you say this:</p>
<pre>
    grep { $_ eq 3 } @list</pre>
<p>it's equivalent to this more explicit use of a curried function:</p>
<pre>
    grep { $^a eq 3 } @list</pre>
<p>But even a <code>grep</code> can use the aliasing syntax above:</p>
<pre>
    grep -&gt; $x { $x eq 3 } @list</pre>
<p>Outside the scope of any topicalizer, a <code>when</code> will assume that
its given was stored in <code>$_</code> and will test implicitly against
that variable.  This allows you to use <code>when</code> in your main loop,
for instance, even if that main loop was supplied by Perl's <code>-n</code>
or <code>-p</code> switch.  Whenever a loop is functioning as a switch,
the break implied by finishing a case functions as a <code>next</code>, not
a <code>last</code>.  Use <code>last</code> if that's what you mean.</p>
<p>A <code>when</code> is the only defaulting construct that pays attention to the
current topicalizer regardless of which variable it is associated
with.  All other defaulting constructs pay attention to a fixed
variable, typically <code>$_</code>.  So be careful what you're matching against
if the given is aliased to something other than <code>$_</code>:</p>
<pre>
    $_ = &quot;foo&quot;;
    given &quot;bar&quot; -&gt; $f {
        if /foo/   { ... } # true, matches against $_
        when /bar/ { ... } # true, matches against $f
    }</pre>
<p>Oh, one other tweak.  The RFC proposes to overload <code>next</code> to mean
"fall through to the next case".  I don't think this is wise, since
we'll often want to use loop controls within a switch statement.
Instead, I think we should use <code>skip</code> to do that.  (To be read as
"Skip to the next statement.")</p>
<p>Similarly, if we make a word to mean to explicitly break out of a
topicalizer, it should not be <code>last</code>.  I'd suggest <code>break</code>!  It will,
of course, be unnecessary to break out of the end of a <code>when</code> case
because the <code>break</code> is implied.  However, there are times when you
might want to break out of a <code>when</code> block early.  Also, since we're
allowing <code>when</code> modifiers that do not implicitly break, we could use
an explicit break for that situation.  You might see cases like this:</p>
<pre>
    given $x {
        warn(&quot;Odd value&quot;)        when !/xxx/;
        warn(&quot;No value&quot;), break  when undef;</pre>
<pre>
        when /aaa/ { break when 1; ... }
        when /bbb/ { break when 2; ... }
        when /ccc/ { break when 3; ... }
    }</pre>
<p>So it looks to me like we need a break.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>


<h3><a href="http://dev.perl.org/rfc/88.html" name="rfc 088: omnibus structured exception/error handling mechanism">RFC 088: Omnibus Structured Exception/Error Handling Mechanism</a></h3>
<p>This RFC posits some requirements for exception handling (all of which I
agree with), but I do have some additional requirements of my own:</p>

<p>

<ul>
<li>
The exception-catching syntax must be considered a form of switch
statement.
</li>
<li>
It should be easy to turn any kind of block into a "try" block,
especially a subroutine.
</li>
<li>
Even <code>try</code>-less try blocks must also be able to specify mandatory
cleanup on exit.
</li>
<li>
It should be relatively easy to determine how much cleanup is necessary
regardless of how a block was exited.
</li>
<li>
It must be possible to base the operation of <code>return</code>, <code>next</code>, and
<code>last</code> on exception handling.
</li>
<li>
The cleanup mechanism should mesh nicely with the notions of post
condition processing under design-by-contract.
</li>
<li>
The exception-trapping syntax must not violate encapsulation of lexical
scopes.
</li>
<li>
At the same time, the exception-trapping syntax should not force
declarations out of their natural scope.
</li>
<li>
Non-linear control flow must stand out visually, making good use of
block structure, indentation and even keyword case.  <code>BEGIN</code> and <code>END</code>
blocks are to be considered prior art.
</li>
<li>
Non-yet-thrown exceptions must be a useful concept.
</li>
<li>
Compatibility with the syntax of any other language is specifically NOT
a goal.
</li></ul>

<p>RFC 88 is massive, weighing in at more than 2400 lines.  Annotating the
entire RFC would make this Apocalypse far too big.  ("Too late!" says
Damian.)  Nonetheless, I will take the approach of quoting various
bits of the RFC and recasting those bits to work with my additional
requirements.  Hopefully this will convey my tweaks most succinctly.</p>
<p>Here's what the RFC gives as its first example:</p>
<pre>
    exception 'Alarm';</pre>
<pre>
    try {
        throw Alarm &quot;a message&quot;, tag =&gt; &quot;ABC.1234&quot;, ... ;
        }

    catch Alarm =&gt; { ... }

    catch Error::DB, Error::IO =&gt; { ... }

    catch $@ =~ /divide by 0/ =&gt; { ... }

    catch { ... }

    finally { ... }</pre>
<p>Here's how I see that being written in Perl 6:</p>
<pre>
    my class X::Alarm is Exception { }     # inner class syntax?</pre>
<pre>
    try {
        throw X::Alarm &quot;a message&quot;, tag =&gt; &quot;ABC.1234&quot;, ... ;</pre>
<pre>
        CATCH {
            when X::Alarm             { ... }
            when Error::DB, Error::IO { ... }
            when /divide by 0/        { ... }
            default                   { ... }
        }
        POST { ... }
    }</pre>
<p>The outer block does not have to be a <code>try</code> block.  It could be a
subroutine, a loop, or any other kind of block, including an <code>eval</code>
string or an entire file.  We will call such an outer block a try
block, whether or not there is an explicit <code>try</code> keyword.</p>
<p>The biggest change is that the various handlers are moved inside
of the try block.  In fact, the <code>try</code> keyword itself is mere
documentation in our example, since the presence of a <code>CATCH</code> or <code>POST</code> block
is sufficient to signal the need for trapping.  Note that the <code>POST</code>
block is completely independent of the <code>CATCH</code> block.  (The <code>POST</code> block
has a corresponding <code>PRE</code> block for design-by-contract programmers.)  Any
of these blocks may be placed anywhere in the surrounding block--they
are independent of the surrounding control flow.  (They do have to
follow any declarations they refer to, of course.)  Only one <code>CATCH</code> is
allowed, but any number of <code>PRE</code> and <code>POST</code> blocks.  (In fact, we may well
encourage ourselves to place <code>POST</code> blocks near the constructors to be
cleaned up after.)  <code>PRE</code> blocks within a particular try block are
evaluated in order before anything else in the block.  <code>POST</code> blocks will
be evaluated in reverse order, though order dependencies between <code>POST</code>
blocks are discouraged.  <code>POST</code> blocks are evaluated after everything
else in the block, including any <code>CATCH</code>.</p>
<p>A <code>try {}</code> without a <code>CATCH</code> is equivalent to Perl 5's <code>eval {}</code>.
(In fact, <code>eval</code> will go back to evaluating only strings in Perl 6, and
<code>try</code> will evaluate only blocks.)</p>
<p>The <code>CATCH</code> and <code>POST</code> blocks are naturally in the lexical scope of
the try block.  They may safely refer to lexically scoped variables
declared earlier in the try block, even if the exception is thrown
during the elaboration sequence.  (The run-time system will guarantee
that individual variables test as undefined (and hence false) before
they are elaborated.)</p>
<p>The inside of the <code>CATCH</code> block is precisely the syntax of a switch
statement.  The discriminant of the switch statement is the exception
object, <code>$!</code>.  Since the exception object stringifies to the error
message, the <code>when /divide by 0/</code> case need not be explicitly
compared against <code>$!</code>.  Likewise, explicit mention of a declared
class implies an "isa" lookup, another built-in feature of the new
switch statement.</p>
<p>In fact, a <code>CATCH</code> of the form:</p>
<pre>
    CATCH { 
        when xxx { ... }          # 1st case
        when yyy { ... }          # 2nd case
        ...                       # other cases, maybe a default
    }</pre>
<pre>
 means something vaguely like:</pre>
<pre>
    BEGIN {
        %MY.catcher = {
            given current_exception() -&gt; $! {</pre>
<pre>
                when xxx { ... }          # 1st case from above
                when yyy { ... }          # 2nd case from above
                ...                       # other cases, maybe a default</pre>
<pre>
                die;            # rethrow $! as implicit default
            }
            $!.markclean;       # handled cleanly, in theory
        }
    }</pre>
<p>The unified "current exception" is <code>$!</code>.  Everywhere this RFC uses
<code>$@</code>, it should be read as <code>$!</code> instead.  (And the too-precious <code>@@</code>
goes away entirely in favor of an array stored internally to the <code>$!</code>
object that can be accessed as <code>@$!</code> or <code>$![-1]</code>.)  (For the legacy
Perl 5 parser, <code>$@</code> and <code>$?</code> will be emulated, but that will
not be available to the Perl 6 parser.)</p>
<p>Also note that the <code>CATCH</code> block implicitly supplies a rethrow (the
<code>die</code> above) after the cases of the switch statement.  This will not
be reached if the user has supplied an explicit <code>default</code> case, since
the <code>break</code> of that default case will always bypass the implicit
<code>die</code>.  And if the switch rethrows the exception (either explicitly or
implicitly), <code>$!</code> is not marked as clean, since the <code>die</code> will bypass
the code that marks the exception as "cleanly caught".  It should be
considered an invariant that any <code>$!</code> in the normal control flow outside
of a <code>CATCH</code> is considered "cleanly caught", according to the definition
in the RFC.  Unclean exceptions should only be seen inside <code>CATCH</code>
blocks, or inside any <code>POST</code> blocks that have to execute while an
exception is propagating to an outer block because the current try
block didn't handle it.  (If the current try block does successfully
handle the exception in its <code>CATCH</code>, any <code>POST</code> blocks at the same level
see a <code>$!</code> that is already marked clean.)</p>
<p>RFC:</p>
<dl>
<dt><dd>
<code>eval {die &quot;Can't foo.&quot;}; print $@;</code> <em>continues to work as before.</em>
<p></p></dl>
<p>That will instead look like</p>
<pre>
    try { die &quot;Can't foo&quot; }; print $!;</pre>
<p>in Perl 6.  A <code>try</code> with no <code>CATCH</code>:</p>
<pre>
    try { ... }</pre>
<p>is equivalent to:</p>
<pre>
    try { ... CATCH { default { } } }</pre>
<p>(And that's another reason I didn't want to use <code>else</code> for the default
case of a switch statement--an <code>else</code> without an <code>if</code> looks really
bizarre...)</p>
<p>Just as an aside, what I'm trying to do here is untangle the exception
trapping semantics of <code>eval</code> from its code parsing and running semantics.
In Perl 6, there is no <code>eval {}</code>.  And <code>eval $string</code> really
means something like this:</p>
<pre>
    try { $string.parse.run }</pre>
<p>RFC:</p>
<dl>
<dt><dd>
<em>This RFC does not require core Perl functions to use exceptions
for signalling errors.</em>
<p></p></dl>
<p>However, Perl core functions will by default signal failure using
unthrown proto-exceptions (that is, interesting values of undef)
that can easily be turned into thrown exceptions via <code>die</code>.
By "interesting values of undef", I don't mean undef with properties.
I mean full-fledged exception objects that just happen to return false
from their <code>.defined</code> and <code>.true</code> methods.  However, the <code>.str</code>
method successfully returns the error message, and the <code>.int</code> method
returns the error code (if any).  That is, they do stringify and numify
like <code>$!</code> ought to.  An exception becomes defined and true when it
is thrown.  (Control exceptions become false when cleanly caught,
to avoid spoofing old-style exception handlers.)</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>This means that all exceptions propagate unless they are cleanly
caught, just as in Perl 5.  To prevent this, use:</em>
<pre>
    try { fragile(); } catch { } # Go on no matter what.</pre>
<p></p></dl>
<p>This will simply be:</p>
<pre>
    try { fragile; }</pre>
<p>But it means the same thing, and it's still the case that all
exceptions propagate unless they are cleanly caught.  In this case, the
caught exception lives on in <code>$!</code> as a new proto-exception that could
be rethrown by a new <code>die</code>, much as we used to use <code>$@</code>.  Whether an
exception is currently considered "cleanly caught" can be reflected in
the state of the <code>$!</code> object itself.  When <code>$!</code> passes through the
end of a <code>CATCH</code>, it is marked as clean, so that subsequent attempts to
establish a new <code>$!</code> know that they can clear out the old <code>@$!</code>
stack.  (If the current <code>$!</code> is not clean, it should just add its
information without deleting the old information--otherwise an error in
a <code>CATCH</code> could delete the exception information you will soon be wanting
to print out.)</p>
<p>RFC:</p>
<pre>
    try { ... } catch &lt;test&gt; =&gt; { ... } finally { ... }</pre>
<p>Now:</p>
<pre>
    { ... CATCH { when &lt;test&gt; { ... } } POST { ... } }</pre>
<p>(The angle brackets aren't really there--I'm just copying the RFC's
metasyntax here.)</p>
<p>Note that we're assuming a test that matches the "boolean" entry from
the switch dwimmery matrix.  If not, you can always wrap closure
curlies around the test:</p>
<pre>
    { ... CATCH { when { &lt;test&gt; } { ... } } POST { ... } }</pre>
<p>That will force the test to be called as a subroutine that ignores its
argument, which happens to be <code>$!</code>, the exception object.  (Recall
that the implied "given" of a <code>CATCH</code> statement sets <code>$!</code> as the given
value.  That given value is automatically passed to any "when" cases that
look like subroutines or closures, which are free either to ignore the passed
value, or access it as <code>$_</code> or <code>$^a</code>.)</p>
<p>Or you might just prefer to use the unary <code>true</code> operator:</p>
<pre>
    { ... CATCH { when true &lt;test&gt; { ... } } POST { ... } }</pre>
<p>I personally find that more readable than the closure.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>The test argument of the catch clause is optional, and is described
below.</em>
</dl>
<p>The test argument of a <code>when</code> clause is NOT optional, since it would
be impossible to distinguish a conditional closure from the following
block.  Use <code>default</code> for the default case.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em><code>try</code>, <code>catch</code>, and <code>finally</code> blocks should share the same lexical
scope, in the way that <code>while</code> and <code>continue</code> do.</em>
</dl>
<p>Actually, this is not so--the <code>while</code> and <code>continue</code> blocks
don't share the same lexical scope even in Perl 5.  But we'll solve
this issue without "tunneling" in any case.  (And we'll change the
<code>continue</code> block into a <code>NEXT</code> block that goes inside, so we
can refer to lexical variables from within it.)</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>Note that <code>try</code> is a keyword, not a function.  This is so
that a <code>;</code> is not needed at the end of the last block.  This is
because a <code>try</code>/<code>catch</code>/<code>finally</code> now looks more like an
<code>if</code>/<code>elsif</code>/<code>else</code>, which does not require such a <code>;</code>, than like
an eval, which does).</em>
</dl>
<p>Again, this entire distinction goes away in Perl 6.  Any expression
block that terminates with a right curly on its own line will be
interpreted as a statement block.  And <code>try</code> is such an expression block.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em><code>$@</code> contains the current exception, and <code>@@</code> contains the current
exception stack, as defined above under <code>die</code>.  The <code>unshift</code> rule
guarantees that <code>$@ == $@[0]</code>.</em>
</dl>
<p>Why an <code>unshift?</code>  A stack is most naturally represented in the
other direction, and I can easily imagine some kinds of handlers that
might well treat it like a stack, stripping off some entries and
pushing others.</p>
<p>Also, <code>@@</code> is a non-starter because everything about the current
exception should all be in a single data structure.  Keeping the info all
in one place makes it easy to rethrow an exception without losing data,
even if the exception was marked as cleanly caught.  Furthermore I don't
think that the exception stack needs to be Huffman coded that badly.</p>
<p>So <code>$!</code> contains the current exception, and <code>$!.stack</code> accesses the
current exception stack.  Through the magic of overloading, the <code>$!</code>
object can likely be used as an array even though it isn't one, in which
case <code>@$!</code> refers to that stack member.  The <code>push</code> rule guarantees
that <code>$!.id == $![-1].id</code>.</p>
<p>RFC (speaking of the <code>exception</code> declaration):</p>
<dl>
<dt><dd>
<em>If the given name matches <code>/::/</code>, something like this happens:</em>
<pre>
    @MyError::App::DB::Foo::ISA = 'MyError::App::DB';</pre>
<p><em>and all non-existent parent classes are automatically created as
inheriting from their parent, or <code>Exception</code> in the tail case.  If
a parent class is found to exist and not inherit from <code>Exception</code>,
a run-time error exception is raised.</em></p>
</dl>
<p>If I understand this, I think I disagree.  A package ought to able to
contain exceptions without being an exception class itself.  There
certainly ought to be a shorthand for exceptions within the current
package.  I suspect they're inner classes of some sort, or inner classes
of an inner package, or some such.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>If the given name does not match <code>/::/</code> (say it's just <code>Alarm</code>),
this happens instead:</em>
<pre>
    @Alarm::ISA = 'Exception';</pre>
<p><em>This means that every exception class isa <code>Exception</code>, even if
<code>Exception::</code> is not used at the beginning of the class name.</em></p>
</dl>
<p>Ack!  This could be really bad.  What if two different modules declare
an <code>Alarm</code> exception with different derivations?</p>
<p>I think we need to say that unqualified exceptions are created within
the current package, or maybe within the X subpackage of the current
package.  If we have inner classes, they could even be lexically scoped
(and hence anonymous exceptions outside the current module).  That
might or might not be a feature.</p>
<p>I also happen to think that <code>Exception</code> is too long a name to prefix
most common exceptions, even though they're derived from that class.  I
think exceptions will be better accepted if they have pithier names
like X::Errno that are derived from <code>Exception</code>:</p>
<pre>
    our class X::Control is Exception;
    our class X::Errno is Exception;
    our class X::NumericError is Exception;</pre>
<pre>
    our class C::NEXT is X::Control;
    our class E::NOSPC is X::Errno;
    our class X::FloatingUnderflow is X::NumericError;</pre>
<p>Or maybe those could be:</p>
<pre>
    c::NEXT
    e::NOSPC
    x::FloatingUnderflow</pre>
<p>if we decide uppercase names are too much like user-defined package
names.  But that looks strange.  Maybe we just reserve single letter
top-level package names for Perl.  Heck, let's just reserve all
top-level package names for Perl.  Er, no, wait...  <code>:-)</code></p>
<p>RFC 80 suggests that exception objects numerify to the system's
<em>errno</em> number when those are available.  That's a possibility,
though by the current switch rules we might have to write</p>
<pre>
    CATCH {
        when +$ENOSPC { ... }
    }</pre>
<p>to force <code>$ENOSPC</code> to do a numeric comparison.  It may well be better
to go ahead and make the errno numbers into exception classes, even
if we have to write something like this:</p>
<pre>
    CATCH {
        when X::ENOSPC { ... }
    }</pre>
<p>That's longer, but I think it's clearer.  Possibly that's <code>E::NOSPC</code>
instead.  But in any event, I can't imagine getting people to prefix
every exception with "<code>Exception::</code>".  That's just gonna discourage
people from using exceptions.  I'm quite willing to at least reserve
the <code>X</code> top-level class for exceptions.  I think <code>X::</code> is quite
sufficiently distinctive.</p>
<p>RFC:</p>
<pre>
    try { my $f = open &quot;foo&quot;; ... } finally { $f and close $f; }</pre>
<p>Now:</p>
<pre>
    {
        my $f = open &quot;foo&quot;; ...
        POST { $f and close $f }
    }</pre>
<p>Note that <code>$f</code> is naturally in scope and guaranteed to have a
boolean value, even if the exception is thrown before the declaration
statement is elaborated!  (An implementation need not allocate an
actual variable before the <code>my</code>.  The code of the <code>POST</code> block could
always be compiled to know that <code>$f</code> is to be assumed undefined if
the allocating code has not yet been reached.)</p>
<p>We could go as far as to make</p>
<pre>
        POST { close $f }</pre>
<p>do something reasonable even without the guard.  Maybe an undefined
object could "emulate" any method for you within a <code>POST</code>.  Maybe <code>try</code>
is really a unary operator:</p>
<pre>
        POST { try close $f }</pre>
<p>Or some such.  I dunno.  This needs more thought along transactional
lines...</p>
<p>Time passes...</p>
<p>Actually, now that I've thought on it, it would be pretty easy to put
wrappers around <code>POST</code> blocks that could do commit or rollback depending
on whether the block exits normally.  I'd like to call them <code>KEEP</code>
and <code>UNDO</code>.  <code>KEEP</code> blocks would only be executed if the block succeeded.
<code>UNDO</code> blocks would only be executed if the block failed.  One could
even envision a syntax that ties the block to particular variable:</p>
<pre>
    UNDO $f { close $f }</pre>
<p>After all, like the <code>CATCH</code> block, all of these blocks are just fancy
<code>BEGIN</code> blocks that attach some meaning to some predefined property of
the block.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

<p>It's tempting to make the execution of <code>UNDO</code> contingent upon
whether the block itself was passed during execution, but I'm afraid
that might leave a window in which a variable could already be set,
but subsequent processing might raise an exception before enabling
the rollback in question.  So it's probably better to tie it to a
particular variable's state more directly than just by placing the
block at some point after the declaration.  In fact, it could be
associated directly with the variable in question at declaration time
via a property:</p>
<pre>
    my $f is undo { close $f } = open $file or die;</pre>
<p>Note that the block is truly a closure because it relies on the
lexical scoping of <code>$f</code>.  (This form of lexical scoping works in Perl
6 because the name <code>$f</code> is introduced immediately within the statement.
This differs from the Perl 5 approach where the name is not introduced
till the end of the current statement.)</p>
<p>Actually, if the <code>close</code> function defaults to <code>$_</code>, we can say</p>
<pre>
    my $f is undo { close } = open $file;</pre>
<p>presuming the managing code is smart enough to pass <code>$f</code>
as a parameter to the closure.  Likewise one could attach a <code>POST</code>
block to a variable with:</p>
<pre>
    my $f is post { close } = open $file;</pre>
<p>Since properties can be combined, you can set multiple handlers on
a variable:</p>
<pre>
    my $f is post { close } is undo { unlink $file } = open &quot;&gt;$file&quot; or die;</pre>
<p>There is, however, no <code>catch</code> property to go with the <code>CATCH</code> block.</p>
<p>I suppose we could allow a <code>pre</code> property to set a <code>PRE</code> block on a variable.</p>
<p>RFC:</p>
<pre>
    sub attempt_closure_after_successful_candidate_file_open
    {
        my ($closure, @fileList) = @_; local (*F);
        foreach my $file (@fileList) {
            try { open F, $file; } catch { next; }
            try { &amp;$closure(*F); } finally { close F; }
            return;
            }
        throw Exception &quot;Can't open any file.&quot;,
               debug =&gt; @fileList . &quot; tried.&quot;;
        }</pre>
<p>Now:</p>
<pre>
    sub attempt_closure_after_successful_candidate_file_open
      (&amp;closure, @fileList)
    {
        foreach my $file (@fileList) {
            my $f is post { close }
                = try { open $file or die; CATCH { next } }
            &amp;closure($f);
            return;
        }
        throw Exception &quot;Can't open any file.&quot;,
               debug =&gt; @fileList . &quot; tried.&quot;;
    }</pre>
<p>Note that the <code>next</code> within the <code>CATCH</code> refers to the loop, not the <code>CATCH</code>
block.  It is legal to <code>next</code> out of <code>CATCH</code> blocks, since we won't use
<code>next</code> to fall through switch cases.</p>
<p>However, <code>X::Control</code> exceptions (such as <code>X::NEXT</code>) are a subset
of <code>Exceptions</code>, so</p>
<pre>
    CATCH {
        when Exception { ... }   # catch any exception
    }</pre>
<p>will stop returns and loop exits.  This could be construed as a
feature.  When it's considered a bug, you could maybe say something
like</p>
<pre>
    CATCH {
        when X::Control { die }  # propagate control exceptions
        when Exception  { ... }  # catch all others
    }</pre>
<p>to force such control exceptions to propagate outward.  Actually, it
would be nice to have a name for non-control exceptions.  Then we
could say (with a tip of the hat to Maxwell Smart):</p>
<pre>
    CATCH {
        when X::Chaos   { ... }  # catch non-control exceptions
    }</pre>
	
<p>
<p>And any control exceptions will then pass unimpeded (since by
default uncaught exceptions are rethrown implicitly by the <code>CATCH</code>).
Fortunately or unfortunately, an explicit <code>default</code> case will not
automatically rethrow control exceptions.</p>
<p>Following are some more examples of how the expression evaluation of
<code>when</code> can be used.  The RFC versions sometimes look more concise, but
recall that the "try" is any block in Perl 6, whereas in the
RFC form there would have to be an extra, explicit <code>try</code> block inside
many subroutines, for instance.  I'd rather establish a culture in
which it is expected that subroutines handle their own exceptions.</p>
<p>RFC:</p>
<pre>
    try { ... } catch $@-&gt;{message} =~ /.../ =&gt; { ... }</pre>
<p>Now:</p>
<pre>
    try {
        ...
        CATCH {
            when $!.message =~ /.../ { ... }
        }
    }</pre>
<p>This works because =~ is considered a boolean operator.</p>
<p>RFC:</p>
<pre>
    catch not &amp;TooSevere =&gt; { ... }</pre>
<p>Now:</p>
<pre>
    when not &amp;TooSevere { ... }</pre>
<p>The unary <code>not</code> is also a boolean operator.</p>
<p>RFC:</p>
<pre>
    try { ... } catch ref $@ =~ /.../ =&gt; { ... }</pre>
<p>Now:</p>
<pre>
    try { ... CATCH { when $!.ref =~ /.../ { ... } } }</pre>
<p>RFC:</p>
<pre>
    try { ... } catch grep { $_-&gt;isa(&quot;Foo&quot;) } @@ =&gt; { ... }</pre>
<p>Now:</p>
<pre>
    try {
        ...
        CATCH {
            when grep { $_.isa(Foo) } @$! { ... }
        }
    }</pre>
<p>I suppose we could also assume grep to be a boolean operator in a
scalar context.  But that's kind of klunky.  If we accept Damian's
superposition RFC, it could be written this way:</p>
<pre>
    try {
        ...
        CATCH {
            when true any(@$!).isa(Foo) { ... }
        }
    }</pre>
<p>Actually, by the "any" rules of the <code>=~</code> table, we can just say:</p>
<pre>
    try {
        ...
        CATCH {
            when @$! =~ Foo { ... }
        }
    }</pre>
<p>The RFC proposes the following syntax for finalization:</p>
<pre>
    try { my $p = P-&gt;new; my $q = Q-&gt;new; ... }
    finally { $p and $p-&gt;Done; }
    finally { $q and $q-&gt;Done; }</pre>
<p>A world of hurt is covered over by that "<code>...</code>", which could move the
<code>finally</code> clauses far, far away from what they're trying to clean up
after.  I think the intent is much clearer with <code>POST</code>.  And note also
that we avoid the "lexical tunneling" perpetrated by <code>finally</code>:</p>
<pre>
    {
        my $p = P.new;   POST { $p and $p.Done; }
        my $q = Q.new;   POST { $q and $q.Done; }
        ...
    }</pre>
<p>More concisely, we can say:</p>
<pre>
    {
        my $p is post { .Done } = P.new;
        my $q is post { .Done } = Q.new;
        ...
    }</pre>
<p>RFC:</p>
<pre>
    try     { TryToFoo; }
    catch   { TryToHandle; }
    finally { TryToCleanUp; }
    catch   { throw Exception &quot;Can't cleanly Foo.&quot;; }</pre>
<p>How I'd write that:</p>
<pre>
    try {
        try {
            TryToFoo;
            POST    { TryToCleanUp; }
            CATCH   { TryToHandle; }
        }
        CATCH   { throw Exception &quot;Can't cleanly Foo.&quot;; }
    }</pre>
<p>That also more clearly indicates to the reader that the final <code>CATCH</code>
governs the inner try completely, rather than just relying on ordering.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>Instances of the actual (non-subclassed) <code>Exception</code> class itself are
used for simple exceptions, for those cases in which one more or
less just wants to say <code>throw&nbsp;Exception&nbsp;&quot;My&nbsp;message.&quot;</code>, without a
lot of extra tokens, and without getting into higher levels of the
taxonomy of exceptions.</em>
<p></p></dl>
<p><code>die &quot;My message.&quot;</code> has much the same effect.  I think
<code>fail&nbsp;&quot;My&nbsp;message.&quot;</code>&nbsp; will also default similarly, though with
return-or-throw semantics that depend on the caller's <code>use fatal</code>
settings.</p>
<p>RFC (regarding <code>on_raise</code>):</p>
<dl>
<dt><dd>
<em>Derived classes may override this method to attempt to "handle" an
exception or otherwise manipulate it, just before it is raised.  If
<code>on_raise</code> throws or returns true the exception is raised, otherwise it
is not.  An exception can be manipulated or replaced and then propagated
in modified form simply by re-raising it in <code>on_raise</code>.</em>
</dl>
<p>Offhand, I don't see this one.  Not only does it seem to be making
the <code>$SIG{__DIE__}</code> mistake all over again, it also makes little sense
to me to use "throw" to do something that doesn't throw.  A throw
should guarantee termination of control, or you're just going to run
user code that wasn't expected to be run.  It'd be like <code>return</code>
suddenly not returning!  Let's please use a different method to
generate an unthrown exception.  I think a <code>fail</code> method is the
right approach--it terminates the control flow one way or another,
even if just returning the exception as a funny-looking undef.</p>
<p>The <code>on_catch</code> might be a bit more useful.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>...because the authors are of the opinion that overloading <code>else</code> and
<code>continue</code> with unwind semantics not traditionally associated with
<code>else</code> and <code>continue</code> can be confusing, especially when intermixed
with local flow-control forms of <code>else</code> and <code>continue</code> (which may
be present in any <code>{&nbsp;...&nbsp;}</code> block), or when an <code>else&nbsp;die&nbsp;$@</code>
is forgotten on a <code>switch</code> that needs to re-throw.</em>
<p></p></dl>
<p><code>CATCH</code> will rethrow by default (unless there is a user-specified default).</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>Some perl6-language-error discussions have suggested leaving out
the try altogether, as in simply writing <code>{ } else { }</code> to indicate
non-local flow-control at work. Yikes!</em>
<p><em>The <code>try</code> is not for Perl's sake.  It's for the developer's sake.
It says, watch out, some sort of non-local flow control is going on
here.  It signals intent to deal with action at a distance
(unwinding semantics).  It satisfies the first requirement listed
under MOTIVATION.</em></p>
<p></p></dl>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

<p><code>try {}</code> is the new spelling of <code>eval {}</code>, so it can still be used
when self-documentation is desired.  It's often redundant, however,
since I think the all-caps <code>CATCH</code> and <code>POST</code> also serve the purpose
of telling the developer to "watch out".  I expect that developers
will get used to the notion that many subroutines will end with a
<code>CATCH</code> block.  And I'm always in favor of reducing the bracket
count of ordinary code where practical.  (That's why the <code>package</code>
declaration has always had a bracketless syntax.  I hope to do the
same for classes and modules in Perl 6.)</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>The comma or <code>=</code><code></code></em> <em>in a conditional catch clause is required so
the expression can be parsed from the block, in the fashion of Perl
5's parsing of: <code>map </code><code>&lt;expression</code><code></code></em><code>, &lt;list</code><code></code>&gt;;
Without the comma, the form <code>catch&nbsp;$foo&nbsp;{&nbsp;...&nbsp;}</code> could be
a test for <code>$foo</code> or a test for <code>$foo{...}</code> (the hash element).&gt;
<p></p></dl>
<p>We now require whitespace before non-subscript block, so this is not
much of a problem.</p>


<p>RFC:</p>
<dl>
<dt><dd>
<em>How can we subclass <code>Exception</code> and control the class namespace?  For
example, if the core can use any <code>Exception::Foo</code>, where does one
connect non-core <code>Exception</code>s into the taxonomy?  Possibly the core
exceptions can derive from <code>Exception::CORE</code>, and everyone else can
use the <code>Exception::MyPackage</code> convention.</em>
<p></p></dl>
<p>I don't think defining things as core vs non-core is very
useful--"core" is not a fundamental type of exception.  I do think the
standard exception taxonomy should be extensible, so that non-standard
exceptions can migrate toward being standard over time.  I also think
that modules and classes should have their own subpackage in which to
store exceptions.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>How can we add new instance variables and methods to classes
derived from <code>Exception</code> and control those namespaces?  Perhaps
this will be covered by some new Perl 6 object technology.
Otherwise, we will need yet another naming scheme convention.</em>
<p></p></dl>
<p>Instance variables and methods in a derived class will not interfere with
base classes (except by normal hiding of duplicate method names).</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>What should the default values be for <code>Exception</code> object instance
variables not specified to the constructor?  For example, <code>tag</code>
could default to file + line number.</em>
<p></p></dl>
<p>Depends on the constructor, I suspect.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>What assertions should be placed on the instance variables, if any?</em>
<p></p></dl>
<p>Probably depends on the class.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<em>What should stringification return?</em>
<p></p></dl>
<p>I lean towards just the message, with a different method for more
info.  But this is somewhat dependent on which representational methods
we define for all Objects.  And that has not been entirely thunk
through.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>Mixed Flow Control</strong>
<p><em>Some of the reference texts, when discussing exception handling, refer
to the matter that it may be difficult to implement a <code>go to</code> across
an unwinding semantics block, as in:</em></p>
<pre>
        try { open F, $f } catch { next; }</pre>
<p><em>This matter will have to be referred to the internals experts.  It's ok
if this functionality is not possible, it can always be simulated with
lexical state variables instead.</em></p>
<p><em>However, the authors would very much prefer that <code>goto</code>s across
unwinding boundaries would dwim.  If that is not possible, hopefully
some sort of compile-time warning could be produced.</em></p>
<p></p></dl>
<p>We can do this with special control exceptions that aren't caught
until it makes sense to catch them.  (Where exactly control exceptions
fit in the class hierarchy is still open to debate.)  In any event,
there's no problem throwing a control exception from a <code>CATCH</code>,
since any exception thrown in a <code>CATCH</code> or <code>POST</code> would propagate
outside the current try block in any event.</p>
<p>Ordinary <code>goto</code> should work as long as it's leaving the current
try scope.  Reentering the try somewhere in the middle via <code>goto</code>
is likely not possible, or even desirable.  A failed try should be
re-entered from the top, once things have been cleared up.  (If the
try is a loop block, going to the next iteration out of its <code>CATCH</code>
will probably be considered safe, just as if there had been an explicit
<code>try</code> block within the loop.  But I could be wrong on that.)</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>Use <code>%@</code> for Errors from Builtins</strong>
<p><em>RFC 151 proposes a mechanism for consolidating the information provided
by of <code>$@</code>, <code>$!</code>, <code>$?</code>, and <code>$^E</code>.  In the opinion of the author of
RFC 88, merging <code>$@</code> and <code>$!</code> should not be undertaken, because <code>$@</code>
should <em>only</em> be set if an exception is raised.</em></p>
<p></p></dl>
<p>The RFC appears to give no justification for this last assertion.  If we
unify the error variables, <code>die</code> with no arguments can simply raise the
current value of <code>$!</code>, and we stay object oriented all the way down.
Then <code>$!</code> indicates the current error whether or not it's being thrown.
It keeps track of its own state, as to whether it is currently in an
"unclean" state, and refuses to throw away information unless it's clean.</p>
<dl>
<dt><dd>
<code>%@</code> <em>should be used to hold this fault-hash, based on the following
arguments for symmetry.</em>
<pre>
        $@    current exception
        @@    current exception stack
        %@    current core fault information</pre>
<pre>
        $@[0]        same as $@</pre>
<pre>
        $@{type}     &quot;IO::File::NotFound&quot;
        $@{message}  &quot;can't find file&quot;
        $@{param}    &quot;/foo/bar/baz.dat&quot;
        $@{child}    $?
        $@{errno}    $!
        $@{os_err}   $^E
        $@{chunk}    That chunk thingy in some msgs.
        $@{file}     Source file name of caller.
        $@{line}     Source line number of caller.</pre>
<p><code>%@</code> <em>should not contain a severity or fatality classification.</em></p>
<p><em>Every call to a core API function should clear <code>%@</code> if it returns
successfully.</em></p>
<p><em>Internally, Perl can use a simple structured data type to hold the
whole canonical <code>%@</code>.  The code that handles reading from <code>%@</code> will
construct it out of the internal data on the fly.</em></p>
<p><em>If <code>use fatal;</code> is in scope, then just before returning, each core
API function should do something like: <code>%@&nbsp;and&nbsp;internal_die&nbsp;%@;</code> </em></p>
<p><em>The <code>internal_die</code> becomes the one place where a canonical <code>Exception</code>
can be generated to encapsulate <code>%@</code> just before raising an exception,
whether or not the use of such canonical <code>Exception</code>s is controlled by a
pragma such as</em> <code>use&nbsp;exceptions;</code>.</p>
<p></p></dl>
<p>This <code>%@</code> proposal just looks like a bunch of unnecessary complication
to me.  A proto-exception object with methods can be just as easily
(and lazily) constructed, and will map straight into a real exception,
unlike this hash.  And an object can always be used as a hash to
access parameterless methods such as instance variable accessors.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>eval</strong>
<p><em>The semantics of <code>eval</code> are, "clear <code>$@</code> and don't unwind unless
the user re-dies after the <code>eval</code>".  The semantics of <code>try</code> are
"unwind after <code>try</code>, unless any raised exception was cleanly and
completely handled, in which case clear <code>$@</code>".</em></p>
<p><em>In the author's opinion, both <code>eval</code> and <code>try</code> should exist in
Perl 6.  This would also mean that the legacy of examples of how to
use <code>eval</code> in Perl will still work.</em></p>
<p><em>And, of course, we still need <code>eval&nbsp;$string</code>.</em></p>
<p><em>Discussions on perl6-language-errors have shown that some would
prefer the <code>eval&nbsp;{&nbsp;...&nbsp;}</code> form to be removed from Perl 6,
because having two exception handling methods in Perl could be
confusing to developers.  This would in fact be possible, since
the same effect can be achieved with:</em></p>
<pre>
        try { } catch { } # Clears $@.</pre>
<pre>
        my $e;</pre>
<pre>
        try { ... } catch { $e = $@; }</pre>
<pre>
        # now process $e instead of $@</pre>
<p><em>On the other hand, <code>eval</code> is a convenient synonym for all that,
given that it already works that way.</em></p>
<p></p></dl>
<p>I don't think the exact semantics of <code>eval {...}</code> are worth
preserving.  I think having bare <code>try {...}</code> assume a <code>CATCH { default {} }</code>
will be close enough.  Very few Perl 5 programs actually care whether
<code>$@</code> is set within the eval.  Given that and the way we've defined
<code>$!</code>, the translation from Perl 5 to Perl 6 involves simply changing
<code>eval&nbsp;{...}</code> to <code>try&nbsp;{...}</code> and <code>$@</code> to <code>$!</code> (which lives on as a
"clean" exception after being caught by the <code>try</code>).  Perhaps some
attempt can be made to pull an external handler into an internal
<code>CATCH</code> block.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong><code>catch v/s else + switch</code></strong>
<p><em>Some participants in discussions on perl6-language-errors have
expressed the opinion that not only should <code>eval</code> be used instead
of <code>try</code>, but <code>else</code> should be used instead of multiple <code>catch</code>
blocks.  They are of the opinion that an</em> <code>else&nbsp;{&nbsp;switch&nbsp;...&nbsp;}</code>
<em>should be used to handle multiple catch clauses, as in:</em></p>
<pre>
        eval { ... }
        else {
            switch ($@) {
                case $@-&gt;isa(&quot;Exception::IO&quot;) { ... }
                case $@-&gt;my_method { ... }
                }
            }</pre>
<p><em>This problem with</em> <code>else&nbsp;{&nbsp;switch&nbsp;...&nbsp;}</code> <em>is: how should the code
implicitly rethrow uncaught exceptions?  Many proponents of this
model think that uncaught exceptions should not be implicitly
rethrown; one suggests that the programmer should <code>undef $@</code> at the
end of *every* successful case block, so that Perl re-raises any
<code>$@</code> still extant at the end of the <code>else</code>.</em></p>
<p><em>This RFC allows a <code>switch</code> to be used in a</em> <code>catch&nbsp;{&nbsp;...&nbsp;}</code>
<em>clause, for cases where that approach would minimize redundant code
in</em> <code>catch</code> <code>&lt;expr</code><code></code>&gt; <code>{ ... }</code> <em>clauses, but with the mechanism
proposed in this RFC, the switch functionality shown above can be
written like this, while still maintaining the automatic exception
propagation when no cases match:</em></p>
<pre>
        try { ... }
        catch Exception::IO =&gt; { ... }
        catch $@-&gt;my_method =&gt; { ... }</pre>
<p></p></dl>
<p>The switch construct works fine, because the implied <code>break</code> of each
handled case jumps over the default rethrow supplied by the <code>CATCH</code>.
There's no reason to invent a parallel mechanism, and lots of reason
not to.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>Mechanism Hooks</strong>
<p><em>In the name of extensibility and debugging, there should be hooks for
callbacks to be invoked when a <code>try</code>, <code>catch</code>, or <code>finally</code> block is
entered or exited, and when a conditional <code>catch</code> is evaluated.  The
callbacks would be passed information about what is happening in the
context they are being called from.</em></p>




<p><em>In order to scope the effect of the callbacks (rather than making them
global), it is proposed that the callbacks be specified as options to
the try statement, something like this:</em></p>
<pre>
    try on_catch_enter =&gt; sub { ... },
        on_catch_exit  =&gt; sub { ... },
    {
        ...
        }</pre>
<p><em>The (dynamic, not lexical) scope of these callbacks is from their try
down through all trys nested under it (until overridden at a lower
level).  Nested callbacks should have a way of chaining to callbacks
that were in scope when they come into scope, perhaps by including a
reference to the outer-scope callback as a parameter to the callback.
Basically, they could be kept in "global" variables overridden with
<code>local</code>.</em></p>
<p></p></dl>
<p>Yuck.  I dislike cluttering up the <code>try</code> syntax with what are essentially
<code>temp</code> assignments to dynamically scoped globals.  It should be
sufficient to say something like:</p>
<pre>
    {
        temp &amp;*on_catch_enter = sub { ... };
        temp &amp;*on_catch_exit  = sub { ... };
        ...
    }</pre>
<p>provided, of course, the implementation is smart enough to look for
those hooks when it needs them.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>Mixed-Mode Modules</strong>
<p><em>Authors of modules who wish to provide a public API that respects the
current state of <code>use&nbsp;fatal;</code> if such a mechanism is available, can
do so as follows.</em></p>
<p><em>Internal to their modules, authors can use lexically scoped
<code>use&nbsp;fatal;</code> to explicitly control whether or not they want
builtins to raise exceptions to signal errors.</em></p>
<p><em>Then, if and only if they want to support the other style, and only
for public API subroutines, they do something like one of these:</em></p>
<ul>
<li>
<em>Use return internally, now add support for throw at API:</em>
<pre>
     sub Foo
     {
        my $err_code = ... ; # real code goes here</pre>
<pre>
        # Replace the old return $err_code with this:</pre>
<pre>
        return $err_code unless $FATAL_MODE &amp;&amp; $error_code != $ok;</pre>
<pre>
        throw Error::Code &quot;Couldn't Foo.&quot;, code =&gt; $err_code;
        }</pre>
<p></p>
<li>
<em>Use throw internally, add support for return at API:</em>
<pre>
     sub Foo
     {
        try {
            # real code goes here, may execute:</pre>
<pre>
            throw Exception &quot;Couldn't foo.&quot;, code =&gt; $err_code;
            }
        catch !$FATAL_MODE =&gt; { return $@-&gt;{code}; }</pre>
<pre>
        return $ok;
        }</pre>
<p></p></ul>
</dl>
<p>Yow.  Too much mechanism.  Why not just:</p>
<pre>
    return proto Exception &quot;Couldn't foo.&quot;, code =&gt; $err_code;</pre>
<p>The <code>proto</code> method can implement the standard <code>use fatal</code> semantics
when that is desired by the calling module, and otherwise set things
up so that</p>
<pre>
    Foo() or die;</pre>
<p>ends up throwing the proto-exception.  (The current proto-exception can
be kept in <code>$!</code> for use in messages, provided it's in thread-local
storage.)</p>
<p>Actually, this is really important to make simple.  I'd be in favor of
a built-in that clearly says what's going on, regardless of whether it
ends in a throw or a return of undef:</p>
<pre>
    fail &quot;Couldn't foo&quot;, errno =&gt; 2;</pre>
<p>Just as an aside, it could be argued that all such "built-ins" are
really methods on an implicit class or object.  In this case, the
<code>Exception</code> class...</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>$SIG{__DIE__}</strong>
<p><em>The try, catch, and finally clauses localize and undef <code>$SIG{__DIE__}</code>
before entering their blocks.  This behavior can be removed if
<code>$SIG{__DIE__}</code> is removed.</em></p>
<p></p></dl>
<p><code>$SIG{__DIE__}</code> must die.  At least, that name must die--we may install
a similar global hook for debugging purposes.</p>
<p>RFC:</p>
<dl>
<dt><dd>
<strong>Legacy</strong>
<p><em>The only changes in respect of Perl 5 behaviour implied by this RFC are
that (1) <code>$@</code> is now always an <code>Exception</code> object (which stringifies
reasonably), it is now read-only, and it can only be set via <code>die</code>, and
(2) the <code>@@</code> array is now special, and it is now read-only too.</em></p>
<p></p></dl>
<p>Perhaps <code>$!</code> could be implicitly declared to have a type of <code>Exception</code>.
But I see little reason to make <code>$!</code> readonly by default.  All that
does is prevent clever people from doing clever things that we haven't
thought of yet.  And it won't stop stupid people from doing stupid things.
In any event, <code>$!</code> is just a reference to an object, and access to the
object will controlled by the class, not by Perl.</p>












<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>


<h3><a href="http://dev.perl.org/rfc/199.html" name="rfc 199: shortcircuiting builtin functions and userdefined subroutines">RFC 199: Short-circuiting built-in functions and user-defined subroutines</a></h3>
<p>First I should note in passing that it is likely that</p>
<pre>
    my ($found) = grep { $_ == 1 } (1..1_000_000);</pre>
<p>will be smart enough to stop on the first one without additional hints,
since the left side will only demand one value of the right side.</p>
<p>However, we do need to unify the behaviors of built-ins with user-defined
control structures.  From an internal point of view, all of these various
ways of exiting a block will be unified as exceptions.</p>
<p>It will be easy enough for a user-defined subroutine to catch the
appropriate exceptions and do the right thing.  For instance, to
implement a loop wrapper (ignoring parser issues), you might write
something like this:</p>
<pre>
    sub mywhile ($keyword, &amp;condition, &amp;block) {
        my $l = $keyword.label;
        while (&amp;condition()) {
            &amp;block();
            CATCH {
                my $t = $!.tag;
                when X::Control::next { die if $t &amp;&amp; $t ne $l); next }
                when X::Control::last { die if $t &amp;&amp; $t ne $l); last }
                when X::Control::redo { die if $t &amp;&amp; $t ne $l); redo }
            }
        }
    }</pre>
	

<p>Remember that those <code>die</code> calls are just rethrows of the current
exception to get past the current try scope (the <code>while</code> in this
case).</p>
<p>How a block gets a label in general is an interesting question.
It's all very well to say that the keyword is the label, but that
doesn't help if you have two nested constructs with the same name.
In Perl 5, labels are restricted to being at the beginning of the
statement, but then how do you label a <code>grep</code>?  Should there be some
way of specifying a label on a keyword rather than on a statement?
We could end up with something like this:</p>
<pre>
    my $found = grep:NUM { $_ == 1 and last NUM: $_ } (1..1_000_000);</pre>
<p>On the other hand, considering how often this feature is (not) going
to used, I think we can stick with the tried-and-true statement label:</p>
<pre>
    my $found = do { NUM: grep { $_ == 1 and last NUM: $_ } (1..1_000_000) };</pre>
<p>This has the advantage of matching the label syntax with a colon on the
end in both places.  I like that.</p>
<p>I don't think every block should implicitly have a way to return, or
we'll have difficulty optimizing away blocks that don't do anything
blockish.  That's because setting up a try environment is always a bit
blockish, and does in fact impose some overhead that we'd just as
soon avoid when it's unnecessary.</p>
<p>However, it's probably okay if certain constructs that would know
how to deal with a label are implicitly labelled by their keyword
name when they don't happen to have an explicit label.  So I think
we can allow something like:</p>
<pre>
    last grep: $_</pre>
<p>Despite its appearance, that is not a method call, because <code>grep</code>
is not a predefined class.  What we have is a unary operator <code>last</code>
that is taking an adverbial modifier specifying what to return from
the loop.</p>
<p>The interesting policy question as we go on will be whether a given
construct responds to a given exception or not.  Some exceptions
will have to be restricted in their use.  For instance, we should
probably say that only explicit <code>sub</code> declarations may respond to a
<code>return</code>.  People will expect <code>return</code> to exit the subroutine they
think they're in, even if there are blocks floating around that are
actually closures being interpreted elsewhere.  It might be considered
antisocial for closure interpreters like <code>grep</code> or <code>map</code> or <code>sort</code>
to trap X::Control::return sooner than the user expects.</p>
<p>As for using numbers instead of labels to indicate how many levels
to break out of, that would be fine, except that I don't believe in
breaking out by levels.  If the problem is complex enough that you
need to break out more than one level, you need a name, not a number.
Then it doesn't matter if you refactor your code to have more block
levels or less.  I find I frequently have to refactor my code that way.</p>
<p>It's possible to get carried away and retrofit <code>grep</code> and <code>map</code>
with every conceivable variety of abort, retry, accept, reject, reduce,
reuse, recycle, or whatever exception.  I don't think that's necessary.
There has to be some reason for writing your own code occasionally.
If we get rid of all the reasons for writing user-defined subroutines,
we might as well pack our bags and go home.  But it's okay at minimum
to treat a looping construct like a loop.</p>

<h3><a href="http://dev.perl.org/rfc/6.html" name="rfc 006: lexical variables made default">RFC 006: Lexical variables made default</a></h3>
<p>This RFC proposes that <code>strict vars</code> should be on by default.  This is
motivated by the desire that Perl better support (or cajole, in this
case) the disciplines that enable successful programming in the large.
This goal is laudable.</p>
<p>However, the programming-in-the-small advocates also have a valid
point: they don't want to have to go to all the trouble of turning off
strictures merely to write a succinct one-liner, since keystrokes are
at a premium in such programming, and in fact the very strictures that
increase clarity in large programs tend to decrease clarity in small
programs.</p>
<p>So this is one of those areas where we desire to have it both ways,
and in fact, we pretty much can.  The only question is where to draw
the line.  Some discussion suggested that only programs specified on
the command line via the <code>-e</code> switch should be exempt from stricture.
But I don't want to force every little file-based script into the
large model of programming.  And we don't need to.</p>
<p>Large programming requires the definition of modules and classes.
The typical large program will (or should) consist mostly of modules
and classes.  So modules and classes will assume <code>strict vars</code>.
Small programming does not generally require the definition of modules
and classes, though it may depend on existing modules and classes.
But even small programs that use a lot of external modules and classes
may be considered throw-away code.  The very fact that the main code
of a program is not typically reused (in the sense that modules and
classes are reused) means that there is where we should draw the
line.  So in Perl 6, the main program will not assume <code>strict vars</code>,
unless you explicitly do something to turn it on, such as to declare
"class Main".</p>

<h3><a href="http://dev.perl.org/rfc/330.html" name="rfc 330: global dynamic variables should remain the default">RFC 330: Global dynamic variables should remain the default</a></h3>
<p>This is fine for the main program, but modules and classes should be held
to the higher standard of <code>use strict</code>.</p>

<h3><a href="http://dev.perl.org/rfc/83.html" name="rfc 083: make constants look like variables">RFC 083: Make constants look like variables</a></h3>
<p>It's important to keep in mind the distinction between variables and
values.  In a pure OO environment, variables are merely references to
values, and have no properties of their own--only the value itself
would be able to say whether it is constant.  Some values are naturally
constant, such as a literal string, while other values could be marked
constant, or created without methods that can modify the object, or
some such mechanism.  In such an environment, there is little use for
properties on variables.  Any time you put a property on a variable,
it's potentially lying about its value.</p>
<p>However, Perl does not aspire to be a pure OO environment.  In Perl-think,
a variable is not merely a container for a value.  Rather, a variable
provides a "view" of a value.  Sometimes that view could even be construed
as a lie.  That's okay.  Lying to yourself is a useful survival skill
(except when it's not).  We find it necessary to repeat "I think I can"
to ourselves precisely when we think we can't.  Conversely, it's often
valuable psychologically to treat possible activities as forbidden.
Abstinence is easier to practice if you don't have to decide anew every
time there's a possible assignation, er, I mean, assignment.</p>
<p>Constant declarations on variables fall into this category.  The value
itself may or may not naturally be constant, but we will pretend that
it is.  We could in theory go farther than that.  We could check the
associated object to make sure that it is constant, and blow up if it's
not, but that's not necessary in this case for consistent semantics.
Other properties may be stricter about this.  If you have a variable
property that asserts a particular shape of multidimensional array,
for instance, the object in question had better be able to supply
semantics consistent with that view, and it's probably a good idea
to blow up sooner rather than later if it can't.  This is something
like strong typing, except that it's optional, because the variable
property itself is optional.</p>
<p>Nevertheless, the purpose of these variable properties is to allow
the compiler to deduce things about the program that it could not
otherwise deduce, and based on those deductions, produce both a more
robust and more efficient compile-time interpretation of the semantics
of the program.  That is to say, you can do more optimizations without
compromising safety.  This is obviously true in the case of inlining
constants, but the principle extends to other variable properties
as well.</p>
<p>The proposed syntax is fine, except that we'll be using <code>is</code> instead of
<code>:</code> for properties, as discussed in Apocalypse 2.  (And it's <code>constant</code>,
not <code>const</code>.)</p>

<h3><a href="http://dev.perl.org/rfc/337.html" name="rfc 337: common attribute system to allow userdefined, extensible attributes">RFC 337: Common attribute system to allow user-defined, extensible attributes</a></h3>
<p>As already revealed in Apocalypse 2, attributes will be known as
"properties" in Perl 6, to avoid confusion with existing OO
nomenclature for instance variables.  Also, we'll use the <code>is</code> keyword
instead of the colon.</p>
<p>Setting properties on array and hash elements bothers me, particularly
when those properties have names like "public" and "private".  This
seems to me to be an attempt to paper over the gap of some missing OO
functionality.  So instead, I'd rather keep arrays and hashes mostly
for homogenous data structures, and encourage people to use objects to
store data of differing types.  Then public and private can be
properties of object attributes, which will look more like real
variables in how they are declared.  And we won't have to worry about
the meaning of <code>my @foo[2]</code>, because that still won't be allowed.</p>
<p>Again, we need to be very clear that the object representing the
variable is different than any objects contained by the variable.  When
we say</p>
<pre>
    my Dog @dogpound is loud;</pre>
<p>we mean that the individual elements of <code>@dogpound</code> are of type <code>Dog</code>, not
that the array variable is of type <code>Dog</code>.  But the <code>loud</code> property
applies to the array, not to the dogs in the array.  If the array
variable needs to have a type, it can be supplied as if it were a
property:</p>
<pre>
    my Dog @dogpound is DogPound is loud;</pre>
<p>That is, if a property is the name of a known package/class, it is
taken to be a kind of <code>tie</code>.  Given the declaration above, the
following is always true:</p>
<pre>
    @dogpound.is.loud</pre>
<p>since the <code>loud</code> is a property of the array object, even if it
contains no dogs.  It turns out that</p>
<pre>
    @dogpound.is.DogPound</pre>
<p>is also true.  This does not do an isa lookup.  For that, say:</p>
<pre>
    @dogpound.isa(Pound)</pre>
<p>Note that you can use:</p>
<pre>
    @dogpound =~ Dog</pre>
<p>to test the individual elements for Doghood.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>


<h3><a href="http://dev.perl.org/rfc/173.html" name="rfc 173: allow multiple loop variables in foreach statements">RFC 173: Allow multiple loop variables in foreach statements</a></h3>
<p>Unfortunately, the proposed syntax could also be interpreted as
parallel traversal:</p>
<pre>
  foreach ($a, $b) (@a, @b)</pre>
<p>Also the RFC assumes pairs will be passed as two elements, which is no
longer necessarily the case.  A hash by itself in list context will
return a list of pair objects.  We'll need to say something like:</p>
<pre>
    %hash.kv</pre>
<p>to get a flattened list of keys alternating with values.  (The same
method on arrays produces alternating indices and values.)</p>
<p>I like the idea of this RFC, but the proposed syntax is not what I'd
like.  There are various possible syntaxes that could also potentially
fulfill the intent of RFC 120:</p>
<pre>
    for [$i =&gt; $elem] (@array) { }
    for {$i =&gt; $elem} (@array) { }
    for ($i, $elem) = (@array.kv) { }</pre>
<p>But I like the idea of something that feels like repeated binding.
We could use the <code>:=</code> binding operator, but since binding is actually
the operation performed by formal parameters of subroutines, and since
we'd like to keep the list near the <code>for</code> and the formals near the
closure, we'll use a variant of subroutine declaration to declare
<code>for</code> loops:</p>
<pre>
    for @list -&gt; $x { ... }         # one value at a time
    for @list -&gt; $a, $b { ... }     # two values at a time</pre>
<p>You can un-interleave an array by saying:</p>
<pre>
    for @xyxyxy -&gt; $x, $y { ... }</pre>
<p>Iterating over multiple lists in parallel needs a syntax much like
a multi-dimensional slice.  That is, something like a comma that
binds looser than a comma.  Since we'll be using semicolon for that
purpose to delimit the dimensions of multi-dimensional slices, we'll
use similar semicolons to delimit a parallel traversal of multiple
lists: So parallel arrays could be stepped through like this:</p>
<pre>
    for @xxx; @yyy; @zzz -&gt; $x; $y; $z { ... }</pre>
<p>If there are semicolons on the right, there must be the same number
as on the left.</p>
<p>Each "stream" is considered separately, so you
can traverse two arrays each two elements at a time like this:</p>
<pre>
    for @ababab; @cdcdcd -&gt; $a, $b; $c, $d { ... }</pre>
<p>If there are no semicolons on the right, the values
are taken sequentially across the streams.  So you can say</p>
<pre>
    for @aaaa; @bbbb -&gt; $a, $b { ... }</pre>
<p>and it ends up meaning the same thing as if the comma were a semicolon,
but only because the number of variables on the right happens to be
the same as the number of streams on the right.  That doesn't have
to be the case.  To get values one at a time across three streams,
you can say</p>
<pre>
    for @a; @b; @c -&gt; $x { ... }</pre>
<p>Each semicolon delimited expression on the left is considered to be a list
of generated values, so it's perfectly legal to use commas or "infinite"
ranges on the left.  The following prints "a0", "b2", "c3", and so on
forever (or at least for a very long time):</p>
<pre>
    for 0 .. Inf; &quot;a&quot; .. &quot;z&quot; x 1000 -&gt; $i; $a {
        print &quot;$a$i&quot;;
    }</pre>
<p>
<h3><a href="http://dev.perl.org/rfc/19.html" name="rfc 019: rename the local operator">RFC 019: Rename the local operator</a></h3>
<p>We'll go with <code>temp</code> for the temporizing operator.</p>
<p>In addition, we're going to be storing more global state in objects
(such as file objects).  So it ought to be possible to temporize
(that is, checkpoint/restore) an attribute of an object, or at least
any attributes that can be treated as an lvalue.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/64.html" name="rfc 064: new pragma 'scope' to change perl's default scoping">RFC 064: New pragma 'scope' to change Perl's default scoping</a></h3>
<p>I can't stop people from experimenting, but I'm not terribly interested
in performing this experiment myself.  I made <code>my</code> short for a reason.
So I'm accepting this RFC in principle, but only in principle.  Standard
Perl declarations will be plainly marked with <code>my</code> or <code>our</code>.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

<h2><a name="rejected rfcs">Rejected RFCs</a></h2>
<p>Just because I've rejected these RFCs doesn't mean that they weren't
addressing at a valid need.  Usually an RFC gets rejected simply
because I think there's a better way to do it.  Often there's little
difference between a rejected RFC that I've borrowed ideas from and
an RFC accepted with major caveats.</p>
<p>We're already running long, so these descriptions will be terse.  Please
read the RFC if you don't understand the commentary.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/89.html" name="rfc 089: controllable data typing">RFC 089: Controllable Data Typing</a></h3>
<p>This is pretty close to what we've been planning for Perl for a long
time.  However, a number of the specifics are suboptimal.</p>
<p>If you declare a constant, it's a constant.  There's no point in
allowing warnings on that by default.  It should be fatal to modify a
constant.  Otherwise you lose all your optimization possibilities.</p>
<p>For historical reasons, the assignment in</p>
<pre>
     my ($a, $b) = new Foo;</pre>
<p>will not distribute automatically over <code>$a</code> and <code>$b</code>.  If you want that,
use the <code>^=</code> hyperassignment instead, maybe.</p>
<p>Constraint lists are vaguely interesting, but seem to be too much
mechanism for the possible benefits.  If you really want a data type
that can be polymorphic, why not just define a polymorphic type?</p>
<p>In general, there seems to be a lot of confusion in this RFC between
constraints on variables and constraints on values.  For constraints
to be useful to the compiler, they have to be on the variable, and
you can't be "pushing" constraints at runtime.</p>
<p>On aliasing via subroutine calls, note that declared parameters will be
constant by default.</p>
<p>So anyway, although I'm rejecting this RFC, we'll certainly have a
declaration syntax resembling some of the tables in the RFC.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/106.html" name="rfc 106: yet another lexical variable proposal: lexical variables made default">RFC 106: Yet another lexical variable proposal: lexical variables made default</a></h3>
<p>Yes, it's true that other widely-admired languages like Ruby do
implicit declaration of lexicals, but I think it's a mistake, the
results of which don't show up until things start getting complicated.
(It's a sign of this weakness that in Ruby you see the workaround of
faking up an assignment to force declaration of a variable.)</p>
<p>I dislike the implicit declaration of lexicals because it tends to
defeat the primary use of them, namely, catching typos.  It's just too
easy to declare additional variable names by accident.  It's also too
easy to broaden the scope of a variable by accident.  You might have a
bunch of separate subroutines each with their own lexical, and suddenly
find that they're all the same variable because you accidentally used
the same variable name in the module initialization code.</p>
<p>When you think about it, requiring <code>my</code> on declaration is a
form of orthogonality.  Otherwise you find your default scoping
rules arbitrarily tied to an inner scope, or an outer scope, or a
subroutine scope.  All of these are suboptimal choices.  And I don't
buy the notion of using <code>my</code> optionally to disambiguate when you
feel like it.  Perl gives you a lot of rope to hang yourself with,
but this is the wrong kind of rope, because it obscures a needful
visual distinction.  Declarations should look like declarations, not
just to the programmer, but also to whoever has to read the program
after them, whether carbon-based or silicon-based.</p>
<p>And when it comes down to it, I believe that declarations with <code>my</code>
are properly Huffman encoded.  Declaring a lexical ought to be harder
than assigning to one.  And declaring a global ought to be harder
than declaring a lexical (at least within classes and modules).</p>
<p>
<h3><a href="http://dev.perl.org/rfc/119.html" name="rfc 119: object neutral error handling via exceptions">RFC 119: Object neutral error handling via exceptions</a></h3>
<p>Good goals, but I don't want yet another independent system of
exception handling.  Simplicity comes through unification.  Also, the
proposed syntax is all just a little too intertwingled for my tastes.
Let's see, how can I explain what I mean?</p>
<p>The out-of-band stuff doesn't stand out visually enough to me, and I
don't like thinking about it as control flow.  Nevertheless, I think
that what we've ended up with solves a number of the problems pointed
out in this RFC.  The RFC essentially asks for the functionality of
<code>POST</code>, <code>KEEP</code> and <code>UNDO</code> at a statement level.  Although <code>POST</code>,
<code>KEEP</code>, and <code>UNDO</code> blocks cannot be attached to any statement,
I believe that allowing <code>post</code>, <code>keep</code>, and <code>undo</code> properties
in scoped declarations is powerful enough, and gives the compiler
something tangible to attach the actions to.  There is a kind of
precision in attaching these actions to a specific variable--the state
is bound to the variable in a transactionally instantaneous way.
I'm afraid if we attach transactional actions to statements as the
RFC proposes, it won't be clear exactly when the statement's state
change is to be considered successful, since the transaction can't
"know" which operation is the crucial one.</p>
<p>Nonetheless, some ideas from this RFC will live on in the <code>post</code>,
<code>keep</code>, and <code>undo</code> property blocks.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/120.html" name="rfc 120: implicit counter in for statements, possibly $#.">RFC 120: Implicit counter in for statements, possibly $#.</a></h3>
<p>I am prejudiced against this one, simply because I've been burned too
many times by implicit variables that mandate implicit overhead.
I think if you need an index, you should declare one, so that if you
don't declare one, the compiler knows not to bother setting up for it.</p>
<p>Another problem is that people will keep asking what</p>
<pre>
    for (@foo,@bar) { print $# }</pre>
<p>is supposed to mean.</p>
<p>I expect that we'll end up with something more like what we discussed earlier:</p>
<pre>
    for @array.kv -&gt; $i, $elem { ... }</pre>
<p>
<h3><a href="http://dev.perl.org/rfc/262.html" name="rfc 262: index attribute">RFC 262: Index Attribute</a></h3>
<p>Everyone has a use for <code>:</code> these days...</p>
<p>This one seems not to be of very high utility, suffering from similar
problems as the RFC 120 proposal.  I don't think it's possible to
efficiently track the container of a value within each contained
object unless we know at compile time what a looping construct is,
which is problematic with user-defined control structures.</p>
<p>And what if an item is a member of more than one list?</p>
<p>Again, I'd rather have something declared so we know whether to take
the overhead.  Then we don't have to pessimize whenever we can't do
a complete static analysis.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/167.html" name="rfc 167: simplify do block syntax">RFC 167: Simplify do BLOCK Syntax</a></h3>
<p>I think the "do" on a <code>do</code> block is useful to emphasize that the
closure in the braces is to be executed immediately.  Otherwise Perl
(or the user (or both)) might be confused as to whether someone was
trying to write a closure that is to be executed later, particularly
if the block is the last item in a subroutine that might be wanting
to return a closure.  In fact, we'll probably outlaw bare blocks at
the statement level as too ambiguous.  Use <code>for 1 {}</code> or some such
when you want a one-time loop, and use <code>return</code> or <code>sub</code> when you
want to return a closure.</p>
<p>We'll solve the <code>;</code> problem by jiggering the definition of <code>{...}</code>, not
by fiddling with <code>do</code>.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/209.html" name="rfc 209: fuller integer support in perl.">RFC 209: Fuller integer support in Perl.</a></h3>
<p>The old <code>use integer</code> pragma was a hack.  I think I'd rather use types
and representation specs on individual declarations for compile-time
selection, or alternate object constructors for run-time selection,
particularly when infinite precision is desired.  I'm not against using
pragmas to alter the defaults, but I think it's generally better to
be more specific when you have the capability.  You can force your
programs to be lexically scoped with pragmas, but data wants to flow
wherever it likes to go, so your lexically scoped module had better
be able to deal rationally with any data thrown at it, even if it
isn't in the exact form that you prefer.</p>
<p>By the way, the RFC is misleading when it asserts that 32-bit integer
precision is lost when represented in floating point.  That's only
true if you use 32-bit floats.  Perl has always used 64-bit doubles,
which give approximately 15 digits of integer precision.  (The issue
does arise with 64-bit integers, of course.)</p>
<p>All that being said, Perl 6 will certainly have better support for
integer types of various sorts.  I just don't think that a pragma
redefining what an "integer" is will provide good documentation to
whoever is trying to understand the program.  Better to declare things
of type MagicNum, or whatever.</p>
<p>I could be wrong, of course.  If so, write your pragma, and have the
appropriate amount of fun.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/279.html" name="rfc 279: my() syntax extensions and attribute declarations">RFC 279: <code>my()</code> syntax extensions and attribute declarations</a></h3>
<p>We already treated this in Apocalypse 2.</p>
<p>The RFC assumes that the type always distributes over a <code>my</code> list.
This is not what is necessary for function signatures, which need
individual types for each formal argument.</p>
<p>And again, it doesn't make much sense to me to put properties on a
variable at run-time.</p>
<p>It makes even less sense to me to be able to declare the type of an
array element lexically.  This is the province of objects, not arrays
pretending to be structs.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/297.html" name="rfc 297: attributes for compiler hints">RFC 297: Attributes for compiler hints</a></h3>
<p>Sorry, we can't have the semantics suddenly varying drastically merely
because the user decided to run the program through a different translator.
I think there's a happy medium in there somewhere where we can have
the same semantics for both interpreter and compiler.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/309.html" name="rfc 309: allow keywords in sub prototypes">RFC 309: Allow keywords in sub prototypes</a></h3>
<p>This RFC is rejected only because it doesn't go far enough.  What we'll
eventually need is to allow a regex-ish syntax notation for parsing that
may be separate from the argument declarations.  (Then again, maybe
not.) In any event, I think some kind of explicit regex notation
is called for, not the promotion of identifiers to token matchers.
We may want identifiers in signatures for something else later, so
we'll hold them in reserve.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/340.html" name="rfc 340: with takes a context">RFC 340: with takes a context</a></h3>
<p>This seems like a solution in search of a problem.  Even if we end up with
a context stack as explicit as Perl 5's, I don't think the amount
we'll deal with it warrants a keyword.  (And I dislike "<code>return with;</code>"
as a needlessly opaque linguistic construct.)</p>
<p>That being said, if someone implements (as user-defined code)
the Pascalish <code>with</code> as proposed in RFC 342 (and rejected), and
if the <code>caller</code> function (or something similar) returns sufficient
information to build references to the lexical scope associated with
the call frame in question, then something like this could also be
implemented as user code.  I can't decide whether it's not clear
that this is a good idea, or it's clear that this is not a good idea.
In any event, I would warn anyone doing this that it's likely to be
extremely confusing, akin to goto-considered-harmful, and for
similar reasons, though in this case by displacing scopes rather than
control flow.</p>
<p>Note that some mechanism resembling this will be necessary for modules
to do exportation to a lexical scope (see <code>%MY</code> in Apocalypse 2).
However, lexical scope modification will be allowed only during the
compile time of the lexical scope in question, since we need to be
careful to preserve the encapsulation that lexical scoping provides.
Turning lexical variables back into dynamic variables will tend to
destroy that security.</p>
<p>So I think we'll stick with closures and continuations that don't
transport lexical scopes at runtime.</p>
<p>
<h3><a href="http://dev.perl.org/rfc/342.html" name="rfc 342: pascallike with">RFC 342: Pascal-like "with"</a></h3>
<p>I expect Perl's parsing to be powerful enough that you could write a
"with" if you wanted one.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S04.html">Synopsis 04</a> for the latest information.</em></p>

<h2><a name="withdrawn rfcs">Withdrawn RFCs</a></h2>
<p>
<h3><a href="http://dev.perl.org/rfc/63.html" name="rfc 063: exception handling syntax">RFC 063: Exception handling syntax</a></h3>
<p>
<h3><a href="http://dev.perl.org/rfc/113.html" name="rfc 113: better constants and constant folding">RFC 113: Better constants and constant folding</a></h3>
<p>
<hr>
<h1><a name="other decisions">Other decisions</a></h1>
<p>
<h3><a name="cstyle for loop">C-style for loop</a></h3>
<p>Due to syntactic ambiguities with the new <code>for</code> syntax of Perl 6,
the generalized C-style <code>for</code> loop is going to get its keyword changed
to <code>loop</code>.  And <code>for</code> will now always mean "foreach".  The expression
"pill" is now optional, so instead of writing an infinite loop like this:</p>
<pre>
    for (;;) {
        ...
    }</pre>
<p>you can now write it like this:</p>
<pre>
    loop {
        ...
    }</pre>
<p>
<h3><a name="cstyle do {} while expr no longer supported">C-style do {} while EXPR no longer supported</a></h3>
<p>In Perl 5, when you used a <code>while</code> statement modifier on a statement
consisting of nothing but a <code>do {}</code>, something magical happened, and
the block would be evaluated once before the condition was evaluated.
This special-cased construct, seldom used and often misunderstood, will
no longer be in Perl 6, and in fact will produce a compile-time error
to prevent people from trying to use it.  Where Perl 5 code has this:</p>
<pre>
    do {
        ...
    } while CONDITION;</pre>
<p>Perl 6 code will use a construct in which the control flow is more explicit:</p>
<pre>
    loop {
        ...
        last unless CONDITION;
    }</pre>
<p>
<h3><a name="bare blocks">Bare blocks</a></h3>
<p>In Perl 5, bare blocks (blocks used as statements) are once-through
loops.  In Perl 6, blocks are closures.  It would be possible to
automatically execute any closure in void context, but unfortunately,
when a closure is used as the final statement in an outer block,
it's ambiguous as to whether you wanted to return or execute the
closure.  Therefore the use of a closure at the statement level
will be considered an error, whether or not it's in a void context.
Use <code>do {}</code> for a "once" block, and an explicit <code>return</code> or <code>sub</code>
when you want to return a reference to the closure.</p>
<p>
<h3><a name="continue block">continue block</a></h3>
<p>The <code>continue</code> block changes its name to <code>NEXT</code> and moves inside the
block it modifies, to work like <code>POST</code> blocks.  Among other things, this
allows <code>NEXT</code> blocks to refer to lexical variables declared within the
loop, provided the <code>NEXT</code> block is place after them.  The generalized
loop:</p>
<pre>
    loop (EXPR1; EXPR2; EXPR3) { ... }</pre>
<p>can now be defined as equivalent to:</p>
<pre>
    EXPR1;
    while EXPR2 {
        NEXT { EXPR3 }
        ...
    }</pre>
<p>(except that any variable declared in <code>EXPR3</code> would have different
lexical scope).  The <code>NEXT</code> block is called only before attempting
the next iteration of the loop.  It is not called when the loop is
done and about to exit.  Use a <code>POST</code> for that.</p>
<p>Well, that about wraps it up for now.  You might be interesting to
know that I'm posting this from the second sesquiannual Perl Whirl
cruise, on board the Veendam, somewhere in the Carribean.  If the ship
disappears in the Bermuda Triangle, you won't have to worry about
the upcoming Exegesis, since Damian is also board.  But for now,
Perl 6 is cruising along, the weather's wonderful, wish you were here.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1240" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/09/perltk.html" rel="bookmark">Creating Custom Widgets</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Steve Lidie</span> on <abbr class="published" title="2002-01-09T00:00:00-08:00">January  9, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<p>
In this Perl/Tk article, I'll discuss balloon help, photos and widget
subclassing.  Help balloons can be attached to widgets, menu items,
and, as we'll see here, individual canvas items. Subclassing a Perl/Tk
widget is also known as creating a derived (mega) widget.  For this
article, I'll presume basic knowledge of mega widgets. If the subject is
new to you, or if there are points you don't understand, then please read
<a href="http://www.oreilly.com/catalog/mastperltk/">Mastering Perl/Tk</a>,
Chapter 14, <i>Creating Custom Widgets in Pure
Perl/Tk</i>, for complete details. Photos are described in Chapter 17,
<i>Images and Animations</i>, and balloon help is discussed in Chapter 23, 
<i>Plethora of pTk Potpourri</i>.
</p>

<p>
We are going to develop a color picker, a window that allows us to select
a color that we might use to configure an application. This widget
differs from most other color pickers you've seen because our palette
is a box of crayons.
</p>

<p>
<code>Tk::CrayolaCrayonColorPicker</code> is a
<code>Tk::DialogBox</code>-derived widget that allows a user to select
a color from a photo of a box of 64 Crayola crayons.  Nominally, one
positions the cursor over the desired crayon and clicks
<code>button-1</code>, whereupon the RGB values of the pixel under the
cursor are returned.  However, in reality, one can click anywhere over
the photo.
</p>

<p>
Balloon help is provided, so that if the cursor lingers over a crayon,
then a ballon pops up, displaying the crayon's actual color - for instance,
"robin's egg blue."
</p>



<p>
    Because <code>Tk::CrayolaCrayonColorPicker</code> is a subclass of
    <code>Tk::DialogBox</code>, the widget can have one or more buttons,
    with the default being a single <code>Cancel</code> button. This
    functionality is provided automatically by the superclass,
    <code>Tk::DialogBox</code>.
</p>

<p>
    Our widget also overrides the <code>Tk::DialogBox::Show()</code>
    method with one of its own.  We do this because, by definition,
    dialogs are modal, which means they perform a grab.
    Unfortunately, balloon help does not work with a grab in effect,
    so <code>Tk::CrayolaCrayonColorPicker::Show()</code> deiconifies
    the color picker window itself, waits for a color selection or a
    click on the <code>Cancel</code> button, and then hides the window.
  </p>

<p>
    The return value from our <code>Show()</code> method is either a
    reference to an array of three integers, the red, green and blue
    pixel triplet, or a string indicating which dialog button was
    clicked.
  </p>

<p>
Here's an example, which creates the window seen in Figure 1:
</p>

<pre>
    use Tk::CrayolaCrayonColorPicker;
    my $cccp = $mw->CrayolaCrayonColorPicker(-title => 'Crayon Picker');
    my $color = $cccp->Show;

    if ( ref($color) =~ /ARRAY/ ) {
        my ($r, $g, $b) = @$color;
        print "r/g/b=$r/$g/$b!\n";
    } else {
        print "no color selected, response=$color!\n";
    }
</pre>


<p><table border="0" width="100%" cellspacing="0" cellpadding="4" align="center">
<tr><td valign="top" bgcolor="#ffffff" width="*">
&nbsp;</td>
<td valign="top" bgcolor="#efefef" width="454" align="center">
<img src="/pub/2002/01/09/graphics/fig1.jpg" width="450" height="375" alt="Figure 1. -- Box of Crayons">
<p class="secondary"><b>Figure 1</b></p>
</td>
<td valign="top" bgcolor="#ffffff" width="*">
&nbsp;</td>
</tr>
</table></p>


<p>
Notice the use of the <code>-title</code> option. Since
<code>Tk::CrayolaCrayonColorPicker</code> is derived from
<code>Tk::DialogBox</code>, it supports all the option/value pairs
defined by its superclass, of which <code>-title</code> is one.
</p>

<p>
    Now let's look at the definition of class
    <code>Tk::CrayolaCrayonColorPicker</code>.  I like to place the
    module's version number as the first line of the file, making it
    easy for MakeMaker (and humans) to find it. (MakeMaker usage is
    also explained in Mastering Perl/Tk, Chapter 14, <i>Creating
    Custom Widgets in Pure Perl/Tk</i>.)
  </p>

<p>
Next is the package definition.
  </p>

<p>
    <code>Tk::widgets</code> is a fast way to use a list of
    widgets. It expands to "<code>use Tk::Widget1; use
    Tk::Widget2;</code>", and so on.
</p>

<p>
    The "<code>use base</code>" statement is important.  It tells
    us two things: First, that we are defining a derived widget
    (i.e. subclassing an existing widget), and, second, the precise
    widget being subclassed. Including <code>Tk::Derived</code> in a
    widget's <code>@ISA</code> array is the telltale marker of a
    derived widget.  Without <code>Tk::Derived</code>, the assumption
    is that we are creating a composite widget.
  </p>

<p>
    We then pre-declare a subroutine and enable a strict programming style.
  </p>

<p>
    The final statement in the module prologue actually defines the widget
    contructor name by modifying our symbol table, and performs other
    heavy magic, allowing us to use the new widget in the same manner as
    any other Perl/Tk widget.
  </p>

<pre>
$Tk::CrayolaCrayonColorPicker::VERSION = '1.0';

package Tk::CrayolaCrayonColorPicker;

use Tk::widgets qw/Balloon/;
use base        qw/Tk::Derived Tk::DialogBox/;
use subs        qw/pick_color/;

use strict;

Construct Tk::Widget 'CrayolaCrayonColorPicker';
  </pre>

<p>
    A <code>CrayolaCrayonColorPicker</code> widget is simply a canvas
    with a photo of a box of Crayola crayons covering it.  Since
    photos are objects that persist until they are destroyed, all
    widget instances can share the same photo. So we can create the
    photo from an image file once, and store its reference in a class
    global variable.  For sizing the canvas, we keep the photo's width
    and height in class variables, too.
  </p>

<pre>
our (
     $crayons,                  # Photo of a bunch of crayons
     $cray_w,                   # Photo width
     $cray_h,                   # Photo height
);
  </pre>

<p>
As part of class initialization, Perl/Tk makes a call to the <code>ClassInit()</code>
method.  This method serves to perform tasks for the class as a whole.
Here we create the photo object and define its dimensions.
  </p>

<pre>
sub ClassInit {

    my ($class, $mw) = @_;

    $crayons = $mw->Photo(-file => 'crayons.gif', -format => 'gif');
    ($cray_w, $cray_h) = ($crayons->width, $crayons->height);

    $class->SUPER::ClassInit($mw);

} # end ClassInit
  </pre>

<p>
    The heart of a widget module is <code>Populate()</code>, where we
    create new widget instances.  A
    <code>CrayolaCrayonColorPicker</code> widget consists of a canvas
    with a photo of a box of Crayola crayons (taken with my handy
    digital camera).  Clicking anywhere on the photo invokes a
    callback that fetches the RGB components of the pixel under the
    click.
  </p>

<p>
Additionally, transparent, trapezoidal, canvas polygons are
superimposed over the tips of each crayon, and each of these items has
a ballon help message associated with it. The message indicates the
crayon's color.
  </p>

<pre>
sub Populate {

    my ($self, $args) = @_;
  </pre>
  











  
  
<p>
Since we are a <code>Tk::DialogBox</code> widget at heart, set up a
default Cancel button to ensure our superclass' <code>Populate()</code>
has a chance to process the option list, then withdraw the window
until it's shown.
</p>

<pre>
    $args->{'-buttons'} = ['Cancel'] unless defined $args->{'-buttons'};
    $self->SUPER::Populate($args);

    $self->withdraw;
  </pre>

<p>
Create the canvas with its photo, and store the canvas reference and
the image id as instance variables.  We'll need access to both later.
  </p>

<pre>
    $self->{can} = $self->Canvas(
        -width  => $cray_w,
        -height => $cray_h,
    )->pack;
    $self->{iid} = $self->{can}->createImage(0, 0,
        -anchor => 'nw',
        -image  => $crayons,
    );
  </pre>

<p>
Define the canvas callback that fetches and returns an RGB
triplet. The <code>CanvasBind()</code> method operates on the entire
canvas, unlike the canvas' <code>bind()</code> method that operates on
an individual canvas tag or id.
  </p>

<pre>
    $self->{can}->CanvasBind('&lt;buttonrelease-1>' => [\&amp;pick_color, $self]);
</pre>

<p></p>

<p>
Next, create the tiny transparent trapezoids that cover the tip
of the 64 crayons, and define the balloon help. When specifying balloon 
help for one or more canvas items, the balloon widget expects its <code>-msg</code>
option to be a reference to a hash, where the hash keys are canvas tags or
ids, and the hash values are the balloon help text.
  </p>

<p>
So, we first create an instance variable that references an empty
anonymous hash, then invoke the private method
<code>make_balloon_items()</code> to do the dirty work.  The method
creates the canvas polygon items and populates the hash pointed to by
<code>$self->{col}</code>. Then, we create the balloon widget, and
attach the canvas and help messages.  The ballon text appears next to
the cursor.
   </p>
 
<pre>
    $self->{col} = {};         # anonymous hash indexes colors by id
    $self->make_balloon_items;

    $self->{bal} = $self->Balloon;
    $self->{bal}->attach($self->{can},
        -balloonposition => 'mouse', 
        -msg             => $self->{col},
    );

} # end Populate
  </pre>

<p>
Here's the class private method <code>make_balloon_items()</code>, which simply
makes 64 calls to <code>make_poly()</code>.
  </p>
<p>
The 64-crayon Crayola box in divided into 4 sections of 16 crayons
each.  Each section contains two rows of eight crayons.  These
subroutine calls create each section, starting with the section's
background row, followed by the section's foreground row.
  </p>
<p>
We create the polygons items from back to front so that the canvas
stacking order is back to front.  This ensures that the balloon help
of foreground polygons items takes precedence over background items.
  </p>

<p>
For obvious brevity, most of the <code>make_poly()</code> calls have
been removed.
  </p>

<pre>
sub make_balloon_items {

    my ($self) = @_;

    # 16 northwest crayons.

    $self->make_poly(132,   8, 'red');

    # 16 northeast crayons.

    $self->make_poly(306,  61, 'gray');

    # 16 southwest crayons.

    $self->make_poly(107,  97, 'brick red');

    # 16 southeast crayons.

    $self->make_poly(270, 157, 'tumbleweed');

} # end make_balloon_items
  </pre>

<p>
Given the coordinates of the point of a crayon, the class private
method <code>make_poly()</code> creates a transparent polygon over the
tip so we can attach a balloon message to it.  The message is the
crayon's color, and is stored in the hash pointed to by
<code>$self->{col}</code>, indexed by polygon canvas id.
  </p>

<p>
The transparent stipple is important, as it allows balloon events
to be seen.  The fill color is irrelevant; we just need something to
fill the polygon items so events are registered.
  </p>

<p>
If we remove the stipple, then the polygon items covering the crayon tips
become visible, as shown in Figure 2.
  </p>

<pre>
    sub make_poly {

        my ($self, $x, $y, $color) = @_;

        my $id = $self->{can}->createPolygon(
            $x-3, $y, $x+3, $y, $x+11, $y+38, $x-11, $y+38, $x-3, $y,
            -fill    => 'yellow',
            -stipple => 'transparent',
        );

        $self->{col}->{$id} = $color;

    } # end make_poly
  </pre>

<p><table border="0" width="100%" cellspacing="0" cellpadding="4" align="center">
<tr><td valign="top" bgcolor="#ffffff" width="*">
&nbsp;</td>
<td valign="top" bgcolor="#efefef" width="454" align="center">
<img src="/pub/2002/01/09/graphics/fig2.jpg" width="450" height="374" alt="Figure 2. -- Crayons with Yellow Tips">
<p class="secondary"><b>Figure 2.</b></p>
</td>
<td valign="top" bgcolor="#ffffff" width="*">
&nbsp;</td>
</tr>
</table></p>

  
  
<p>
Subroutine <code>pick_color()</code> is our last class private method.  It
demonstrates a rather dubious object oriented programming technique -
meddling with the internals of its superclass!  But we do this out of
necessity, as a workaround for the "balloons do not work with a grab"
bug.
  </p>

<p>
We want to override <code>Tk::DialogBox::Show</code>, so we need to know what its
<code>waitVariable()</code> is waiting for. It's this variable that the dialog
buttons set when we click on them, and it turns out to be
<code>$self->{'selected_button'}</code>.
  </p>

<p>
We make <code>pick_color()</code> set the same variable when returning
a pixel's RGB values, thus unblocking the <code>waitVariable()</code>
and returning the RGB data to the user.
  </p>

<p>
In case you're interested, early-on in the coding I determined the
coordinates of each crayon's point by printing $x and $y in this
callback.
  </p>

<pre>
    sub pick_color {

        my ($canvas, $self) = @_;
        my ($x, $y) = ($Tk::event->x, $Tk::event->y);
        my $i = $canvas->itemcget($self->{iid}, -image);
        $self->{'selected_button'} = $i->get($x, $y);

    } # end pick_color
  </pre>

<p>
Here is our only class public method, <code>Show()</code>.  We can't
use the standard DialogBox <code>Show()</code> method because the grab
interferes with balloon help.  So we roll our own, forgoing the modal
approach.  Control passes from <code>waitVariable()</code> in one of
two ways: 1) a color is selected (see <code>pick_color()</code>
above), or, 2), the <code>Cancel</code> button is activated.
  </p>

<pre>
    sub Show {

        my ($self) = @_;
        $self->Popup;
        $self->waitVariable(\$self->{'selected_button'});
        $self->withdraw;
        return $self->{'selected_button'};

    } # end Show
  </pre>

And that's it. Until next time ... <code>use Tk;</code>

<hr>
You can download the <a href="/2002/01/09/examples/CrayolaCrayonColorPicker.pm">class module</a>,
<a href="/2002/01/09/graphics/crayons.gif">associated .GIF file</a> and a <a href="/2002/01/09/examples/crayons.txt">test program</a> 
that uses the new class.

<hr size="1" noshade="noshade" />

<p>
O'Reilly &amp; Associates recently released (January 2002) <a href="http://www.oreilly.com/catalog/mastperltk/">Mastering Perl/Tk</a>. </p>

<ul> 
<li><p><a href="http://www.oreilly.com/catalog/mastperltk/chapter/ch15.html">Sample Chapter 15, Anatomy of the MainLoop</a>, is available free online. </p></li>

<li><p>
You can also look at the <a href="http://www.oreilly.com/catalog/mastperltk/toc.html">Table of Contents</a>, the <a href="http://www.oreilly.com/catalog/mastperltk/inx.html">Index</a>, and the <a href="http://oreilly.com/catalog/mastperltk/desc.html">Full Description</a> of the book. </p></li>

<li><p>
For more information, or to order the book, 
<a href="http://www.oreilly.com/catalog/mastperltk/">click here</a>. </p></li>  
</ul>






        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1248" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/p6pdigest/20020105.html" rel="bookmark">This Week on Perl 6 (30 December 2001 - 5 Jan 2002)</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Bryan Warnock</span> on <abbr class="published" title="2002-01-05T00:00:00-08:00">January  5, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <h3><a name="Notes">Notes</a></h3>
<p><csquery path="q/20" where="cs_rid != {cs_rid}"></p>
<p>
You can subscribe to an email version of this summary by sending an empty
message to 
<a href="mailto:perl6-digest-subscribe@netthink.co.uk">perl6-digest-subscribe@netthink.co.uk</a>.
</p>

<p>
This summary, as with past summaries, can be found in
<a href="http://members.home.com/bcwarno/Perl6/digests/">here</a>.  Please send additions, submissions, corrections, kudos, and complaints to 
<a href="mailto:bwarnock@capita.com">bwarnock@capita.com</a>.
</p>

<p>
For more information on the Perl 6 and Parrot development efforts, visit
<a href="http://dev.perl.org/perl6/">dev.perl.org</a> and
<a href="http://www.parrotcode.org/">parrotcode.org</a>.
</p>

<p>
There were 373 messages across 112 threads, with 50 authors contributing.
Most of the messages were patches.  For 2001, about 340 folks submitted
over 9000 messages across 1300 or so threads.  
<h3><a name="Generators">Generators</a></h3>

</p>

<p>

(8 posts) Clark C. Evans 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07228.html">asked</a> whether Parrot will support generators, a cousin to continuations.  Dan
Sugalski 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07241.html">says</a> coroutines and continuations are in, but didn't really answer about
generators.  (As a sidebar, the rest of the thread was an interesting 
discussion about Python's recent addition of generators and 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07246.html">how they work</a>.)
<h3><a name="Platform_Fixes">Platform Fixes</a></h3>

</p>

<p>

Win32 has had more work done on it; in particular, the continual makefile
problems.  LP64 environments, such as 64-bit Solaris and Tru64, also
received a much-needed fix, allowing them to finally work.
</p>

<h3><a name="Signed_vs_Unsigned">Signed vs. Unsigned</a></h3>


<p>

A huge signed-to-unsigned migration was finally begun.  Somewhere between
the original design and the initial code, the use of an unsigned partner
to INTVAL (The Type Formerly Known As IV) was dropped.  It's now been 
reintroduced, and implicitly unsigned values are slowly being converted.</p>

<h3><a name="Strings">Strings</a></h3>

<p>
There were a lot of cleanup and additions made to string support in Parrot.
There was a mild discussion on being able to 
<a href="http://archive.develooper.com/perl6-internals@perl.org/msg07307.html">dereference</a> a stringified address.</p>

<h3><a name="Fixed_sized_Output_Records">Fixed-sized Output Records</a></h3>


<p>
The language list received a
<a href="http://archive.develooper.com/perl6-language@perl.org/msg08840.html">question</a> from Tzadik Vanderhood, asking if a fixed-sized output record will be allowed,
in line with its input record counterpart:
<code>$/ =\80;</code>.
</p>

<p>
Aaron Sherman gave a 
<a href="http://archive.develooper.com/perl6-language@perl.org/msg08841.html">good response</a>.</p>
<h3><a name="Parroty_Bits">Parroty Bits</a></h3>



<p>

The 
<a href="http://donate.perl-foundation.org">Perl Development Grant Fund </a> creeped up to 26%.
</p>

<hr>

<a href="http://members.home.com/bcwarno/Perl6/">Bryan C. Warnock</a>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1238" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/01/02/bioinf.html" rel="bookmark">Beginning Bioinformatics</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">James D. Tisdall</span> on <abbr class="published" title="2002-01-02T00:00:00-08:00">January  2, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            

<p>
Bioinformatics, the use of computers in biology research, has been increasing
in importance during the past decade as the Human Genome Project went from
its beginning to the announcement last year of a "draft" of the complete
sequence of human DNA.
</p>

<p>
The importance of programming in biology stretches back before the previous decade.
And it certainly has a significant future now that it is a
recognized part of research into many areas of medicine and basic biological research.
This may not be news to biologists.
But Perl programmers may be surprised to find that their handsome language has
become one of the most - if not <em>the</em> most popular - of computer languages
used in bioinformatics.
</p>
<p>
My new book <a href="http://www.oreilly.com/catalog/begperlbio/"><strong>Beginning Perl for
Bioinformatics</strong></a> from <em>O'Reilly &amp; Associates</em> addresses
the needs of biologists who want to learn Perl programming.
In this article, I'm going to approach the subject from another,
almost opposite, angle.
I want to address the needs of Perl programmers who want
to learn biology and bioinformatics.
</p>



<p>
First, let me talk about ways to go from Perl programmer to &quot;bioinformatician&quot;.
I'll describe my experience, and give some ideas for making the jump.
Then, I'll try to give you a taste of modern biology by talking about
some of the technology used in the sequencing of genomes.
</p>

<h3>
My Experience
</h3>
<p>
Bioinformaticians generally have either a biology or programming background,
and then receive additional training in the other field.  The common wisdom
is that it's easier for biologists to pick up programming than the other
way around; but, of course, it depends on the individual.
How does one take the skills learned while programming in, say, the telecommunications industry,
and bring them to a job programming for biology?
</p>
<p>
I used to work at Bell Labs in Murray Hill, N.J., in the Speech Research Department.
It was my first computer programming job; I got to do stuff with computer sound, and learn
about speech science and linguistics as well.  I also got to do some
computer music on the side, which was fantastic for me.
I became interested in the theory of computer science, and entered academia full time
for a few years.
</p>
<p>
When it became time for me to get back to a regular salary, the Human Genome Project
had just started a bioinformatics lab
at the university where I was studying.
I had a year of molecular biology some years before as an undergraduate,
but that was before the PCR technique revolutionized the field.
At that time, I read Watson's
classic "The Molecular Biology of the Gene" and so I had an inkling about DNA,
which probably helped, and I knew I liked the subject.
I went over to meet the directors and leveraged
my Unix and C and Bell Labs background to get a job as the systems manager. 
(PCR, the polymerase chain reaction, is the way we make enough copies ("clones") of
a stretch of DNA to be able to do experiments on it.
After learning the basics of DNA -- keep reading! -- PCR would be a great topic to
start learning about molecular biology techniques.  I'll explain how in just a bit.)
</p>
<p>
In my new job I
started working with bioinformatics software, both supporting and writing it.
In previous years, I'd done practically no programming, having concentrated
on complexity theory and parallel algorithms.
Now I was plunged into a boatload of programming -- C, Prolog, Unix shell and
FORTRAN were the principal languages we used.
At that time, just as I was starting the job, a friend at the university pressed
his copy of <a href="http://oreilly.com/catalog/pperl3/">Programming Perl</a> into my hands.
It made a strong impression on me, and in short order I was turning to Perl
for most of the programming jobs I did.
</p>

<!--  sidebar begins  -->
<table width="187" border="0" cellspacing="12" cellpadding="6" align="right"><tr><td width="187" valign="top" bgcolor="#ffffff">
<a href="http://conferences.oreilly.com/biocon/"><img src="/images/conf/biocon2002/chrome.gif" width="162" height="100" border="0" alt="O'Reilly Bioinformatics Technology Conference" /></a>
<p class="medlist" style="color: #333333;">Don't miss the <a href="http://conferences.oreillynet.com/cs/bio2002/view/e_sess/1935">Beginning Perl for Bioinformatics session</a>, Monday, January 28, 2002, at the <a href="http://conferences.oreilly.com/biocon/">O'Reilly Bioinformatics Technology Conference</a>.</p>
<img src="/images/conf/biocon2002/chrome_rule.gif" width="162" height="5" border="0" alt=" " />
</td></tr></table>
<!--  sidebar ends  -->

<p>
I also started hanging out with the genome project people.  I took some
graduate courses
in human genetics and molecular biology, which helped me a lot in understanding
what everyone around me was doing.
</p>
<p>
After a few years, when the genome project closed down at my university, I went to
other organizations to do bioinformatics, first at a biotech startup, then at a national
comprehensive cancer center, and now consulting for biology researchers.
So that's my story in a nutshell, which I offer as one man's path from programming to bioinformatics.
</p>
<h3>
Bringing Programming to Biology
</h3>
<p>
Especially now that bioinformatics is seen as an important field, many biology
researchers are adding bioinformatics to their grant proposals and research programs.
I believe the kind of path that I took is even more possible now than
then, simply due to the amount of bioinformatics funding and jobs that are now staffed.
Find biology research organizations that are advertising for programmers,
and let them know you have the programming skills and the interest in biology
that would make you an asset to their work.
</p>
<p>
But what about formal training?
It's true that the ideal bioinformatician has graduate degrees in both computer
science and biology.  But such people are extremely rare.
Most workers in the field have a good mix of computer and biology skills,
but their degrees tend to come from one or the other.
Still, formal training in biology is a good way for a computer programmer
to learn about bioinformatics, either preceding or concurrently with a
job in the field.
</p>
<p>
I can understand the reluctance to face another degree.
(I earned my degrees with a job and a family to support, and it was stressful at times.)
Yes, it is best to get a degree if you're going to be working in biology.
A masters degree is OK, but most of the best 
jobs go to those who have their doctrate degree. They are, however, in ample supply and often get relatively low pay, as in
postdoc positions that are frequently inhabited for many years.
So the economic benefit of formal training in biology is not great, compared to what you
may be earning as a computer expert.  But at present bioinformatics pays OK.
</p>
<p>
On the other hand, to really work in biology, training is a good thing.  It's
a deep subject, and in many ways quite dissimilar to computer science or electrical
engineering or similar fields.  It has many surprises, and the whole "wet lab" experimental 
approach is hard to get out of books.
</p>
<p>
For self-study, there's one book that I think is a real gem for Perl programmers who want to learn
about modern biology research.
The book is called "Recombinant DNA," by the co-discoverer of the structure
of DNA, James Watson, and his co-authors Gilman, Witkowski, Zoller, and Witkowski.
The book was deliberately written for a wide audience, so you can start at the beginning
with an explanation of what, exactly, are DNA and proteins, the two most important types
of molecules in biology.  But it goes on to introduce a wide range of fundamental topics
in biology research, including explanations of the molecular biology laboratory techniques
that form the basis of the revolution and the golden age in biology that we're now experiencing.
I particularly like the use of illustrations to explain the techniques and the biology --
they're outstanding.
In my jobs as manager of bioinformatics, I've always strongly urged the programmers to keep
the book around and to dip into it often.
</p>
<p>
The book does have one drawback, however.  It was published in 1992.  Ten years is as long in
biology as it is in computer technology; so "Recombinant DNA" will not go into newer stuff such as microarrays or SNPs.
(And don't get the even earlier "Recombinant DNA: A Short Course" -- the 1992
edition is the one to get for now.)
But what it does give you is a chance to really
understand the fundamental techniques of modern molecular biology; and if you want to bring
your Perl programming expertise to a biology research setting, then this is a great way to get
a good start getting the general idea.
</p>














<p>
There are a few other good books out, and several more coming during the next year, in the
bioinformatics field.
Waterman; Mount; Grant and Ewens; Baxevanis et al, and Pevzner are a few of the most popular
books (some more theoretical than others).
My book, although for beginning
programmers, may be helpful in the later chapters to get an idea of basic
biological data and programs.
Gibas and Jambeck's book <a href="http://www.oreilly.com/catalog/bioskills/">Developing Bioinformatics Computer Skills</a> gives a 
good overview of
much of the software and the general computational approach that's used in bioinformatics,
although it also includes some beginning topics unsuitable for the experienced programmer.
</p>



<p>
Of all the bioinformatics programs that one might want to learn about,
the Perl programmer will naturally gravitate toward the Bioperl project.
This is an open-source, international collaborative effort to write useful Perl bioinformatics
modules, and it has reached a point during the past few years where it is quite useful stuff.
The 1.0 release may be available by the time you read this.
Exploring this software, available at http://www.bioperl.org, is highly recommended, with
one caveat: It does not include much tutorial material, certainly not for teaching basic
biology concepts.  Still, you'll find lots of great stuff to explore and use in Bioperl.
It's a must for the Perl bioinformatician.
</p>
<p>
Apart from self-study, you may also want to try to get into some seminars or reading groups at the
local university or biotech firm, or generally meet people.
If you're job hunting, then you may want to go introduce
yourself to the head of the biology department at the U, and let her (yes, there are
a lot of women working in biology research, a much better situation than in programming)
-- know that
you want a bioinformatics job and that you are a wizard at 1) programming in
general, 2) Web programming, and 3) getting a lot out of computers for minimal
money.
But be prepared for them to have sticker shock when it comes to salaries.
Maybe it's getting a
little better now, but I've often found that biologists want to pay you about
half of what you're worth on the market.  Their pay level is just lower than
that in computer programming.
When you get to that point, you might have to be a bit hardnosed during salary
negotiations to maintain your children's nutritional requirements.
</p>
<p>
I don't know of a book or training program that's
specifically targeted at programmers interested in learning
about biology.
However, many universities have started offering bioinformatics courses, training programs, and even degrees,
and some of their course offerings are designed for the experienced programmer.
You might consider attending one of the major bioinformatics conferences.
However, there will be a tutorial aimed at you
in the <a href="http://conferences.oreilly.com/biocon/">upcoming O'Reilly bioinformatics conference</a> -- indeed, the main focus of
that conference is from the programming side more than the biology side.
</p>
</p>
Apart from the upcoming O'Reilly conference already mentioned,
there is the <a href="http://www.ismb.org">ISMB conference</a>,
the largest in the bioinformatics field, which is in Calgary this
coming summer; a good place to meet people and learn.
It will also play host to the Bioperl yearly meeting, which is directly on target.
Actually, if you check out the presenters at the ISMB, RECOMB or O'Reilly conferences, then you will find
computer science people who are specializing in biology-related problems, as well as biologists
specializing in infomatics, and
many of these will be many of these will be lab heads or managers who maintain staffs of programmers.
</p>
<p>
The thing about biology is that it's a very large area.  Most researchers stake out a
claim to some particular system -- say, the regulation of nervous system development in the fly -- and work there.  So it's hard to really prepare yourself for the particular biology you might find on the job.  The "Recombinant DNA" book will give you an overview of some of the more important techniques that are commonly used in most labs.
</p>
<h3>
A Taste of Molecular Biology
</h3>
<p>
Now that I've given you my general take on how a Perl programmer could move into
biology research, I'll turn my attention to two basic molecular biology techniques that
are fundamental in biology research, as for instance in the Human Genome Project:
restriction enzymes and cloning with PCR.
</p>
<p>
First, we have to point out that the two most important biological molecules, DNA
and proteins, are both polymers, which are chains of smaller building block molecules.  DNA
is made out of four building blocks, the nucleotides or "bases"; proteins are made
from 20 amino acids.  DNA has a regular structure, usually the famous double helix
of two complementary strands intertwined; whereas proteins fold up
in a wide variety of ways that have an important effect on what the proteins are
able to do inside the cell.
DNA is the primary genetic material that transmits traits to succeeding generations.
Finally, DNA contains the coded templates from which
proteins are made; and proteins accomplish much of the work of the cell.
</p>
<p>
One important class of proteins are <EM>enzymes</EM>, which promote certain specific
chemical reactions in the cell.
In 1978 the Nobel Prize
was awarded to Werner Arber, Daniel Nathans, and Hamilton Smith for their discovery
and work on <EM>restriction enzymes</EM> in the 1960s and early 1970s.
Restriction enzymes are a large group of enzymes that have the
useful property of cutting DNA at specific locations called <EM>restriction sites</EM>.
This has been exploited in several important ways.
It has been an important technique in <EM>fingerprinting</EM> DNA, as is used in forensic
science to identify individuals.
It has been instrumental in developing <EM>physical maps</EM>, which are known positions
along DNA and are used to zero in on the location of genes, and also serve as a
reference point for the lengthy process of the determination of the entire sequence of bases
in DNA.
</p>
<p>
Restriction enzymes are fundamental to modern biological research.
To learn more about them, you could go to the <A href="http://www.neb.com/rebase ">REBASE</A>
restriction enzyme database where detailed information about
all known restriction enzymes is collected.  Many of them are easily ordered
from supply houses for use in the lab.
</p>
<p>
One of the most common restriction
enzymes is called EcoRI.  When it finds the six bases GAATTC along a strand
of DNA, it cleaves the DNA.
</p>
<p>
The other main technique I want to introduce is one already mentioned: PCR, or
the polymerase chain reaction.
This is the most important way that DNA samples are cloned, that is, have copies made.
PCR is very powerful at this; in a short time many millions of copies of a stretch of
DNA can be created, at which point there is enough of a "sample" of the DNA to perform
other molecular biology experiments, such as determining what exactly is the sequence
of bases in the DNA (as has been accomplished for humans in the Human Genome
Project.)
</p>
<p>
PCR also won a Nobel prize for its invention, by Kary Mullis in 1983.
The basic idea is quite simple.  We've mentioned that the two intertwined strands of
the double helix of DNA are complementary.  They are different, but given one strand
we know what the other strand is, as they always pair in a specific way.  PCR
exploits this property.
</p>
<h3>
Motivation
</h3>
<p>
It's clear that a short article is not going to get very far in introducing a major science
such as biology.  But I hope I've given you enough pointers to enable you to make a good
start at learning about this explosive science, and about how a Perl programmer might
be able to bring needed skills to the great challenge of understanding life and 
curing disease.
</p>
<p>
In the 10 years I've been working in biology, I've found it to be a really exciting
field, very stimulating intellectually; and I've found that going to work
to try to help to cure cancer, Alzheimer's disease, and others,
has been very satisfying emotionally.
</p>
<p>
I wish you the very best of luck.  If you make it to the <a href="http://conferences.oreilly.com/biocon/">O'Reilly conference</a>, please
look me up!
</p>







        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/2001/12/">&laquo; December 2001</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/2002/02/">February 2002 &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2014/02/">February 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2014/01/">January 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/10/">October 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/01/">January 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/12/">December 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/11/">November 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/10/">October 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/08/">August 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/06/">June 2012 (11)</a></li>
        
    
        
            <li><a href="/pub/2012/05/">May 2012 (18)</a></li>
        
    
        
            <li><a href="/pub/2012/04/">April 2012 (17)</a></li>
        
    
        
            <li><a href="/pub/2012/02/">February 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/12/">December 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/09/">September 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/08/">August 2011 (2)</a></li>
        
    
        
            <li><a href="/pub/2011/06/">June 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/05/">May 2011 (3)</a></li>
        
    
        
            <li><a href="/pub/2011/04/">April 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/03/">March 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/02/">February 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/01/">January 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/11/">November 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/10/">October 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/09/">September 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/08/">August 2010 (3)</a></li>
        
    
        
            <li><a href="/pub/2010/07/">July 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/04/">April 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/03/">March 2010 (4)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.13-en" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

            <div class="widget-creative-commons widget">
                <div class="widget-content">
                    This blog is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons License</a>.
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
