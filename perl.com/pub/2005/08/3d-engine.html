<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    
    <link rel="prev bookmark" href="/pub/2005/07/20050728.html" title="This Week in Perl 6, July 20-26, 2005" />
    <link rel="next bookmark" href="/pub/2005/08/20050804.html" title="This Week in Perl 6, through August 2, 2005" />
    
    
    <title>Building a 3D Engine in Perl, Part 4 - Perl.com</title>
</head>
<body id="perl-com" class="mt-entry-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <div id="entry-812" class="entry-asset asset hentry">
                                <div class="asset-header">
                                    <h1 id="page-title" class="asset-name entry-title">Building a 3D Engine in Perl, Part 4</h1>
                                    <div class="asset-meta">
                                        <span class="byline">

                                            By <span class="vcard author">Geoff Broadwell</span> on <abbr class="published" title="2005-08-04T00:00:00-08:00">August  4, 2005 12:00 AM</abbr>

                                        </span>


                                    </div>
                                </div>
                                <div class="asset-content entry-content">

                                    <div class="asset-body">
                                        
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />
<p>This article is the fourth in a series aimed at <a
href="/pub/au/Broadwell_Geoff">building a full 3D engine in Perl</a>. The <a
href="/pub/a/2004/12/01/3d_engine.html">first article</a> started with basic
program structure and worked up to displaying a simple depth-buffered scene in
an OpenGL window. The <a href="/pub/a/2004/12/29/3d_engine.html">second
article</a> followed with a discussion of time, view animation, SDL events,
keyboard handling, and a nice chunk of refactoring. The <a
href="/pub/a/2005/02/17/3d_engine.html">third article</a> continued with
screenshots, movement of the viewpoint, simple OpenGL lighting, and subdivided
box faces.</p>

<p>At the end of the last article, the engine was quite slow. This article shows
how to locate the performance problem and what to do about it. Then it
demonstrates how to apply the same new OpenGL technique a different way to
create an on-screen frame rate counter. As usual, you can follow along with the
code by downloading the <a href="/2005/08/04/examples/perl_opengl_examples_4.tar.gz">sample
code</a>.</p>

<h3>SDL_perl Developments</h3>

<p>First, there is some good news--Win32 users are no longer left out in the
cold. Thanks to Wayne Keenan, SDL_perl 1.x now fully supports OpenGL on Win32,
and prebuilt binaries are available. There are more details at the new <a
href="http://www.broadwell.org/graphics/sdl-perl/">SDL_perl 1.x page</a> on my
site; browse the Subversion repository at <a
href="http://svn.openfoundry.org/sdlperl1/">svn.openfoundry.org/sdlperl1</a>.</p>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/911" template="b/article_sidebar.view">
<!-- sidebar ends -->
<p>If you'd like to help in the efforts to improve SDL_perl 1.x, please come
visit the <a href="http://www.broadwell.org/graphics/sdl-perl/">SDL_perl 1.x
page</a>, check out the <a href="http://svn.openfoundry.org/sdlperl1/">code</a>
and send me comments or patches, or ping me in <code>#sdlperl</code> on
<code>irc.freenode.net</code>.</p>

<h3>Benchmarking the Engine</h3>

<p>As I mentioned in the introduction, when last I left off, the engine pretty
much crawled. It's time to figure out why and figure out what to do about it.
The right tool for the first job is a <em>profiler</em>, which watches a
running program and keeps track of the performance of each part of it. Perl's native
profiler is <code>dprofpp</code>, which tracks time spent and call count for
every subroutine in the program. Examining these numbers will reveal if the
engine spends most of its time in one routine, which will then be the focus for
optimization.</p>

<p>It's best if these numbers are relatively repeatable from run to run, making
it easy to compare profiles before and after a change. For a rendering engine,
the easiest solution is a benchmark mode. In benchmark mode, the engine runs for
a set period of time or number of frames, displaying a predefined scene or
sequence. I chose to enable benchmark mode with a new setting in
<code>init_conf</code>:</p>

<pre><code>benchmark =&gt; 1,</code></pre>

<p>The engine already displays a constant scene as long as the user doesn't
press any keys; the remaining requirement is to quit after a set period.</p>

<p>In previous articles I've simply hardcoded an out-of-time check into the
rendering loop, but this time I opted for a more general approach, using
<em>triggered events</em>.  Engine events so far have always come from SDL in
response to external input, such as key presses and window close events. In
contrast, the engine itself produces triggered events in response to changes in
the state of the simulated world, such as a player attempting to open a door or
attack an enemy.</p>

<p>To gather these events, I added two new lines to the beginning of
<code>do_events</code>; the opening lines are now:</p>

<pre><code>sub do_events
{
    my $self = shift;

    my $queue     = $self-&gt;process_events;
    my $triggered = $self-&gt;triggered_events;
    push @$queue, @$triggered;</code></pre>

<p>After processing the SDL events with <code>process_events</code> and
stuffing the resulting commands into the <code>$queue</code>,
<code>do_events</code> calls <code>triggered_events</code> to gather commands
from any pending internally generated events and adds them to the
<code>$queue</code>.  <code>triggered_events</code> can be pretty simple for
now:</p>

<pre><code>sub triggered_events
{
    my $self = shift;

    my @queue;
    push @queue, 'quit' if $self-&gt;{conf}{benchmark} and
                           $self-&gt;{world}{time} &gt;= 5;
    return \@queue;
}</code></pre>

<p>This is pretty much a direct translation of the old hardcoded timeout code
to the command queue concept. Normally <code>triggered_events</code> simply
returns an empty arrayref, indicating no events were triggered, and therefore
no commands generated. Benchmark mode adds a quit command to the queue as soon
as the world time reaches 5 seconds. Normal command processing in
<code>do_events</code> will take care of the rest.</p>













<h3><code>dprofpp</code> is Your (Obtuse) Friend</h3>

<p>With benchmark mode enabled, the engine runs under <code>dprofpp</code>. The
first step is to collect the profile data:</p>

<pre><code>dprofpp -Q -p step065</code></pre>

<p><code>-p step065</code> tells <code>dprofpp</code> to <em>p</em>rofile the
program named <code>step065</code>, and <code>-Q</code> tells it to
<em>q</em>uit after collecting the data.  <code>dprofpp</code> ran
<code>step065</code>, collected the profile data, and stored it in a
specially formatted text file named
<em>tmon.out</em> in the current directory.</p>

<p>To turn the profile data into human-readable output, I used
<code>dprofpp</code> without any arguments. It crunched the collected data for
a while and finally produced this:</p>

<pre><code>$ dprofpp
Exporter::Heavy::heavy_export_to_level has 4 unstacked calls in outer
Exporter::export_to_level has -4 unstacked calls in outer
Exporter::export has -12 unstacked calls in outer
Exporter::Heavy::heavy_export has 12 unstacked calls in outer
Total Elapsed Time = 4.838377 Seconds
  User+System Time = 1.498377 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 88.1   1.320  1.320      1   1.3200 1.3200  SDL::SetVideoMode
 38.1   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 16.0   0.240  0.341      8   0.0300 0.0426  SDL::OpenGL::BEGIN
 13.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 11.3   0.170  0.170      1   0.1700 0.1700  DynaLoader::dl_load_file
 9.34   0.140  0.020     12   0.0116 0.0017  Exporter::export
 6.67   0.100  0.100   1001   0.0001 0.0001  SDL::in
 4.00   0.060  0.060      1   0.0600 0.0600  SDL::Init
 3.34   0.050  0.847      8   0.0062 0.1059  main::BEGIN
 2.00   0.030  0.040      5   0.0060 0.0080  SDL::Event::BEGIN
 1.80   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 1.47   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.33   0.020  0.020      1   0.0200 0.0200  warnings::BEGIN
 1.33   0.020  0.020     16   0.0012 0.0012  Exporter::as_heavy
 1.33   0.020  0.209      5   0.0040 0.0418  SDL::BEGIN</code></pre>

<p>There are several problems with this output. The numbers are clearly silly
(88 percent of its time spent in <code>SDL::SetVideoMode</code>?), the statistics for
the various <code>BEGIN</code> blocks are inconsequential to the task and in
the way, and the error messages at the top are rather disconcerting. To fix
these issues, <code>dprofpp</code> has the <code>-g</code> option, which tells
<code>dprofpp</code> to only display statistics for a particular routine and
its descendants:</p>

<pre><code>$ dprofpp -g main::main_loop
Total Elapsed Time = 4.952042 Seconds
  User+System Time = 0.812051 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 70.3   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 24.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 3.32   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 2.71   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.23   0.010  0.010     49   0.0002 0.0002  SDL::OpenGL::Rotate
 1.11   0.009  0.009      7   0.0013 0.0013  main::prep_frame
 1.11   0.009  0.009     70   0.0001 0.0001  SDL::OpenGL::Color
 0.25   0.002  0.002   2947   0.0000 0.0000  SDL::OpenGL::Begin
 0.00       - -0.000      1        -      -  main::action_quit
 0.00       - -0.000      2        -      -  SDL::EventType
 0.00       - -0.000      2        -      -  SDL::Event::type
 0.00       - -0.000      7        -      -  SDL::GetTicks
 0.00       - -0.000      7        -      -  SDL::OpenGL::Clear
 0.00       - -0.000      7        -      -  SDL::OpenGL::GL_NORMALIZE
 0.00       - -0.000      7        -      -  SDL::OpenGL::GL_SPOT_EXPONENT</code></pre>

<p>You may have noticed that I specified <code>main::main_loop</code> instead
of just <code>main_loop</code>.  <code>dprofpp</code> always uses
fully qualified names and will give empty results if you use
<code>main_loop</code> without the <code>main::</code> package qualifier.</p>

<p>In this exclusive times view, the percentages in the first column and the
row order depend only on the runtime of each routine, without respect to its
children. Using just this view, I might have tried to optimize
<code>draw_quad_face</code> somehow, as it appears to be the most expensive
routine by a large margin.  That's not the best approach, however, as an
inclusive view (<code>-I</code>) shows:</p>

<pre><code>$ dprofpp -I -g main::main_loop
Total Elapsed Time = 4.952042 Seconds
  User+System Time = 0.812051 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 100.       -  0.814      7        - 0.1163  main::do_frame
 99.9       -  0.812      1        - 0.8121  main::main_loop
 99.7       -  0.810      7        - 0.1158  main::draw_view
 99.2       -  0.806      7        - 0.1151  main::draw_frame
 98.6   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 95.3   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 24.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 2.71   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.23   0.010  0.010     49   0.0002 0.0002  SDL::OpenGL::Rotate
 1.11   0.009  0.009     70   0.0001 0.0001  SDL::OpenGL::Color
 1.11   0.009  0.009      7   0.0013 0.0013  main::prep_frame
 0.25   0.002  0.002   2947   0.0000 0.0000  SDL::OpenGL::Begin
 0.00       - -0.000      1        -      -  main::action_quit
 0.00       - -0.000      2        -      -  SDL::EventType
 0.00       - -0.000      2        -      -  SDL::Event::type</code></pre>

<p>In this view, <code>draw_quad_face</code> looks even worse, because the first
column now includes the time taken by all of the OpenGL calls inside of it,
including tens of thousands of <code>glVertex</code> calls. It seems that I
should do something to speed it up, but at this point it's not entirely clear
how to simplify it or reduce the number of OpenGL calls it makes (other than
reducing the subdivision level of each face, which would reduce rendering
quality).</p>

<p>Actually, there's a better option. The real problem is that
<code>draw_cube</code> dominates the execution time, and
<code>draw_quad_face</code> dominates that. How about not calling
<code>draw_cube</code> (and therefore <code>draw_quad_face</code>) <em>at
all</em> during normal rendering? It seems extremely wasteful to have to tell
OpenGL how to render a cube face dozens of times each frame. If only there were
a way to tell OpenGL to remember the cube definition once, and just refer to
that definition each time the engine needs to draw it.</p>













<h3>Display Lists</h3>

<p>I expect no one will find it surprising that OpenGL provides exactly this
function, with the <em>display lists</em> facility. A display list is a list of
OpenGL commands to execute to perform some function. The OpenGL driver stores
it (sometimes in a mildly optimized format) and further code refers to it by
number. Later, the program can request that OpenGL run the commands in some
particular list as many times as desired. Lists can even call other lists; a
bicycle model might call a wheel display list twice, and the wheel display list
might itself call a spoke display list dozens of times.</p>

<p>I added <code>init_models</code> to create display lists for each shape I
want to model:</p>

<pre><code>sub init_models
{
    my $self = shift;

    my %models = (
        cube =&gt; \&amp;draw_cube,
    );
    my $count  = keys %models;
    my $base   = glGenLists($count);
    my %display_lists;

    foreach my $model (keys %models) {
        glNewList($base, GL_COMPILE);
        $models{$model}-&gt;();
        glEndList;

        $display_lists{$model} = $base++;
    }

    $self-&gt;{models}{dls} = \%display_lists;
}</code></pre>

<p><code>%models</code> associates each model with the code needed to draw it.
Because the engine already knows how to draw a cube, I simply reused
<code>draw_cube</code> here. The next two lines begin the work of building the
display lists. The code first determines how many display lists it needs and
then calls <code>glGenLists</code> to allocate them. OpenGL numbers the
allocated lists in sequence, returning the first number in the sequence (the
<em>list base</em>). For example, if the code had requested four lists, OpenGL
might have numbered them 1051, 1052, 1053, and 1054, and would then return 1051
as the list base.</p>

<p>For each defined model, <code>init_models</code> calls
<code>glNewList</code> to tell OpenGL that it is ready to compile a new display
list at the number <code>$base</code>. OpenGL then prepares to convert any
subsequent OpenGL calls to entries in the list, rather than rendering them
immediately. If I had chosen <code>GL_COMPILE_AND_EXECUTE</code> instead of
<code>GL_COMPILE</code>, OpenGL would perform the rendering and save the calls
in the display list at the same time. <code>GL_COMPILE_AND_EXECUTE</code> is
useful for on-the-fly caching when code needs active rendering anyway. Because
<code>init_models</code> is simply precaching the rendering commands and
nothing should render while this occurs, <code>GL_COMPILE</code> is the better
choice.</p>

<p>The code then calls the drawing routine, which conveniently submits all of
the OpenGL calls needed for the new list. The call to <code>glEndList</code>
then tells OpenGL to stop recording entries in the display list and return to
normal operation. The model loop then records the display list number used by
the current model in the <code>%display_lists</code> hash, and increments
<code>$base</code> for the next iteration. After processing all of the models,
<code>init_models</code> saves <code>%display_lists</code> into a new structure
in the engine object.</p>

<p><code>init</code> calls <code>init_models</code> just before
<code>init_objects</code>:</p>

<pre><code>$self-&gt;init_models;
$self-&gt;init_objects;</code></pre>

<p>With this initialization in place, the next step was to change
<code>draw_view</code> to draw from either a model or a draw routine. To do
this, I replaced the <code>$o-&gt;{draw}-&gt;()</code> call with:</p>

<pre><code>    if ($o-&gt;{model}) {
        my $dl = $self-&gt;{models}{dls}{$o-&gt;{model}};
        glCallList($dl);
    }
    else {
        $o-&gt;{draw}-&gt;();
    }</code></pre>

<p>If the object has an associated model, <code>draw_view</code> looks up the
display list in the hash created by <code>init_models</code>, and then calls
the list using <code>glCallList</code>. Otherwise, <code>draw_view</code> falls
back to calling the object's draw routine as before. A quick run confirmed that
the fallback works and adding <code>init_models</code> didn't break anything,
so it was safe to change <code>init_objects</code> to use models instead of
draw routines for the cubes. This involved replacement of just three lines--I
changed each copy of:</p>

<pre><code>        draw        =&amp; \&amp;draw_cube,</code></pre>

<p>to:</p>

<pre><code>        model       =&amp; 'cube',</code></pre>

<p>Suddenly, the engine was <em>much</em> faster and more responsive. A
<code>dprofpp</code> run confirmed this:</p>

<pre><code>$ dprofpp -Q -p step068

Done.
$ dprofpp -I -g main::main_loop
Total Elapsed Time = 4.053240 Seconds
  User+System Time = 0.973250 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 99.9       -  0.973      1        - 0.9733  main::main_loop
 86.5   0.024  0.842    413   0.0001 0.0020  main::do_frame
 58.1   0.203  0.566    413   0.0005 0.0014  main::draw_view
 56.9   0.016  0.554    413   0.0000 0.0013  main::draw_frame
 20.1   0.196  0.196    413   0.0005 0.0005  SDL::GLSwapBuffers
 19.3       -  0.188    413        - 0.0005  SDL::App::sync
 18.4       -  0.180    413        - 0.0004  main::end_frame
 16.7   0.163  0.163   2891   0.0001 0.0001  SDL::OpenGL::CallList
 9.14   0.028  0.089    413   0.0001 0.0002  main::do_events
 8.53   0.035  0.083    413   0.0001 0.0002  main::prep_frame
 6.68   0.008  0.065    413   0.0000 0.0002  main::process_events
 5.03   0.049  0.049   3304   0.0000 0.0000  SDL::OpenGL::GL_LIGHTING
 4.93   0.002  0.048    413   0.0000 0.0001  SDL::Event::pump
 4.73   0.046  0.046    413   0.0001 0.0001  SDL::PumpEvents
 4.11   0.012  0.040    413   0.0000 0.0001  main::update_time</code></pre>

<p>Note that I had to run <code>dprofpp -Q -p</code> again with the new code
before doing the analysis, or <code>dprofpp</code> would have just reused the
old <code>tmon.out</code>.</p>

<p>The first thing to note in this report is that previously the engine only
managed seven frames (calls to <code>do_frame</code>) before timing out, but now
managed 413 in the same time! Secondly, as intended, <code>main_loop</code>
never calls <code>draw_cube</code>, having replaced all such calls with calls
to <code>glCallList</code>. Because of this it is no longer necessary to do
many thousands of low-level OpenGL calls to draw the scene each frame, with the
attendant Perl and XS overhead. Instead, the OpenGL driver handles all of those
calls internally, with minimal overhead.</p>

<p>This has the added advantage that it is now feasible to run the engine on
one computer and display the window on another, as the OpenGL driver on the
displaying computer saves the display lists. Once <code>init_models</code>
compiles the display lists, they are loaded into the display driver, and future
frames require minimal network traffic to handle <code>glCallList</code>.
(Adventurous users running X can do this by logging in locally to the display
computer, <code>ssh</code>ing to the computer that has the engine and SDL_perl
on it, and running the program there. If your <code>ssh</code> has X11
forwarding turned on, your reward should be a local window. And there was much
rejoicing.)</p>













<h3>An FPS Counter</h3>

<p>The measurements that <code>dprofpp</code> performs have enough overhead to
significantly reduce the engine's apparent performance. (Even old hardware can
do better than 80-100 FPS with this simple scene.) The overhead is necessary to
get a detailed analysis, but when it comes time to show off, most users want to
have a nice frame rate display showing the performance of the engine running as
fast as it can.</p>

<p>Making a frame rate display requires the ability to render text in front of
the scene. The necessary pieces of that are:</p>

<ol>

<li>A font containing glyphs for the characters to display (at least 0 through
9).</li>

<li>A font reader to load the font from a file into memory as bitmaps.</li>

<li>A converter from raw bitmaps to a format that OpenGL can
readily display.</li>

<li>A way to render the proper bitmaps for a given string.</li>

<li>A way to calculate the current frame rate.</li>

</ol>

<h4>The Numbers Font</h4>

<p>There are hundreds of freely available fonts, but most of them are available
only in fairly complex font formats such as TrueType and Type 1. Some versions
of SDL_perl support these complex font formats, but this support has
historically been frustratingly buggy or incomplete.</p>

<p>Given the relatively simple requirement (render a single integer), I chose
instead to create a very simple bitmapped font format just for this article.
The font file is <i>numbers-7x11.txt</i> in the examples tarball. It
begins as follows:</p>

<pre><code>7x11

30
..000..
.0...0.
.0...0.
0.....0
0.....0
0.....0
0.....0
0.....0
.0...0.
.0...0.
..000..

31
...0...
..00...
00.0...
...0...
...0...
...0...
...0...
...0...
...0...
...0...
0000000</code></pre>

<p>The first line indicates the size of each character cell in the font; in
this case, seven columns and 11 rows. The remaining chunks each consist of the
character's codepoint in hex followed by a bitmap represented as text--<code>.</code> represents a transparent pixel, and <code>0</code> represents a
rendered pixel. Empty lines separate chunks.</p>

<h4>The Font Reader</h4>

<p>To read the glyph definitions into bitmaps, I first added
<code>read_font_file</code>:</p>

<pre><code>sub read_font_file
{
    my $self = shift;
    my $file = shift;

    open my $defs, '&lt;', $file
        or die &quot;Could not open '$file': $!&quot;;
    local $/ = '';

    my $header  = &lt;$defs&gt;;
    chomp($header);
    my ($w, $h) = split /x/ =&amp; $header;

    my %bitmaps;
    while (my $def = &lt;$defs&gt;) {
        my ($hex, @rows) = grep /\S/ =&amp; split /\n/ =&amp; $def;

        @rows = map {tr/.0/01/; pack 'B*' =&amp; $_} @rows;

        my $bitmap           = join '' =&amp; reverse @rows;
        my $codepoint        = hex $hex;

        $bitmaps{$codepoint} = $bitmap;
    }

    return (\%bitmaps, $w, $h);
}</code></pre>

<p><code>read_font_file</code> begins by opening the font file for reading. It
next requests paragraph slurping mode by setting <code>$/</code> to
<code>''</code>. In this mode, Perl automatically breaks up the font file at
empty lines, with the header first followed by each complete glyph definition
as a single chunk. Next, the routine reads the header, chomps it, and splits the
cell size definition into width and height.</p>

<p>With the preliminaries out of the way, <code>read_font_file</code> creates a
hash to store the finished bitmaps and enters a <code>while</code> loop over
the remaining chunks of the font file. Each glyph definition is split into a
hex number and an array of bitmap rows; using <code>grep /\S/ =&amp;</code>
ignores any trailing blank lines.</p>

<p>The next line converts textual rows to real bitstrings. First, each
transparent pixel (<code>.</code>) becomes <code>0</code>, and each rendered
pixel (<code>0</code>) turns into a <code>1</code>. Feeding the resulting
binary text string to <code>pack 'B*'</code> converts the binary into an actual
bitstring, with the bits packed in starting from the high bit of each byte (as
OpenGL prefers). The resulting bitstrings are stored back in
<code>@rows</code>.</p>

<p>Because OpenGL prefers bitmaps to start at the bottom and go up, the code
reverses <code>@rows</code> before <code>join</code>ing to create the finished
bitmap. The <code>hex</code> operator converts the hex number to decimal to be
the key for the newly created bitmap in the <code>%bitmaps</code> hash.</p>

<p>After parsing the whole font file, the function returns the bitmaps to the
caller, along with the cell size metrics.</p>













<h4>Speaking OpenGL's Language</h4>

<p>The bitmaps produced by <code>read_font_file</code> are simply packed
bitstrings, in this case 11 bytes long (one byte per seven-pixel row). Before using
them to render strings, the engine must first load these bitmaps into OpenGL.
This happens in the main <code>init_fonts</code> routine:</p>

<pre><code>sub init_fonts
{
    my $self  = shift;

    my %fonts = (
        numbers =&amp; 'numbers-7x11.txt',
    );

    glPixelStore(GL_UNPACK_ALIGNMENT, 1);

    foreach my $font (keys %fonts) {
        my ($bitmaps, $w, $h) = 
            $self-&gt;read_font_file($fonts{$font});

        my @cps    = sort {$a &lt;=&amp; $b} keys %$bitmaps;
        my $max_cp = $cps[-1];
        my $base   = glGenLists($max_cp + 1);

        foreach my $codepoint (@cps) {
            glNewList($base + $codepoint, GL_COMPILE);
            glBitmap($w, $h, 0, 0, $w + 2, 0,
                     $bitmaps-&gt;{$codepoint});
            glEndList;
        }

        $self-&gt;{fonts}{$font}{base} = $base;
    }
}</code></pre>

<p><code>init_fonts</code> opens with a hash associating each known font with a
font file; at the moment, only the <code>numbers</code> font is defined. The
real work begins with the <code>glPixelStore</code> call, which tells OpenGL
that the rows for all bitmaps are tightly packed (along one-byte boundaries)
rather than being padded, so that each row begins at even two-, four-, or eight-byte
memory locations.</p>

<p>The main font loop starts by calling <code>read_font_file</code> to load the
bitmaps for the current font into memory. The next line sorts the codepoints
into <code>@cps</code>, and the following line finds the maximum codepoint by
simply taking the last one in <code>@cps</code>.</p>

<p>The <code>glGenLists</code> call allocates display lists for codepoints 0
through <code>$max_cp</code>, which will have numbers from <code>$base</code>
through <code>$base + $max_cp</code>. For each codepoint defined by the font,
the inner loop uses <code>glNewList</code> to start compiling the appropriate
list, <code>glBitmap</code> to load the bitmap into OpenGL, and finally,
<code>glEndList</code> to finish compiling the list.</p>

<p>The <code>glBitmap</code> call has six parameters aside from the bitmap
data itself (<code>$bitmaps-&gt;{$codepoint}</code>).  The first two are the
width and height of the bitmap in pixels, which <code>read_font_file</code>
conveniently provides. The next two define the <em>origin</em> for the bitmap,
counted from the lower-left corner. Bitmap fonts use a non-zero origin for
several purposes, generally when the glyph extends farther left or below the
&quot;normal&quot; lower-left corner. This may be because the glyph has a
<em>descender</em> (a part of the glyph that descends below the general line
of text, as with the lowercase letters &quot;p&quot; and &quot;y&quot;), or perhaps because the font
leans to the left. The simple code in <code>init_fonts</code> assumes none of
these special cases apply and sets the origin to (0,0).</p>

<p>The last two parameters are the X and Y <em>increments</em>, the distances
that OpenGL should move along the X and Y axes before drawing the next
character. Left-to-right languages use fonts with positive X and zero Y
increments; right-to-left languages use negative X and zero Y. Top-to-bottom
languages use zero X and negative Y. The increments must include both the
width/height of the character itself and any additional distance needed to
provide proper spacing. In this case, the rendering will be left to right. I
wanted two extra pixels for spacing, so I set the X increment to width plus
two, and the Y increment to zero.</p>

<p>The last line of the outer loop simply saves the list base for the font to
make it available later during rendering.</p>

<p><code>init</code> calls <code>init_fonts</code> as usual, just after the
call to <code>init_time</code>:</p>

<pre><code>$self-&gt;init_fonts;</code></pre>

<h4>Text Rendering</h4>

<p>The hard part is now done: parsing the font file and loading the bitmaps
into OpenGL. The new <code>draw_fps</code> routine calculates and renders the
frame rate:</p>

<pre><code>sub draw_fps
{
    my $self   = shift;

    my $base   = $self-&gt;{fonts}{numbers}{base};
    my $d_time = $self-&gt;{world}{d_time} || 0.001;
    my $fps    = int(1 / $d_time);

    glColor(1, 1, 1);
    glRasterPos(10, 10, 0);
    glListBase($base);
    glCallListsScalar($fps);
}</code></pre>

<p>The routine starts by retrieving the list base for the <code>numbers</code>
font, retrieving the world time delta for this frame, and calculating the
current frames per second as one frame in <code>$d_time</code> seconds. It takes
a little care to make sure <code>$d_time</code> is non-zero, even if the engine
is running so fast that it renders a frame in less than a millisecond (the
precision of SDL time handling); otherwise, the <code>$fps</code> calculation
would die with a divide-by-zero error.</p>













<p>The OpenGL section begins by setting the current drawing color to white with
a call to <code>glColor</code>. The next line sets the <em>raster
position</em>, the window coordinates at which to place the origin of the next
bitmap. After rendering each bitmap, the raster position is automatically
updated using the bitmap's X and Y increments so that the bitmaps will not
overlap each other. In this case, <code>(10, 10, 0)</code> sets the raster position ten
pixels up and right from the lower-left corner of the window, with <code>Z=0</code>.</p>

<p>The next two lines together actually call the appropriate display list in
our bitmap font for each character in the <code>$fps</code> string.
<code>glCallListsScalar</code> breaks the string into individual characters and
calls the display list with the same number as the codepoint of the character.
For example, for the "5" character (at codepoint 53 decimal),
<code>glCallListsScalar</code> calls display list 53. Unfortunately, there's no
guarantee that display list 53 actually will display a "5," because the font's
list base may not be 0. If the font had a list base of 1500, for example, the
code would need to call display list 1500+53=1553 to display the "5."</p>

<p>Rather than make the programmer do this calculation manually every time,
OpenGL provides the <code>glListBase</code> function, which sets the list base
to use with <code>glCallLists</code>. After the <code>glListBase</code> call
above, OpenGL will automatically offset every display list number specified
with <code>glCallLists</code> by <code>$base</code>.</p>

<p>You may have noticed that in the code I use <code>glCallListsScalar</code>,
but the previous paragraph referred to <code>glCallLists</code> instead.
<code>glCallListsScalar</code> is actually an SDL_perl extension (not part of
core OpenGL) that provides an alternate calling convention for
<code>glCallLists</code> in Perl. Internally, SDL_perl implements both Perl
routines using the same underlying C function in OpenGL
(<code>glCallLists</code>).  SDL_perl provides two different calling
conventions because Perl treats a string and an array of numbers as two
different things, while C treats them as essentially the same.</p>

<p>If you want to render a string, and all of the characters in the string have
codepoints &lt;= 255 decimal (single-byte character sets, and the ASCII subset
of most variable-width character sets), you can use
<code>glCallListsScalar</code>, and it will do the right thing for you:</p>

<pre><code>glCallListsScalar($string);</code></pre>

<p>If you simply want to render several display lists with a single call, and
you're not trying to render a string, use the standard version of
<code>glCallLists</code>:</p>

<pre><code>glCallLists(@lists);</code></pre>

<p>If you need to render a string, but it contains characters above codepoint
255, you have to use a more complex workaround:</p>

<pre><code>glCallLists(map ord($_) =&amp; split // =&amp; $string);</code></pre>

<p>Because the FPS counter merely renders ASCII digits, the first option works
fine.</p>

<p><code>draw_frame</code> now ends with a call to <code>draw_fps</code>, like
so:</p>

<pre><code>sub draw_frame
{
    my $self = shift;

    $self-&gt;set_projection_3d;
    $self-&gt;set_eye_lights;
    $self-&gt;set_view_3d;
    $self-&gt;set_world_lights;
    $self-&gt;draw_view;
    $self-&gt;draw_fps;
}</code></pre>

<p>For now, I decided to turn off benchmark mode by changing the config setting
in <code>init_config</code> to <code>0</code>:</p>

<pre><code>    benchmark =&amp; 0,</code></pre>

<p>With the font handling in place, and <code>draw_fps</code> called each frame
to display the frame rate in white in the lower-left corner, everything should
be grand, as Figure 1 shows.</p>

<p><img src="/pub/2005/08/04/graphics/step070.gif" width="400" height="400" alt="drawing frame rate, take one" /><br
/><em>Figure 1. Drawing the frame rate</em></p>

<p>Oops. There's no frame rate display. Actually, it's there, just
<em>very</em> faint. If you look very carefully (or turn your video card's
gamma up very high), you can just make out the frame rate display near the top
of the window, above the big white box on the right. There are (at least) two
problems--the text is too dark and it's in the wrong place.</p>













<p>The first problem is reminiscent of the dark scene in the <a
href="/pub/a/2005/02/17/3d_engine.html">last article</a>,
after enabling lighting but no lights. Come to think of it, there's not much
reason to have lighting enabled just to display stats, but the last object
rendered by <code>draw_view</code> left it on. To make sure lighting is off, I
added a <code>set_lighting_2d</code> routine, which <code>draw_frame</code> now
calls just before calling <code>draw_fps</code>:</p>

<pre><code>sub set_lighting_2d
{
    glDisable(GL_LIGHTING);
}</code></pre>

<p><img src="/pub/2005/08/04/graphics/step071.gif" width="400" height="400" alt="the unlit frame rate" /><br /><em>Figure 2. The
unlit frame rate</em></p>

<p>Figure 2 is much better! With lighting turned off, the frame rate now
renders in bright white as intended. The next problem is the incorrect
position. Moving and rotating the viewpoint shows that while the digits always
face the screen, their apparent position moves around (Figure 3).</p>

<p><img src="/pub/2005/08/04/graphics/step071a.gif" width="400" height="400" alt="moving frame rate" /><br /><em>Figure 3. A
moving frame rate</em></p>

<p>It turns out that the current modelview and projection matrices transform
the raster position set by <code>glRasterPos</code>, just like the coordinates
from a <code>glVertex</code> call. That means OpenGL reuses whatever state the
modelview and projection matrices are in.</p>

<p>To get unaltered window coordinates, I need to use an orthographic
projection (no foreshortening or other non-linear effects) matching the window
dimensions. I also need to set an identity modelview matrix (so that the
modelview matrix won't transform the coordinates at all). All of this happens in
<code>set_projection_2d</code>, called just before <code>set_lighting_2d</code>
in <code>draw_frame</code>:</p>

<pre><code>sub set_projection_2d
{
    my $self = shift;

    my $w    = $self-&gt;{conf}{width};
    my $h    = $self-&gt;{conf}{height};

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluOrtho2D(0, $w, 0, $h);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}</code></pre>

<p>This routine first gathers the window width and height from the
configuration hash. It then switches to the projection matrix
(<code>GL_PROJECTION</code>) and restores the identity state before calling
<code>gluOrtho2D</code> to create an orthographic projection matching the
window dimensions. Finally, it switches back to the modelview matrix
(<code>GL_MODELVIEW</code>) and restores its identity state as well. The frame
rate now renders at the intended spot near the lower-left corner (Figure
4).</p>

<p><img src="/pub/2005/08/04/graphics/step072.gif" width="400" height="400" alt="frame rate in the right spot" /><br /><em>Figure
4. The frame rate in the correct position</em></p>

<p>There is another more subtle rendering problem, however, which you can see
by moving the viewpoint forward a bit (Figure 5).</p>

<p><img src="/pub/2005/08/04/graphics/step072a.gif" width="400" height="400" alt="frame rate depth problems" /><br /><em>Figure
5. Frame rate depth problems</em></p>

<p>Notice how the &quot;5&quot; is partially cut off. The problem is that OpenGL compares
the depth of the pixels in the thin yellow box to the depth of the pixels in
the frame rate display, and finds that some of the pixels in the 5 are farther
away than the pixels in the box. In effect, part of the 5 draws <em>inside</em>
the box. In fact, moving the viewpoint slightly to the left from this point
will make the frame rate disappear altogether, hidden by the near face of the
yellow box.</p>

<p>That's not very good behavior from a statistics display that should appear
to hover in front of the scene. The solution is to turn off OpenGL's depth
testing, using a new line at the end of <code>set_projection_2d</code>:</p>

<pre><code>glDisable(GL_DEPTH_TEST);</code></pre>

<p>With this change, you can move the view anywhere without fear that the frame
rate will be cut off or disappear entirely (Figure 6).</p>

<p><img src="/pub/2005/08/04/graphics/step073.gif" width="400" height="400" alt="position-independent frame rate" /><br
/><em>Figure 6. Position-independent frame rate</em></p>













<h3>Too Fast</h3>

<p>There's yet another problem; this time, one that will require a change to the
frame rate calculations. The frame rate shown in the above screenshots is
either 333 or 500, but nothing else. On this system, the frames take between two
and three milliseconds to render, but because SDL can only provide one-millisecond
resolution, the time delta for a single frame will appear to be
<em>exactly</em> either .002 second or .003 second.  1/.002=500, and 1/.003=333, so the display is a blur, flashing back and forth between the two possible
values.</p>

<p>To get a more representative (and easier-to-read) value, the code must
average frame rate over a number of frames.  Doing this will allow the total
measured time to be long enough to drown out the resolution deficiency of SDL's
clock.</p>

<p>The first thing I needed was a routine to initialize the frame rate data to
carry over multiple frames:</p>

<pre><code>sub init_fps
{
    my $self = shift;

    $self-&gt;{stats}{fps}{cur_fps}    = 0;
    $self-&gt;{stats}{fps}{last_frame} = 0;
    $self-&gt;{stats}{fps}{last_time}  = $self-&gt;{world}{time};
}</code></pre>

<p>The new <code>stats</code> structure in the engine object will hold any
statistics that the engine gathers about itself. To calculate FPS, the engine
needs to remember the last frame for which it took a timestamp, as well as the
timestamp for that frame. Because the engine calculates the frame rate only
every few frames, it also saves the last calculated FPS value so that it can
render it as needed. The <code>init_fps</code> call, as usual, goes at the end
of <code>init</code>:</p>

<pre><code>$self-&gt;init_fps;</code></pre>

<p>The new <code>update_fps</code> routine now calculates the frame rate:</p>

<pre><code>sub update_fps
{
    my $self      = shift;

    my $frame     = $self-&gt;{state}{frame};
    my $time      = $self-&gt;{world}{time};

    my $d_frames  = $frame - $self-&gt;{stats}{fps}{last_frame};
    my $d_time    = $time  - $self-&gt;{stats}{fps}{last_time};
    $d_time     ||= 0.001;

    if ($d_time &gt;= .2) {
        $self-&gt;{stats}{fps}{last_frame} = $frame;
        $self-&gt;{stats}{fps}{last_time}  = $time;
        $self-&gt;{stats}{fps}{cur_fps}    = int($d_frames / $d_time);
    }
}</code></pre>

<p><code>update_fps</code> starts by gathering the current frame number and
timestamp, and calculating the deltas from the saved values. Again,
<code>$d_time</code> must default to 0.001 second to avoid possible divide-by-zero errors later on.</p>

<p>The <code>if</code> statement checks to see if enough time has gone by to
result in a reasonably accurate frame rate calculation. If so, it sets the last
frame number and timestamp to the current values and the current frame rate to
<code>$d_frames / $d_time</code>.</p>

<p>The <code>update_fps</code> call must occur early in the
<code>main_loop</code>, but after the engine has determined the new frame
number and timestamp. <code>main_loop</code> now looks like this:</p>

<pre><code>sub main_loop
{
    my $self = shift;

    while (not $self-&gt;{state}{done}) {
        $self-&gt;{state}{frame}++;
        $self-&gt;update_time;
        $self-&gt;update_fps;
        $self-&gt;do_events;
        $self-&gt;update_view;
        $self-&gt;do_frame;
    }
}</code></pre>

<p>The final change needed to enable the new more accurate display is in
<code>draw_fps</code>; the <code>$d_time</code> lookup goes away and the
<code>$fps</code> calculation turns into a simple retrieval of the current
value from the <code>stats</code> structure:</p>

<pre><code>my $fps  = $self-&gt;{stats}{fps}{cur_fps};</code></pre>

<p>The more accurate calculation now makes it easy to see the difference
between the frame rate for a simple view (Figure 7):</p>

<p><img src="/pub/2005/08/04/graphics/step074.gif" width="400" height="400" alt="frame rate for a simple view" /><br /><em>Figure
7. Frame rate for a simple view</em></p>

<p>and the frame rate for a more complex view (Figure 8).</p>

<p><img src="/pub/2005/08/04/graphics/step074a.gif" width="400" height="400" alt="frame rate for a complex view" /><br
/><em>Figure 8. Frame rate for a complex view</em></p>

<h4>Is the New Display a Bottleneck?</h4>

<p>The last thing to do is to check that the shiny new frame rate display is
not itself a major bottleneck. The easiest way to do that is to turn benchmark
mode back on in <code>init_conf</code>:</p>

<pre><code>    benchmark =&amp; 1,</code></pre>

<p>After doing that, I ran the engine under <code>dprofpp</code> again, and
then analyzed the results, just as I had earlier:</p>

<pre><code>$ dprofpp -Q -p step075

Done.
$ dprofpp -I -g main::main_loop
Total Elapsed Time = 3.943764 Seconds
  User+System Time = 1.063773 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 100.       -  1.064      1        - 1.0638  main::main_loop
 94.6   0.006  1.007    384   0.0000 0.0026  main::do_frame
 85.2   0.019  0.907    384   0.0000 0.0024  main::draw_frame
 50.7   0.205  0.540    384   0.0005 0.0014  main::draw_view
 16.8   0.073  0.179    384   0.0002 0.0005  main::draw_fps
 15.4   0.095  0.164    384   0.0002 0.0004  main::set_projection_2d
 11.6   0.045  0.124    384   0.0001 0.0003  main::draw_axes
 10.9   0.116  0.116   2688   0.0000 0.0000  SDL::OpenGL::CallList
 8.74   0.013  0.093    384   0.0000 0.0002  main::end_frame
 7.52   0.003  0.080    384   0.0000 0.0002  SDL::App::sync
 7.24   0.077  0.077    384   0.0002 0.0002  SDL::GLSwapBuffers
 4.89   0.052  0.052   3072   0.0000 0.0000  SDL::OpenGL::PopMatrix
 4.70   0.023  0.050    384   0.0001 0.0001  main::update_view
 3.67   0.039  0.039   3456   0.0000 0.0000  SDL::OpenGL::GL_LIGHTING
 3.48   0.037  0.037    384   0.0001 0.0001  SDL::OpenGL::Begin</code></pre>

<p>As it currently stands, <code>draw_view</code> takes half of the run time of
<code>main_loop</code>, and the combination of <code>set_projection_2d</code>
and <code>draw_fps</code> takes about a third of the <code>main_loop</code> time
together. Is that good or bad news?</p>

<p><code>draw_view</code> is so quick now because I've just optimized it. Now
that it's running so fast again, I can afford to add more features and perhaps
make a more complex scene, either of which will make <code>draw_view</code>
take a larger percentage of the time again. Also,
<code>set_projection_2d</code> is necessary for any in-window statistics,
debugging, or HUD (heads up display) anyway, so the time spent there will not
go to waste.</p>

<p>That leaves <code>draw_fps</code>, taking about one sixth of
<code>main_loop</code>'s run time. That's perhaps a bit larger than I'd like,
but not large enough to warrant additional effort yet. I'll save my energy for
the next set of features.</p>

<h3>Conclusion</h3>

<p>During this article, I covered several concepts relating to engine
performance: adding a benchmark mode; profiling with <code>dprofpp</code>;
using display lists to optimize slow, repetitive rendering tasks; and using
display lists, bitmapped fonts, and averaging to produce a smooth frame rate
display. I also added a stub for a triggered events subsystem, which I'll come
back to in a future article.</p>

<p>With these performance improvements, the engine is ready for the next new
feature, textured surfaces, which will be the main topic for the next
article.</p>

<p>Until then, enjoy yourself and have fun hacking!</p>



                                    </div>


                                </div>
                                <div class="asset-footer">

    
                                    <div class="entry-categories">
                                        <h4>Categories<span class="delimiter">:</span></h4>
                                        <ul>
                                            <li><a href="/pub/games/" rel="tag">Games</a></li>
                                        </ul>
                                    </div>
    


                                    <div class="entry-tags">
                                        <h4>Tags<span class="delimiter">:</span></h4>
                                        <ul>
                                            <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=OpenGL%20lighting&amp;limit=20';return false;" rel="tag">OpenGL lighting</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=OpenGL%20tutorial&amp;limit=20';return false;" rel="tag">OpenGL tutorial</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=OpenGL%20viewpoint&amp;limit=20';return false;" rel="tag">OpenGL viewpoint</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=Perl%203D&amp;limit=20';return false;" rel="tag">Perl 3D</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=Perl%20game%20programming&amp;limit=20';return false;" rel="tag">Perl game programming</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=Perl%20graphics&amp;limit=20';return false;" rel="tag">Perl graphics</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=Perl%20OpenGL&amp;limit=20';return false;" rel="tag">Perl OpenGL</a><span class="delimiter">,</span></li> <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=Perl%20SDL&amp;limit=20';return false;" rel="tag">Perl SDL</a></li>
                                        </ul>
                                    </div>

                                </div>
                            </div>


                    
                    


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2010/07/">July 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
