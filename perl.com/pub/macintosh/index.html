<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Macintosh Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Macintosh</em> Category</h1>






                            
                            <div id="entry-862" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/01/macglue.html" rel="bookmark">Introducing Mac::Glue</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Cozens</span> on <abbr class="published" title="2004-01-23T00:00:00-08:00">January 23, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p> Thanks to the popularity of Mac OS X, the new iBook, and the
    PowerBook G4, it's no longer uncool to talk about owning an
    Apple. Longtime Mac devotees have now been joined by longtime
    Unix devotees and pretty much anyone who wants computers to be
    shiny, and speakers at conferences such as the <a
    href="http://conferences.oreillynet.com/os2004/">Open Source
    Convention</a> are beginning to get used to looking down over a
    sea of Apple laptops.
    </p>

    <p> One of the great features about Apple's Mac OS is its support
      for flexible inter-process communication (IPC), which Apple
      calls inter-application communication (IAC). One of the components
      of IAC is called Apple events, and allows applications to
      command each other to perform various tasks. On top of the raw
      Apple events layer, Apple has developed the <b>Open Scripting
	Architecture</b>, an architecture for scripting languages such
      as Apple's own AppleScript.
    </p>

    <p>
      But this is <code>perl.com</code>, and we don't need inferior
      scripting languages! The <code>Mac::Glue</code> module provides
      OSA compatibility and allows us to talk to Mac applications with
      Perl code. Let's take a look at how to script Mac tools at a
      high level in Perl.
    </p>

    <h3>The Pre-History of <code>Mac::Glue</code></h3>

    <p>
      In the beginning, there was <code>Mac::AppleEvents</code>. This
      module wrapped the raw Apple events API, with its cryptic
      four-character codes to describe applications and their
      capabilities, and its collection of awkward constants. You had
      to find out the four-character identifiers yourself, you had to
      manage and dispose of memory yourself, but at least it got you
      talking Apple events. Here's some <code>Mac::AppleEvents</code>
      code to open your System Folder in the Finder::
    </p>

    <pre><code>
use Mac::AppleEvents;

my $evt = AEBuildAppleEvent('aevt', 'odoc', typeApplSignature, 
             'MACS', kAutoGenerateReturnID, kAnyTransactionID,
             "'----': obj{want:type(prop), from:'null'()," .
                "form:prop, seld:type(macs)}"
          );
my $rep = AESend($evt, kAEWaitReply);

AEDisposeDesc($evt);
AEDisposeDesc($rep);
</code></pre>

    <p>
       Obviously this isn't putting the computer to its full use; in a
       high-level language like Perl, we shouldn't have to concern
       ourselves with clearing up descriptors when they're no longer
       in use, or providing low-level flags. We just want to send the
       message to the Finder. So along came
       <code>Mac::AppleEvents::Simple</code>, which does more of the work:
    </p>

<pre><code>
use Mac::AppleEvents::Simple;
do_event(qw(aevt odoc MACS),
     "'----': obj{want:type(prop), from:'null'()," .
     "form:prop, seld:type(macs)}"
);
</code></pre>

    <p>
       This is a bit better; at least we're just talking the IAC
      language now, instead of having to emulate the raw API. But
      those troublesome identifiers -- "aevt" for the Finder, "odoc"
      to open a document, and "MACS" for the System folder. 
    </p>
    <p>
      Maybe we'd be better off in AppleScript after all -- the
      AppleScript code for the same operation looks like this:
    </p>
<pre><code>
tell application "Finder" to open folder "System Folder"
</code></pre>
    <p>
      And before <code>Mac::Glue</code> was ported to Mac OS X, this is
      exactly what we had to do: 
    </p>
    <pre><code>
use Mac::AppleScript qw(RunAppleScript);
RunAppleScript('tell application "Finder" to open folder "System Folder"');
</code></pre>
    <p>
      This is considerably easier to understand, but it's just not
      Perl. <code>Mac::Glue</code> uses the same magic that allows
      AppleScript to use names instead of identifiers, but wraps it in
      Perl syntax:
    </p>
    <pre><code>
use Mac::Glue;
my $finder = Mac::Glue->new('Finder');
$finder->open( $finder->prop('System Folder') );
</code></pre>

<csperl file="grab" domain="on" record="b/1005" template="b/article_sidebar.view">

<h3>Setting Up and Creating Glues</h3>

    <p>On Mac OS 9, MacPerl comes with <code>Mac::Glue</code>. However, OS
    X users will need to install it themselves. <code>Mac::Glue</code>
    requires several other CPAN modules to be installed, including the
    <code>Mac-Carbon</code> distribution.</p>
    <p>
      Because this in turn requires the Carbon headers to be
      available, you need to install the correct Apple developer kits;
      if you don't have the Developer Tools installed already, you can
      download them from <a href="https://connect.apple.com/">the ADC
      site</a>.
    </p>
    <p>
      Once you have the correct headers installed, the best way to get
      <code>Mac::Glue</code> up and running is through the CPAN or
      CPANPLUS modules:
    </p>
    <pre><code>
% perl -MCPAN -e 'install "Mac::Glue"'
</code></pre>
    <p>
      This should download and install all the prerequisites and then
      the <code>Mac::Glue</code> module itself.
    </p>
    <p>
      When it installs itself, <code>Mac::Glue</code> also creates
      "glue" files for the core applications -- Finder, the System Events
      library, and so on. A glue file is used to describe the resources
      available to an application and what can be done to the
      properties that it has.
    </p>
    <p>
      If you try to use <code>Mac::Glue</code> to control an
      application for which it doesn't currently have a glue file, it
      will say something like this:
    </p>
    <pre><code>
No application glue for 'JEDict' found in 
'/Library/Perl/5.8.1/Mac/Glue/glues' at -e line 1
</code></pre>
    <p>
      To create glues for additional applications that are not
      installed by default, you can drop them onto the Mac OS 9 droplet
      "macglue." On Mac OS X, run the <code>gluemac</code> command.
    </p>
<h3>What's a Property?</h3>
    <p>
      Once you have all your glues set up, you can start scripting Mac
      applications in Perl. It helps if you already have some
      knowledge of how AppleScript works before doing this, because
      sometimes <code>Mac::Glue</code> doesn't behave the way you
      expect it to.
    </p>
    <p>
      For instance, we want to dump all the active to-do items from
      iCal. To-dos are associated with calendars, so first we need a
      list of all the calendars:
    </p>
    <pre><code>
use Mac::Glue;
my $ical = new Mac::Glue("iCal");

my @cals = $ical->prop("calendars");
</code></pre>
    <p>
       The problem we face immediately is that
      <code>$ical->prop("calendars")</code> doesn't give us the
      calendars. Instead, it gives us a way to talk about the
      calendars' property. It's an object. To get the value of that
      property, we call its <code>get</code> method:
    </p>
    <pre><code>
my @cals = $ical->prop("calendars")->get;
</code></pre>
    <p>
      This returns a list of objects that allow us to talk about
      individual calendars. We can get their titles like so:
    </p>
    <pre><code>
for my $cal (@cals) {
    my $name = $cal->prop("title")->get;
</code></pre>
    <p>
      And now we want to get the to-dos in each calendar that haven't
      yet been completed or have no completion date:
    </p>
    <pre><code>
    my @todos = grep { !$_->prop("completion_date")->get }
                       $cal->prop("todos")->get;
</code></pre>
    <p>
      If we then store the summary for each of the to-do items in a
      hash keyed by the calendar name:
    </p>
    <pre><code>
    $todos{$name} = [ map { $_->prop("summary")->get } @todos ]
	if @todos;
}
</code></pre>
    <p>
      Then we can print out the summary of all the outstanding to-do
      items in each calendar: 
</p>
    <pre><code>
for my $cal(keys %todo) {
    print "$cal:\n";
    print "\t$_\n" for @{$todo{$cal}};
}
</code></pre>
    <p>
      Putting it all together, the code looks like:
    </p>
    <pre><code>
use Mac::Glue;
my $ical = new Mac::Glue("iCal");

my @cals = $ical->prop("calendars")->get;
for my $cal (@cals) {
    my $name = $cal->prop("title")->get;
    my @todos = map  { $_->prop("summary")->get }
                grep { !$_->prop("completion_date")->get }
                       $cal->prop("todos")->get;
    $todo{$name} = \@todos if @todos;
}

for my $cal(keys %todo) {
    print "$cal:\n";
    print "\t$_\n" for @{$todo{$cal}};
}
</code></pre>
    <p>
       The question is, where did we get the property names like
       <code>summary</code> and <code>completion_date</code> from? How did we know that the
       calendars had <code>titles</code> but the to-do items had <code>summaries</code>, and
       so on?
    </p>
    <p>
       There are two answers to this: the first is to use the
       documentation created when the glue is installed. Typing
       <code>gluedoc iCal</code> on Mac OS X or using Shuck on Mac OS 9, you
       will find the verbs, properties, and objects that the
      application supports. For instance, under the calendar class,
      you should see:
    </p>
    <blockquote>
<dl>
<dd>
This class represents a calendar
</dd>
<dd>
<p>Properties:</p>
</dd>
<dd>
<pre>
    description (wr12/utxt): This is the calendar
description. (read-only)
    inheritance (c@#^/item): All of the properties of the
superclass. (read-only)
    key (wr03/utxt): An unique calendar key (read-only)
    tint (wr04/utxt): The calendar color (read-only)
    title (wr02/utxt): This is the calendar title.
    writable (wr05/bool): If this calendar is writable
(read-only)</pre>
</dd>
<dd>
<p>Elements:</p>
</dd>
<dd>
<pre>
    event, todo</pre>
</dd>
</dl>
</blockquote>
    <p>
      This tells us that we can ask a calendar for its
      <code>title</code> property, and also for the
      <code>events</code> or <code>todos</code> contained within it.
    </p>
    <p>
      Similarly, when we get the events back, we can look up the
      "event" class in the documentation and see what properties are
      available on it.
    </p>
    <p>
      The second, and perhaps easier, way to find out what you can do
      with an application is to open the AppleScript Script Editor
      application, select Open Dictionary from the File menu, and
      choose the application you want to script. Now you can browse a
      list of the classes and commands associated with the application:
    </p>
    
<img src="/pub/2004/01/23/graphics/glue.jpg" width="450" height="343" alt="" /> 
<p>
      When you need to know how to translate those back into Perl, you
      can then consult the glue documentation. It takes a few attempts
      to get used to the way <code>Mac::Glue</code> works, but once
      you've done that, you'll find that you can translate between the
      AppleScript documentation and a <code>Mac::Glue</code>
      equivalent in your head.
    </p>
	










	
	
<h3>Some Examples</h3>
    <p>
      In a couple of weeks, we'll be presenting a "Mac::Glue Hacks"
      article in the spirit of the O'Reilly <a
      href="http://hacks.oreilly.com">hacks books</a> series, with
      several simple <code>Mac::Glue</code>-based application
      scripting tricks to whet your appetite and explore what
      <code>Mac::Glue</code> can do. But to get you started, here's a
      couple we found particularly useful.
    </p>
    <p>
      First, iTunes allows you to give a rating to your favorite
      songs, on the scale of zero to five stars. Actually,
      internally, this is stored in the iTunes database as a number
      between 0 and 100. Simon keeps iTunes playing randomly over his
      extensive music collection, and every time an interesting track
      comes up, he runs this script:
    </p>
    <pre><code>
my $itunes = Mac::Glue->new("iTunes");
exit unless $itunes->prop("player state")->get eq "playing";

my $rating = $itunes->prop("current track")->prop("rating");
$rating->set(to => ($rating->get + 20))
  if $rating->get &lt; 81;
</code></pre>
    <p>
      As well as getting properties from <code>Mac::Glue</code>, we
      can also set them back with the <code>set</code> method.
    </p>
    <p>
      One more complex example is the <a
      href="http://dev.macperl.org/files/scripts/happening">happening</a> script Chris uses to publish details of
      what's going on at his computer. As well as simply reporting the
      current foremost application, it dispatches based on that
      application to report more information. For instance, if Safari
      has the focus, it reports what web page is being looked at; if
      it's the Terminal, what program is currently being run. It also
      contacts iTunes to see what song is playing, and if there's
      nothing playing on a local iTunes, asks likely other computers
      on the network if they're playing anything.
    </p>
    <p>
      Once <code>happening</code> has discovered what's going on, it
      checks to see if the iChat status is set to "Available," and if
      so, resets itself it to report this status. Let's break down
      <code>happening</code> and see how it accomplishes each of these
      tasks.
    </p>
    <p>
      First, to work out the name of the currently focused application:
    </p>
    <pre><code>
my $system = get_app('System Events') or return;
$app    ||= $system->prop(name => item => 1,
    application_process => whose(frontmost => equals => 1)
);

$app-&gt;get;
</code></pre>
    <p>
      <code>get_app</code> is just a utility function that memorizes
      the process of calling
      <code>Mac::Glue-&gt;new($app_name)</code>; since loading up the
      glue file is quite expensive, keeping around application glue
      objects is a big speed-saving approach. 
    </p>
    <p>
      The next incantation shows you how natural <code>Mac::Glue</code>
      programming can look, but also how much you need to know about how
      the Apple environment works. We're asking the System Events
      library to tell us about the application process that matches a
      certain condition. <code>Mac::Glue</code> exports the
      <code>whose</code> function to create conditions.
    </p>
    <p>
      The important thing about this is the fact that we use
      <code>$app ||= ...</code>. The construction that we saved in
      <code>$app</code> does not give us "the name of the front-most
      application at this moment," but it represents the whole concept
      of "the name of the front-most application." At any time in the
      future, we can call <code>get</code> on it, and it will find out
      and return the name of the front-most application at that time, even
      if it has changed since the last time you called <code>get</code>.
    </p>
    <p>
      Now that we know what the front-most application is, we can look it up
      in a hash that contains subroutines returning information
      specific to that application. For instance, here's the entry for
      Safari:
    </p>
    <pre><code>
Safari => sub { my ($glue) = @_;
                my $obj = $glue->prop(url => document => 1 => window => 1);
                my $url = $obj->get;
                return URI->new($url)->host if $url;
</code></pre>
    <p>
      This returns the host part of the URL in the first document in
      the first window. For <code>ircle</code>, an IRC client, this code will get
      the channel and server name for the current connection:
    </p>
    <pre><code>
ircle       => sub { sprintf("%s:%s",
               $_[0]->prop('currentchannel')->get,
               $_[0]->prop(servername => connection =>
                   $_[0]->prop('currentconnection')->get
               )->get
              )
            },
</code></pre>
    <p>
      A decent default action is to return the window title:
    </p>
    <pre><code>
default     => sub { my($glue) = @_;
                     my $obj = $objs{$glue->{APPNAME}} ||=
                               $glue->prop(name => window => 1);
                     $obj->get;
                   },
</code></pre>
    <p>
      As before, we cache the concept of "the name of the current
      window" and only create it when we don't have one already.
    </p>
    <p>
      Now let's look at the "Now playing in iTunes" part:
    </p>
    <pre><code>
$state  ||= $itunes->prop('player state');
return unless $state->get eq "playing";

$track  ||= $itunes->prop('current track');
%props    = map { $_ => $track->prop($_) } qw(name artist)
            unless keys %props;

my %info;
for my $prop (keys %props) {
    $info{$prop} = $props{$prop}->get;
}
</code></pre>
    <p>
      This first checks to see if iTunes is playing, and returns
      unless it is. Next, we look for the current track, and get
      handles to the name and artist properties of that track, as in
      our previous iTunes example.
    </p>
    <p>
      Finally, when we've set up all the handles we need, we call
      <code>get</code> to turn them into real data. This populates
      <code>%info</code> with the name and artist of the
      currently playing track.
    </p>
    <p>
      Now that we have the current application name, the extra information,
      and the current track, we can publish them as the iChat status,
      with this subroutine:
    </p>
    <pre><code>
use Mac::Apps::Launch qw(IsRunning);

sub ichat {
    my($output) = @_;

    my $ichat = get_app('iChat') or return;
    return unless IsRunning($ichat->{ID});

    $status  ||= $ichat->prop('status');
    return unless $status->get eq 'available';

    $message ||= $ichat->prop('status message');
    $message->set(to => $output);
}
</code></pre>
    <p>
      First, we have the <code>IsRunning</code>
      subroutine from <code>Mac::AppleEvents::Simple</code>, which
      takes the old-style four-character ID of the application we want
      to ask about. The <code>ID</code> slot of the glue object will
      tell us this ID, and so we can immediately give up setting the
      iChat status if iChat isn't even running. Then we use
      <code>set</code> as before to change the status to whatever we want.
    </p>
    <p>
      Finally, we mentioned that <code>happening</code> can also ask other
      hosts what's playing on their iTunes as well. This is because, if
      "Remote Apple Events" is turned on in the Sharing preferences,
      Macs support passing these Apple events between machines. Of
      course, this often requires authentication, so when it first
      contacts a host to send an Event, <code>happening</code> will
      pop-up a login box to ask for credentials -- this is all handled
      internally by the operating system. Here's the code that
      <code>happening</code> actually uses:
    </p>
    <pre><code>
my $found = 0;
if (IsRunning($itunes->{ID})) {
    $itunes->ADDRESS;
    $found = 1 if $state->get eq 'playing';
}

unless ($found) {
    for my $host (@hosts) {
        next unless $hosts{$host} + 60 &lt; time();
        $itunes-&gt;ADDRESS(eppc => iTunes => $host);
        $found = 1, last if $state->get eq 'playing';
        $hosts{$host} = time();
    }
}
</code></pre>
    <p>
      The first paragraph checks to see if iTunes is running
      locally. If so, we're done. If not, we're
      going to have to ask the hosts specified in the
      <code>@hosts</code> array about it. The first and last lines
      inside the <code>for</code> loop simple ensure that hosts are
      only tried every minute at most. The second line in there is the
      interesting one, though:
    </p>
    <pre><code>
$itunes-&gt;ADDRESS(eppc => iTunes => $host);
</code></pre>
    <p>
      This changes the <code>iTunes</code> glue handle from being a
      local one to being one that contacts the "iTunes" application on
      host <code>$host</code> over EPPC, the remote Apple events
      transport.
    </p>
    <p>
      Because <code>$state</code> is the player status of
      <code>$itunes</code>, it will now return the correct status even
      though <code>$itunes</code> now refers to an application on a
      different computer! Similarly, all the handles we have to the
      artist and name of the  current track will correctly refer to
      <code>$itunes</code>, no matter which iTunes instance that means.
    </p>
    <p>
      We hope you'll join us next time for more <code>Mac::Glue</code>
      tips and tricks, as we look at real-life applications of
      scripting Mac applications in Perl.
    </p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/lists/">&laquo; Lists</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/mail-and-usenet-news/">Mail and USENET News &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
