<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: XML Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>XML</em> Category</h1>






                            
                            <div id="entry-992" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/09/drop-the-soap.html" rel="bookmark">Don't Be Afraid to Drop the SOAP</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Sam Tregar</span> on <abbr class="published" title="2004-09-30T00:00:00-08:00">September 30, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>SOAP has great hype; portable, simple, efficient, flexible, and open, SOAP
has it all. According to many intelligent people, writing a web service with
SOAP should be a snap, and the results will speak for themselves. So they do,
although what they have to say isn't pretty.</p>

<p>Two years ago I added a SOAP interface to the <a href="http://bricolage.cc/">Bricolage</a> open source content management
system.  I had high expectations. SOAP would give me a flexible and efficient
control system, one that would be easy to develop and simple to debug.  What's
more, I'd be out on the leading edge of cool XML tech.</p>

<p>Unfortunately the results haven't lived up to my hopes. The end result is
fragile and a real resource hog. In this article I'll explore what went wrong
and why.</p>

<p>Last year, I led the development of a new content-management system called
<a href="http://krang.sf.net/">Krang</a>, and I cut SOAP out of the mix.
Instead, I created a custom XML file-format based on TAR. Performance is up,
development costs are down, and debugging is a breeze. I'll describe this
system in detail at the end of the article.</p>

<table width="220" border="0" cellspacing="8" cellpadding="4" align="right">
<tr>
<td width="220" valign="top" bgcolor="#efefef">
<div class="secondary"><h3>What is SOAP?</h3>

<p>In case you've been out to lunch, SOAP (Simple Object Access Protocol) is a
relatively new RPC (Remote Procedure Call) system that works by exchanging XML
messages over a network connection, usually over HTTP. In an RPC system, a
server offers routines (procedures) that clients may call over a network
connection. SOAP surpasses its direct predecessor, XML-RPC, with an enhanced type system and an improved error-handling system.  Despite the name, SOAP is
neither particularly simple nor object-oriented.</p></div>
</td></tr></table>

<h3>Bricolage Gets SOAP</h3>

<p>When I joined the Bricolage project, it lacked a good way to control the
application aside from the browser-based GUI. In particular, we needed a way to
import data and trigger publish runs. Bricolage is a network application, and
some useful tasks require interaction with multiple Bricolage servers. SOAP
seemed like an obvious choice. I read "Programming Web Services with Perl" and
I was ready to go.</p>

<p>I implemented the Bricolage SOAP interface as a set of classes that map
SOAP requests to method calls on the underlying objects, with some glue code to
handle XML serialization and deserialization. I used XML Schema to describe an
XML vocabulary for each object type, which we used to validate input and output
for the SOAP methods during testing.</p>

<p>By far the most important use-case for this new system was data import. Many
of our customers were already using content management systems (CMSs) and we needed to
move their data into Bricolage. A typical migration involved processing a
database dump from the client's old system and producing XML files to load in
Bricolage via SOAP requests.</p>

<p>The SOAP interface could also move content from one system to another, most
commonly when moving completed template changes into production. Finally, SOAP
helped to automate publish runs and other system maintenance tasks.</p>

<p>To provide a user interface to the SOAP system, I wrote a command-line
client called <code>bric_soap</code>. The <code>bric_soap</code> script is a
sort of Swiss Army knife for the Bricolage SOAP interface; it can call any
available method and pipe the results from command to command. For example, to
find and export all the story objects with the word <code>foo</code> in their
title:</p>

<pre><code>$ <strong>bric_soap story list_ids --search "title=%foo%" |
	bric_soap story export - &gt; stories.xml</strong></code></pre>

<p>Later we wrote several single-purpose SOAP clients, including
<code>bric_republish</code> for republishing stories and
<code>bric_dev_sync</code> for moving templates and elements between
systems.</p>

<h4>What Went Right</h4>

<csperl file="grab" domain="on" record="b/708" template="b/article_sidebar.view">

<ul>

<li>The well-documented XML format for Bricolage objects made developing data import systems straightforward. Compared to previous projects that attempted
direct-to-SQL imports, the added layer of abstraction and validation was an
advantage.</li>

<li>The interface offered by the Bricolage SOAP classes is simpler and more
regular than the underlying Bricolage object APIs. This, coupled with the
versatile <code>bric_soap</code> client, allowed developers to easily script
complex automations.</li>

</ul>

<h4>What Went Wrong</h4>

<ul>

<li>SOAP is difficult to debug. The SOAP message format is verbose even by XML
standards, and decoding it by hand is a great way to waste an afternoon. As a
result, development took almost twice as long as anticipated.</li>

<li>The fact that all requests happened live over the network further hampered
debugging. Unless the user was careful to log debugging output to a file it was
difficult to determine what went wrong.</li>

<li>SOAP doesn't handle large amounts of data well. This became immediately
apparent as we tried to load a large data import in a single request.
Since SOAP requires the entire request to travel in one XML document, SOAP
implementations usually load the entire request into memory.  This required us
to split large jobs into multiple requests, reducing performance and making it
impossible to run a complete import inside a transaction.</li>

<li>SOAP, like all network services, requires authentication to be safe against
remote attack. This means that each call to <code>bric_soap</code> required at
least two SOAP requests &mdash; one to login and receive a cookie and the
second to call the requested method.  Since the overhead of a SOAP request is
sizable, this further slowed things down. Later we added a way to save the
cookie between requests, which helped considerably.</li>

<li>Network problems affected operations that needed to access multiple
machines, such as the program responsible for moving templates and elements
&mdash; <code>bric_dev_sync</code>. Requests would frequently timeout in the
middle, sometimes leaving the target system in an inconsistent state.</li>

<li>At the time, there was no good Perl solution for validating object XML
against an XML Schema at runtime. For testing purposes I hacked together a way
to use a command-line verifier using Xerces/C++. Although not a deficiency in
SOAP itself, not doing runtime validation led to bad data passing through the
SOAP interface and ending up in the database where we often had to perform
manual cleanup.</li>

</ul>

<h3>Round Two: Krang</h3>

<p>When I started development on Krang, our new content management system, I
wanted to find a better way to meet our data import and automation needs. After
searching in vain for better SOAP techniques, I realized that the problems were
largely inherent in SOAP itself. SOAP is a network system, tuned for small
messages and it carries with it complexity that resists easy debugging.</p>

<p>On the other hand, when I considered the XML aspects of the Bricolage
system, I found little to dislike. XML is easy to understand and is sufficiently
flexible to represent all the data handled by the system. In particular, I
wanted to reuse my hard-won XML Schema writing skills, although I knew that I'd
need runtime validation.</p>

<p>In designing the new system I took a big step back from the leading edge. I
based the new system on the TAR archive file format, which dates back to the
mid-70s!</p>

<p><img src="/pub/2004/09/30/graphics/KDS.jpg" width="206" height="294" alt="" /><br /><em>Figure 1. </em></p>

<p>I named the file format "Krang Data Set" (KDS). A KDS file is a TAR archive
containing a set of XML files. A special file, <em>index.xml</em>, contains
data about all the files contained in the KDS file, providing class names and
IDs. To reduce their size, it's possible to compress KDS files using
<code>gzip</code>.</p>

<p>I wrote two scripts, <code>krang_import</code> and
<code>krang_export</code>, to read and write KDS files. Each object type has
its own XML Schema document describing its structure. Krang classes implement
their own <code>deserialize_xml()</code> and <code>serialize_xml()</code>
methods. For example, to export all templates into a file called
<em>templates.kds</em>:</p>

<pre><code>$ <strong>krang_export --templates --output templates.kds</strong></code></pre>

<p>To import those templates, possibly on a different machine:</p>

<pre><code>$ <strong>krang_import templates.kds</strong></code></pre>

<p>If the object being exported has any dependencies, the KDS file will include
them.  In this way a KDS file generated by <code>krang_export</code> is
guaranteed to import successfully.</p>

<p>By using a disk-based system for importing and exporting data I cut the
network completely out of the picture. This alone accomplishes a major
reduction in complexity and a sizable performance increase. Recently we
completed a very large import into Krang comprising 12,000 stories and 160,000
images. This took around 4 hours to complete, which may seem like a long time
but it's a big improvement over the 28 hours the same import required using
SOAP and Bricolage!</p>

<p>For system automation such as running publish jobs from <code>cron</code>, I
decided to code utilities directly to Krang's Perl API. This means these tools
must run on the target machine, but in practice this is usually how people used
the Bricolage tools. When an operation must run across multiple machines,
perhaps when moving templates from beta to production, the administrator simply
uses <code>scp</code> to transfer the KDS files.</p>

<p>I also took the opportunity to write XML::Validator::Schema, a pure-Perl XML
Schema validator. It's far from complete, but it supports all the schema
constructs I needed for Krang. This allows Krang to perform runtime schema
validation on KDS files.</p>

<h4>What Went Right</h4>

<ul>

<li>The new system is fast. Operating on KDS files on disk is many times faster
than SOAP network transfers.</li>

<li>Capacity is practically unlimited. Since KDS files separate objects into
individual XML files, Krang never has to load them all into memory at once.
This means that a KDS file containing 10,000 objects is just as easy to process
as one containing 10.</li>

<li>Debugging is much easier. When an import fails the user simply sends me the
KDS file and I can easily examine the XML files or attempt an import on my own
system. I don't have to wade through SOAP XML noise or try to replicate network
operations to reproduce a bug. Separating each object into a single XML file
made working on the data much easier because each file is small enough to load
into Emacs.</li>

<li>Runtime schema validation helps find bugs faster and prevents bad data
from ending up in the database.</li>

<li>Because Krang's design accounted for the XML system from the start it has a
much closer integration with the overall system. This gives it greater coverage
and stability.</li>

</ul>

<h4>What Went Wrong</h4>

<ul>

<li>Operations across multiple machines require the user to manually transfer
KDS files across the network.</li>

<li>Users who have developed expertise in using the Bricolage SOAP clients must
learn a new technology.</li>

</ul>

<h3>Conclusion</h3>

<p>SOAP isn't a bad technology, but it does have limits. My experience
developing a SOAP interface for Bricolage taught me some important lessons that
I've tried to apply to Krang. So far the experiment is a success, but Krang is
young and problems may take time to appear.</p>

<p>Does this mean you shouldn't use SOAP for your next project? Not
necessarily. It does mean that you should take a close look at your
requirements and consider whether an alternative implementation would help you
avoid some of the pitfalls I've described.</p>

<p>The best candidates for SOAP applications are lightweight network
applications without significant performance requirements.  If your application
doesn't absolutely require network interaction, or if it will deal with large
amounts of data then you should avoid SOAP. Maybe you can use TAR instead!</p>

<h3>Resources</h3>

<ul>

<li><a href="http://krang.sf.net/">Krang</a></li>

<li><a href="http://bricolage.cc/">Bricolage</a></li>

<li><a href="http://bricolage.cc/docs/current/api/Bric/SOAP.html">Bricolage
SOAP documentation</a></li>

<li><a href="http://www.w3.org/TR/SOAP/">SOAP</a></li>

<li><a href="http://www.soaplite.com/">SOAP::Lite</a></li>

<li><a href="http://xml.apache.org/xerces-c/">Xerces/C++</a></li>

<li><a href="http://www.w3.org/XML/Schema">XML Schema</a></li>

<li><a href="http://search.cpan.org/~samtregar/XML-Validator-Schema/">XML::Validator::Schema</a></li>

<li><a href="http://www.oreilly.com/catalog/pwebserperl/">Programming Web
Services with Perl</a> by Randy J. Ray and Pavel Kulchenko</li>

</ul>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1362" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/09/axkit.html" rel="bookmark">An AxKit Image Gallery</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Barrie Slaymaker</span> on <abbr class="published" title="2002-09-24T00:00:00-08:00">September 24, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->
<p>AxKit is not limited to working with pure XML data.  Starting with
this article, we'll work with and around non-XML data by developing
an image browser that works with two types of non-XML data: a directory
listing built from operating system calls (file names and statistics)
and image files. Furthermore, it will be built from small modules that
you can adapt to your needs or use elsewhere, like the <a href="/pub/a/2002/09/24/axkit.html?page=4#My::Thumbnailer">thumbnail generator</a> or the <a href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">HTML table wrapper</a>.</p>

<p>By the time we're done, several articles from now, we'd like an
application that:</p>

<ul>

  <li>provides navigation around a tree of directories containing images,</li>

  <li>displays <a href="/pub/a/2002/09/24/axkit.html?page=1#proofsheet.png">image galleries with
  thumbnails</a>,</li>

  <li>ignores nonimage files,</li>

  <li>allows you to define and present a custom set of information
  ("meta data") about each image,</li>

  <li>allows you to view the complete images with and without
  metadata,</li>

  <li>uses a non-AxKit mod_perl handler to generate thumbnail images on
  the fly, and</li>

  <li>allows you to edit the metadata information in-browser</li>

</ul>

<p>That feature list should allow us to build a "real world" 
application (rather than the weather examples we've
discussed so far), and hopefully a useful one as well.  Here's a
screenshot of the page created by this article and the next:</p>

<p><a name="proofsheet.png"></a><img src="/pub/2002/09/24/graphics/proofsheet.png" alt="Example page." width="472" height="661" border="0"/></p>

<p>That page has four sections:</p>

<ol>
    <li><b>Heading</b>: Tells you where you are and offers navigation
    up the directory tree.</li>
    <li><b>Folders</b>: links to the parent directory and any sub
    folders (Jim and Mary).</li>
    <li><b>Images</b>: offers a thumbnail and caption area for
    each image.  Clicking on an image or image title takes you to
    the full-size variant.</li>
    <li><b>Footer</b>: A breadcrumbs display for getting back up the
    directory tree after scrolling down through a large page of
    images.</li>
</ol>

<p>We'll implement the (most challenging) third section in this article
and the other section in the next article.</p>

<p>If you want to review the basics of AxKit and Apache configuration,
then here are the previous articles in this series:</p>

<ul>
    <li><a href="/pub/a/2002/03/12/axkit.html">Introducing
    AxKit</a></li>
    <li><a href="/pub/a/2002/04/16/axkit.html">XSP,
    Taglibs and Pipelines</a></li>
    <li><a href="/pub/a/2002/07/02/axkit.html">Taglib TMTOWTDI</a></li>
</ul>

<a name="WorkingWithNonXMLDataAsXML"/><h3>Working with non-XML data as XML</h3>

<p>The easiest way to actually work with non-XML data in AxKit is 
to turn it in to XML often and feed it to AxKit.  AxKit itself takes this
approach in its new directory handling feature -- thanks to Matt Sergeant
and J&ouml;rg Walters AxKit can now scan the directory and build an XML
document with all of the data.  This is a lot like what native Apache
does when it serves up an HTML directory listing, but it allows
you to filter it.  The main part of this article is about
filtering this directory listing in order to create a gallery, or
proofsheet, of thumbnail images.</p>

<!--  begin sidebar  -->
<table width="50%" border="0" cellspacing="8" cellpadding="8"  align="right">
<tr><td valign="top" bgcolor="#efefef">
<p class="medlist"><b>In This Series</b></p>
<p class="smalllist"><b>
<a href="/pub/a/2002/03/16/axkit.html">Introducing AxKit</a></b><br />
The first in a series of articles by Barrie Slaymaker on setting up and running
AxKit. AxKit is a mod_perl application for dynamically transforming XML. In this
 first article, we focus on getting started with AxKit.</p>
<p class="smalllist"><b>
<a href="/pub/a/2002/04/16/axkit.html">XSP, Taglibs and Pipelines</a></b><br />
Barrie explains what a "taglib" is, and how to use them to create dynamic pages
inside of AxKit.</p>
<p class="smalllist"><b><a href="/pub/a/2002/07/02/axkit.html">Taglib TMTOWTDI</a></b><br />
Continuing our look at AxKit tag libraries, Barrie explains the use of SimpleTaglib and LogicSheets.</p>
</td></tr>
</table>
<!--  end sidebar  -->

<p>In this case, we'll be using a relatively recent addition to AxKit's
standard toolkit, SAX Machines, integrated in to AxKit thanks to Kip
Hampton. (disclaimer: <a href="http://search.cpan.org/author/RBS/XML-SAX-Machines/lib/XML/SAX/Machines.pm">XML::SAX::Machines</a>
is a module I wrote.) The SAX machine we'll create will be a straight
pipeline with a few filters, a lot like the pipelines that AxKit uses.
This pipeline will dissect directory listings and generate a list of
images segmented into rows for easy display purposes.  We don't get in
to the details of SAX or SAX machines except to bolt together three
building blocks; all of the gory details are handled for us by other
modules.  If you are interested in the gory details, then see <a href="http://xml.com/pub/a/2002/02/13/sax-machines.html">Part One</a>
and <a href="http://xml.com/pub/a/2002/03/20/machines.html">Part Two</a>
of Kip's article "Introducing XML::SAX::Machines" on <a href="http://xml.com/">XML.com</a>.</p>

<p>After the SAX machine builds our list of images, XSLT will be used to
merge in metadata (like image titles and comments) from independant XML
files and format the result for the browser.  The resulting pages look
like:</p>


<a name="ManagingNonXMLData"/><h3>Managing non-XML data (the images)</h3>

<p>On the other hand, it doesn't make sense to XMLify raw image data (though things like <a href="http://www.w3.org/TR/SVG/">SVG</a>--covered in <a href="http://www.xml.com/pub/q/sacresvg">XML.com's Sacre SVG
articles</a>--and <a href="http://www.lysator.liu.se/~alla/dia/">dia</a>
files are a natural fit), so we'll take advantage of AxKit's integration
with Apache and mod_perl to delegate image handlng to these more suitable
tools.</p>

<p>This is done by using a distinctive URL for thumbnail image files and
a custom mod_perl handler, <a href="/pub/a/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a> to convert full-size images
to thumbnails.  Neither AxKit nor mod_perl code will be used to serve
the images, that will be left to Apache.</p>

<p>Thumbnails will be autogenerated in files with the same name as the
main image file with a leading period (".") stuck on the front.  In Unix
land, this indicates a hidden file, and we don't want thumbnails (or other
dotfiles) showing up in our gallery pages.</p>

<p>My::Thumbnailer uses the relatively new <a href="http://search.cpan.org/author/ADDI/Imager/Imager.pm">Imager</a>
module by Arnar M. Hrafnkelsson and Tony Cook.  This is a best-of-breed
module that competes with the likes of the venerable <a href="http://search.cpan.org/author/LDS/GD/GD.pm">GD</a>, the juggernaut
<a href="http://search.cpan.org/author/JCRISTY/PerlMagick/Magick.pm">Image::Magick</a>,
and <a href="http://search.cpan.org/author/JLAPEYRE/libplot-perl/Libplot.pm">Graphics::Libplot</a>).
Imager is gaining a reputation for speed, quality and a full-featured
API.</p>


<csperl file="include_from_orn" record="b/708" template="b/article_sidebar2.view">



<a name="TheMetaFile" /><h3>The <code>.meta</code> file</h3>

<p>Before we delve in to the implementation, let's look at one of the
more subtle points of this design.  Our previous examples have all been
of straight pipelines that successively process a source document into
an HTML page.  In this application, however, we'll be funneling data
from the source document and a collection of related files we'll call
meta files.</p>

<p>This subtlety is not apparent from the <a href="/pub/a/2002/09/24/axkit.html?page=1#proofsheet.png">screenshot</a>, but if you look closely you can
see that the caption for the first image ("A baby picture") contains
more information than the captions for the other eight.  This is because
the first image has a meta file that contains a title and a comment to
be displayed while the others don't (though they could).</p>

<p> The first image ("A baby picture") is from a file named
<code>a-look.jpeg</code>, for which there is a meta file named
<code>a-look.meta</code> in the same directory that looks like
(<b>bold</b> shows the data that ends up getting sent to the
browser):</p>

<a name="a-look.meta"/>
<pre><code>    &lt;meta&gt;
      &lt;title&gt;<b>A baby picture</b>&lt;/title&gt;
      &lt;comment&gt;
        <b>&lt;b&gt;ME!&lt;/b&gt;.  Well, not really.  Actually, it's some
        random image from the 'net.</b>
      &lt;/comment&gt;
    &lt;/meta&gt;</code></pre>

<p>An important feature of this file is that its contents and how they
are presented within the caption area are completely unspecified by the
core image gallery code.  This makes our image gallery highly
customizable: the site designer can determine what meta information
needs to be associated with each image and how that information gets 
presented.  Data can be presented in the thumbnail caption, in the
expanded view, or used for nondisplay purposes.</p>

<p>Here's what's in each caption area:</p>

<ol>

  <li><b>The title</b>.  If a .meta file is found for an image and it
  has a nonempty <code>&lt;title&gt;</code> element, then it is used
  as the name, otherwise the image's filename is stripped of extensions
  and used.</li>

  <li><b>The last modified time of the image file</b> (in server-local
  time, unfortunately).</li>

  <li><b>A comment</b> (optional): if a .meta file has a
  <code>&lt;comment&gt;</code> element, including XHTML markup, it is
  displayed.</li>

</ol>

<p>Why a .meta file per image instead of one huge file? It will
hopefully allow admins to manage images and meta files together and to
allow us to access an image's meta information in a single file, a
natural thing to do in AxKit.  By having a pair of files for each image,
you can use simple filesystem manipulations to move them around, or use
filesystem links to make an image appear in multiple directories,
perhaps with the same meta file, perhaps with different ones.  This way
we don't need to develop a lot of complex features to get a lot of
mileage out of our image gallery (though we could if need be).</p>


<a name="ThePipeline" /><h3>The Pipeline</h3>

<p>No AxKit implementation documentation would be complete without
detailing the pipeline.  Here is the pipeline for the image proofsheet
page shown above (click on any of the boxes to take you to the
discussion about that portion of the pipeline, click on any of the
miniature versions of this diagram to come to this one):</p>

<a name="pipeline.png"></a>
<table width="450" border="0" cellspacing="0" cellpadding="0"><tr><td>
<p class="secondary"><img src="/pub/2002/09/24/graphics/pipeline.png" alt="The AxKit pipeline for the image gallery application, take 1" width="450" height="385" border="0" USEMAP="pipeline_png_map" /><br />
<MAP name="pipeline_png_map" id="pipeline_png_map">
<!-- #$-:Image Map file created by GIMP Imagemap Plugin -->
<!-- #$-:GIMP Imagemap Plugin by Maurits Rijk -->
<!-- #$-:Please do not edit lines starting with "#$" -->
<!-- #$VERSION:1.3 -->
<!-- #$AUTHOR:barries -->
<AREA SHAPE="RECT" COORDS="0,0,71,100" href="/pub/a/2002/09/24/axkit.html?page=2#filelist" alt="The &lt;filelist&gt; document generated by AxKit">
<AREA SHAPE="RECT" COORDS="87,43,186,69" href="/pub/a/2002/09/24/axkit.html?page=2#My::Filelist2Data" alt="My::Filelist2Data. Converts the <filelist> to a Perl data structure">
<AREA SHAPE="RECT" COORDS="201,43,280,69" href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet" alt="My::ProofSheet.  Takes the Perl data structure and generates a list of images with some metadata">
<AREA SHAPE="RECT" COORDS="297,43,390,70" href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper" alt="XML::Filter::TableWrapper.  Segments the list of images in to rows suitable for use in an HTML &lt;table&gt;">
<AREA SHAPE="RECT" COORDS="73,0,408,82" href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine" alt="My::ProofSheetMachine.  A SAX machine containing 3 SAX filters">
<AREA SHAPE="RECT" COORDS="62,219,146,358" href="/pub/a/2002/09/24/axkit.html?page=3#rowsplitter.xsl" alt="rowsplitter.xsl.  Converts each row of thumbnail metadata in to two rows, one for images, the other for captions">
<AREA SHAPE="RECT" COORDS="147,218,221,384" href="/pub/a/2002/09/24/axkit.html?page=3#metamerger.xsl" alt="metamerger.xsl.  Adds in the external .meta files, if they exist">
<AREA SHAPE="RECT" COORDS="105,123,267,199" href="/pub/a/2002/09/24/axkit.html#TheMetaFile" alt=".meta files for the images">
<AREA SHAPE="RECT" COORDS="226,219,302,358" href="/pub/a/2002/09/24/axkit.html?page=4#captionstyler.xsl" alt="captionstyler.xsl.  Converts the captions to XHTML">
<AREA SHAPE="RECT" COORDS="306,218,386,382" href="/pub/a/2002/09/24/axkit.html?page=4#pagestyler.xsl" alt="pagestyler.xsl.  Converts the main part of the page to XHTML">
<AREA SHAPE="RECT" COORDS="391,208,449,292" href="/pub/a/2002/09/24/axkit.html?page=1#proofsheet.png" alt="the final output">
</MAP>
The blue documents are content: the directory listing, the meta files and the generated HTML.  This does not show the image processing, see <a href="/pub/a/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a> for that.</p>

</td></tr></table>

<p>In this case, unlike our previous pipelines, data does not flow in a
purely linear fashion: The directory listing from AxKit (<a href="/pub/a/2002/09/24/axkit.html?page=2#filelist">&lt;filelist&gt;</a>) feeds the pipeline and is
massaged by three SAX filters and then by four XSLT filters.  There are so many
filters because this application is built to be customizable by tweaking
specific filters or by adding other filters to the pipeline.  It also
uses several SAX filters available on CPAN to make life
much easier for us.</p>

<p>In actual use, you may want to add more filters for things like
branding, distinguishing groups of images by giving directory
heirarchies different backgrounds or titles, adding ad banners, etc.</p>
  
<p>Here's a brief description of what each filter does, and why each is
an independant filter:</p>

<ul>

  <li><a href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a> is a
  short module that builds a <a href="http://search.cpan.org/author/RBS/XML-SAX-Machines/lib/XML/SAX/Machines.pm#DESCRIPTION">SAX
  Machine Pipeline</a>.  SAX filters are used in this application to
  handle tasks that are more suited to Perl than to XSLT or XSP:

    <ul>

      <li><a href="/pub/a/2002/09/24/axkit.html?page=2#My::Filelist2Data">My::FileList2Data</a> is another
      short module that uses the <a href="http://search.cpan.org/author/GRANTM/XML-Simple/Simple.pm">XML::Simple</a>
      module from CPAN to convert the <code>&lt;filelist&gt;</code> in
      to a Perl data structure that is passed on.  This is its own
      filter because we want to customize XML::Simple and the resulting
      data structure a bit before passing it on.</li>

      <li><a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> is the heart of
      the gallery page generation.  It builds a list of images from the
      filelist data structure and adds information about the
      thumbnail images and meta files.</li>

      <li><a href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a>
      is a module from CPAN
      that is used to wrap a possibly lengthy list of images into rows
      of no more than five images each.</li>

    </ul>

  </li>

  <li><a href="/pub/a/2002/09/24/axkit.html?page=3#rowsplitter.xsl">rowsplitter.xsl</a> takes each row of images and makes it
  into two table rows: one for the images and one for the captions.
  This is easier to do in XSLT than in SAX, so here is where we shift
  from SAX processing to XSLT processing.</li>

  <li><a href="/pub/a/2002/09/24/axkit.html?page=3#metamerger.xsl">metamerger.xsl</a> examines each caption
  to see if My::ProofSheet put the URL for a meta file in it.  If so, it
  opens the meta file and inserts it in the caption.  This is a separate
  filter because the site admin may prefer to write a custom filter here
  to integrate meta information from some other source, like a single
  master file or a centralized database.</li>

  <li><a href="/pub/a/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> looks at each
  caption and rewrites it to be XHTML.  This is a separate filter for
  two reasons: it allows the look and feel of the captions to be altered
  without having to mess with the other filters and, because it is the
  only filter that cares about the contents of the meta file, the site
  admin can alter the schema of the meta files and then alter this
  filter to match.</li>

  <li><a href="/pub/a/2002/09/24/axkit.html?page=4#pagestyler.xsl">pagestyler.xsl</a> converts everything
  outside of the caption elements in to HTML.  It is separate so that
  the page look and feel can be altered per-site or per-directory
  without affecting the caption content, etc.</li> </ul>

<p>There are several key things to note about this design.  The first is
that the separation of the process into multiple filters offers the
administrator the ability to modify the site's content and styling.
Second, because AxKit is built on Apache's configuration engine, which
filters are used for a particular directory request can be selected
based on URL, directory path, query string parameters, browser types,
etc.  The third point to note is the use of SAX processors to handle
tasks that are easier (far easier in some cases) to implement in Perl,
while XSLT is used when it is more (programmer and/or processor)
efficient.</p>














<a name="httpd.conf"></a><a name="TheConfiguration"></a><h3>The Configuration</h3>

<p>Here's how we configure AxKit to do all of this:</p>

<pre><code>    ##
    ## Init the httpd to use our "private install" libraries
    ##
    PerlRequire startup.pl

    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &lt;Directory "/home/me/htdocs"&gt;
        Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxTraceIntermediate /home/me/axtrace

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param

        AxAddStyleMap text/xsl \
                      Apache::AxKit::Language::LibXSLT

        <b>AxAddStyleMap application/x-saxmachines \
                      Apache::AxKit::Language::SAXMachines</b>

    &lt;/Directory&gt;

    <b>
    &lt;Directory "/home/me/htdocs/04"&gt;
        </b><font color="#000000"># Enable XML directory listings (see <a href="/pub/a/2002/09/24/axkit.html?page=2#filelist">Generating File Lists</a>)</font><b>
        AxHandleDirs On

        </b><font color="#000000">#######################</font><b>
        </b><font color="#000000"># Begin pipeline config</font><b>
        AxAddRootProcessor application/x-saxmachines . \
            {http://axkit.org/2002/filelist}filelist
        PerlSetVar AxSAXMachineClass "<a href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a>"

        </b><font color="#000000"># The absolute stylesheet URLs are because</font><b>
        </b><font color="#000000"># I prefer to keep stylesheets out of the</font><b>
        </b><font color="#000000"># htdocs for security reasons.</font><b>
        AxAddRootProcessor text/xsl <a href="/pub/a/2002/09/24/axkit.html?page=3#rowsplitter.xsl">file:///home/me/04/rowsplitter.xsl</a> \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl <a href="/pub/a/2002/09/24/axkit.html?page=3#metamerger.xsl">file:///home/me/04/metamerger.xsl</a> \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl <a href="/pub/a/2002/09/24/axkit.html?page=4#captionstyler.xsl">file:///home/me/04/captionstyler.xsl</a> \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl <a href="/pub/a/2002/09/24/axkit.html?page=4#pagestyler.xsl">file:///home/me/04/pagestyler.xsl</A> \
            {http://axkit.org/2002/filelist}filelist
        </b><font color="#000000"># End pipeline config</font><b>
        </b><font color="#000000">#####################</font><b>

        </b><font color="#000000"># This is read by <a href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a></font><b>
        PerlSetVar MyColumns 5

        </b><font color="#000000"># This is read by <a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a></font><b>
        PerlSetVar MyMaxX 100

        </b><font color="#000000"># Send thumbnail image requests to our</font><b>
        </b><font color="#000000"># thumbnail generator</font><b>
        &lt;FilesMatch "^\."&gt;
            SetHandler  perl-script
            PerlHandler My::Thumbnailer
            PerlSetVar  MyMaxX 100
            PerlSetVar  MyMaxY 100
        &lt;/FilesMatch&gt;
        
    &lt;/Directory&gt;</b></code></pre>

<p>The first <code>&lt;Directory&gt;</code> section contains the AxKit
directives we introduced in <a href="/pub/a/2002/07/02/axkit.html?page=2#MixingAndMatching">article
1</a> and a new stylesheet mapping for
<code>application/x-saxmachines</code> that allows us to use a SAX machine in
the pipeline.  Otherwise, all of the configuration directives key to
this example are in the <code>&lt;Directory
"/home/me/htdocs/04"&gt;</code> section.</p>

<blockquote><p>We saw basic examples of how AxKit works with the Apache
configuration engine in <a href="/pub/a/2002/07/02/axkit.html?page=2#MixingAndMatching">article
1</a> and <a href="/pub/a/2002/04/16/axkit.html#httpd.conf">article
2</a> in this series.  We'll use this photo gallery application to
demonstrate many of the more powerful mechanisms in a future article.</p>
</blockquote>

<p>By setting <code>AxHandleDirs On</code>, we tell AxKit to generate
the &lt;filelist&gt; document (<a href="/pub/a/2002/09/24/axkit.html?page=2#GeneratingFileLists">described in the section
Generating File Lists</a>) in the 04
directory and below.</p>

<p>Then it's off to configure the pipeline for the 04 directory
hierarchy.  To do this, we take advantage of the fact that AxKit places
all elements in the filelist document in to the namespace
<code>http://axkit.org/2002/filelist</code>.  The
<code>AxAddRootProcessor</code>'s third parameter causes AxKit to look
at all documents it serves from the 04 directory tree and check to see
whether the root element matches the namespace and element name.</p>

<blockquote>
<p>This is specified in the notation used
by James Clark in his <a href="http://www.jclark.com/xml/xmlns.htm">introduction to XML
namespaces</a>.</p>
</blockquote>

<p>If the document matches, and all AxKit-generated filelists will, then
the MIME type and the stylesheet specified in the first two parameters
are added to the pipeline.  The four <code>AxAddRootProcessor</code>
directives add the SAX machine and the four XSLT filters we described in
<a href="/pub/a/2002/09/24/axkit.html#ThePipeline">the section "The Pipeline"</a>.</p>

<p>When loading a SAX machine into the pipeline, you can give it a
simple list of SAX filters (<a href="http://search.cpan.org/search?mode=module&amp;query=XML%3A%3AFilter">there are many available on
CPAN</a>) and it will build a pipeline of them.  This is done with a
(not shown) <code>PerlSetVar AxSAXMachineFilters "..."</code> directive.
The limitation with this directive is that you cannot pass in any
initialization values to the filters and we want to.</p>

<p>So, instead, we use the <code>PerlSetVar AxSAXMachineClass
"My::ProofSheetMachine"</code> to tell the
Apache::AxKit::Language::SAXMachines module to load the class
<a href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a>
and let that class construct the SAX machine.</p>

<p>The final part of the configuration uses a <code>&lt;Files&gt;</code>
section to forward all requests for thumbnail images to the mod_perl
handler in <a href="/pub/a/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a>.</p>

<a name="WalkingThePipeline" /><h3>Walking the Pipeline</h3>

<p>Now that we have our filters in place, let's walk the pipeline and
take a look at each filter and what it emits.</p>

<a name="filelist"/>
<a name="GeneratingFileLists" /><h4>Generating File Lists</h4>

<p><a name="pipeline_filelist.png"  href="/pub/a/2002/09/24/axkit.html#pipeline.png"><img src="/pub/2002/09/24/graphics/pipeline_filelist.png" alt="&lt;filelist&gt; document's position in the processing pipeline" width="110" height="84" border="0" align="right"/></a></p>

<p>First, here's a look at the <code>&lt;filelist&gt;</code> document that
feeds the chain.  This is created by AxKit when it serves a directory
request in much the same way that Apache creates HTML directory
listings.  AxKit only generates these pages when <code>AxHandleDirs
On</code> directive.  This causes AxKit to scan the directory for the
above screenshot and emit XML like (whitespace added, repetitive stuff
elided):</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!DOCTYPE filelist PUBLIC
      "-//AXKIT/FileList XML V1.0//EN"
      "file:///dev/null"
    &gt;
    &lt;filelist xmlns="http://axkit.org/2002/filelist"&gt;
      &lt;directory
        atime="1032276941"
        mtime="1032276939"
        ctime="1032276939"
        readable="1"
        writable="1"
        executable="1"
        size="4096" &gt;.&lt;/directory&gt;
      &lt;directory ...&gt;<b>..</b>&lt;/directory&gt;
      &lt;directory ...&gt;<b>Mary</b>&lt;/directory&gt;
      &lt;directory ...&gt;<b>Jim</b>&lt;/directory&gt;
      &lt;file <b>mtime="1031160766"</b> ...&gt;a-look.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1031160787"</b> ...&gt;<b>a-lotery</b>.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1031160771"</b> ...&gt;<b>a-lucky</b>.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1032197214"</b> ...&gt;a-look.meta&lt;/file&gt;
      &lt;file <b>mtime="1035239142"</b> ...&gt;foo.html&lt;/file&gt;
      ...
    &lt;/filelist&gt;</code></pre>

<p>The emboldened bits are the pieces of data we want to display: some
filenames and their modification times.  Some things to notice:
</p>
<ul>

<li>All of the elements -- most importantly the root element as we'll see
in a bit -- are in a special namespace,
<code>http://axkit.org/2002/filelist</code>, using the
<code>xmlns=</code> attribute (see <a href="http://www.jclark.com/xml/xmlns.htm">James Clark's
introduction</a> for details).</li>

<li>The entries are in unsorted order.  We might want to allow the
user to sort by different attributes someday, but this means that we at
least need to sort the results somehow.</li>

<li>They contain the complete output from the <code>stat()</code> system
call as attributes, so we can use the <code>mtime</code> attribute to
derive a modification time.</li>

<li>There are
files in there (<code>a-look.meta</code> and <code>foo.html</code>) that
we clearly should not be displayed as images.</li>

<li>The filename for <code>a-look.jpeg</code> is not emboldened: We'll
use the <code>&lt;title&gt;</code> element from the
<code>a-look.meta</code> file instead.</li>

</ul>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!DOCTYPE filelist PUBLIC
      "-//AXKIT/FileList XML V1.0//EN"
      "file:///dev/null"
    &gt;
    &lt;filelist xmlns="http://axkit.org/2002/filelist"&gt;
      &lt;directory
        atime="1032276941"
        mtime="1032276939"
        ctime="1032276939"
        readable="1"
        writable="1"
        executable="1"
        size="4096" &gt;.&lt;/directory&gt;
      &lt;directory ...&gt;<b>..</b>&lt;/directory&gt;
      &lt;directory ...&gt;<b>Mary</b>&lt;/directory&gt;
      &lt;directory ...&gt;<b>Jim</b>&lt;/directory&gt;
      &lt;file <b>mtime="1031160766"</b> ...&gt;a-look.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1031160787"</b> ...&gt;<b>a-lotery</b>.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1031160771"</b> ...&gt;<b>a-lucky</b>.jpeg&lt;/file&gt;
      &lt;file <b>mtime="1032197214"</b> ...&gt;a-look.meta&lt;/file&gt;
      &lt;file <b>mtime="1035239142"</b> ...&gt;foo.html&lt;/file&gt;
      ...
    &lt;/filelist&gt;</code></pre>

<a name="My::ProofSheetMachine" /></a><h4>My::ProofSheetMachine</h4>

<p><a name="pipeline_proofsheetmachine_pm.png" href="/pub/a/2002/09/24/axkit.html#pipeline.png"></a>
<img src="/pub/2002/09/24/graphics/pipeline_proofsheetmachine_pm.png" alt="My::ProofSheetMachine's position in the processing pipeline." width="110" height="84" border="0" align="right"/></p>

<p>The processing pipeline is kicked off with a set of three SAX filters built by the My::ProofSheetMachine module:</p>


<pre><code>    package My::ProofSheetMachine;
    
    use strict;
    
    use XML::SAX::Machines qw( Pipeline );
    use My::ProofSheet;
    use XML::Filter::TableWrapper;
    
    sub new {
        my $proto = shift;
        return bless {}, ref $proto || $proto;
    }
    
    sub get_machine {
        my $self = shift;
        my ( $r ) = @_;
    
        my $m = Pipeline(
            <a href="/pub/a/2002/09/24/axkit.html?page=2#My::Filelist2Data">My::Filelist2Data</a>
            => <a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a>->new( Request => $r ),
            => <a href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a>->new(
                ListTags => "{}images",
                Columns  => $r->dir_config( "MyColumns" ) || 3,
            ),
        );
    
        return $m;
    }
    
    1;</code></pre>

<p>This module provides a minimal constructor, <code>new()</code> so it
can be instantiated (this is an Apache::AxKit::Language::SAXMachines
requirement, we don't need that for our sake).  AxKit will call the
<code>get_machine()</code> method once each request to obtain the SAX
machine is used.  SAX machines are not reused from request to request.</p>

<p><code>$r</code> is a reference to the <a href="http://search.cpan.org/author/JIMW/libapreq/Request/Request.pm">Apache
request</a> object (well, actually, to an AxKit subclass of it).  This
is passed into 
<a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a>, which uses to interact
query some <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a> settings, to control
AxKit's cache, and to probe the filesystem through Apache.</p>

<p><code>$r</code> is also queried in this module to see whether there is a
<code>MyColumns</code> setting for this request, with a default
in case, it's not.  The <code>ListTags</code> setting tells <a href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a> to
segment the image list produced by the first two filters into rows of
images (preparing it to be an HTML table, in other words).</p>

<p>The need to pass parameters like this to the SAX filters is the sole
reason we're using a SAX machine factory class like this.  This class is
specified by using <code>PerlSetVar AxSAXMachineClass</code>; if we
didn't need to initialize the filters like this, then we could have listed
them in a <code>PerlSetVar AxSAXMachineFilters</code> directive.  For
more details on how SAX machines are integrated with AxKit, see <a href="http://search.cpan.org/author/MSERGEANT/AxKit/lib/Apache/AxKit/Language/SAXMachines.pm">the
man page</a></p>

<p>Currently, only one SAX machine is allowed in an AxKit pipeline at a
time (though different pipelines can have different machines in them).
This is a limitation of the configuration system more than anything and
may well change if need be.  However, if we need to add SAX processors
to the end of the machine, then the <code>PerlSetVar
AxSAXMachineFilters</code> can be used to insert site-specific filters
after the main machine (and before the XSLT processors).</p>

<a name="My::Filelist2Data"></a><h4>My::Filelist2Data</h4>


<a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_filelist.png2"><p><img src="/pub/2002/09/24/graphics/pipeline_filelist2data_pm.png" alt="My::Filelist2Data's position in the processing pipeline." width="110" height="84" border="0" align="right"/></a></p>

<p>Converting the <code>&lt;filelist&gt;</code> into a proofsheet takes a
bit of detailed data munging.  This is quite easy in Perl, so the first
step in our pipeline is to convert the XML file listing into data.  <a href="http://search.cpan.org/author/GRANTM/XML-Simple/Simple.pm">XML::Simple</a>
provides this functionality for us, and we overload it so we can grab
the resulting data structure and pass it on:</p>

<pre><code>    package My::Filelist2Data;
    
    use XML::Simple;
    @ISA = qw( XML::Simple );
    
    use strict;
    
    sub new {
        my $proto = shift;
        my %opts = @_;
    
        <font color="#000000"># The Handler value is passed in by the Pipeline()</font>
        <font color="#000000"># call in My::ProofSheetMachine.</font>
        my $h = delete $opts{Handler};
    
        <font color="#000000"># Even if there's only one file element present,</font>
        <font color="#000000"># make XML::Simple put it in an ARRAY so that</font>
        <font color="#000000"># the downstream filter can depend on finding an</font>
        <font color="#000000"># array of elements and not a single element.</font>
        <font color="#000000"># This is an XML::Simple option that is almost</font>
        <font color="#000000"># always set in practice.</font>
        $opts{forcearray} = [qw( file )];
    
        <font color="#000000"># Each &lt;file> and &lt;directory> element contains</font>
        <font color="#000000"># the file name as simple text content.  This</font>
        <font color="#000000"># option tells XML::Simple to store it in the</font>
        <font color="#000000"># data member "filename".</font>
        $opts{contentkey} = "filename";
    
        <font color="#000000"># This subroutine gets called when XML::Simple</font>
        <font color="#000000"># has converted the entire document with the</font>
        <font color="#000000"># $data from the document.</font>
        $opts{DataHandler} = sub {
            shift;
            my ( $data ) = @_;
    
            <font color="#000000"># If no files are found, place an array</font>
            <font color="#000000"># reference in the right spot.  This is to</font>
            <font color="#000000"># to simplify downstream filter code.</font>
            $data->{file}      ||= [];
    
            <font color="#000000"># Pass the data structure to the next filter.</font>
            $h->generate( $data );
        } if $h;
    
        <font color="#000000"># Call XML::Simple's constructor.</font>
        return $proto->SUPER::new( %opts );;
    }
    
    1;</code></pre>

<p>Sending a data structure like this between SAX machines using a
non-SAX event is known as "cheating."  But this is Perl, and
allowing you to cheat responsibly and judiciously is one of Perl's great
strengths.  This works and should work for the foreseeable future.  If
you're planning on doing something like this for a general purpose
filter, then it behooves you to also provide <code>set_handler</code> and
<code>get_handler</code> methods so your filter can be repositioned
after instantiation (something XML::SAX::Machines do if need be), but we
don't need to clutter this single-purpose example.</p>

<p>The <code>&lt;filelist&gt;</code> document gets converted to a Perl
data structure where each element is a data member in a HASH or an
array,  like (data elided and rearranged to relate well to the
source XML):</p>

<pre><code>    {
      xmlns => 'http://axkit.org/2002/filelist',
      directory => [
        {
          atime      => '1032276941'
          mtime      => '1032276939',
          ctime      => '1032276939',
          readable   => '1',
          writable   => '1',
          executable => '1',
          size       => '4096',
          content    => '.',
        },
        {
          ...
          content    => '<b>..</b>',
        },
        {
          ...
          content    => '<b>Mary</b>',
        },
        {
          ...
          content    => '<b>Jim</b>',
        }
      ]
      file => [
        {
          <b>mtime      => '1031160766</b>',
          ...
          content    => '<b>a-look.jpeg</b>',
        },
        {
          <b>mtime      => '1031160787</b>',
          ...
          content    => '<b>a-lotery.jpeg</b>',
        },
        {
          <b>mtime      => '1031160771</b>',
          ...
          content    => '<b>a-lucky.jpeg</b>',
        },
        {
          <b>mtime      => '035239142</b>',
          ...
          content    => '<b>foo.html</b>',
        },
        ...
      ],
    }</code></pre>















<a name="My::ProofSheet"></a><h4>My::ProofSheet</h4>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_proofsheet_pm.png"><img src="/pub/2002/09/24/graphics/pipeline_proofsheet_pm.png" alt="My::ProofSheet's position in the processing pipeline." width="110" height="84" border="0" align="right"/></a></p>

<p>Once the data is in Perl data structure, it's easy to tweak it (making
<code>mtime</code> fields into something readable, for instance)
and extend it (adding information about thumbnail images and .meta
files, for instance).  This is what My::ProofSheet does:</p>


<pre><code>    package My::ProofSheet;
    
    use XML::SAX::Base;
    @ISA = qw( XML::SAX::Base );
    
    <font color="#000000"># We need to access the Apache request object to</font>
    <font color="#000000"># get the URI of the directory we're presenting,</font>
    <font color="#000000"># its physical location on disk, and to probe</font>
    <font color="#000000"># the files in it to see if they are images.</font>
    use Apache;
    
    <font color="#000000"># My::Thumbnailer is an Apache/mod_perl module that</font>
    <font color="#000000"># creates thumbnail images on the fly.  See below.</font>
    use My::Thumbnailer qw( image_size thumb_limits );
    
    <font color="#000000"># XML::Generator::PerlData lets us take a Perl data</font>
    <font color="#000000"># structure and emit it to the next filter serialized</font>
    <font color="#000000"># as XML.</font>
    use XML::Generator::PerlData;
    
    use strict;
    
    sub generate {
        my $self = shift;
        my ( $data ) = @_;
    
        <font color="#000000"># Get the AxKit request object so we can</font>
        <font color="#000000"># ask it for the URI and use it to test</font>
        <font color="#000000"># whether files are images or not.</font>
        my $r = $self->{Request};
    
        my $dirname = $r->uri;      <font color="#000000"># "/04/Baby_Pictures/Other/"</font>
        my $dirpath = $r->filename; <font color="#000000"># "/home/me/htdocs/...Other/"</font>
    
    
        my @images = map $self->file2image( $_, $dirpath ),
            sort {
                $a->{filename} cmp $b->{filename}
            } @{$data->{file}};
    
        <font color="#000000"># Use a handy SAX module to generate XML from our Perl</font>
        <font color="#000000"># data structures.  The XML will look basically like:</font>
        <font color="#000000"># Write XML that looks like</font>
        <font color="#000000">#</font>
        <font color="#000000"># &lt;proofsheet></font>
        <font color="#000000">#   &lt;images></font>
        <font color="#000000">#     &lt;image>...&lt;/image></font>
        <font color="#000000">#     &lt;image>...&lt;/image></font>
        <font color="#000000">#     ...</font>
        <font color="#000000">#   &lt;/images></font>
        <font color="#000000">#   &lt;title>/04/BabyePictures/Others&lt;/title></font>
        <font color="#000000"># &lt;/proofsheet></font>
        <font color="#000000">#</font>
        XML::Generator::PerlData->new(
            rootname => "proofsheet",
            Handler => $self,
        )->parse( {
            title       => $dirname,
            images      => { image => \@images },
        } );
    }
    
    
    sub file2image {
        my $self = shift;
        my ( $file, $dirpath ) = @_;
    
        <font color="#000000"># Remove the filename from the fields so it won't</font>
        <font color="#000000"># show up in the &lt;image> structure.</font>
        my $fn = $file->{filename};
    
        <font color="#000000"># Ignore hidden files (first char is a ".").</font>
        <font color="#000000"># Thumbnail images are cached as hidden files.</font>
        return () if 0 == index $fn, ".";
    
        <font color="#000000"># Ignore files Apache knows aren't images</font>
        my $type = $self->{Request}->lookup_file( $fn )->content_type;
        return () unless
            defined $type
            &amp;&amp; substr( $type, 0, 6 ) eq "image/";
    
        <font color="#000000"># Strip the extension(s) off.</font>
        ( my $name = $fn ) =~ s/\..*//;
    
        <font color="#000000"># A meta filename is the image filename with a ".meta"</font>
        <font color="#000000"># extension instead of whatever extension it has.</font>
        my $meta_fn   = "$name.meta";
        my $meta_path = "$dirpath/$meta_fn";
    
        <font color="#000000"># The thumbnail file is stored as a hidden file</font>
        <font color="#000000"># named after the image file, but with a leading</font>
        <font color="#000000"># '.' to hide it.</font>
        my $thumb_fn   = ".$fn";
        my $thumb_path = "$dirpath/$thumb_fn";
    
        my $last_modified = localtime $file->{mtime};
    
        my $image = {
            %$file,                  <font color="#000000"># Copy all fields</font>
            type           => $type, <font color="#000000"># and add a few</font>
            name           => $name,
            thumb_uri      => $thumb_fn,
            path           => "$dirpath/$fn",
            last_modified  => $last_modified,
        };
    
        if ( -e $meta_path ) {
            <font color="#000000"># Only add a URI to the meta info, metamerger.xsl will</font>
            <font color="#000000"># slurp it up if and only if &lt;meta_uri> is present.</font>
            $image->{meta_filename} = $meta_fn;
            $image->{meta_uri}      = "file://$meta_path";
        }
    
        <font color="#000000"># If the thumbnail exists, grab its width and height</font>
        <font color="#000000"># so later stages can populate the &lt;img> tag with them.</font>
        <font color="#000000"># The eval {} is in case the image doesn't exist or</font>
        <font color="#000000"># the library can't cope with the image format.</font>
        <font color="#000000"># Disable caching AxKit's output if a failure occurs.</font>
        eval {
            ( $image->{thumb_width}, $image->{thumb_height} )
                = image_size $thumb_path;
        } or $self->{Request}->no_cache( 1 );
    
        return $image;
    }
    
    
    1;</code></pre>

<p>When My::Filelist2Data calls <code>generate()</code>,
<code>generate()</code> sorts and scans the list of files by filename,
converts each to an image and sends a page title and the resulting list
of images to the next filter (<a href="/pub/a/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a>).  Kip Hampton's
<a href="http://search.cpan.org./author/KHAMPTON/XML-Generator-PerlData/PerlData.pm">XML::Generator::PerlData</a>
is a Perl data -&gt; XML serialization module.  It's not meant for
generating generic XML; it focuses purely on building an XML
representation of a Perl data structure.  In this case, that's ideal,
because we will be generating the output document with XSLT templates
and we don't care about the exact order of the elements in each
<code>&lt;image&gt;</code> element, each <code>&lt;image&gt;</code>
element is just a hash of key/value pairs.  We do control the order of
the <code>&lt;image&gt;</code> elements, however, by passing an ordered
list of them in to XML::Generator::PerlData as an array.</p>

<p>Sorting by filename may not be the preferred thing to do for all
applications, because users may prefer to sort by the caption title
for the image, but then again they may not, and this allows the site
administrator to control sort order by naming the files appropriately.
We can add always add sorting later.</p>

<p>Another peculiarity of this code is that it doesn't guarantee that
there will be <code>thumb_width</code> and <code>thumb_height</code>
values available.  If you just drop the source images in a directory,
then the first time the server generates this page, there will be no
thumbnails available.  In this case, the call to
<code>no_cache(1)</code> prevents AxKit from caching the output page so
that suboptimal HTML does not get stuck in the cache.  This will give
the server another chance at generating it with proper tags, hoping of
course that by the next time this page is requested, the requisite
thumbnails will be available to measure.</p>

<p>This approach gets the HTML to the browser fast, so the user's
browser window will clear quickly and start filling with the top of ths
page, so the user will see some activity and be less likely to get
impatient.  The thumbnails will be generated when the browser sees all
the <code>&lt;img&gt;</code> tags.  The alternative approach would be to
thumbnail the images inline, which would result in a significant delay
on large listings before the first HTML hits the browser, or
prethumbnailing.</p>

<p>One thing to note about this approach is that many browsers will
request images several at a time, which will cause several server
processes to be thumbnailing several different images at once.  This
should result in lower lag on low-load servers because processes can
interleave CPU time and disk I/O waits, and can take advantage of
multiple processors, if present.  On heavily loaded servers, of course,
this might be a bad thing; pregenerating thumbnails there would be a
good idea.</p>

<p>The output from this filter looks like:</p>

<pre><code>    &lt;?xml version="1.0"?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;image&gt;
          &lt;path&gt;
		    /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
		  &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;<b>a-look.jpeg</b>&lt;/filename&gt;
          &lt;thumb_uri&gt;<b>.a-look.jpeg</b>&lt;/thumb_uri&gt;
          &lt;meta_filename&gt;a-look.meta&lt;/meta_filename&gt;
          &lt;name&gt;a-look&lt;/name&gt;
          &lt;last_modified&gt;<b>Wed Sep  4 13:32:46 2002</b>&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          <b>&lt;meta_uri&gt;
            <a href="/pub/a/2002/09/24/axkit.html#TheMetaFile">file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta</a>
          &lt;/meta_uri&gt;</b>
          &lt;mtime&gt;1031160766&lt;/mtime&gt;
          &lt;size&gt;8522&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032553327&lt;/atime&gt;
        &lt;/image&gt;
        &lt;image&gt;
          &lt;path&gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-lotery.jpeg
          &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;<b>a-lotery.jpeg</b>&lt;/filename&gt;
          &lt;thumb_uri&gt;.a-lotery.jpeg&lt;/thumb_uri&gt;
          &lt;name&gt;<b>a-lotery</b>&lt;/name&gt;
          &lt;last_modified&gt;<b>Wed Sep  4 13:33:07 2002</b>&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          &lt;mtime&gt;1031160787&lt;/mtime&gt;
          &lt;size&gt;10113&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032553327&lt;/atime&gt;
        &lt;/image&gt;
      &lt;/images&gt;
      ...
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;</code></pre>

<p>All the data from the original <code>&lt;file&gt;</code> elements are
in each <code>&lt;image&gt;</code> element along with the new fields.
Note that the first <code>&lt;image&gt;</code> contains the
<code>&lt;meta_uri&gt;</code> (pointing to <a href="/pub/a/2002/09/24/axkit.html#TheMetaFile">a-look.meta</a>)
while the second doesn't because there is no <code>a-lotery.meta</code>.  As
expected both have the <code>&lt;thumb_uri&gt;</code> tags.  The parts
in <b>bold</b> face are the bits that our presentation happens to want;
yours might want more or different bits.</p>

<p>While there is a lot of extra information in this structure, it's
really just the output from one system call (<code>stat()</code>) and
some possibly useful byproducts of the My::ProofSheet machinations, so
it's very cheap information that some front end somewhere might want.
It's also easier to leave it all in than to emit just what our example
frontend might want and will enable any future upstream filters or
extentions to AxKit's directory scanning to shine through.</p>

<p>No <code>&lt;thumb_width&gt;</code> or
<code>&lt;thumb_height&gt;</code> tags are present because I copied this
file from the axtrace directory (see the
<code>AxTraceIntermediate</code> directive in <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">our
httpd.conf file</a>) after viewing a newly added directory.  Here's what
the first <code>&lt;image&gt;</code> element looks like when viewing
after my browser had requested all thumbnails:</p>

<pre><code>    &lt;?xml version="1.0"?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;image&gt;
          <b>&lt;thumb_width&gt;72&lt;/thumb_width&gt;</b>
          &lt;path&gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
          &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;a-look.jpeg&lt;/filename&gt;
          <b>&lt;thumb_height&gt;100&lt;/thumb_height&gt;</b>
          &lt;thumb_uri&gt;.a-look.jpeg&lt;/thumb_uri&gt;
          &lt;meta_filename&gt;a-look.meta&lt;/meta_filename&gt;
          &lt;name&gt;a-look&lt;/name&gt;
          &lt;last_modified&gt;Wed Sep  4 13:32:46 2002&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          &lt;meta_uri&gt;
            file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta
          &lt;/meta_uri&gt;
          &lt;mtime&gt;1031160766&lt;/mtime&gt;
          &lt;size&gt;8522&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032784360&lt;/atime&gt;
        &lt;/image&gt;
        ...
      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;</code></pre>

<a name="XML::Filter::TableWrapper" /><h4>XML::Filter::TableWrapper</h4>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_tablewrapper_pm.png"><img src="/pub/2002/09/24/graphics/pipeline_tablewrapper_pm.png" alt="My::TableWrapper's position in the processing pipeline" width="110" height="84" border="0" align="right"/></a></p>

<p><a href="http://search.cpan.org/author/RBS/XML-Filter-TableWrapper/lib/XML/Filter/TableWrapper.pm">XML::Filter::TableWrapper</a>
is a CPAN module is used to take the <code>&lt;images&gt;</code> list
and segmenting it by insert <code>&lt;tr&gt;...&lt;/tr&gt;</code> tags
around every (it's configurable) <code>&lt;image&gt;</code>
elements.  This configuration is done by the <a href="/pub/a/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a> module we showed
earlier:</p>

<pre><code>    XML::Filter::TableWrapper->new(
        ListTags => "{}images",
        Columns  => $r->dir_config( "MyColumns" ) || 3,
    ),</code></pre>

<p>The output, for our list of 9 images, looks like:</p>

<pre><code>    &lt;?xml version="1.0"?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;tr&gt;
          &lt;image&gt;
            ...
          &lt;/image&gt;
          ... 4 more image elements...
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;image&gt;
            ...
          &lt;/image&gt;
          ... 3 more image elements...
        &lt;/tr&gt;
      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;</code></pre>

<p>Now all the presentation stylesheet (<a href="/pub/a/2002/09/24/axkit.html?page=4#pagestyler.xsl">pagestuler.xsl</a>) can key off the
<code>&lt;tr&gt;</code> tags to build an HTML <code>&lt;table&gt;</code>
or ignore them (and not pass them through) if it wants to display in a
list format.</p>

<p>While I'm sure this is possible in XSLT, I have no idea how to do it easily.</p>

<a name="rowsplitter.xsl" /><h4>rowsplitter.xsl</h4>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_rowsplitter_xsl.png"><img src="/pub/2002/09/24/graphics/pipeline_rowsplitter_xsl.png" alt="rowsplitter.xsl's position in the processing pipeline." width="110" height="84" border="0" align="right"/></a></p>

<p>Experimentation with an early version of this application showed that
presenting captions in the same table cell as the thumbnails when the
thumbnails are of differing heights caused the captions to be showed at
varying heights.  This made it hard to scan the captions and added a lot
of visual clutter to the page.</p>

<p>One solution is to add an XSLT filter that splits each table row of
image data in to two rows, one for the thumbnail and another for the
caption:</p>

<pre><code>    &lt;xsl:stylesheet 
      version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    &gt;
    
    &lt;xsl:template match="image" mode="caption"&gt;
      &lt;caption&gt;
        &lt;xsl:copy-of select="@*|*|node()" /&gt;
      &lt;/caption&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="images/tr"&gt;
      &lt;xsl:copy-of select="." /&gt;
      &lt;tr>&lt;xsl:apply-templates select="image" mode="caption" /&gt;&lt;/tr&gt;
    &lt;/xsl:template&gt;
    
    &lt;xsl:template match="@*|node()"&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select="@*|node()"/&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;
    
    &lt;/xsl:stylesheet&gt;</code></pre>

<p>The second template in this stylesheet matches each row
(<code>&lt;tr&gt;</code> element) in the <code>&lt;images&gt;</code>
element and copies it verbatim and then emits a second
<code>&lt;tr&gt;</code> element right after it with a list of
<code>&lt;caption&gt;</code> elements with copies of the content of each
of the <code>&lt;image&gt;</code> tags in the original row.  The first
template is applied only to the <code>&lt;image&gt;</code> tags when
creating this second row due to the <code>mode="caption"</code>
attributes.</p>

<p>The third template is a standard piece of XSLT boilerplate that
passes through all the XML that is not matched by the first two
templates.  This XML would otherwise be mangled (stripped of elements,
to be specific) by the wacky default XSLT rules.</p>

<p>Now, I know several ways to do this in Perl in the AxKit environment
and none are so easy for me as using XSLT.  <a href="http://info.astrian.net/jargon/terms/y.html#YMMV">YMMV</a>.</p>

<p>The output from that stage looks like:</p>


<pre><code>    &lt;?xml version="1.0"?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;

        &lt;tr&gt;&lt;image&gt;...  &lt;/image&gt;   ...total of 5... &lt;/tr&gt;
        &lt;tr&gt;&lt;caption&gt;...&lt;/caption&gt; ...total of 5... &lt;/tr&gt;

        &lt;tr&gt;&lt;image&gt;...  &lt;/image&gt;   ...total of 4... &lt;/tr&gt;
        &lt;tr&gt;&lt;caption&gt;...&lt;/caption&gt; ...total of 4... &lt;/tr&gt;

      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;</code></pre>

<p>The content of each <code>&lt;image&gt;</code> tag and each
<code>&lt;caption&gt;</code> tag is identical.  It's easier to do the
transform this way and allows the frontend stylesheets the flexibility
of doing things like putting the image filename or modification time in
the same cell as the thumbnail.<p>

<a name="metamerger.xsl" /><h4>metamerger.xsl</h4>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_metamerger_xsl.png"><img src="/pub/2002/09/24/graphics/pipeline_metamerger_xsl.png" alt="metamerger.xsl's position in the processing pipeline" border="0" align="right"/></a></p>

<p>As with the row splitter, expressing the metamerger in XSLT is an
expedient way of merging in external XML documents, for several reasons.
The first is for efficiency's sake: We're already using XSLT before and
after this filter, and AxKit optimizes XSLT->XSLT handoffs to avoid
reparsing.  Another is that the underlying implementation of AxKit's
XSLT engine is the speedy C of libxslt. A third is that we're not
altering the incoming file at all in this stage, so the XSLT does not
get out of hand (I do not consider XSLT to be a very readable
programming language; its XML syntax makes for very opaque source code).</p>

<p>Another approach would be to go back and tweak <a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> to inherit from <a href="http://search.cpan.org/author/RBS/XML-SAX-Machines/lib/XML/Filter/Merger.pm">XML::Filter::Merger</a>
and insert it using a SAX parser.  That would be a bit slower, I
suspect, because SAX parsing in general tends to be slower than XSLT's
internal parsing.  It would rob the application of the configurability
that having merging as a separate step engenders.  By factoring this
functionality in to the metamerger.xsl stylesheet, we offer the site
designer the ability to pull data from other sources, or even to fly
without any metadata at all.</p>

<p>Here's what metamerger.xsl looks like:</p>

<pre><code>    &lt;xsl:stylesheet 
      version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    >
    
    &lt;xsl:template match="caption">
      &lt;caption>
        &lt;xsl:copy-of select="*|@*|node()" />
        &lt;xsl:copy-of select="document( meta_uri )" />
      &lt;/caption>
    &lt;/xsl:template>
    
    &lt;xsl:template match="*|@*">
      &lt;xsl:copy>
        &lt;xsl:apply-templates select="*|@*|node()" />
      &lt;/xsl:copy>
    &lt;/xsl:template>
    
    &lt;/xsl:stylesheet></code></pre>

<p>The first template does all the work of matching each
<code>&lt;caption&gt;</code> element and copying its content, then
parsing and inserting the document indicated by the
<code>&lt;meta_uri&gt;</code> element, if present.  The
<code>document()</code> function turns into a noop if
<code>&lt;meta_uri&gt;</code> is not present.  The second template is
that same piece of boilerplate we saw in <a href="/pub/a/2002/09/24/axkit.html?page=3#rowsplitter.xsl">rowsplitter.xsl</a> to copy through everything we don't explicitly match.














<p>And here's what the <code>&lt;caption&gt;</code> for
<code>a-look.jpeg</code> now looks like (all the other
<code>&lt;caption&gt;</code> elements were left untouched because there
are no other .meta files in this directory):</p>

<pre><code>    &lt;caption>
      &lt;thumb_width>72&lt;/thumb_width>
      &lt;path>/home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg&lt;/path>
      &lt;writable>1&lt;/writable>
      &lt;filename>a-look.jpeg&lt;/filename>
      &lt;thumb_height>100&lt;/thumb_height>
      &lt;thumb_uri>.a-look.jpeg&lt;/thumb_uri>
      &lt;meta_filename>a-look.meta&lt;/meta_filename>
      &lt;name>a-look&lt;/name>
      &lt;last_modified>Wed Sep  4 13:32:46 2002&lt;/last_modified>
      &lt;ctime>1032552249&lt;/ctime>
      &lt;meta_uri>file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta&lt;/meta_uri>
      &lt;mtime>1031160766&lt;/mtime>
      &lt;size>8522&lt;/size>
      &lt;readable>1&lt;/readable>
      &lt;type>image/jpeg&lt;/type>
      &lt;atime>1032784360&lt;/atime>
      <b>&lt;meta>
        &lt;title>A baby picture&lt;/title>
        &lt;comment>&lt;b>ME!&lt;/b>.  Well, not really.  Actually, it's some random image from the 'net.
&lt;/comment>
      &lt;/meta></b>
    &lt;/caption></code></pre>

<p>As mentioned before, this stylesheet does not care what you put in
the meta file, it just inserts anything in that file from the root
element on down.  So you are free to put any meta information your
application requires in the meta file and adjust the presentation
filters to style it as you will.</p>

<p>The .meta information is not inserted in to the
<code>&lt;image&gt;</code> tags because we know that none of our
presentation will not need any of it there.</p>

<a name="captionstyler.xsl" /><h4>captionstyler.xsl</h4>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_captionstyler_xsl.png"><img src="/pub/2002/09/24/graphics/pipeline_captionstyler_xsl.png" alt="captionstyler.xsl's position in the processing pipeline" width="110" height="84" border="0" align="right" /></a></p>

<p>The last two stages of our pipeline turn the data assembled so far into HTML.  This is done in two stages in order to separate general layout and presentation from the presentation of the caption because the
these portions of the presentation might need to vary independently between one collection of images and another.</p>

<p>The caption stylesheet for this example is:</p>


<pre><code>    &lt;xsl:stylesheet 
      version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    >
    
    &lt;xsl:template match="caption">
      &lt;caption width="100" align="left" valign="top">
    
        &lt;a href="{filename}">
          &lt;xsl:choose>
            &lt;xsl:when test="meta/title and string-length( meta/title )">
              &lt;xsl:copy-of select="meta/title/node()" />
            &lt;/xsl:when>
            &lt;xsl:otherwise>
              &lt;xsl:value-of select="name" />
            &lt;/xsl:otherwise>
          &lt;/xsl:choose>
        &lt;/a>&lt;br />
    
        &lt;font size="-1" color="#808080">
          &lt;xsl:copy-of select="last_modified/node()" />
          &lt;br />
        &lt;/font>
    
        &lt;xsl:copy-of select="meta/comment/node()" />
    
      &lt;/caption>
    &lt;/xsl:template>
    
    &lt;xsl:template match="*|@*|node()">
      &lt;xsl:copy>
        &lt;xsl:apply-templates />
      &lt;/xsl:copy>
    &lt;/xsl:template>
    
    &lt;/xsl:stylesheet></code></pre>

<p>The first template replaces all <code>&lt;caption&gt;</code> elements
with new <code>&lt;caption&gt;</code> cells with a default width and
alignment, and then fills these with the name of the image, which is
also a link to the underling image file, and the
<code>&lt;last_modified</code> time string formatted by <a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> and any
<code>&lt;comment&gt;</code> that might be present in the meta
file.</p>

<p>The <code>&lt;xsl:choose&gt;</code> element is what selects the title
to display for the image.  The first <code>&lt;xsl:when&gt;</code>looks
to see if there is a <code>&lt;title&gt;</code> element in the meta file
and uses it if present.  The
<code>&lt;xsl:otherwise&gt;</code> defaults the name to the
<code>&lt;name&gt;</code> set by My::ProofSheet.</p>

<p>The captions output by this stage look like:</p>

<pre><code>    &lt;caption width="100" align="left" valign="top">
      &lt;a href="a-look.jpeg">A baby picture&lt;/a>
      &lt;br/>
      &lt;font size="-1" color="#808080">Wed Sep
        4 13:32:46 2002&lt;br/>
      &lt;/font>
      &lt;b>ME!&lt;/b>.  Well, not really.  Actually, it's
        some random image from the 'net.
    &lt;/caption>
    &lt;caption width="100" align="left" valign="top">
      &lt;a href="a-lotery.jpeg">a-lotery&lt;/a>
      &lt;br/>
      &lt;font size="-1" color="#808080">Wed Sep
        4 13:33:07 2002&lt;br/>&lt;/font>
    &lt;/caption></code></pre>

<p>The former is what comes out when a .meta file is found, the latter
when it is not.</p>

<a name="pagestyler.xsl"/><h4>pagestyler.xsl</h4>

<p>And now, the final stage.  If you've made it this far,
congratulations; this is the start of a real application and not just a
toy, so it's taken quite some time to get here.</p>

<p><a href="/pub/a/2002/09/24/axkit.html#pipeline.png" name="pipeline_pagestyler_xsl.png"><img src="/pub/2002/09/24/graphics/pipeline_pagestyler_xsl.png" alt="pagestyler.xsl's position in the processing pipeline" width="110" height="84" border="0" align="right"/></a></p>

<p>The final stage of the processing pipeline generates an HTML page from the raw data, except for the attributes and content of <code>&lt;caption&gt;</code> tags, which it passes through as-is:</p>


<pre><code>    &lt;xsl:stylesheet 
      version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    >
    
    &lt;xsl:template match="/*">
      &lt;html>
        &lt;head>
          &lt;title>Images in &lt;xsl:value-of select="title" />&lt;/title>
        &lt;/head>
        &lt;body bgcolor="#ffffff">
          &lt;xsl:apply-templates select="images" />
        &lt;/body>
      &lt;/html>
    &lt;/xsl:template>
    
    
    &lt;xsl:template match="images">
      &lt;table>
        &lt;xsl:apply-templates />
      &lt;/table>
    &lt;/xsl:template>
    
    &lt;xsl:template match="tr">
      &lt;xsl:copy>
        &lt;xsl:apply-templates select="*" />
      &lt;/xsl:copy>
    &lt;/xsl:template>
    
    &lt;xsl:template match="image">
      &lt;td align="left" valign="top">
        &lt;a href="{filename}">
          &lt;img border="0" src="{thumb_uri}">
            &lt;xsl:if test="thumb_width">
              &lt;xsl:attribute name="width">
                &lt;xsl:value-of select="thumb_width" />
              &lt;/xsl:attribute>
            &lt;/xsl:if>
            &lt;xsl:if test="thumb_height">
              &lt;xsl:attribute name="height">
                &lt;xsl:value-of select="thumb_height" />
              &lt;/xsl:attribute>
            &lt;/xsl:if>
          &lt;/img>
        &lt;/a>
      &lt;/td>
    &lt;/xsl:template>
    
    &lt;xsl:template match="@*|node()" mode="caption">
      &lt;xsl:copy>
        &lt;xsl:apply-templates select="@*|node()" mode="caption" />
      &lt;/xsl:copy>
    &lt;/xsl:template>
    
    &lt;xsl:template match="caption">
      &lt;td>
        &lt;xsl:apply-templates select="@*|node()" mode="caption" />
      &lt;/td>
    &lt;/xsl:template>
    
    &lt;/xsl:stylesheet></code></pre>

<p>The first template generates the skeleton of the HTML page, the
second one grabs the <code>&lt;images&gt;</code> list from the source
document, emits a <code>&lt;table&gt;</code>, the third copies the
<code>&lt;tr&gt;</code> tags, the fourth replaces all
<code>&lt;image&gt;</code> tags with <code>&lt;td&gt;</code> tags
containing the thumbnail image as a link to the underlying image
(similar to what <a href="/pub/a/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> did
with the picture name).  The only subtlety here is that the optional
<code>&lt;thumb_width&gt;</code> and <code>&lt;thumb_height&gt;</code>
elements are used, if present, to inform the browser of the size of the
thumbnail in order to speed up the layout process (as mentioned before, pages
that don't contain this information are not cached so that when the
thumbnails are generated, new HTML will be generated with it).</p>

<p>The fourth template converts the <code>&lt;caption&gt;</code>
elements to <code>&lt;td&gt;</code> elements and copies all their
content through, since <a href="/pub/a/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> already did the
presentation for them.</p>

<p>Tweaking this stylesheet or replacing it controls the entire page
layout other than thumbnail sizing (which is set by the optional
<code>MyMaxX</code> and <code>MyMaxY</code> <code>PerlSetVar</code>
settings in <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a>).  A different
stylesheet in this point in the chain could choose to ignore the
<code>&lt;tr&gt;</code> tags and present a list style output.  A later
stylesheet could be added to add branding or advertising to the site,
etc., etc.</p>

<a name="My::Thumbnailer"/><h4>My::ThumbNailer</h4>

<p>Here's the apache module that generates thumbnails.  The key thing to
remember is that, unlike all the other code and XML shown in this
article, this is called once per thumbnail image, not once per
directory.  When a browser requests a directory listing, it gets HTML
from the pipeline above with lots of URIs for thumbnail images.  It will
then usually request each of those in turn.  The <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a> file directs all requests for dotfiles
to this module:</p>


<pre><code>    package My::Thumbnailer;
    
    <font color="#000000"># Allow other modules like <a href="/pub/a/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</A> to use some</font>
    <font color="#000000"># of our utility routines.</font>
    use Exporter;
    @ISA = qw( Exporter );
    @EXPORT_OK = qw( image_size thumb_limits );
    
    use strict;
    
    use <a href="http://search.cpan.org/author/DOUGM/mod_perl-1.27/Constants/Constants.pm">Apache::Constants</a> qw( DECLINED );
    use <a href="http://search.cpan.org/author/JIMW/libapreq/Request/Request.pm">Apache::Request</a>;
    use <a href="http://search.cpan.org/author/JHI/perl/lib/File/Copy.pm">File::Copy</a>;
    use <a href="http://search.cpan.org/author/ADDI/Imager/Imager.pm">Imager</a>;
    
    
    sub image_size {
        my $img = shift;
    
        if ( ! ref $img ) {
            my $fn = $img;
            $img = Imager->new;
            $img->open( file => $fn )
                or die $img->errstr(), ": $fn";
        }
    
        ( $img->getwidth, $img->getheight );
    }
    
    
    sub thumb_limits {
        my $r = shift;
    
        <font color="#000000"># See if the site admin has placed MyMaxX and/or</font>
        <font color="#000000"># MyMaxY in the <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a>.</font>
        my ( $max_w, $max_h ) = map
            $r->dir_config( $_ ),
            qw( MyMaxX MyMaxY );
    
        return ( $max_w, $max_h )
            if $max_w || $max_h;
    
        <font color="#000000"># Default to scaling down to fit in a 100 x 100</font>
        <font color="#000000"># pixel area (aspect ration will be maintained).</font>
        return ( 100, 100 );
    }
    
    
    <font color="#000000"># Apache/mod_perl <a href="/pub/a/2002/09/24/axkit.html?page=2#httpd.conf">is configured</a> to call</font>
    <font color="#000000"># this handler for every dotfile</font>
    <font color="#000000"># requested.  All thumbnail images are dotfiles,</font>
    <font color="#000000"># some dotfiles may not be thumbnails.</font>
    sub handler {
        my $r = Apache::Request->new( shift );
    
        <font color="#000000"># We only want to handle images.</font>
        <font color="#000000"># Let Apache handle non-images.</font>
        goto EXIT
            unless substr( $r->content_type, 0, 6 ) eq "image/";
    
        <font color="#000000"># The actual image filename is the thumbnail</font>
        <font color="#000000"># filename without the leading ".".  There's</font>
        ( my $orig_fn = $r->filename ) =~ s{/\.([^/]+)\z}{/$1}
            or die "Can't parse ", $r->filename;
    
        <font color="#000000"># Let Apache serve the thumbnail if it already</font>
        <font color="#000000"># exists and is newer than the original file.</font>
        {
            my $thumb_age = -M $r->finfo;
            my $orig_age  = -M $orig_fn;
            goto EXIT
                if $thumb_age &amp;&amp; $thumb_age &lt;= $orig_age;
        }
    
        <font color="#000000"># Read in the original file</font>
        my $orig = Imager->new;
        unless ( $orig->open( file => $orig_fn ) ) {
            <font color="#000000"># Imager can't hack the format, fall back</font>
            <font color="#000000"># to the original image.  This can happen</font>
            <font color="#000000"># if you forget to install libgif</font>
            <font color="#000000"># (as I have done).</font>
            goto FALLBACK
                if $orig->errstr =~ /format not supported/;
    
            <font color="#000000"># Other errors are probably more serious.</font>
            die $orig->errstr, ": $orig_fn\n";
        }
    
        my ( $w, $h ) = image_size( $orig );
    
        die "!\$w for ", $r->filename, "\n" unless $w;
        die "!\$h for ", $r->filename, "\n" unless $h;
    
        my ( $max_w, $max_h ) = thumb_limits( $r );
    
        <font color="#000000"># Scale down only,  If the image is smaller than</font>
        <font color="#000000"># the thumbnail limits, let Apache serve it as-is.</font>
        <font color="#000000"># thumb_limits() guarantees that either $max_w</font>
        <font color="#000000"># or $max_h will be true.</font>
        goto FALLBACK
            if ( ! $max_w || $w &lt; $max_w )
            &amp;&amp; ( ! $max_h || $h &lt; $max_h );
    
        <font color="#000000"># Scale down to the maximum dimension to the</font>
        <font color="#000000"># requested size.  This can mess up for images</font>
        <font color="#000000"># that are meant to be scaled on each axis</font>
        <font color="#000000"># independantly, like graphic bars for HTML</font>
        <font color="#000000"># page seperators, but that's a very small</font>
        <font color="#000000"># demographic.</font>
        my $thumb = $orig->scale(
            $w > $h
                ? ( xpixels => $max_w )
                : ( ypixels => $max_h )
        );
        $thumb->write( file => $r->filename,)
            or die $thumb->errstr, ": ", $r->filename;
    
        goto BONK;
    
    FALLBACK:
        <font color="#000000"># If we can't or don't want to build the thumbnail,</font>
        <font color="#000000"># just copy the original and let Apache figure it out.</font>
        warn "Falling back to ", $orig_fn, "\n";
        copy( $orig_fn, $r->filename );
    
    BONK:
        <font color="#000000"># Bump apache on the head just hard enough to make it</font>
        <font color="#000000"># forget the thumbnail file's old stat() and</font>
        <font color="#000000"># mime type since we've most likely changed all</font>
        <font color="#000000"># that now.  This is important for the headers</font>
        <font color="#000000"># that control downstream caching, for instance,</font>
        <font color="#000000"># or in case Imager changed mime types on us</font>
        <font color="#000000"># (unlikely, but hey...)</font>
        $r->filename( $r->filename );
    
    EXIT:
        <font color="#000000"># We never serve the image data, Apache is perfectly</font>
        <font color="#000000"># good at doing this without our help.  Returning</font>
        <font color="#000000"># DECLINED causes Apache to use the next handler in</font>
        <font color="#000000"># its list of handlers.  Normally this is the default</font>
        <font color="#000000"># Apache file handler.</font>
        return DECLINED;
    }
    
    1;</code></pre>

<p>There should be enough inline commentary to explain that lot.  The
only thing I'll say is that, to head off the gotophobes, I think the use
of <code>goto</code> makes this routine a lot clearer than the
alternatives; the early versions did not use it and were less
readable/maintainable.  This is because the three normal exit routes
happen to stack nicely up from the bottom so the fallthrough from one
labeled chunk to the next happens nicely.</p>

<p>The most glaring mistake here is that there is no file locking.
We'll add that in next time.</p>

<a name="Summary"/><h3>Summary</h3>

<p>The final result of the code in this article is to build the image
proofsheet section of <a href="/pub/a/2002/09/24/axkit.html?page=1#proofsheet.png">the page we showed at the
beginning of the article</a>.  The next article will complete that page, and
then we'll build the image presentation page and a metadata editor in future
articles.</p>


<a name="help" /><h3>Help and thanks</h3>

<p>In case of trouble, have a look at some of the <a href="/pub/a/2002/03/12/axkit.html?page=3#help">helpful resources we
listed in the first article</a>.</p>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1320" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2002/07/axkit.html" rel="bookmark">Taglib TMTOWTDI</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Barrie Slaymaker</span> on <abbr class="published" title="2002-07-02T00:00:00-08:00">July  2, 2002 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->
<p>As with many Perl systems, AxKit often provides multiple ways of doing
things.  Developers from other programming cultures may find these choices and
freedom a bit bewildering at first but this (hopefully) soon gives way to the
realization that the options provide power and freedom.  When a
tool set limits your choices too much, you end up doing things like driving
screws with a nailgun.  Of course, too many choices isn't necessarily a good
thing, but it's better than too few.</p>

<p><a href="/pub/a/2002/04/16/axkit.html">Last time</a>, we
saw how to build a weather reporting application by implementing a simple
taglib module, My::WeatherTaglib, in Perl and deploying it in <a
herf="/pub/a/2002/04/16/axkit.html#weather1_flow.png">a
pipeline</a> with other XML filters.  The pipeline approach allows one kind of
flexibility: the freedom to decompose an application in the most appropriate
manner for the requirements at hand and for the supporting organization.</p>



<p>Another kind of flexibility is the freedom to implement filters using
different technologies.  For instance, it is sometimes wise to build taglibs in
different ways.  In this article, we'll see how to build the same taglib using
two other approaches.  The first rebuild uses the technique implemented by the
Cocoon project, <a
href="http://xml.apache.org/cocoon/userdocs/xsp/logicsheet-concepts.html">LogicSheets</a>.
The second uses J&ouml;rg Walter's relatively new <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm">SimpleTaglib</a>
in place of the <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm">TaglibHelper</a>
used for My::WeatherTaglib in the previous article. SimpleTaglib is a somewhat
more powerful, and, oddly, more complex module than TaglibHelper (though the
author intends to make it a bit simpler to use in the near future).</p>

<a name="CHANGES" /><h3>CHANGES</h3>

<p>AxKit v1.6 is now out with some nice bug fixes and performance
improvements, mostly by Matt Sergeant and J&ouml;rg Walter, along with several
new advanced features from Kip Hampton which we'll be covering in future
articles. 

<p>Matt has also updated his AxKit compatible <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.6/lib/Apache/AxKit/Language/AxPoint.pm">AxPoint</a>
PowerPoint-like HTML/PDF/etc. presentation system.  If you're going to attend any of the
big Perl conferences this season, then you're likely to see presentations built with
AxPoint. It's a nice system that's also covered in an <a
href="http://www.xml.com/pub/a/2002/06/19/perl-xml.html">XML.com article by Kip
Hampton</a>.</p>

<a name="AxTraceIntermediate" /><h4>AxTraceIntermediate</h4>

<p>The one spiffy new feature I used -- rather more often than I'd like to
admit -- in writing this article is the debugging directive
<code>AxTraceIntermediate</code>, added by J&ouml;rg Walter.  This directive
defines a directory in which AxKit will place a copy each of the intermediate
documents passed between filters in the pipeline.  So a setting like:</p>

<pre><code>    AxTraceIntermediate /home/barries/AxKit/www/axtrace
</code></pre>

<p>will place one file in the <code>axtrace</code> directory for each
intermediate document.  The full set of directives in <code>httpd.conf</code>
used for this article is <a href="/pub/a/2002/07/02/axkit.html?page=2#httpd.conf">shown later</a>.</p>

<p>Here is the axtrace directory after requesting the URIs <code>/</code>
(from the first article), <code>/02/weather1.xsp</code> (from the second
article), <code>/03/weather1.xsp</code> and <code>/03/weather2.xsp</code> (both
from this article):</p>

<pre><code>    |index.xsp.XSP         # Perl source code for /index.xsp
    |index.xsp.0           # Output of XSP filter

    |02|weather1.xsp.XSP   # Perl source code for /02/weather1.xsp
    |02|weather1.xsp.0     # Output of XSP
    |02|weather1.xsp.1     # Output of weather.xsl
    |02|weather1.xsp.2     # Output of as_html.xsl

    |03|weather1.xsp.XSP   # Perl source code for /03/weather1.xsp
    |03|weather1.xsp.0     # Output of XSP
    |03|weather1.xsp.1     # Output of weather.xsl
    |03|weather1.xsp.2     # Output of as_html.xsl

    |03|weather2.xsp.XSP   # Perl source code for /02/weather2.xsp
    |03|weather2.xsp.0     # output of my_weather_taglib.xsl
    |03|weather2.xsp.1     # Output of XSP
    |03|weather2.xsp.2     # Output of weather.xsl
    |03|weather2.xsp.3     # Output of as_html.xsl
</code></pre>

<p>Each filename is the path portion of the URI with the <code>/</code>s
replaced with <code>|</code>s and a step number (or .XSP) appended.  The
numbered files are the intermediate documents and the <code>.XSP</code> files
are the Perl source code for any XSP filters that happened to be compiled for
this request.  Compare the <code>|03|weather2.xsp.*</code> files to the <a
href="#weather2_pipeline.png">the pipeline diagram</a> for the /03/weather2.xsp
request.

<p>Watch those "<code>|</code>" characters: they force you to quote the
filenames in most shells (and thus foil any use of wildcards):</p>

<pre><code>    $ <b>xmllint --format "www/axtrace/|03|weather2.xsp.3"</b>
    &lt;?xml version="1.0" standalone="yes"?&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/&gt;
        &lt;title&gt;My Weather Report&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;a name="title"/&gt;My Weather Report&lt;/h1&gt;
        &lt;p&gt;Hi! It's 12:43:52&lt;/p&gt;
        &lt;p&gt;The weather in Pittsburgh is Sunny
        ....
</code></pre>

<p><b>NOTE:</b> The <code>.XSP</code> files are only generated if the XSP sheet
is recompiled, so you may need to <code>touch</code> the source document or
restart the server to generate a new one.  Another gotcha is that if an error
occurs halfway down the processing pipeline, then you can end up with stale files.
In this case, the lower-numbered files (those generated by successful filters)
will be from this request, but the higher-numbered files will be stale, left
over from the previous requests.  A slightly different issue can occur when
using dynamic pipeline configurations (which we'll cover in the future): you
can end up with a shorter pipeline that only overwrites the lower-numbered
files and leaves stale higher-numbered files around.</p>

<p>These are pretty minor gotchas when compared to the usefulness of this
feature, you just need to be aware of them to avoid confusion.  When debugging
for this article, I used a Perl script that does something like:</p>

<pre><code>    rm -f www/axtrace/*
    rm www/logs/*
    www/bin/apachectl stop
    sleep 1
    www/bin/apachectl start
    GET http://localhost:8080/03/weather1.xsp
</code></pre>

<p>to start each test run with a clean fileset.</p>

<a name="UnderTheXSPHood" /><h3>Under the XSP Hood</h3>

<p>Before we move on to the examples, let's take a quick peek at how XSP pages
are handled by AxKit.  This will help us understand the tradeoffs inherent in
the different approaches.</p>

<p>AxKit implements XSP filters by compiling the source XSP page into a
<code>handler()</code> function that is called to generate the output page.
This is compiled in to Perl bytecode, which is then run to generate the XSP
output document:</p>

<a name="xsp_compiler.png" /><img src="/pub/2002/07/02/graphics/xsp_compiler.png" alt="XSP architecture" width="340" height="219" />

<p>This means that XSP page is not executed directly, but by running relatively
efficient compiled Perl code.  The bytecode is kept in memory so the overhead
of parsing and code generation is not incurred for each request.</p>

<p>There are three types of Perl code used in building the output
document: code to build the bits of static content, code that was
present verbatim in the source document -- enclosed in tags like
<code>&lt;xsp:logic&gt;</code> and
<code>&lt;xsp:expr&gt;</code> -- and code that implements tags
handled by registered taglib modules like My::WeatherTaglib
from the last article.<p>

<p>Taglib modules hook in to the XSP compiler by registering themselves
as handlers for a namespace and then coughing up snippets of code to be
compiled in to the <code>handler()</code> routine:</p>

<a name="xsp_taglib_hookin.png" /><img src="/pub/2002/07/02/graphics/xsp_taglib_hookin.png" alt="XSP with Taglib Modules Hooking in" width="351" height="372" />

<p>The snippets of code can call back into the taglib module or out to other
modules as needed.  Modules like <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm">TaglibHelper</a>,
which we used to build My::WeatherTaglib and <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm">SimpleTaglib</a>,
which we use later in this article for My::SimpleWeatherTaglib, automate the
drudgery of building a taglib module so you don't need to parse XML or even
(usually) generate XML.</p>

<p>You can view the source code that AxKit generates by cranking the
<code>AxDebugLevel</code> up to 10 (which places the code in Apache's ErrorLog)
or using the <code>AxTraceIntermediate</code> directive mentioned above.  Then
you must persuade AxKit to recompile the XSP page by restarting the server and
requesting a page. If either of the necessary directives are already present in
a running server, then simply <code>touch</code>ing the file to update its
modification time will suffice.</p>

<p>This can be useful for getting a <i>really</i> good feel for what's going on
under the hood.  I encourage new taglib authors to do this to see how the code
for your taglib is actually executed.  You'll end up needing to do it to debug
anyway (trust me :).</p>

<a name="XSLT" /><h3>LogicSheets: Upstream Taglibs</h3>

<p>AxKit uses a pipeline processing model and XSP includes tags like
<code>&lt;xsp:logic&gt;</code> and <code>&lt;xsp:expr&gt;</code> that allow you
to embed Perl code in an XSP page.  This allows taglibs to be implemented as XML
filters that are placed upstream of the XSP processor.  These usually use XSLT
to and convert taglib invocations to inline code using XSP tags:</p>

<a name="logic_sheet_pipeline.png" /><img src="/pub/2002/07/02/graphics/logic_sheet_pipeline.png" alt="Upstream LogicSheets feeding the XSP processor" width="420" height="200"/>

<p>In fact, this is how XSP was originally designed to operate and Cocoon uses
this approach exclusively to this day (but with inline Java instead of Perl).
I did not show this approach in the first article because it is considerably
more awkward and less flexible than the taglib module approach offered by
AxKit.</p>

<p>The Cocoon project calls XSLT sheets that implement taglibs <a
href="http://xml.apache.org/cocoon/userdocs/xsp/logicsheet-concepts.html">LogicSheets</a>
a convention I follow in this article (I refer to the all-Perl taglib
implementation as "taglib modules").</p>

<a name="weather2.xsp" /><h4><code>weather2.xsp</code></h4>

<p>Before we look at the logicsheet version of the weather report
taglib, here is the XSP page from the last article updated to use
it:

<pre><code>
<b>&lt;?xml-stylesheet href="my_weather_taglib.xsl" type="text/xsl"?&gt;</b>
&lt;?xml-stylesheet href="NULL"                  type="application/x-xsp"?&gt;
&lt;?xml-stylesheet href="weather.xsl"           type="text/xsl"?&gt;
&lt;?xml-stylesheet href="as_html.xsl"           type="text/xsl"?&gt;

&lt;xsp:page
    xmlns:xsp="<b>http://apache.org/xsp/core/v1</b>"
    xmlns:util="http://apache.org/xsp/util/v1"
    xmlns:param="http://axkit.org/NS/xsp/param/v1"
    xmlns:weather="http://slaysys.com/axkit_articles/weather/"
&gt;
&lt;data&gt;
  &lt;title&gt;&lt;a name="title"/&gt;My Weather Report&lt;/title&gt;
  &lt;time&gt;
    &lt;util:time format="%H:%M:%S" /&gt;
  &lt;/time&gt;
  &lt;weather&gt;
    &lt;weather:report&gt;
      &lt;!-- Get the ?zip=12345 from the URI and pass it
           to the weather:report tag as a parameter --&gt;
      &lt;weather:zip&gt;&lt;param:zip/&gt;&lt;/weather:zip&gt;
    &lt;/weather:report&gt;
  &lt;/weather&gt;
&lt;/data&gt;
&lt;/xsp:page&gt;
</code></pre>

<!--  begin sidebar  -->
<table width="50%" border="0" cellspacing="8" cellpadding="8"  align="right">
<tr><td valign="top" bgcolor="#efefef">
<p class="medlist"><b>In This Series</b></p>
<p class="smalllist"><b>
<a href="/pub/a/2002/03/16/axkit.html">Introducing AxKit</a></b><br />
The first in a series of articles by Barrie Slaymaker on setting up and running AxKit. AxKit is a mod_perl application for dynamically transforming XML. In this first article, we focus on getting started with AxKit.</p>
<p class="smalllist"><b>
<a href="/pub/a/2002/04/16/axkit.html">XSP, Taglibs and Pipelines</a></b><br />
Barrie explains what a "taglib" is, and how to use them to create dynamic pages inside of AxKit.</p>
</td></tr>
</table>
<!--  end sidebar  -->
<p>The <code>&lt;?xml-stylesheet href="my_weather_taglib.xsl"
type="text/xsl"?&gt;</code> processing instruction causes
<code>my_weather_taglib.xsl</code> (which we'll cover next) to be applied to
the <code>weather2.xsp</code> page before the XSP processor sees it.  The other
three PIs are identical to the previous version: the XSP processor is invoked,
followed by the same <a
href="/pub/a/2002/04/16/axkit.html#weather.xsl"
alt="previous article">presentation</a> and <a
href="/pub/a/2002/04/16/axkit.html#as_html.xsl"
alt="previous article">HTMLification</a> XSLT stylesheets that we used last
time.</p>

<p>The only other change from the previous version is that this one uses the
corrent URI for XSP tags.  I accidently used a deprecated URI for XSP tags in
the previous article and ended up tripping over it when I used the up-to-date
URI in the LogicSheet for this one.  Such is the life of a pointy-brackets
geek.</p>

<p>The ability to switch implementations without altering (much) code is one of
XSP's advantages over things like inline Perl code: the implementation is
nicely decoupled from the API (the tags).  The only reason we had to alter
<code>weather1.xsp</code> at all is because we're switching from a more
advanced approach (a taglib module, My::WeatherTaglib) that is configured in
the <code>httpd.conf</code> file to LogicSheets, which need per-document
configuration when using <code>&lt;xml-stylesheet&gt;</code> stylesheet
specifications.  AxKit has more flexible <code>httpd.conf</code>, plugin and
Perl based stylesheet specification mechanisms which we will cover in a future
article; I'm using the processing instructions here because they are simple and
obvious.</p>

<p>The pipeline built by the processing instructions looks like:</p>

<a name="weather2_pipeline.png" /><img src="/pub/2002/07/02/graphics/weather2_pipeline.png" alt="The pipeline for weather2.xsp" width="409" height="197" />

<p>(does not show final compression stage).</p>

<a name="my_weather_taglib.xsl" /><h4><code>my_weather_taglib.xsl</code></h4>

<p>Now that we've seen the source document and the overall pipeline,
here is <a
href="/pub/a/2002/04/16/axkit.html#My::WeatherTaglib">My::WeatherTaglib</a>
recast as a LogicSheet, <code>my_weather_taglib.xsl</code>:

<pre><code>
&lt;xsl:stylesheet 
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xsp="http://apache.org/xsp/core/v1"
  xmlns:weather="http://slaysys.com/axkit_articles/weather/"
&gt;

&lt;xsl:output indent="yes" /&gt;

&lt;xsl:template match="xsp:page"&gt;
  &lt;xsl:copy&gt;
<b>    &lt;xsp:structure&gt;
      use Geo::Weather;
    &lt;/xsp:structure&gt;</b>
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="weather:report"&gt;
<b>  &lt;xsp:logic&gt;
    my $zip = &lt;xsl:apply-templates select="weather:zip/*" /&gt;;
    my $w = Geo::Weather-&gt;new-&gt;get_weather( $zip );
    die "Could not get weather for zipcode '$zip'\n" unless ref $w;
  &lt;/xsp:logic&gt;</b>
  &lt;state&gt;<b>&lt;xsp:expr&gt;$w-&gt;{state}&lt;/xsp:expr&gt;</b>&lt;/state&gt;
  &lt;heat&gt;<b>&lt;xsp:expr&gt;$w-&gt;{heat}&lt;/xsp:expr&gt;</b>&lt;/heat&gt;
  &lt;page&gt;<b>&lt;xsp:expr&gt;$w-&gt;{page}&lt;/xsp:expr&gt;</b>&lt;/page&gt;
  &lt;wind&gt;<b>&lt;xsp:expr&gt;$w-&gt;{wind}&lt;/xsp:expr&gt;</b>&lt;/wind&gt;
  &lt;city&gt;<b>&lt;xsp:expr&gt;$w-&gt;{city}&lt;/xsp:expr&gt;</b>&lt;/city&gt;
  &lt;cond&gt;<b>&lt;xsp:expr&gt;$w-&gt;{cond}&lt;/xsp:expr&gt;</b>&lt;/cond&gt;
  &lt;temp&gt;<b>&lt;xsp:expr&gt;$w-&gt;{temp}&lt;/xsp:expr&gt;</b>&lt;/temp&gt;
  &lt;uv&gt;<b>&lt;xsp:expr&gt;$w-&gt;{uv}&lt;/xsp:expr&gt;</b>&lt;/uv&gt;
  &lt;visb&gt;<b>&lt;xsp:expr&gt;$w-&gt;{visb}&lt;/xsp:expr&gt;</b>&lt;/visb&gt;
  &lt;url&gt;<b>&lt;xsp:expr&gt;$w-&gt;{url}&lt;/xsp:expr&gt;</b>&lt;/url&gt;
  &lt;dewp&gt;<b>&lt;xsp:expr&gt;$w-&gt;{dewp}&lt;/xsp:expr&gt;</b>&lt;/dewp&gt;
  &lt;zip&gt;<b>&lt;xsp:expr&gt;$w-&gt;{zip}&lt;/xsp:expr&gt;</b>&lt;/zip&gt;
  &lt;baro&gt;<b>&lt;xsp:expr&gt;$w-&gt;{baro}&lt;/xsp:expr&gt;</b>&lt;/baro&gt;
  &lt;pic&gt;<b>&lt;xsp:expr&gt;$w-&gt;{pic}&lt;/xsp:expr&gt;</b>&lt;/pic&gt;
  &lt;humi&gt;<b>&lt;xsp:expr&gt;$w-&gt;{humi}&lt;/xsp:expr&gt;</b>&lt;/humi&gt;</b>
&lt;/xsl:template&gt;

&lt;xsl:template match="@*|node()"&gt;
  &lt;!-- Copy the rest of the doc almost verbatim --&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</code></pre>

<p>The first <code>&lt;xsl:template&gt;</code> inserts an
<code>&lt;xsp:structure&gt;</code> at the top of the page with some Perl code
to <code>use Geo::Weather;</code> so the Perl code in the later
<code>&lt;xsl:logic&gt;</code> element can refer to it.  You could also preload
Geo::Weather in <code>httpd.conf</code> to share it amongst httpd processes and
simplify this stylesheet, but that would introduce a bit of a maintainance
hassle: keeping the server config and the LogicSheet in synchronization.</p>

<p>The second <code>&lt;xsl:template&gt;</code> replaces all occurences of
<code>&lt;weather:report&gt;</code> (assuming the <code>weather:</code> prefix
happens to map to the taglib URI; see <a
href="http://www.jclark.com/xml/xmlns.htm">James Clark's introduction to
namespace</a> for more details).  In place of the
<code>&lt;weather:report&gt;</code> tag(s) will be some Perl code surrounded by
<code>&lt;xsp:logic&gt;</code> and <code>&lt;xsp:expr&gt;</code> tags.  The
<code>&lt;xsp:logic&gt;</code> tag is used around Perl code that is just logic:
any value the code returns is ignored.  The
<code>&lt;xsp:expr&gt;</code> tags surround Perl code that returns a value to
be emitted as text in the result document.</p>

<p>The <code>get_weather()</code> call returns a hash describing the most
recent weather oberservations somewhere close to a given zip code:</p>

<a name="hash" /><pre><code>    {
      'city'  =&gt; 'Pittsburgh',
      'state' =&gt; 'PA',
      'cond'  =&gt; 'Sunny',
      'temp'  =&gt; '77',
      ...
    };
</code></pre>

<p>All those <code>&lt;xsp:expr&gt;</code> tags extract the values from the hash one by one and build an XML data structure.  The resulting XSP document looks like:

<pre><code>    &lt;?xml version="1.0"?&gt;
    &lt;xsp:page xmlns:xsp="http://apache.org/xsp/core/v1"<br /> xmlns:util="http://apache.org/xsp/util/v1"<br /> xmlns:param="http://axkit.org/NS/xsp/param/v1"<br /> xmlns:weather="http://slaysys.com/axkit_articles/weather/"&gt;
      &lt;xsp:structure&gt;
          use Geo::Weather;
      &lt;/xsp:structure&gt;
      &lt;data&gt;
        &lt;title&gt;&lt;a name="title"/&gt;My Weather Report&lt;/title&gt;
        &lt;time&gt;
          &lt;util:time format="%H:%M:%S"/&gt;
        &lt;/time&gt;
        &lt;weather&gt;
          &lt;xsp:logic&gt;
            my $zip = &lt;param:zip/&gt;;
            my $w = Geo::Weather-&gt;new-&gt;get_weather( $zip );
            die "Could not get weather for zipcode '$zip'\n" unless ref $w;
          &lt;/xsp:logic&gt;
          &lt;state&gt;&lt;xsp:expr&gt;$w-&gt;{state}&lt;/xsp:expr&gt;&lt;/state&gt;
          &lt;heat&gt;&lt;xsp:expr&gt;$w-&gt;{heat}&lt;/xsp:expr&gt;&lt;/heat&gt;
          &lt;page&gt;&lt;xsp:expr&gt;$w-&gt;{page}&lt;/xsp:expr&gt;&lt;/page&gt;
          &lt;wind&gt;&lt;xsp:expr&gt;$w-&gt;{wind}&lt;/xsp:expr&gt;&lt;/wind&gt;
          &lt;city&gt;&lt;xsp:expr&gt;$w-&gt;{city}&lt;/xsp:expr&gt;&lt;/city&gt;
          &lt;cond&gt;&lt;xsp:expr&gt;$w-&gt;{cond}&lt;/xsp:expr&gt;&lt;/cond&gt;
          &lt;temp&gt;&lt;xsp:expr&gt;$w-&gt;{temp}&lt;/xsp:expr&gt;&lt;/temp&gt;
          &lt;uv&gt;&lt;xsp:expr&gt;$w-&gt;{uv}&lt;/xsp:expr&gt;&lt;/uv&gt;
          &lt;visb&gt;&lt;xsp:expr&gt;$w-&gt;{visb}&lt;/xsp:expr&gt;&lt;/visb&gt;
          &lt;url&gt;&lt;xsp:expr&gt;$w-&gt;{url}&lt;/xsp:expr&gt;&lt;/url&gt;
          &lt;dewp&gt;&lt;xsp:expr&gt;$w-&gt;{dewp}&lt;/xsp:expr&gt;&lt;/dewp&gt;
          &lt;zip&gt;&lt;xsp:expr&gt;$w-&gt;{zip}&lt;/xsp:expr&gt;&lt;/zip&gt;
          &lt;baro&gt;&lt;xsp:expr&gt;$w-&gt;{baro}&lt;/xsp:expr&gt;&lt;/baro&gt;
          &lt;pic&gt;&lt;xsp:expr&gt;$w-&gt;{pic}&lt;/xsp:expr&gt;&lt;/pic&gt;
          &lt;humi&gt;&lt;xsp:expr&gt;$w-&gt;{humi}&lt;/xsp:expr&gt;&lt;/humi&gt;
        &lt;/weather&gt;
      &lt;/data&gt;
    &lt;/xsp:page&gt;
</code></pre>

<p>and the output document of that XSP page looks like:</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;data&gt;
      &lt;title&gt;&lt;a name="title"/&gt;My Weather Report&lt;/title&gt;
      &lt;time&gt;17:06:15&lt;/time&gt;
      &lt;weather&gt;
        &lt;state&gt;PA&lt;/state&gt;
        &lt;heat&gt;77&lt;/heat&gt;
        &lt;page&gt;/search/search?what=WeatherLocalUndeclared
        &amp;where=15206&lt;/page&gt;
        &lt;wind&gt;From the Northwest at 9 gusting to 16&lt;/wind&gt;
        &lt;city&gt;Pittsburgh&lt;/city&gt;
        &lt;cond&gt;Sunny&lt;/cond&gt;
        &lt;temp&gt;77&lt;/temp&gt;
        &lt;uv&gt;4&lt;/uv&gt;
        &lt;visb&gt;Unlimited miles&lt;/visb&gt;
        &lt;url&gt;http://www.weather.com/search/search?
        what=WeatherLocalUndeclared&amp;where=15206&lt;/url&gt;
        &lt;dewp&gt;59&lt;/dewp&gt;
        &lt;zip&gt;15206&lt;/zip&gt;
        &lt;baro&gt;29.97 inches and steady&lt;/baro&gt;
        &lt;pic&gt;http://image.weather.com/web/common/wxicons/52/30.gif&lt;/pic&gt;
        &lt;humi&gt;54%&lt;/humi&gt;
      &lt;/weather&gt;
    &lt;/data&gt;
</code></pre>

<a name="LogicSheetAdvantages" /><h4>LogicSheet Advantages</h4>

<ul>

  <li>One taglib can generate XML that calls another taglib.  Taglib
  modules may call each other at the Perl level, but taglib modules are
  XSP compiler plugins and do not cascade: The XSP compiler lives in a
  pipeline environment but does not use a pipeline internally.</li>

  <li>No need to add an <code>AxAddXSPTaglib</code> directive and
  restart the Web server each time you write a tag lib.</li>

</ul>

<p>Restarting a Web server just because a taglib has changed can be
awkward in some environments, but this seems to be rare; restarting an
Apache server is usually quick enough in a development environment and
better not be necessary too often in a production environment.</p>

<p>In the Cocoon community, LogicSheets can be registered and shared somewhat
like the Perl community uses CPAN to share modules.  This is an additional
benefit when Cocooning, but does not carry much weight in the Perl world, which
already has CPAN (there are many taglib modules on CPAN).  There is no Java
equivalent to CPAN in wide use, so Cocoon logic sheets need their own
mechanism.</p>

<a name="LogicSheetDisadvantages" /><h4>LogicSheet Disadvantages</h4>

<p>There are two fundamental drwabacks with LogicSheets, each with
several symptoms.  Many of the symptoms are minor, but they add up:

<ol>

  <li>Requires inline code, usually in an XSLT stylesheet.

    <ul>

      <li>Putting Perl code in XML is awkward: You can't easily syntax check
      the code (I happen to like to run <code>perl -cw ThisFile.pm</code> a lot
      while writing Perl code) or take advantage of language-oriented editor
      features such as autoindenting, tags and syntax highlighting.</li>

      <li>The taglib author needs to work in four languages/APIs: XSLT
      (typically), XSP, Perl, and the taglib under development. XSLT and Perl
      are far from trivial, and though XSP is pretty simple, it's easy to trip
      yourself up when context switching between them.</li>

      <li>LogicSheets are far less flexible than taglib modules.  For
      instance, compare the rigidity of 
      <code>my_weather_taglib.xsl</code>'s output structure with the
      that of My::WeatherTaglib or
      My::SimpleWeatherTaglib.  The LogicSheet approach
      requires hardcoding the result values, while the two taglib
      modules simply convert whatever is in the weather report data
      structures to XML.</li>

      <li>XSLT requires a fair amount of extra boilerplate to copy
      non-taglib bits of XSP pages through.  This can usually be set up
      as boilerplate, but boilerplate in a program is just another thing
      to get in the way and require maintainance.</li>

      <li>LogicSheet are inherently single-purpose.  Taglib modules, on
      the other hand, can be used as regular Perl modules.  An
      authentication module can be used both as a taglib and as a
      regular module, for instance.</li>

      <li>LogicSheets need a working Web server for even the most basic
      functional testing since they need to be run in an XSP environment and
      AxKit does not yet support XSP outside a Web server.  Writing taglib
      modules allows simple test suites to be written to vet the taglib's code
      without needing a working Web server.</li>

      <li>Writing LogicSheets works best in an XML editor, otherwise
      you'll need to escape all your <code>&lt;</code> characters, at
      least, and reading / writing XML-escaped Perl and Java code
      can be irksome.</li>

      <li>Embracing and extending a LogicSheet is difficult to do:
      The source XSP page needs to be aware of the fact that the taglib
      it's using is using the base taglib and declare both of their
      namespaces.  With taglib modules, Perl's standard function
      import mechanism can be used to releive XSP authors of this
      duty.</li>

    </ul>
  </li>

  <li>Requires an additional stylesheet to process, usually XSLT.  This
  means:

    <ul>

      <li>A more complex processing chain, which leads to XSP page complexity
      (and thus more likelihood of bugs) because each page must declare both
      the namespace for the taglib tags <b>and</b> a processing instruction to
      run the taglib. As an example of a gotcha in this area, I used an
      outdated version of the XSP namespace URI in <code>weather2.xsp</code>
      and the current URI in <code>my_weather_taglib.xsl</code>.  This
      caused me a bit of confusion, but the <code>AxTraceIntermediate</code>
      directive helped shed some light on it.</li>

      <li>More disk files to check for changes each time an XSP page
      is served.  Since each LogicSheet affects the output, each
      LogicSheet must be <code>stat()</code>ed to see if it has changed
      since the last time the XSP page was compiled.</li>

    </ul>
  
  </li>

</ol>

<p>As you can probably tell, I feel that LogicSheets are a far more awkward and
less flexible approach than writing taglibs as Perl modules using one of the
helper libraries.  Still, using upstream LogicSheets is a valid and perhaps
occasionally useful technique for writing AxKit taglibs.</p>











<a name="UpstreamGoodFor" /><h3>Upstream Filters good for?</h3>

<p>So what is XSLT upstream of an XSP processor good for?  You can do many
things with it other than implementing LogicSheets.  One use is to implement
branding: altering things like logos, site name, and perhaps colors, or other
customization, like administrator's mail addresses on a login page that is
shared by several sub-sites.</p>

<p>A key advantage of doing transformations upstream of the XSP processor is
that the XSP process caches the results of upstream transformations.  XSP
converts whatever document it receives in to Perl bytecode in memory and then
just runs that bytecode if none of the upstream documents have changed.</p>

<p>Another use is to convert source documents that declare what should
be on a page to XSP documents that implement the machinery of a page.
For instance, a survey site might have the source documents declare what
questions to ask:</p>

<pre><code>    &lt;survey&gt;
      &lt;question&gt;
        &lt;text&gt;Have you ever eaten a Balut&lt;/text&gt;
        &lt;response&gt;Yes&lt;/response&gt;
        &lt;response&gt;No&lt;/response&gt;
        &lt;response&gt;Eeeewww&lt;/response&gt;
      &lt;/question&gt;
      &lt;question&gt;
        &lt;text&gt;Ok, then, well how about a nice haggis&lt;/text&gt;
        &lt;response&gt;Yes&lt;/response&gt;
        &lt;response&gt;No&lt;/response&gt;
        &lt;response&gt;Now that's more like it!&lt;/response&gt;
      &lt;/question&gt;
      ...
    &lt;/survey&gt;
</code></pre>

<p>XSLT can be used to transform the survey definition in to an XSP page that
uses the <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-XSP-PerForm-1.6/PerForm.pm">PerForm
taglib</a> to automate form filling, etc.  This approach allows pages to be
defined in terms of what they are instead of how they should work.</p>

<p>You can also use XSLT upstream of the XSP processor to do other things, like
translate from a limited or simpler domain-specific tagset to a more complex or
general purpose taglib written as a taglib module.  This can allow you to
define taglibs that are easier to use in terms of more powerful (but scary!)
taglibs that are loaded in to the XSP processor.</p>

<a name="My::SimpleWeatherTaglib" /><h3>My::SimpleWeatherTaglib</h3>

<p>A new-ish taglib helper module has been bundled in recent AxKit releases:
J&ouml;rg Walter's <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm">SimpleTaglib</a>
(the full module name is Apache::AxKit::Language::XSP::SimpleTaglib).  This
module performs roughly the same function as Steve Willer's <a
href="http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm">TaglibHelper</a>,
but supports namespaces and uses a feature new to Perl, subroutine attributes,
to specify the parameters and result formatting instead of a string.</p>

<p>Here is My::SimpleWeatherTaglib:

<pre><code>    package My::SimpleWeatherTaglib;

    use Apache::AxKit::Language::XSP::SimpleTaglib;

    $NS = "http://slaysys.com/axkit_articles/weather/";

    package My::SimpleWeatherTaglib::Handlers;

    use strict;
    require Geo::Weather;

    ## Return the whole report for fixup later in the processing pipeline
    sub report :  child(zip) struct({}) {
        return 'Geo::Weather-&gt;new-&gt;get_weather( $attr_zip );'
    }

    1;
</code></pre>

<p>The <code>$NS</code> variable defines the namespace for this taglib.  This
module uses the same namespace as <code>my_weather_taglib.xsl</code> and
My::WeatherTaglib, because all three implement the same taglib (this
repetetiveness is to demonstrate the differences between the approaches).  See
the <a href="#MixingAndMatching">Mixing and Matching Taglibs</a> section to see how My::WeatherTaglib and
My::SimpleWeatherTaglib can both be used in the same server instance.</p>

<p>My::SimpleWeatherTaglib then shifts gears in to a new <code>package</code>,
My::SimpleWeatherTaglib::Handlers to define the subroutines for the taglib
tags.  Using a virgin package like this provides a clean place with which to declare
the tag handlers.  SimpleTaglib looks for the modules in the Foo::Handlers
package if it's <code>use()</code>d in the Foo package (don't use
<code>require</code> for this!).

<p>My::SimpleWeatherTaglib <code>require</code>s Geo::Weather and declares a
single tag, which handles the <code>&lt;weather:report&gt;</code> tag in
<code>weather1.xsp</code> (which we'll show in a moment).</p>

<p>The <code>require Geo::Weather;</code> instead of <code>use
Geo::Weather;</code> is to avoid importing subroutines in to our otherwise
<code>...::Handlers</code> namespace which might look like a handler.</p>

<p>There's something new afoot in the declaration for <code>sub report</code>:
subroutine attributes.  Subroutine attributes are a new feature of Perl (as of
perl5.6) that allow us to hang additional little bits of information on the
subroutine declaration that describe it a bit more.  <a
href="http://search.cpan.org/doc/JHI/perl-5.7.3/pod/perlsub.pod"><code>perldoc
perlsub</code></a> for the details of this syntax.  Some attributes are
predefined by Perl, but modules may define others for their own purposes. In
this case, the SimpleTaglib module defines a handful of attributes, some of
which describe what parameters the taglib tag can take and others which
describe how to convert the result value from the taglib implementation into
XML output.<p>

<p>The <code>child(zip)</code> subroutine attribute tells the SimpleTaglib
module that this handler expects a single child element named <code>zip</code>
in the taglib's namespace.  In <code>weather1.xsp</code>, this ends up looking
like:</p>

<pre><code>
    &lt;weather:report&gt;
      &lt;!-- Get the ?zip=12345 from the URI and pass it
           to the weather:report tag as a parameter --&gt;
      <b>&lt;weather:zip&gt;&lt;param:zip/&gt;&lt;/weather:zip&gt;</b>
    &lt;/weather:report&gt;
</code></pre>

<p>The text from the <code>&lt;weather:zip&gt;</code> element (which will be
filled in from the URI query string using the <code>param:</code> taglib) will
be made available in a variable named <code>$attr_zip</code> at request time.
The fact that the text from an element shows up in a variable beginning with
<code>$attr_</code> is confusing, but it does actually work that way.</p>

<p>The <code>struct({})</code> attribute specifies that the result of this tag
will be returned as a Perl data structure that will be converted into XML.
<code>Geo::Weather-&gt;new-&gt;get_weather( $zip )</code> returns a HASH reference that looks like:</p>

<a name="hash_2" /><pre><code>    {
      'city'  =&gt; 'Pittsburgh',
      'state' =&gt; 'PA',
      'cond'  =&gt; 'Sunny',
      'temp'  =&gt; '77',
      ...
    };
</code></pre>

<p>The <code>struct</code> attribute tells SimpleTaglib to turn this in to XML
like:</p>

<pre><code>
    &lt;city&gt;Pittsburgh&lt;/city&gt;
    &lt;state&gt;PA&lt;/state&gt;
    &lt;cond&gt;Sunny&lt;/cond&gt;
    &lt;temp&gt;77&lt;/temp&gt;
    ....
</code></pre>

<p>The <code>{}</code> in the <code>struct({})</code> attribute specifies that
the result nodes should be not be in a namespace (and thus have no namespace
prefix), just like the static portions of our <code>weather1.xsp</code>
document.  This is one of the advantages that SimpleTaglib has over other
methods: It's easier to emit nodes in different namespaces.  To emit nodes in a
specific namespace, put the namespace URI for that namespace inside the
curlies: <code>struct({http://my.namespace.com/foo/bar})</code>.  The
<code>{}</code> notation is referred to as <a
href="http://www.jclark.com/xml/xmlns.htm">James Clark (or jclark)
notation</a>.<p>

<p>Now, the tricky bit.  Harkening back to our <a
href="/pub/a/2002/07/axkit.html?page=1#UnderTheXSPHood">discussion of how XSP is implemented</a>, remember that
the XSP processor compiles the XSP document into Perl code that is executed
to build the output document.  As XSP compiles the page, it keeps a lookout
for tags in namespaces handled by taglib modules that have been configured in
with <code>AxAddXSPTaglib</code>.  When XSP sees one of these tags, it calls in
to the taglib module--My::SimpleWeatherTaglib here--for that namespace and
requests a chunk of Perl source code to compile in place of the tag.</p>

<p>Taglibs implemented with the SimpleTaglib module covered here declare
handlers for each taglib tag (<code>sub report</code>, for instance).  That
handler subroutine is called at parse time, not at request time.  Its job is to
return the chunk of code that will be compiled and then run
later, at request time, to generate the output.  So <code>report()</code>
returns a string containing a snippet of Perl code that calls
into Geo::Weather.  This Perl code will be compiled once, then
run for each request.</p>

<p>This is a key difference between the TaglibHelper module that
My::WeatherTaglib used in the previous article and the SimpleTaglib module used
here.  SimpleTaglib calls My::SimpleWeatherTaglib's <code>report()</code>
subroutine at compile time whereas TaglibHelper quietly, automatically arranges
to call My::WeatherTaglib's <code>report()</code> subroutine at request time.<p>

<p>This difference makes SimpleTaglib not so simple unless you are used to
writing code that generates code that will be compiled and run later.  On the
other hand, "Programs that write programs are the happiest programs in the
world" (Andrew Hume, according to a few places on the net).  This is true here
because we are able to return whatever code is appropriate for the task at
hand.  In this case, the code is so simple that we can return it directly.  If
the work to be done was more complicated, then we could also return a call to a
subroutine of our own devising.  So, while a good deal less simple than the
approach taken by TaglibHelper, this approach does offer a bit more
flexibility.</p>

<p>SimpleTaglib's author does promise that a new version of SimpleTaglib will
offer the "call this subroutine at request time" API which I (and I suspect
most others) would prefer most of the time.</p>

<p>I will warn you that the documentation for SimpleTaglib does not stand on
its own, so you need to have the source code for an example module or two to put
it all together.  Beyond the overly simple example presented here, the
documentation refers you to a couple of others.  Mind you, I'm casting stones
while in my glass house here, because nobody has ever accused me of fully
documenting my own modules.</p>

<p>For reference, here is the <code>weather1.xsp</code> from the previous
article, which we are reusing verbatim for this example:

<pre><code>    &lt;?xml-stylesheet href="NULL"        type="application/x-xsp"?&gt;
    &lt;?xml-stylesheet href="weather.xsl" type="text/xsl"?&gt;
    &lt;?xml-stylesheet href="as_html.xsl" type="text/xsl"?&gt;

    &lt;xsp:page
        xmlns:xsp="http://www.apache.org/1999/XSP/Core"
        xmlns:util="http://apache.org/xsp/util/v1"
        xmlns:param="http://axkit.org/NS/xsp/param/v1"
        <b>xmlns:weather="http://slaysys.com/axkit_articles/weather/"</b>
    &gt;
    &lt;data&gt;
      &lt;title&gt;&lt;a name="title"/&gt;My Weather Report&lt;/title&gt;
      &lt;time&gt;
        &lt;util:time format="%H:%M:%S" /&gt;
      &lt;/time&gt;
      &lt;weather&gt;
        <b>&lt;weather:report&gt;
          &lt;!-- Get the ?zip=12345 from the URI and pass it
               to the weather:report tag as a parameter --&gt;
          &lt;weather:zip&gt;&lt;param:zip/&gt;&lt;/weather:zip&gt;
        &lt;/weather:report&gt;</b>
      &lt;/weather&gt;
    &lt;/data&gt;
    &lt;/xsp:page&gt;
</code></pre>

<p>The processing pipeline and intermediate files are also identical to those
from the <a
href="/pub/a/2002/04/16/axkit.html">previous article</a>, so we won't repeat them here.

<a name="MixingAndMatching" /><h3>Mixing and Matching Taglibs using
<code>httpd.conf</code></h3>

<p>As detailed in <a href="/pub/a/2002/03/12/axkit.html">the first article</a> in this series, AxKit
integrates tightly with Apache and Apache's configuration engine.
Apache allows different files and directories to have different
configurations applied, including what taglibs are used.  In the real
world, for instance, it is sometimes necessary to have part of a site
to use a new version of a taglib that might break an old portion.</p>

<p>In the server I used to build the examples for this article, for instance,
the <code>02/</code> directory still uses My::WeatherTaglib from the last
article, while the <code>03/</code> directory uses the
<code>my_weather_taglib.xsl</code> for one of this article's examples and
My::SimpleWeatherTaglib for the other. This is done by combining Apache's
<code>&lt;Directory&gt;</code> sections with the <code>AxAddXSPTaglib</code>
directive:</p>

<a name="httpd.conf" /><pre><code>    ##
    ## Init the httpd to use our "private install" libraries
    ##
    PerlRequire startup.pl

    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &lt;Directory "/home/me/htdocs"&gt;
        Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxTraceIntermediate /home/me/axtrace

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param

        AxAddStyleMap application/x-xsp \\
                      Apache::AxKit::Language::XSP

        AxAddStyleMap text/xsl \\
                      Apache::AxKit::Language::LibXSLT
    &lt;/Directory&gt;

    &lt;Directory "/home/me/htdocs/02"&gt;
    <b>    AxAddXSPTaglib My::WeatherTaglib</b>
    &lt;/Directory&gt;

    &lt;Directory "/home/me/htdocs/03"&gt;
    <b>    AxAddXSPTaglib My::SimpleWeatherTaglib</b>
    &lt;/Directory&gt;
</code></pre>

<p>See <a href="http://httpd.apache.org/docs/sections.html" alt="Apache
httpd documentation">How
Directory, Location and Files sections work</a> from the apache
httpd documentation (v1.3 or 2.0) for the details of how to use
<a href="http://httpd.apache.org/docs/mod/core.html#directory"
alt="Apache documentation"><code>&lt;Directory&gt;</code></a> and other
httpd.conf sections to do this sort of thing.</p>

<a name="help" /><h3>Help and thanks</h3>

<p>J&ouml;rg Walter as well as Matt Sergeant were of great help in writing this
article, especially since I don't do LogicSheets.  J&ouml;rg also fixed a bug
in absolutely no time and wrote the SimpleTaglib module and the <code>AxTraceIntermediate</code> feature.</p>

<p>In case of trouble, have a look at some of the <a
href="/pub/a/2002/03/12/axkit.html?page=3#help">helpful resources we
listed in the first article</a>.</p>

<p>Copyright 2002, Robert Barrie Slaymaker, Jr.  All Rights Reserved.


        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/win32/">&laquo; Win32</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/y2k/">Y2K &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
