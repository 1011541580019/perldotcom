<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: CPAN Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>CPAN</em> Category</h1>






                            
                            <div id="entry-666" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/09/pdf-processing-with-perl.html" rel="bookmark">PDF Processing with Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Detlef Groth</span> on <abbr class="published" title="2007-09-21T00:00:00-08:00">September 21, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p><a href="http://www.adobe.com/">Adobe</a>'s PDF has become a standard for text documents. Most office products can export their content into PDF. However, this software reaches its limits if you want advanced tasks such as combining different PDF documents into one single document or adding and adjusting the bookmarks panel for better navigation. Imagine that you want to collect all relevant Perl.com articles in one PDF file with an up-to-date bookmarks panel. You could use a tool like <a href="http://www.easysw.com/">HTMLDOC</a>, but adding article number 51 would require you to fetch articles one through 50 from the Web again. In most cases you would not be satisfied by the resulting bookmarks panel, either. This article shows how to use <a href="http://search.cpan.org/dist/PDF-Reuse/">PDF::Reuse</a>, by Lars Lundberg, for combining different PDF documents and adding bookmarks to them.</p>

<h3>Example Material</h3>

<p>Although its capabilities are limited in this area, you can also use <code>PDF::Reuse</code> to create PDF documents. If you want to create more sophisticated documents you should investigate other PDF-packages like <a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a> from Alfred Reibenschuh or <a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a> from Martin Hosken. However <code>PDF::Reuse</code> is sufficient to create a simple PDF to use in later examples. The following listing should be rather self explanatory.</p>

<pre><code> # file: examples/create-pdfs.pl
  use strict;
  use PDF::Reuse;

  mkdir "out" if (!-e "out") ;

  foreach my $x (1..4) {
      prFile("out/file-$x.pdf");

      foreach my $y (1..10) {
          prText(35,800,"File: file-$x.pdf");
          prText(510,800,"Page: $y");

          foreach my $z (1..15) {
              prText(35,700-$z*16,"Line $z");
          }

          # add graphics with the prAdd function

          # stroke color
          prAdd("0.1 0.1 0.9 RG\n");

          # fill color
          prAdd("0.9 0.1 0.1 rg\n");

          my $pos = 750 - ($y * 40);

          prAdd("540 $pos 10 40 re\n");
          prAdd("B\n");

          if ($y &lt; 10) {
              prPage();
          }
      }

      prEnd();
  }</code></pre>

<p>Open a new file with with <code>prFile($filename)</code> and close it with <code>prEnd</code>. Between those two calls, add text with the <code>prText</code> command. You can also draw graphics by using the low level command <code>prAdd</code> with plain PDF markup as parameter. Start a new page with <code>prPage</code>. <code>prFile</code> starts the first one automatically, so you need to add a new page only if your document has more than one page. Be aware that for the <code>prText(x,y,Text)</code> command the origin of the coordinate system is on the left bottom of the page.</p>

<p>As an example of adding PDF markup with <code>prAdd</code>, the code creates a red rectangle with blue borders. In case you would like to add more graphics or complex graphics to your PDF, you can study the examples of the <a href="http://partners.adobe.com/public/developer/pdf/index_reference.html">PDF reference manual</a>. If so, consider switching to <code>PDF::API2</code> or <code>Text::PDF</code> instead of using <code>prAdd</code>, as they both provide a comfortable layer of abstraction over the PDF markup language.</p>

<h3>Combining PDF Documents</h3>

<p><code>PDF::Reuse</code>'s main strength is the modification and reassembling of existing PDF documents. The next example assembles a new file from the example material.</p>

<pre><code>  # file: examples/combine-pdfs.pl

  use strict;
  use PDF::Reuse;

  prFile("out/resultat.pdf");

  prDoc('out/file-1.pdf',1,4);
  prDoc('out/file-2.pdf',2,9);
  prDoc('out/file-3.pdf',8);
  prDoc('out/file-4.pdf');

  prEnd();</code></pre>

<p>Again, <code>prFile($filename)</code> opens the file. Next, the <code>prDoc($filename, $firstPage, $lastPage)</code> calls add to the new file various page ranges from the example file. The arguments <code>$firstPage</code> and <code>$lastPage</code> are optional. Omit both to add the entire document. If only <code>$firstPage</code> is present, the call will add everything from that page to the end. Finally, <code>prEnd</code> closes the file.</p>

<h3>Reusing Existing PDF Files</h3>

<p>With <code>PDF::Reuse</code> it is possible to use existing PDF files as templates for creating new documents. Suppose that you have a file <em>customer.txt</em> containing a list of customers to whom to send a letter. You've used a tool to create a PDF document, such as OpenOffice.org or Adobe Acrobat, to produce the letter itself. Now you can write a short program to add the date and the names and addresses of your customers to the letter.</p>

<pre><code>  # file: examples/reuse-letter.pl
  use PDF::Reuse;
  use Date::Formatter;
  use strict;

  my $date = Date::Formatter-&gt;now();
  $date-&gt;createDateFormatter("(DD).(MM). (YYYY)");

  my $n      =  1;
  my $incr   = 14;
  my $infile = 'examples/customer.txt';

  prFile("examples/sample-letters.pdf");

  prCompress(1);
  prFont('Arial');
  prForm("examples/sample-letter.pdf");

  open (my $fh, "&lt;$infile") || die "Couldn't open $infile, $!\n aborts!\n";

  while (my $line = &lt;$fh&gt;)  {
      my $x = 60;
      my $y = 760;

      my ($first, $last, $street, $zipCode, $city, $country) = split(/,/, $line);
      last unless $country;

      prPage() if $n++ &gt; 1 ;
      prText($x, $y, "$first $last");

      $y -= $incr;
      prText($x, $y, $street);

      $y -= $incr;
      prText($x, $y, $zipCode);
      prText(($x + 40), $y, $city);

      $y -= $incr;
      prText($x,   $y, $country);
      prText(60,  600, "Dear $first $last,");
      prText(400, 630, "Berlin, $date");
  }

  prEnd();
  close $fh;</code></pre>

<p>After opening the file with <code>prFile</code>, the call to <code>prCompress(1)</code> enables PDF compression. <code>prFont</code> sets the file's font. The always-available options are Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, and Helvetica-BoldOblique. Set the font size with <code>prFontSize</code>. The default font is Helvetica, with 12 pixel size.</p>

<p>The rest of the code is a simple loop over the file containing the customer data to filling the template with <code>prText</code>.</p>













<h3>Adding Page Numbers</h3>

<p>Sometimes you need only make a small change to a document, such as adding missing page numbers.</p>

<pre><code>  # file: examples/sample-numbers.pl
  use PDF::Reuse;
  use strict;

  my $n = 1;

  prFile('examples/sample-numbers.pdf');

  while (1) {
     prText(550, 40, $n++);
     last unless prSinglePage('sample-letters.pdf');
  }

  prEnd();</code></pre>

<p><code>prSinglePage</code> takes one page after the other from an existing PDFdocument and returns the number of remaining pages after each invocation.</p>

<h3>Low-Level PDF Commands</h3>

<p>If you know low-level PDF instructions, you can add them with with the <code>prAdd(string)</code> subroutine. <code>PDF::Reuse</code> will perform no syntax checks on the instructions, so refer to the PDF reference manual. Here's an example of printing colored rectangles with the <code>prAdd</code> subroutine.</p>

<pre><code>  # file: examples/sample-rectangle.pl
  use PDF::Reuse;
  use strict;

  prFile('examples/sample-rectangle.pdf');

  my $x = 40;
  my $y = 50;
  my @colors;

  foreach my $r (0..5) {
     foreach my $g (0..5) {
         foreach my $b (0..5) {
             push @colors,
                 sprintf("%1.1f %1.1f %1.1f rg\n",
                 $r * 0.2, $g * 0.2, $b * 0.2);
         }
     }
  }

  while (1) {
     if ($x &gt; 500) {
         $x = 40; $y += 40;
         last unless @colors;
     }

     # a rectangle
     my $string = "$x $y 30 30 re\n";
     $string   .= shift @colors;

     # fill and stroke
     $string   .= "b\n";

     prAdd($string);

     $x += 40;
  }

  prEnd();</code></pre>

<h3>Adding Bookmarks</h3>

<p>Working with PDF files becomes comfortable if the document has bookmarks with a table of contents-like structure. Some applications either can't provide the PDF document with bookmarks or support insufficient or incorrect bookmarks. <code>PDF::Reuse</code> can fill this gap with the <code>prBookmark($reference)</code> subroutine.</p>

<p>A bookmark reference is a hash or a array of hashes that looks like:</p>

<pre><code>   {  text  =&gt; 'Document-Text',
             act   =&gt; 'this.pageNum = 0; this.scroll(40, 500);',
             kids  =&gt; [ { text =&gt; 'Chapter 1',
                          act  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          act  =&gt; '10, 40, 600'
                        }
                      ]
   }</code></pre>

<p>...where <code>act</code> is a JavaScript action to trigger when someone clicks on the bookmark. Because those JavaScript actions only work in the Acrobat Reader but not in other PDF viewer applications, I will later show a improvement of <code>PDF::Reuse</code> that fixes this issue.</p>

<p>Other examples for using <code>PDF::Reuse</code>, including image embedding, are available in the <a href="http://search.cpan.org/perldoc?PDF::Reuse::Tutorial">PDF::Reuse::Tutorial</a>.</p>

<h3>A Console Application for Combining PDF Documents</h3>

<p>To avoid editing the Perl code for combining PDF documents every time you want to merge documents, I've written a console application that takes the names of the input files and the page ranges for each file as arguments. That's easy to reuse in a graphical application using Perl/Tk, so I've put that code in a separate Perl module called <code>CombinePDFs</code>. The command-line application will interact with this package instead of directly working on <code>PDF::Reuse</code>. The following diagram shows the relationship between the Packages, example, and applications.</p>

<pre><code>  Examples    |     Packages            |     applications
  -------------------------------------------------------------------
  combine.pdfs                           app-combine-console-pdfs.pl
              \                         /
               PDF::Reuse -- CombinePDFs
              /                         \
   create.pdfs                           app-combine-tk-pdfs.pl</code></pre>

<p>The application <em>app-combine-console-pdfs.pl</em> does not deal directly with <code>PDF::Reuse</code> but parses the command line arguments with <a href="http://search.cpan.org/perldoc?Getopt::Long">Getopt::Long</a> written by Johan Vromans. This is the standard package for this task. Here it parses the input filenames and the page ranges into two arrays of same length. The user also has to supply a filename for the output and, optionally, a bookmarks file. The main subroutine that parses the command line arguments and executes <code>CombinePDFs::createPDF</code> is:</p>

<pre><code>  sub main {
      GetOptions("infile=s"    =&gt; \@infiles,
                 "outfile=s"   =&gt; \$outfile,
                 "pages=s",    =&gt; \@pages,
                 'overwrite'   =&gt; \$overwrite,
                 'bookmarks:s' =&gt; \$bookmarks,
                 'help'        =&gt; \&amp;help);
      help unless ((@infiles and $outfile and @pages) and @pages == @infiles);

      checkPages();
      checkFiles();
      checkBookmarks();

      CombinePDFs::createPDF(\@infiles, \@pages, $outfile, $bookmarks);
  }</code></pre>

<p>If the user passes an insufficient number of arguments, invalid filenames, or incorrect page ranges, the code invokes the the usage subroutine. It also gets invoked if the user asks explicitly for <code>-help</code> on the command line. Any good command line application should be written that way. <code>Getopt::Long</code> can distinguish between mandatory arguments, with <code>=</code> as the symbol after the argument name (infile, pages), optional arguments, with <code>:</code> (bookmarks), or flags (overwrite, usage), without a symbol. It can store these arguments as arrays (infile, pages), hashes, or scalars. It also supports type checking.</p>













<h3>CombinePDFs Package</h3>

<p>The application itself mainly performs error checking. If everything is fine, it calls the <code>CombinePDFs::createPDF</code> subroutine, passing the array of input files, the array of page ranges, and the bookmarks information. The bookmarks scalar is optional.</p>

<p>Page ranges can be comma-separated ranges (<code>1-11,14,17-23</code>), single pages, or the <code>all</code> token. You can include the same page several times in the same document.</p>

<p>The file-checking code looks for read permissions and tests if the file is a PDF document by using the <code>CombinePDFs::isPDF($filename)</code> subroutine. Although <a href="http://search.cpan.org/dist/PDF/">PDF</a>, by Antonio Rosella, also provides such a method, this package was not developed with the <code>use strict</code> pragma and gives a lot of warnings. Furthermore, the package is not actively maintained, so there seems to be no chance to fix this in the near future. Implementing the <code>isPDF</code> subroutine is quite simple; it reads the first line of the PDF file and checks for the magic string <code>%PDF-1.[0-9]</code> in the first line of the document.</p>

<p>Please note that <code>PDF::Reuse</code> is not an object oriented package. Therefore the <code>CombinePDFs</code> package is not object oriented, either. A user of this package could create several instances, but all instances work on the same PDF file.</p>

<p>Submitting complex data structures via the command line is a difficult issue, so I decided that bookmarks should come from a text file. This file has a simple markup to reflect a tree structure, where each line resembles:</p>

<pre><code> &lt;level&gt; "bookmarks text" &lt;page&gt;</code></pre>

<p>The level starts with 0 for root bookmarks. Children of the root bookmarks have a level of 1, their children a level of 2, and so on. Currently, the system supports bookmarks up to three levels of nesting:</p>

<pre><code> 0 "Folder File 1 - Page 1" 1
 1 "File 1 - Page 2" 2
 1 "Subfolder File 1 - Page 3" 3
 2 "File 1 - Page 4"  4
 0 "Folder File 2 - Page 7 " 7
 1 "File 2 - Page 7" 7
 1 "File 2 - Page 9" 9</code></pre>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> should be easy to understand, though that's not necessarily true of the complex data structure created inside this subroutine.</p>

<p>Bookmarks are an array of hashes. <code>addBookmarks</code> uses several attributes. <code>text</code> is the title of the entry in the bookmarks panel. <code>act</code> is the action to trigger when someone clicks the entry. Here it is the page number to open. <code>kids</code> contains a reference to the children of this bookmark entry. During the loop over the file content, the code searches for each level the last entry in a variable and pushes its related children on those last entries. The root bookmarks get collected as an array, and the loop adds the children as a reference to an array, and so on for the grand children. The result is a nested complex data structure which stores all children in the <code>kids</code> attribute of the parent's bookmarks hash&#8212;an array of hashes containing other arrays of hashes and so on.</p>

<p>The parsing subroutine for the bookmarks file <code>CombinePDFs::addBookmarks($filename)</code> collects bookmarks in a array of hashes. At the end, it adds the bookmarks to the document with <code>prBookmarks($reference)</code>. All of this means that you can use a bookmarks file with the PDF file with a command line like:</p>

<pre><code>   $ perl bin/app-combine-pdfs.pl \
      --infile out/file-1.pdf --pages 1-6 \
      --infile out/file-2.pdf --pages 1-4,7,9-10 \
      --bookmarks out/bookmarks.cnt \
      --outfile file-all.pdf --overwrite</code></pre>

<p>Currently, you must open the document's navigation panel manually because <code>PDF::Reuse</code> does not yet allow you to declare a default view, whether full screen or panel view. This is easy to fix, and the author Lars Lundberg has promised me to do so in a next release of <code>PDF::Reuse</code>. In order to enable this feature until a new release will appear I included a modified version of <code>PDF::Reuse</code> in the examples zip file that accompanies this article.</p>

<p>Furthermore, the bookmarks use JavaScript functions. To use the bookmarks in PDF viewers other than Acrobat Reader, my patched <code>PDF::Reuse</code> package replaces JavaScript bookmarks with PDF specification compliant bookmarks. To do that, replace the <code>act</code> key with a <code>page</code> key using the appropiate page number and scroll options:</p>

<pre><code> $bookmarks = {  text  =&gt; 'Document',
                 page  =&gt; '0,40,50;',
                 kids  =&gt; [ { text =&gt; 'Chapter 1',
                          page  =&gt; '1, 40, 600'
                        },
                        { text =&gt; 'Chapter 2',
                          page  =&gt; '10, 40, 600'
                        }
                      ]
          }</code></pre>

<p>Then print the bookmarks to the PDF document as usual with <code>prBookmark($bookmarks);</code>.</p>

<h3>Tk Application to Combine PDF Documents</h3>

<p>Console applications are fine for experienced users, but you can't expect that all users belong to this category. Therefore it might be worth it to write a GUI for combining PDF documents. The <a href="http://search.cpan.org/dist/Tk/">Perl/Tk toolkit</a> founded on the old Tix widgets for Tcl/Tk is not very modern, although this might change with the <a href="http://www.tcl.tk/software/tcltk/8.5.html">Tcl/Tk release 8.5</a> and the Tile widgets&#8212;but it is very portable. That's why I used it for the GUI example. Because I put a layer between the <code>PDF::Reuse</code> package and the command line application with the <code>CombinePDFs</code> package, it was easy to reuse those parts in the Tk-application <em>app-combine-tk-pdfs.pl</em>.</p>

<p>With the Tk application, the user visually selects PDF files, orders the files in a <code>Tk::Tree</code> widget, and changes the page ranges and the bookmarks text in <code>Tk::Entry</code> fields. Furthermore, the application can store the resulting tree structure inside a session file and restored that later on. It's also possible to copy and paste entries inside the tree, which makes it easy to create a bookmarks panel for single files without using bookmark files. The Tk application can be found in the download at the end of this article.</p>

<p>Beside the final PDF file, the application creates a file with the same basename and the <em>.cnt</em> extension. This file contains the bookmarks for the PDF. It's also useful to continue the processing of the combined PDF file instead of reassembling all the source files again. The entry for this feature is <code>File-&gt;Load Bookmarks-File</code>.</p>

<p>When loading a bookmarks file, the same extension convention is in place.</p>

<h3>Other PDF Packages on CPAN</h3>

<p>I like <code>PDF::Reuse</code>, but there are several other options for PDF creation and manipulation on the CPAN.</p>

<ul>
<li><a href="http://search.cpan.org/dist/PDF-API2/">PDF::API2</a>, by Alfred Reibenschuh, is actively maintained. It is the package of choice if creating new PDF documents from scratch.</li>

<li><a href="http://search.cpan.org/dist/PDF-API2-Simple/">PDF::API2::Simple</a>, by Red Tree Systems, is a wrapper over the <code>PDF::API2</code> module for users who find the PDF::API2 module to difficult to use.</li>

<li><a href="http://search.cpan.org/dist/Text-PDF">Text::PDF</a>, by Martin Hosken, can work on more than PDF file at the same time and has Truetype font support.</li>

<li><a href="http://search.cpan.org/dist/CAM-PDF">CAM::PDF</a>, by Clotho Advanced Media, is like <code>PDF::Reuse</code> more focused on reading and manipulating existing PDF documents. However, it can work on multiple files at the same time. Use it if you need more features than <code>PDF::Reuse</code> actually provides.</li>
</ul>

<h3>Conclusions</h3>

<p><code>PDF::Reuse</code> is a well-written and well-documented package, which makes it easy to create, combine, and change existing PDF documents. The two sample applications show some of its capabilities. Two limitations should be mentioned however, <code>PDF::Reuse</code> can't reuse existing bookmarks, and after combining different PDF documents some of the inner document hyperlinks might stop working properly. The <a href="/2007/09/20/pdf_reuse.zip">example source code</a> for the applications, packages, and the modified <code>PDF::Reuse</code> is available.</p>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-664" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/08/making-perl-modules.html" rel="bookmark">Making Perl Reusable with Modules</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Andy Sylvester</span> on <abbr class="published" title="2007-08-07T00:00:00-08:00">August  7, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Perl software development can occur at several levels. When first developing the idea for an application, a Perl developer may start with a short program to flesh out the necessary algorithms. After that, the next step might be to create a package to support object-oriented development. The final work is often to create a Perl module for the package to make the logic available to all parts of the application. Andy Sylvester explores this topic with a simple mathematical function.</p>

<h3>Creating a Perl Subroutine</h3>

<p>I am working on ideas for implementing some mathematical concepts for a method of composing music. The ideas come from the work of <a href="http://en.wikipedia.org/wiki/Joseph_Schillinger">Joseph Schillinger</a>. At the heart of the method is being able to generate patterns using mathematical operations and using those patterns in music composition. One of the basic operations described by Schillinger is creating a "resultant," or series of numbers, based on two integers (or "generators"). Figure 1 shows a diagram of how to create the resultant of the integers 5 and 3.</p>

<p><img src="/pub/2007/08/09/graphics/Figure1.jpg" alt="creating the resultant of 5 and 3" /><br />
<em>Figure 1. Creating the resultant of 5 and 3</em></p>

<p>Figure 1 shows two line patterns with units of 5 and units of 3. The lines continue until both lines come down (or "close") at the same time. The length of each line corresponds to the product of the two generators (5 x 3 = 15). If you draw dotted lines down from where each of the two generator lines change state, you can create a third line that changes state at each of the dotted line points. The lengths of the segments of the third line make up the resultant of the integers 5 and 3 (3, 2, 1, 3, 1, 2, 3).</p>

<p>Schillinger used graph paper to create resultants in his <a href="http://www.schillingersystem.com/whatis.htm">System of Musical Composition</a>. However, another convenient way of creating a resultant is to calculate the modulus of a counter and then calculate a term in the resultant series based on the state of the counter. An algorithm to create the terms in a resultant might resemble:</p>

<pre><code>Read generators from command line
Determine total number of counts for resultant
   (major_generator * minor_generator)
Initialize resultant counter = 0
For MyCounts from 1 to the total number of counts
   Get the modulus of MyCounts to the major and minor generators
   Increment the resultant counter
   If either modulus = 0
     Save the resultant counter to the resultant array
     Re-initialize resultant counter = 0
   End if
End for</code></pre>

<p>From this design, I wrote a short program using the Perl modulus operator (<code>%</code>):</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# FILENAME: result01.pl
#
# USAGE: perl result01.pl major_generator minor_generator
#
# DESCRIPTION:
#    This Perl script will generate a Schillinger resultant
#    based on two integers for the major generator and minor
#    generator.
#
#    In normal usage, the user will input the two integers
#    via the command line. The sequence of numbers representing
#    the resultant will be sent to standard output (the console
#    window).
#
# INPUTS:
#    major_generator - First generator for the resultant, input
#                      as the first calling argument on the
#                      command line.
#
#    minor_generator - Second generator for the resultant, input
#                      as the second calling argument on the
#                      command line.
#
# OUTPUTS:
#    resultant - Sequence of numbers written to the console window
#
#**************************************************************

   use strict;
   use warnings;

   my $major_generator = $ARGV[0];
   my $minor_generator = $ARGV[1];

   my $total_counts   = $major_generator * $minor_generator;
   my $result_counter = 0;
   my $major_mod      = 0;
   my $minor_mod      = 0;
   my $i              = 0;
   my $j              = 0;
   my @resultant;

   print "Generator Total = $total_counts\n";

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $major_generator;
       $minor_mod = $i % $minor_generator;
       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@resultant, $result_counter);
          $result_counter = 0;
       }
       print "$i \n";
       print "Modulus of $major_generator is $major_mod \n";
       print "Modulus of $minor_generator is $minor_mod \n";
   }

   print "\n";
   print "The resultant is @resultant \n";</code></pre>

<p>Run the program with 5 and 3 as the inputs (<code>perl result01.pl 5 3</code>):</p>

<pre><code>Generator Total = 15
1
Modulus of 5 is 1
Modulus of 3 is 1
2
Modulus of 5 is 2
Modulus of 3 is 2
3
Modulus of 5 is 3
Modulus of 3 is 0
4
Modulus of 5 is 4
Modulus of 3 is 1
5
Modulus of 5 is 0
Modulus of 3 is 2
6
Modulus of 5 is 1
Modulus of 3 is 0
7
Modulus of 5 is 2
Modulus of 3 is 1
8
Modulus of 5 is 3
Modulus of 3 is 2
9
Modulus of 5 is 4
Modulus of 3 is 0
10
Modulus of 5 is 0
Modulus of 3 is 1
11
Modulus of 5 is 1
Modulus of 3 is 2
12
Modulus of 5 is 2
Modulus of 3 is 0
13
Modulus of 5 is 3
Modulus of 3 is 1
14
Modulus of 5 is 4
Modulus of 3 is 2
15
Modulus of 5 is 0
Modulus of 3 is 0

The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This result matches the resultant terms as shown in the graph in Figure 1, so it looks like the program generates the correct output.</p>













<h3>Creating a Perl Package from a Program</h3>

<p>With a working program, you can create a Perl package as a step toward being able to reuse code in a larger application. The initial program has two pieces of input data (the major generator and the minor generator). The single output is the list of numbers that make up the resultant. These three pieces of data could be combined in an object. The program could easily become a subroutine to generate the terms in the resultant. This could be a method in the class contained in the package. Creating a class implies adding a constructor method to create a new object. Finally, there should be some methods to get the major generator and minor generator from the object to use in generating the resultant (see the <a href="http://perldoc.perl.org/perlboot.html">perlboot</a> and <a href="http://perldoc.perl.org/perltoot.html">perltoot</a> tutorials for background on object-oriented programming in Perl).</p>

<p>From these requirements, the resulting package might be:</p>

<pre><code>#!/usr/bin/perl
#*******************************************************
#
# Filename: result01a.pl
#
# Description:
#    This Perl script creates a class for a Schillinger resultant
#    based on two integers for the major generator and the
#    minor generator.
#
# Class Name: Resultant
#
# Synopsis:
#
# use Resultant;
#
# Class Methods:
#
#   $seq1 = Resultant -&gt;new(5, 3)
#
#      Creates a new object with a major generator of 5 and
#      a minor generator of 3. These parameters need to be
#      initialized when a new object is created, as there
#      are no methods to set these elements within the object.
#
#   $seq1-&gt;generate()
#
#      Generates a resultant and saves it in the ResultList array
#
# Object Data Methods:
#
#   $major_generator = $seq1-&gt;get_major()
#
#      Returns the major generator
#
#   $minor_generator = $seq1-&gt;get_minor()
#
#      Returns the minor generator
#
#
#**************************************************************

{ package Resultant;
  use strict;
  sub new {
    my $class           = shift;
    my $major_generator = shift;
    my $minor_generator = shift;

    my $self = {Major =&gt; $major_generator,
                Minor =&gt; $minor_generator,
                ResultantList =&gt; []};

    bless $self, $class;
    return $self;
  }

  sub get_major {
    my $self = shift;
    return $self-&gt;{Major};
  }

  sub get_minor {
    my $self = shift;
    return $self-&gt;{Minor};
  }

  sub generate {
    my $self         = shift;
    my $total_counts = $self-&gt;get_major * $self-&gt;get_minor;
    my $i            = 0;
    my $major_mod;
    my $minor_mod;
    my @result;
    my $result_counter = 0;

   while ($i &lt; $total_counts) {
       $i++;
       $result_counter++;
       $major_mod = $i % $self-&gt;get_major;
       $minor_mod = $i % $self-&gt;get_minor;

       if (($major_mod == 0) || ($minor_mod == 0)) {
          push(@result, $result_counter);
          $result_counter = 0;
       }
   }

   @{$self-&gt;{ResultList}} = @result;
  }
}

#
# Test code to check out class methods
#

# Counter declaration
my $j;

# Create new object and initialize major and minor generators
my $seq1 = Resultant-&gt;new(5, 3);

# Print major and minor generators
print "The major generator is ", $seq1-&gt;get_major(), "\n";
print "The minor generator is ", $seq1-&gt;get_minor(), "\n";

# Generate a resultant
$seq1-&gt;generate();

# Print the resultant
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>Execute the file (<code>perl result01a.pl</code>):</p>

<pre><code>The major generator is 5
The minor generator is 3
The resultant is 3 2 1 3 1 2 3</code></pre>

<p>This output text shows the same resultant terms as produced by the first program.</p>

<h3>Creating a Perl Module</h3>

<p>From a package, you can create a Perl module to make the package fully reusable in an application. Also, you can modify our original test code into a series of module tests to show that the module works the same as the standalone package and the original program.</p>

<p>I like to use the Perl module <a href="http://search.cpan.org/perldoc?Module::Starter">Module::Starter</a> to create a skeleton module for the package code. To start, install the <code>Module::Starter</code> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Module::Starter</code> module installed, type <code>perldoc Module::Starter</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Select a working directory to create the module directory. This can be the same directory that you have been using to develop your Perl program. Type the following command (though with your own name and email address):</p>

<pre><code>$ <strong>module-starter --module=Music::Resultant --author="John Doe" \
    --email=john@johndoe.com</strong></code></pre>

<p>Perl should respond with:</p>

<pre><code>Created starter directories and files</code></pre>

<p>In the working directory, you should see a folder or directory called <em>Music-Resultant</em>. Change your current directory to <em>Music-Resultant</em>, then type the commands:</p>

<pre><code>$ <strong>perl Makefile.PL</strong>
$ <strong>make</strong></code></pre>

<p>These commands will create the full directory structure for the module. Now paste the text from the package into the module template at <em>Music-Resultant/lib/Music/Resultant.pm</em>. Open <em>Resultant.pm</em> in a text editor and paste the subroutines from the package after the lines:</p>

<pre><code>=head1 FUNCTIONS

=head2 function1

=cut</code></pre>

<p>When you paste the package source code, remove the opening brace from the package, so that the first lines appear as:</p>

<pre><code> package Resultant;
  sub new {
    use strict;
    my $class = shift;</code></pre>

<p>and the last lines of the source appears without the the final closing brace as:</p>

<pre><code>   @{$self-&gt;{ResultList}} = @result;
  }</code></pre>

<p>After making the above changes, save <em>Resultant.pm</em>. This is all that you need to do to create a module for your own use. If you eventually release your module to the Perl community or upload it to <a href="http://www.cpan.org/">CPAN</a>, you should do some more work to prepare the module and its documentation (see the <a href="http://perldoc.perl.org/perlmod.html">perlmod</a> and <a href="http://perldoc.perl.org/perlmodlib.html">perlmodlib</a> documentation for more information).</p>













<p>After modifying <em>Resultant.pm</em>, you need to install the module to make it available for other Perl applications. To avoid configuration issues, install the module in your home directory, separate from your main Perl installation.</p>

<ol>
<li>
<p>In your home directory, create a <em>lib/</em> directory, then create a <em>perl/</em> directory within the <em>lib/</em> directory. The result should resemble:</p>

<pre><code>/home/myname/lib/perl</code></pre>
</li>

<li>
<p>Go to your module directory (<em>Music-Resultant</em>) and re-run the build process with a directory path to tell Perl where to install the module:</p>

<pre><code>$ <strong>perl Makefile.PL LIB=/home/myname/lib/perl</strong> $
<strong>make install</strong></code></pre>

<p>Once this is complete, the module will be installed in the directory.</p>
</li>
</ol>

<p>The final step in module development is to add tests to the <em>.t</em> file templates created in the module directory. The Perl distribution includes several built-in test modules, such as <a href="http://search.cpan.org/perldoc?Test::Simple">Test::Simple</a> and <a href="http://search.cpan.org/perldoc?Test::More">Test::More</a> to help test Perl subroutines and modules.</p>

<p>To test the module, open the file <em>Music-Resultant/t/00-load.t</em>. The initial text in this file is:</p>

<pre><code>#!perl -T

use Test::More tests =&gt; 1;

BEGIN {
    use_ok( 'Music::Resultant' );
}

diag( "Testing Music::Resultant $Music::Resultant::VERSION, Perl $], $^X" );</code></pre>

<p>You can run this test file from the <em>t/</em> directory using the command:</p>

<pre><code>perl -I/home/myname/lib/perl -T 00-load.t</code></pre>

<p>The <code>-I</code> switch tells the Perl interpreter to look for the module <em>Resultant.pm</em> in your alternate installation directory. The directory path must immediately follow the <code>-I</code> switch, or Perl may not search your alternate directory for your module. The <code>-T</code> switch is necessary because there is a <code>-T</code> switch in the first line of the test script, which turns on taint checking. (Taint checking only works when enabled at Perl startup; <code>perl</code> will exit with an error if you try to enable it later.) Your results should resemble the following(your Perl version may be different).</p>

<pre><code>1..1
ok 1 - use Music::Resultant;
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>The test code from the second listing is easy to convert to the format used by <code>Test::More</code>. Change the number at the end of the tests line from 1 to 4, as you will be adding three more tests to this file. The template file has an initial test to show that the module exists. Next, add tests after the <code>BEGIN</code> block in the file:</p>

<pre><code># Test 2:
my $seq1 = Resultant-&gt;new(5, 3);  # create an object
isa_ok ($seq1, Resultant);        # check object definition

# Test 3: check major generator
my $local_major_generator = $seq1-&gt;get_major();
is ($local_major_generator, 5, 'major generator is correct' );

# Test 4: check minor generator
my $local_minor_generator = $seq1-&gt;get_minor();
is ($local_minor_generator, 3, 'minor generator is correct' );</code></pre>

<p>To run the tests, retype the earlier command line in the <em>Music-Resultant/</em> directory:</p>

<pre><code>$ <strong>perl -I/home/myname/lib/perl -T t/00-load.t</strong></code></pre>

<p>You should see the results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>These tests create a Resultant object with a major generator of 5 and a minor generator of 3 (Test 2), and check to see that the major generator in the object is correct (Test 3), and that the minor generator is correct (Test 4). They do <em>not</em> cover the resultant terms. One way to check the resultant is to add the test code used in the second listing to the <em>.t</em> file:</p>

<pre><code># Generate a resultant
$seq1-&gt;generate();

# Print the resultant
my $j;
print "The resultant is ";
foreach $j (@{$seq1-&gt;{ResultList}}) {
  print "$j ";
}
print "\n";</code></pre>

<p>You should get the following results:</p>

<pre><code>1..4
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
The resultant is 3 2 1 3 1 2 3
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<p>That's not valid test output, so it needs a little bit of manipulation. To check the elements of a list using a testing function, install the <a href="http://search.cpan.org/perldoc?Test::Differences">Test::Differences</a> module and its associated modules from CPAN, using the Perl Package Manager, or some other package manager. To see if you already have the <code>Test::Differences</code> module installed, type <code>perldoc Test::Differences</code> in a terminal window. If the man page does not appear, you probably do not have the module installed.</p>

<p>Once that module is part of your Perl installation, change the number of tests from 4 to 5 on the <code>Test::More</code> statement line and add a following statement after the <code>use Test::More</code> statement:</p>

<pre><code>use Test::Differences;</code></pre>

<p>Finally, replace the code that prints the resultant with:</p>

<pre><code># Test 5: (uses Test::Differences and associated modules)
$seq1-&gt;generate();
my @result   = @{$seq1-&gt;{ResultList}};
my @expected = (3, 2, 1, 3, 1, 2, 3);
eq_or_diff \@result, \@expected, "resultant terms are correct";</code></pre>

<p>Now when the test file runs, you can confirm that the resultant is correct:</p>

<pre><code>1..5
ok 1 - use Music::Resultant;
ok 2 - The object isa Resultant
ok 3 - major generator is correct
ok 4 - minor generator is correct
ok 5 - resultant terms are correct
# Testing Music::Resultant 0.01, Perl 5.008006, perl</code></pre>

<h3>Summary</h3>

<p>There are multiple levels of Perl software development. Once you start to create modules to enable reuse of your Perl code, you will be able to leverage your effort into larger applications. By using Perl testing modules, you can ensure that your code works the way you expect and provide a way to ensure that the modules continue to work as you add more features.</p>

<h3>Resources</h3>

<p>Here are some other good resources on creating Perl modules:</p>

<ul>
<li><a href="http://world.std.com/~swmcd/steven/perl/module_mechanics.html">Perl Module Mechanics</a> goes into detail about the various files created when you create a module directory.</li>

<li><a href="http://mathforum.org/~ken/perl_modules.html">Creating (and Maintaining) Perl Modules</a> includes information on coding, documentation, testing, and installation.</li>

<li><a href="http://www.perlmonks.org/?node_id=431702">Jose's Guide for creating Perl modules</a> gives some helpful tips on getting a module ready for CPAN distribution.</li>
</ul>

<p>Here are some good resources for using Perl testing modules like <code>Test::Simple</code> and <code>Test::More</code>:</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?Test::Tutorial">Test::Tutorial</a> gives the basics of using <code>Test:Simple</code> and <code>Test::More</code>.</li>

<li><a href="/pub/a/2001/12/04/testing.html">An Introduction to Testing</a> presents the benefits of developing tests and code at the same time, and provides a variety of examples.</li>
</ul>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-662" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/07/options-and-configuration.html" rel="bookmark">Option and Configuration Processing Made Easy</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Jon Allen</span> on <abbr class="published" title="2007-07-12T00:00:00-08:00">July 12, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>When you first fire up your editor and start writing a program, it's tempting to hardcode any settings or configuration so you can focus on the real task of getting the thing working. But as soon as you have users, even if the user is only yourself, you can bet there will be things they want to choose for themselves.</p>

<p>A search on CPAN reveals almost 200 different modules dedicated to option processing and handling configuration files. By anyone's standards that's quite a lot, certainly too many to evaluate each one.</p>

<p>Luckily, you already have a great module right in front of you for handling options given on the command line: <a href="http://search.cpan.org/perldoc?Getopt::Long"><code>Getopt::Long</code></a>, which is a core module included as standard with Perl. This lets you use the standard double-dash style of option names:</p>

<pre><code>myscript --source-directory "/var/log/httpd" --verbose \ --username=JJ</code></pre>

<h4>Using Getopt::Long</h4>

<p>When your program runs, any command-line arguments will be in the <code>@ARGV</code> array. <code>Getopt::Long</code> exports a function, <code>GetOptions()</code>, which processes <code>@ARGV</code> to do something useful with these arguments, such as set variables or run blocks of code. To allow specific option names, pass a list of option specifiers in the call to <code>GetOptions()</code> together with references to the variables in which you want the option values to be stored.</p>

<p>As an example, the following code defines two options, <code>--run</code> and <code>--verbose</code>. The call to <code>GetOptions()</code> will then assign the value <code>1</code> to the variables <code>$run</code> and <code>$verbose</code> respectively if the relevant option is present on the command line.</p>

<pre><code>use Getopt::Long;
my ($run,$verbose);
GetOptions( 'run'     =&gt; \$run,
             'verbose' =&gt; \$verbose );</code></pre>

<p>When <code>Getopt::Long</code> has finished processing options, any remaining arguments will remain in <code>@ARGV</code> for your script to handle (for example, specified filenames). If you use this example code and call your script as:</p>

<pre><code>myscript --run --verbose file1 file2 file3</code></pre>

<p>then after <code>GetOptions()</code> has been called the <code>@ARGV</code> array will contain the values <code>file1</code>, <code>file2</code>, and <code>file3</code>.</p>

<h4>Types of Command-Line Options</h4>

<p>The option specifier provided to <code>GetOptions()</code> controls not only the option name, but also the option type. <code>Getopt::Long</code> gives a lot of flexibility in the types of option you can use. It supports Boolean switches, incremental switches, options with single values, options with multiple values, and even options with hash values.</p>

<p>Some of the most common specifiers are:</p>

<pre><code>name     # Presence of the option will set $name to 1
name!    # Allows negation, e.g. --name will set $name to 1,
         #    --noname will set $name to 0
name+    # Increments the variable each time the option is found, e.g.
         # if $name = 0 then --name --name --name will set $name to 3
name=s   # String value required
         #    --name JJ or --name=JJ will set $name to JJ
         # Spaces need to be quoted
         #    --name="Jon Allen" or --name "Jon Allen"</code></pre>

<p>So, to create an option that requires a string value, format the call to <code>GetOptions()</code> like this:</p>

<pre><code>my $name;
GetOptions( 'name=s' =&gt; \$name );</code></pre>

<p>The value is required. If the user omits it, as in:</p>

<pre><code>myscript --name</code></pre>

<p>then the call to <code>GetOptions()</code> will <code>die()</code> with an appropriate error message.</p>

<h4>Options with Multiple Values</h4>

<p>The option specifier consists of four components: the option name; data type (Boolean, string, integer, etc.); whether to expect a single value, a list, or a hash; and the minimum and maximum number of values to accept. To require a list of string values, build up the option specifier:</p>

<pre><code>Option name:   name
Option value:  =s    (string)
Option type:   @     (array)
Value counter: {1,}  (at least 1 value required, no upper limit)</code></pre>

<p>Putting these all together gives:</p>

<pre><code>my $name;
GetOptions('name=s@{1,}' =&gt; \$name);</code></pre>

<p>Now invoking the script as:</p>

<pre><code>myscript --name Barbie Brian Steve</code></pre>

<p>will set <code>$name</code> to the array reference <code>['Barbie','Brian','Steve']</code>.</p>

<p>Giving a hash value to an option is very similar. Replace <code>@</code> with <code>%</code> and on the command line give arguments as key=value pairs:</p>

<pre><code>my $name;
GetOptions('name=s%{1,}',\$name);</code></pre>

<p>Running the script as:</p>

<pre><code>myscript --name Barbie=Director JJ=Member</code></pre>

<p>will store the hash reference <code>{ Barbie =&gt; 'Director', JJ =&gt; 'Member' }</code> in <code>$name</code>.</p>

<h4>Storing Options in a Hash</h4>

<p>By passing a hash reference as the first argument to <code>GetOptions</code>, you can store the complete set of option values in a hash instead of defining a separate variable for each one.</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose' );</code></pre>

<p>Option names will be hash keys, so you can refer to the <code>name</code> value as <code>$options{name}</code>. If an option is not present on the command line, then the corresponding hash key will not be present.</p>

<h4>Options that Invoke Subroutines</h4>

<p>A nice feature of <code>Getopt::Long</code> is that, as an alternative to simply setting a variable when an option is found, you can tell the module to run any code of your choosing. Instead of giving <code>GetOptions()</code> a variable reference to store the option value, pass either a subroutine reference or an anonymous code reference. This will then be executed if the relevant option is found.</p>

<pre><code>GetOptions( version =&gt; sub{ print "This is myscript, version 0.01\n"; exit; }
            help    =&gt; \&amp;display_help );</code></pre>

<p>When used in this way, <code>Getopt::Long</code> also passes the option name and value as arguments to the subroutine:</p>

<pre><code>GetOptions( name =&gt; sub{ my ($opt,$value) = @_; print "Hello, $value\n"; } );</code></pre>

<p>You can still include code references in the call to <code>GetOptions()</code> even if you use a hash to store the option values:</p>

<pre><code>my %options;
GetOptions( \%options, 'name=s', 'verbose', 'dest=s',
            'version' =&gt; sub{ print "This is myscript, version 0.01\n"; exit; } );</code></pre>

<h4>Dashes or Underscores?</h4>

<p>If you need to have option names that contain multiple words, such as a setting for "Source directory," you have a few different ways to write them:</p>

<pre><code>--source-directory
--source_directory
--sourcedirectory</code></pre>

<p>To give a better user experience, <code>Getopt::Long</code> allows option aliases to allow either format. Define an alias by using the pipe character (<code>|</code>) in the option specifier:</p>

<pre><code>my %options;
GetOptions( \%options, 'source_directory|source-directory|sourcedirectory=s' );</code></pre>

<p>Note that if you're storing the option values in a hash, the first option name (in this case, <code>source_directory</code>) will be the hash key, even if your user gave an alias on the command line.</p>













<p>If you have a lot of options, it might be helpful to generate the aliases using a function:</p>

<pre><code>use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;

my %specifiers = ( 'source-directory' =&gt; '=s',
                   'verbose'          =&gt; '' );
my %options;
GetOptions( \%options, optionspec(%specifiers) );

print Dumper(\%options);

sub optionspec {
  my %option_specs = @_;
  my @getopt_list;

  while (my ($option_name,$spec) = each %option_specs) {
    (my $variable_name = $option_name) =~ tr/-/_/;
    (my $nospace_name  = $option_name) =~ s/-//g;
    my  $getopt_name   = ($variable_name ne $option_name)
        ? "$variable_name|$option_name|$nospace_name" : $option_name;

    push @getopt_list,"$getopt_name$spec";
  }

  return @getopt_list;
}</code></pre>

<p>Running this script with each format in turn shows that they are all valid:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --source-directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --source_directory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };

varos:~/writing/argvfile jj$ ./optionspec.pl --sourcedirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<p>Additionally, <code>Getopt::Long</code> is case-insensitive by default (for option names, not values), so your users can also use <code>--SourceDirectory</code>, <code>--sourceDirectory</code>, etc., as well:</p>

<pre><code>varos:~/writing/argvfile jj$ ./optionspec.pl --SourceDirectory /var/spool
$VAR1 = {
          'source_directory' =&gt; '/var/spool'
        };</code></pre>

<h4>Configuration Files</h4>

<p>The next stage on from command-line options is to let your users save their settings into config files. After all, if your program expands to have numerous options it's going to be a real pain to type them in every time.</p>

<p>When it comes to the format of a configuration file, there are a lot of choices, such as XML, INI files, and the Apache <em>httpd.conf</em> format. However, all of these formats share a couple of problems. First, your users now have two things to learn: the command-line options and the configuration file syntax. Second, even though many CPAN modules are available to parse the various config file formats, you still must write the code in your program to interact with your chosen module's API to set whatever variables you use internally to store user settings.</p>

<h4>Getopt::ArgvFile to the Rescue</h4>

<p>Fortunately, someone out there in CPAN-land has the answer (you can always count on the Perl community to come up with innovative solutions). <a href="http://search.cpan.org/dist/Getopt-ArgvFile"><code>Getopt::ArgvFile</code></a> tackles both of these problems, simplifying the file format and the programming interface in one fell swoop.</p>

<p>To start with, the file format used by <code>Getopt::ArgvFile</code> is extremely easy for users to understand. Config settings are stored in a plain text file that holds exactly the same directives that a user would type on the command line. Instead of typing:</p>

<pre><code>myscript --source-directory /usr/local/src --verbose --logval=alert</code></pre>

<p>your user can use the config file:</p>

<pre><code>--source-directory /usr/local/src
--verbose
--logval=alert</code></pre>

<p>and then run <code>myscript</code> for instant user gratification with no steep learning curve.</p>

<p>Now to the clever part. <code>Getopt::ArgvFile</code> itself doesn't actually care about the contents of the config file. Instead, it makes it appear to your program that all the settings were actually options typed on the command line--the processing of which you've already covered with <code>Getopt::Long</code>. As well as saving your users time by not making them learn a new syntax, you've also saved yourself time by not needing to code against a different API.</p>

<p>The most straightforward method of using <code>Getopt::ArgvFile</code> involves simply including the module in a <code>use</code> statement:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>A program called <em>myscript</em> that contains this code will search the user's home directory (whatever the environment variable <code>HOME</code> is set to) for a config file called <em>.myscript</em> and extract the contents ready for processing by <code>Getopt::Long</code>.</p>

<p>Here's a complete example:</p>

<pre><code>use strict;
use warnings;
use Getopt::ArgvFile home=&gt;1;
use Getopt::Long;

my %config;
GetOptions( \%config, 'name=s' );

if ($config{name}) {
  print "Hello, $config{name}\n";
} else {
  print "Who am I talking to?\n";
}</code></pre>

<p>Save this as <em>hello</em>, then run the script with and without a command-line option:</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Who am I talking to?

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>

<p>Now, create a settings file called <em>.hello</em> in your home directory containing the <code>--name</code> option. Remember to double quote the value if you want to include spaces.</p>

<pre><code>varos:~/writing/argvfile jj$ cat ~/.hello
--name "Jon Allen"</code></pre>

<p>Running the script without any arguments on the command line will show that it loaded the config file, but you can also override the saved settings by giving the option on the command line as normal.</p>

<pre><code>varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello --name JJ
Hello, JJ</code></pre>













<h4>Advanced Usage</h4>

<p>In many cases the default behaviour invoked by loading the module will be all you need, but <code>Getopt::ArgvFile</code> can also cater to more specific requirements.</p>

<h4>User-Specified Config Files</h4>

<p>Suppose your users want to save different sets of options and specify which one to use when they run your program. This is possible using the <code>@</code> directive on the command line:</p>

<pre><code>varos:~/writing/argvfile jj$ cat jj.conf
--name JJ

varos:~/writing/argvfile jj$ ./hello
Hello, Jon Allen

varos:~/writing/argvfile jj$ ./hello @jj.conf
Hello, JJ</code></pre>

<p>Note that there's no extra programming required to use this feature; handling <code>@</code> options is native to <code>Getopt::ArgvFile</code>.</p>

<h4>Changing the Default Config Filename or Location</h4>

<p>Depending on your target audience, the naming convention offered by <code>Getopt::ArgvFile</code> for config files might not be appropriate. Using a dotfile (<em>.myscript</em>) will render your user's config file invisible in his file manager or when listing files at the command prompt, so you may wish to use a name like <em>myscript.conf</em> instead.</p>

<p>Again, it may also be helpful to allow for default configuration files to appear somewhere other than the user's home directory, for example, if you need to allow system-wide configuration.</p>

<p>A further consideration here is <a href="http://par.perl.org/">PAR</a> , the tool for creating standalone executables from Perl programs. PAR lets you include data files as well as Perl code, so you can bundle a default settings file using a command such as:</p>

<pre><code>pp hello -o hello.exe -a hello.conf</code></pre>

<p>which will be available to your script as <code>$ENV{PAR_TEMP}/inc/hello.conf</code>.</p>

<p>I mentioned earlier that <code>Getopt::ArgvFile</code> can load arbitrary config files if the filename appears with the <code>@</code> directive on the command line. Essentially, what the module does when loaded with:</p>

<pre><code>use Getopt::ArgvFile home=&gt;1;</code></pre>

<p>is to prepend <code>@ARGV</code> with <code>@$ENV{HOME}/.scriptname</code>, then resolve all <code>@</code> directives, leaving <code>@ARGV</code> with the contents of the files. This means that running the script as:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>is basically equivalent to writing:</p>

<pre><code>myscript @$ENV{HOME}/.myscript --name-JJ</code></pre>

<p>To load other config files, <code>Getopt::ArgvFile</code> supports disabling the automatic <code>@ARGV</code> processing and triggering it later. With a little manipulation of <code>@ARGV</code> first, you can make:</p>

<pre><code>myscript --name=JJ</code></pre>

<p>equivalent to:</p>

<pre><code>myscript @/path/to/default.conf @/path/to/system.conf @/path/to/user.conf \
    --name=JJ</code></pre>

<p>which will load the set of config files in the correct priority order.</p>

<p>All you need to do to enable this feature is change the <code>use</code> statement to read:</p>

<pre><code>use Getopt::ArgvFile qw/argvFile/;</code></pre>

<p>Loading the module in this way tells <code>Getopt::ArgvFile</code> to export the function <code>argvFile()</code>, which your program needs to call to process the <code>@</code> directives, and also prevents any automated processing from occurring.</p>

<p>Here's an example that first loads a config file from the application bundle (if packaged by PAR) and then from the directory containing the application binary:</p>

<pre><code>use File::Basename qw/basename/;
use FindBin qw/$Bin/;
use Getopt::ArgvFile qw/argvFile/;

# Define config filename as &lt;application_name&gt;.conf
(my $configfile = basename($0)) =~ s/^(.*?)(?:\..*)?$/$1.conf/;

# Include config file from the same directory as the application binary
if (-e "$Bin/$configfile") {
  unshift @ARGV,'@'."$Bin/$configfile";
}

# If we have been packaged with PAR, include the config file from the
# application bundle
if ($ENV{PAR_TEMP} and -e "$ENV{PAR_TEMP}/inc/$configfile") {
  unshift @ARGV,'@'."$ENV{PAR_TEMP}/inc/$configfile";
}

argvFile();  # Process @ARGV to load specified config files</code></pre>

<p>You can also use this technique together with <a href="http://search.cpan.org/dist/File-HomeDir"><code>File::HomeDir</code></a> to access the user's application data directory in a cross-platform manner, so that the location of the config file conforms to the conventions set by the user's operating system.</p>

<h4>Summary</h4>

<p><code>Getopt::Long</code> provides an easy to use, extensible system for processing command-line options. With the addition of <code>Getopt::ArgvFile</code>, you can seamlessly handle configuration files with almost no extra coding. Together, these modules should be first on your list when writing scripts that need any amount of configuration.</p>




        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/courses-and-training/">&laquo; Courses and Training</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/data-structures/">Data Structures &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
