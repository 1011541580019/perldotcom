<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.13-en" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>
<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="/pub/">
<dc:title>Perl.com</dc:title>
<dc:description>news and views of the Perl programming language</dc:description>
<license rdf:resource="http://creativecommons.org/licenses/by-nc-nd/3.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-nc-nd/3.0/">
</License>
</rdf:RDF>
-->

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
<script type='text/javascript' src='http://partner.googleadservices.com/gampad/google_service.js'></script>
<script type='text/javascript'>
GS_googleAddAdSenseService("ca-pub-4136420132070439");
GS_googleEnableAllServices();
</script>
<script type='text/javascript'>
GA_googleAddSlot("ca-pub-4136420132070439", "Perl_728x90");
</script>
<script type='text/javascript'>GA_googleFetchAds();</script>
    <title>Perl.com: January 2006 Archives</title>


    <link rel="prev" href="/pub/2005/12/" title="December 2005" />
    <link rel="next" href="/pub/2006/02/" title="February 2006" />

</head>
<body id="perl-com" class="mt-archive-listing mt-datebased-monthly-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <span id="top_advert"> 
<!-- Put any landscape advert in here -->
<!-- Perl_728x90 -->
<script type='text/javascript'>
GA_googleFillSlot("Perl_728x90");
</script>
        </span> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description">news and views of the Perl programming language</div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <h1 id="page-title" class="archive-title">January 2006 Archives</h1>





                            
                            <div id="entry-678" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/01/26/more_advanced_perl.html" rel="bookmark">More Advancements in Perl Programming</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Simon Cozens</span> on <abbr class="published" title="2006-01-26T00:00:00-08:00">January 26, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Around Easter last year, I finished writing the second edition of <a href="http://www.oreilly.com/catalog/advperl2/">Advanced Perl Programming</a>, a task that had been four years in the making. The aim of this new edition was to reflect the way that Perl programming had changed since the first edition. Much of what Sriram wrote in the original edition was still true, but to be honest, not too much of it was useful anymore--the Perl world has changed dramatically since the original publication.</p>

<p>The first edition was very much about how to do things yourself; it operated at a very low level by current Perl standards. With the explosion of CPAN modules in the interim, "advanced Perl programming" now consists of plugging all of the existing components together in the right order, rather than necessarily writing the components from scratch. So the nature of the book had to change a lot.</p>

<p>However, CPAN is still expanding, and the Perl world continues to change; <em>Advanced Perl Programming</em> can never be a finished book, but only a snapshot in time. On top of all that, I've been learning more, too, and discovering more tricks to get work done smarter and faster. Even during the writing of the book, some of the best practices changed and new modules were developed.</p>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1714" template="b/article_sidebar.view">
<!-- sidebar ends -->
<p>The book is still, I believe, an excellent resource for learning how to master Perl programming, but here, if you like, I want to add to that resource. I'll try to say something about the developments that have happened in each chapter of the book.</p>

<h3>Advanced Perl</h3>

<p>I'm actually very happy with this chapter. The only thing I left out of the first chapter which may have been useful there is a section on <code>tie</code>; but this is covered strongly in <em>Programming Perl</em> anyway.</p>

<p>On the other hand, although it's not particularly advanced, one of the things I wish I'd written about in the book was best practices for creating object-oriented modules. My fellow O'Reilly author Damian Conway has already written two books about these topics, so, again, I didn't get too stressed out about having to leave those sections out. That said, the two modules I would recommend for building OO classes don't appear to get a mention in <em>Perl Best Practices</em>.</p>

<p>First, we all know it's a brilliant idea to create accessors for our data members in a class; however, it's also a pain in the neck to create them yourself. There seem to be hundreds of CPAN modules that automate the process for you, but the easiest is the <a href="http://search.cpan.org/perldoc?Class::Accessor"><code>Class::Accessor</code></a> module. With this module, you declare which accessors you want, and it will automatically create them. As a useful bonus, it creates a default <code>new()</code> method for you if you don't want to write one of those, either.</p>

<p>Instead of:</p>

<pre><code>package MyClass;

sub new { bless { %{@_} }, shift; }

sub name {
    my $self = shift;
    if (@_) { $self-&gt;{name} = shift; }
    $self-&gt;{name}
}

sub address {
    my $self = shift;
    if (@_) { $self-&gt;{address} = shift; }
    $self-&gt;{address}
}</code></pre>

<p>you can now say:</p>

<pre><code>package MyClass;
use base qw(Class::Accessor);

MyClass-&gt;mk_accessors(qw( name address ));</code></pre>

<p><code>Class::Accessor</code> also contains methods for making read-only accessors and for creating separate read and write accessors, and everything is nicely overrideable. Additionally, there are subclasses that extend <code>Class::Accessor</code> in various ways: <a href="http://search.cpan.org/perldoc?Class::Accessor::Fast"><code>Class::Accessor::Fast</code></a> trades off a bit of the extensibility for an extra speed boost, <a href="http://search.cpan.org/perldoc?Class::Accessor::Chained"><code>Class::Accessor::Chained</code></a> returns the object when called with parameters, and <a href="http://search.cpan.org/perldoc?Class::Accessor::Assert"><code>Class::Accessor::Assert</code></a> does rudimentary type checking on the parameter values. There are many, many modules on the CPAN that do this sort of thing, but this one is, in my opinion, the most flexible and simple.</p>

<p>Speaking of flexibility, one way to encourage flexibility in your modules and applications is to make them pluggable--that is, to allow other pieces of code to respond to actions that you define. <a href="http://search.cpan.org/perldoc?Module::Pluggable"><code>Module::Pluggable</code></a> is a simple but powerful little module that searches for installed modules in a given namespace. Here's an example of its use in <a href="http://search.cpan.org/perldoc?Email::FolderType"><code>Email::FolderType</code></a>:</p>

<pre><code>use Module::Pluggable 
    search_path =&gt; "Email::FolderType", 
    require     =&gt; 1, 
    sub_name    =&gt; 'matchers';</code></pre>

<p>This looks for all modules underneath the <code>Email::FolderType::</code> namespace, <code>require</code>s them, and assembles a list of their classes into the <code>matchers</code> method. The module later determines the type of an email folder by passing it to each of the recognizers and seeing which of them handles it, with the moral equivalent of:</p>

<pre><code>sub folder_type {
    my ($self, $folder) = @_;
    for my $class ($self-&gt;matchers) {
        return $class if $class-&gt;match($folder);
    }
}</code></pre>

<p>This means you don't need to know, when you're writing the code, what folder types you support; you can start off with no recognizers and add them later. If a new type of email folder comes along, the user can install a third-party module from CPAN that deals with it, and <code>Email::FolderType</code> requires no additional coding to add support for it.</p>













<h3>Parsing</h3>

<p>Perhaps the biggest change of heart I had between writing a chapter and its publication was in the parsing chapter. That chapter had very little about parsing HTML, and what it did have was not very friendly. Since then, Gisle Aas and Sean Burke's <a href="http://search.cpan.org/perldoc?HTML::TreeBuilder"><code>HTML::TreeBuilder</code></a> and the corresponding <a href="http://search.cpan.org/perldoc?XML::TreeBuilder"><code>XML::TreeBuilder</code></a> have established themselves as much simpler and more flexible ways to navigate HTML and XML documents.</p>

<p>The basic concept in <code>HTML::TreeBuilder</code> is the HTML element, represented as an object of the <code>HTML::Element</code> class:</p>

<pre><code>$a = HTML::Element-&gt;new('a', href =&gt; 'http://www.perl.com/');
$html = $a-&gt;as_HTML;</code></pre>

<p>This creates a new element that is an anchor tag, with an <code>href</code> attribute. The HTML equivalent in <code>$html</code> would be <code>&lt;a href="http://www.perl.com"/&gt;</code>.</p>

<p>Now you can add some content to that tag:</p>

<pre><code>$a-&gt;push_content("The Perl Homepage");</code></pre>

<p>This time, the object represents <code>&lt;a href="http://www.perl.com"&gt; The Perl Homepage &lt;/a&gt;</code>.</p>

<p>You can ask this element for its tag, its attributes, its content, and so on:</p>

<pre><code>$tag = $a-&gt;tag;
$link = $a-&gt;attr("href");
@content = $a-&gt;content_list; # More HTML::Element nodes</code></pre>

<p>Of course, when you are parsing HTML, you won't be creating those elements manually. Instead, you'll be navigating a tree of them, built out of your HTML document. The top-level module <code>HTML::TreeBuilder</code> does this for you:</p>

<pre><code>use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&gt;new();
$tree-&gt;parse_file("index.html");</code></pre>

<p>Now <code>$tree</code> is a <code>HTML::Element</code> object representing the <code>&lt;html&gt;</code> tag and all its contents. You can extract all of the links with the <code>extract_links()</code> method:</p>

<pre><code>for (@{ $tree-&gt;extract_links() || [] }) {
     my($link, $element, $attr, $tag) = @$_;
     print "Found link to $link in $tag\n";
}</code></pre>

<p>Although the real workhorse of this module is the <code>look_down()</code> method, which helps you pull elements out of the tree by their tags or attributes. For instance, in a search engine indexer, indexing HTML files, I have the following code:</p>

<pre><code>for my $tag ($tree-&gt;look_down("_tag","meta")) {
    next unless $tag-&gt;attr("name");
    $hash{$tag-&gt;attr("name")} .= $tag-&gt;attr("content"). " ";
}

$hash{title} .= $_-&gt;as_text." " for $tree-&gt;look_down("_tag","title");</code></pre>

<p>This finds all <code>&lt;meta&gt;</code> tags and puts their attributes as name-value pairs in a hash; then it puts all the text inside of <code>&lt;title&gt;</code> tags together into another hash element. Similarly, you can look for tags by attribute value, spit out sub-trees as HTML or as text, and much more, besides. For reaching into HTML text and pulling out just the bits you need, I haven't found anything better.</p>

<p>On the XML side of things, <a href="http://search.cpan.org/perldoc?XML::Twig"><code>XML::Twig</code></a> has emerged as the usual "middle layer," when <a href="http://search.cpan.org/perldoc?XML::Simple"><code>XML::Simple</code></a> is too simple and <a href="http://search.cpan.org/perldoc?XML::Parser"><code>XML::Parser</code></a> is, well, too much like hard work.</p>

<h3>Templating</h3>

<p>There's not much to say about templating, although in retrospect, I would have spent more of the paper expended on <a href="http://search.cpan.org/perldoc?HTML::Mason"><code>HTML::Mason</code></a> talking about the <a href="http://www.template-toolkit.org/">Template Toolkit</a> instead. Not that there's anything wrong with <code>HTML::Mason</code>, but the world seems to be moving away from templates that include code in a specific language (say, Perl's) towards separate templating little languages, like <a href="http://search.cpan.org/perldoc?Template::TAL">TAL</a> and Template Toolkit.</p>

<p>The only thing to report is that Template Toolkit finally received a bit of attention from its maintainer a couple of months ago, but the long-awaited Template Toolkit 3 is looking as far away as, well, Perl 6.</p>

<h3>Natural Language Processing</h3>

<p>Who would have thought that the big news of 2005 would be that Yahoo is relevant again? Not only are they coming up with interesting new search technologies such as Y!Q, but they're releasing a lot of the guts behind what they're doing as public APIs. One of those that is particularly relevant for NLP is the <a href="http://developer.yahoo.net/search/content/V1/termExtraction.html">Term Extraction web service</a>.</p>

<p>This takes a chunk of text and pulls out the distinctive terms and phrases. Think of this as a step beyond something like <a href="http://search.cpan.org/perldoc?Lingua::EN::Keywords"><code>Lingua::EN::Keywords</code></a>, with the firepower of Yahoo behind it. To access the API, simply send a HTTP <code>POST</code> request to a given URL:</p>

<pre><code>use LWP::UserAgent;
use XML::Twig;
my $uri  = "http://api.search.yahoo.com/ContentAnalysisService/V1/termExtraction";
my $ua   = LWP::UserAgent-&gt;new();
my $resp = $ua-&gt;post($uri, {
    appid   =&gt; "PerlYahooExtractor",
    context =&gt; &lt;&lt;EOF
Two Scottish towns have seen the highest increase in house prices in the
UK this year, according to new figures. 
Alexandria in West Dunbartonshire and Coatbridge in North Lanarkshire
both saw an average 35% rise in 2005. 
EOF
});
if ($resp-&gt;is_success) { 
    my $xmlt = XML::Twig-&gt;new( index =&gt; [ "Result" ]);
    $xmlt-&gt;parse($resp-&gt;content);
    for my $result (@{ $xmlt-&gt;index("Result") || []}) {
        print $result-&gt;text;
    }
}</code></pre>

<p>This produces:</p>

<pre><code>north lanarkshire
scottish towns
west dunbartonshire
house prices
coatbridge
dunbartonshire
alexandria</code></pre>

<p>Once I had informed the London Perl Mongers of this amazing discovery, Simon Wistow immediately bundled it up into a Perl module called <a href="http://search.cpan.org/perldoc?Lingua::EN::Keywords::Yahoo"><code>Lingua::EN::Keywords::Yahoo</code></a>, coming soon to a CPAN mirror near you.</p>













<h3>Unicode</h3>

<p>The best news about Unicode over the last year is that you should not have noticed any major changes. By now, the core Unicode support in Perl just works, and most of the CPAN modules that deal with external data have been updated to work with Unicode.</p>

<p>If you don't see or hear anything about Unicode, that's a good thing: it means it's all working properly.</p>

<h3>POE</h3>

<p>The chapter on POE was a great introduction to how POE works and some of the things that you can do with it, but it focused on using POE for networking applications and for daemons. This is only half the story. Recently a lot of interest has centered on using POE for graphical and command-line applications: Randal Schwartz takes over from the RSS aggregator at the end of the chapter by integrating it with a graphical interface in "<a href="http://www.stonehenge.com/merlyn/PerlJournal/col11.html">Graphical interaction with POE and Tk</a>." Here, I want to consider command-line applications.</p>

<p>The <a href="http://search.cpan.org/perldoc?Term::Visual"><code>Term::Visual</code></a> module is a POE component for creating applications with a split-screen interface; at the bottom of the interface, you type your input, and the output appears above a status line. The module handles all of the history, status bar updates, and everything else for you. Here's an application that uses <a href="http://search.cpan.org/perldoc?Chatbot::Eliza"><code>Chatbot::Eliza</code></a> to provide therapeutic session with everyone's favorite digital psychiatrist.</p>

<p>First, set up the chatbot and create a new <code>Term::Visual</code> object:</p>

<pre><code>#!/usr/bin/perl -w
use POE;
use POSIX qw(strftime);
use Term::Visual;
use Chatbot::Eliza;
my $eliza = Chatbot::Eliza-&gt;new();
my $vt    = Term::Visual-&gt;new( Alias =&gt; "interface" );</code></pre>

<p>Now create the window, which will have space on its status bar for a clock:</p>

<pre><code>my $window_id = $vt-&gt;create_window(
   Status =&gt; { 0 =&gt; { format =&gt; "[%8.8s]", fields =&gt; ["time"] } },
   Title =&gt; "Eliza" 
);</code></pre>

<p>You also need a <a href="http://search.cpan.org/perldoc?POE::Session"><code>POE::Session</code></a>, which will do all the work. It will have three states; the first is the <code>_start</code> state, to tell <code>Term::Visual</code> what to do with any input it gets from the keyboard and to update the clock:</p>

<pre><code>POE::Session-&gt;create
(inline_states =&gt;
  { _start          =&gt; sub {
        $_[KERNEL]-&gt;post( interface =&gt; send_me_input =&gt; "got_term_input" );
        $_[KERNEL]-&gt;yield( "update_time" );
    },</code></pre>

<p>Updating the clock is simply a matter of setting the <code>time</code> field declared earlier to the current time, and scheduling another update at the top of the next minute:</p>

<pre><code>    update_time     =&gt; sub {
        $vt-&gt;set_status_field( $window_id,
                               time =&gt; strftime("%I:%M %p", localtime) );
        $_[KERNEL]-&gt;alarm( update_time =&gt; int(time() / 60) * 60 + 60 );
    },</code></pre>

<p>Finally, you need to handle the input from the user. Do that in a separate subroutine to make things a big clearer:</p>

<pre><code>    got_term_input  =&gt; \&amp;handle_term_input,
  }
);

$poe_kernel-&gt;run();</code></pre>

<p>When <code>Term::Visual</code> gets a line of text from the user, it passes it to the state declared in the <code>_start</code> state. The code takes that text, prints it to the terminal as an echo, and then passes it through Eliza:</p>

<pre><code>sub handle_term_input {
  my ($heap, $input) = @_[HEAP, ARG0];
  if ($input =~ m{^/quit}i) {
    $vt-&gt;delete_window($window_id); 
    exit;
  }

  $vt-&gt;print($window_id, "&gt; $input");
  $vt-&gt;print($window_id, $eliza-&gt;transform($input));
}</code></pre>

<p>In just a few lines of code you have a familiar interface, similar to many IRC or MUD clients, with POE hiding all of the event handling away.</p>













<h3>Testing</h3>

<p><em>Advanced Perl Programming</em> showed how to write tests so that we all can be more sure that our code is doing what it should. How do you know your tests are doing enough? Enter Paul Johnson's <a href="http://search.cpan.org/perldoc?Devel::Cover"><code>Devel::Cover</code></a>!</p>

<p><code>Devel::Cover</code> makes a record of each time a Perl operation or statement is executed, and then compares this against the statements in your code. So when you're running your tests, you can see which of the code paths in your module get exercised and which don't; if you have big branches of code that never get tested, maybe you should write more tests for them!</p>

<p>To use it on an uninstalled module:</p>

<pre><code>$ <strong>cover -delete</strong>
$ <strong>HARNESS_PERL_SWITCHES=-MDevel::Cover make test</strong>
$ </code>cover</pre>

<p>This will give you a textual summary of code coverage; <code>cover -report html</code> produces a colorized, navigable hypertext summary, useful for showing to bosses.</p>

<p>This ensures that your code works--or at least, that it does what your tests specify. The next step is to ensure that your code is actually of relatively decent quality. Because "quality" is a subjective metric when it comes to the art of programming, Perl folk have introduced the objective of "Kwalitee" instead, which may or may not have any bearing on quality.</p>

<p>All modules on CPAN have their Kwalitee measured as part of the <a href="http://cpants.dev.zsi.at/">CPANTS</a> (CPAN Testing Service) website. One way to test for and increase your Kwalitee is to use the <a href="http://search.cpan.org/perldoc?Module::Build::Kwalitee"><code>Module::Build::Kwalitee</code></a> module; this copies some boilerplate tests into your distribution that ensure that you have adequate and syntactically correct documentation, that you <code>use strict</code> and <code>warnings</code>, and so on.</p>

<p>All of this ought to go a fair way to improving the Kwalitee of your code, if not its actual quality!</p>

<h3>Inline</h3>

<p>One of the things that has come over into Perl 5 from Perl 6 development is the concept of the Native Call Interface (NCI). This hasn't fully been developed yet, but chromatic (yes, the editor of this very site) has been working on it.</p>

<p>The idea is that, instead of having something like Inline or XS that  creates a "buffer" between Perl and C libraries, you just call those libraries directly. At the moment, you need to compile any XS module against the library you're using. This is particularly awkward for folk on cut-down operating systems that do not ship a compiler, such as Palm OS or Windows.</p>

<p>The strength of NCI is that it doesn't require a compiler; instead, it uses the operating system's normal means of making calls into libraries. (Hence "Native Call.") It uses Perl's <code>DynaLoader</code> to find libraries, load them, and then find the address of symbols inside of the library. Then it calls a generic "thunk" function to turn the symbol's address into a call. For instance:</p>

<pre><code>my $lib = P5NCI::Library-&gt;new( library =&gt; 'nci_test', package =&gt; 'NCI' );
$lib-&gt;install_function( 'double_int', 'ii' );

my $two = NCI::double_int( 1 );</code></pre>

<p>These lines find the <code>nci_test</code> shared library and get ready to put its functions into the <code>NCI</code> namespace. It then installs the function <code>double_int</code>, which is of signature <code>int double_int(int)</code> (hence <code>ii</code>). Once this is done, you can call the function from Perl. It's not much trickier than Inline, but without the intermediate step of compilation.</p>

<p>NCI isn't quite there yet, and it only supports very simple function signatures. However, because of its portability, it's definitely the one to watch for Perl-C interfaces in the future.</p>

<h3>Everything Else</h3>

<p>The last chapter is "Fun with Perl." Now, much has happened in the world of Perl fun, but much has happened all over Perl. There were many other things I wanted to write about, as well: CPAN best practices for date/time handling and email handling, Perl 6 and Pugs, the very latest web application frameworks such as Catalyst and Jifty, and so on. But all these would fill another book--and if I ever finished that, it too would require an update like this one. So I hope this is enough for you to be getting on with!</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-676" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/01/19/analyzing_html.html" rel="bookmark">Analyzing HTML with Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Kendrew Lau</span> on <abbr class="published" title="2006-01-19T00:00:00-08:00">January 19, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Routine work is all around us every day, no matter if you like it or not. For a teacher on computing subjects, grading assignments can be such work. Certain computing assignments aim at practicing operating skills rather than creativity, especially in elementary courses. Grading this kind of assignment is time-consuming and repetitive, if not tedious.</p>

<p>In a business information system course that I taught, one lesson was about writing web pages. As the course was the first computing subject for the students, we used <a href="http://www.nvu.com/">Nvu</a>, a WYSIWYG web page editor, rather than coding the HTML. One class assignment required writing three or more inter-linked web pages containing a list of HTML elements.</p>


<p>Write three or more web pages having the following:</p>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1714" template="b/article_sidebar.view">
<!-- sidebar ends -->
<ul>
<li>Italicized text (2 points)</li>

<li>Bolded text (2 points)</li>

<li>Three different colors of text (5 points)</li>

<li>Three different sizes of text (5 points)</li>

<li>Linked graphics with border (5 points)</li>

<li>Linked graphics without border (5 points)</li>

<li>Non-linked graphics with border (3 points)</li>

<li>Non-linked graphics without border (2 points)</li>

<li>Three external links (5 points)</li>

<li>One horizontal line--not full width of page (5 points)</li>

<li>Three internal links to other pages (10 points)</li>

<li>Two tables (10 points)</li>

<li>One bulleted list (5 points)</li>

<li>One numerical list (5 points)</li>

<li>Non-default text color (5 points)</li>

<li>Non-default link color (2 points)</li>

<li>Non-default active link color (2 points)</li>

<li>Non-default visited link color (2 points)</li>

<li>Non-default background color (5 points)</li>

<li>A background image (5 points)</li>

<li>Pleasant appearance in the pages (10 points)</li>
</ul>

<p>Beginning to grade the students' work, I found it monotonous and error-prone. Because the HTML elements could be in any of the pages, I had to jump to every page and count the HTML elements in question. I also needed to do it for each element in the requirement. While some occurrences were easy to spot in the rendered pages in a browser, others required close examination of the HTML code. For example, a student wrote a horizontal line (<code>&lt;hr&gt;</code> element) extending 98 percent of the width of the window, which was difficult to differentiate visually from a full-width horizontal line. Some other students just liked to use black and dark gray as two different colors in different parts of the pages. In addition to locating the elements, awarding and totaling marks were also error-prone.</p>

<p>I felt a little regret on the flexibility in the requirement. If I had fixed the file names of the pages and assigned the HTML elements to individual pages, grading could have been easier. Rather than continuing the work with regret, I wrote a Perl program to grade the assignments. The program essentially parses the web pages, awards marks according to the requirements, writes basic comments, and calculates the total score.</p>

<h3>Processing HTML with Perl</h3>

<p>Perl's regular expressions have excellent text processing capability and there are handy modules for parsing web pages. The module <a href="http://search.cpan.org/perldoc?HTML::TreeBuilder"><code>HTML::TreeBuilder</code></a> provides a HTML parser that builds a tree structure of the elements in a web page. It is easy to create a tree and build its content from a HTML file:</p>

<pre><code>$tree = HTML::TreeBuilder-&gt;new;
$tree-&gt;parse_file($file_name);</code></pre>

<p>Nodes in the tree are <a href="http://search.cpan.org/perldoc?HTML::Element"><code>HTML::Element</code></a> objects. There are plenty of methods with which to access and manipulate elements in the tree. When you finish using the tree, destroy it and free the memory it occupied:</p>

<pre><code>$tree-&gt;delete;</code></pre>

<p>The module <code>HTML::Element</code> represents HTML elements in tree structures created by <code>HTML::TreeBuilder</code>. It has a huge number of methods for accessing and manipulating the element and searching for descendants down the tree or ancestors up the tree. The method <code>find()</code> retrieves all descending elements with one or more specified tag names. For example:</p>

<pre><code>@elements = $element-&gt;find('a', 'img');</code></pre>

<p>stores all <code>&lt;a&gt;</code> and <code>&lt;img&gt;</code> elements at or under <code>$element</code> to the array <code>@elements</code>. The method <code>look_down()</code> is a more powerful version of <code>find()</code>. It selects descending elements by three kinds of criteria: exactly specifying  an attribute's value or a tag name, matching an attribute's value or tag name by a regular expression, and applying a subroutine that returns true on examining desired elements. Here are some examples:</p>

<pre><code>@anchors = $element-&gt;look_down('_tag' =&gt; 'a');</code></pre>

<p>retrieves all <code>&lt;a&gt;</code> elements at or under <code>$element</code> and stores them to the array <code>@anchors</code>.</p>

<pre><code>@colors = $element-&gt;look_down('style' =&gt; qr/color/);</code></pre>

<p>selects all elements at or under <code>$element</code> having a <code>style</code> attribute value that contains <code>color</code>.</p>

<pre><code>@largeimages = $element-&gt;look_down(
    sub {
         $_[0]-&gt;tag() eq 'img'          and
        ($_[0]-&gt;attr('width') &gt; 100 or
         $_[0]-&gt;attr('height')  &gt; 100)
    }
);</code></pre>

<p>locates at or under <code>$element</code> all images (<code>&lt;img&gt;</code> elements) with widths or heights larger than 100 pixels. Note that this code will produce a warning message on encountering an <code>&lt;img&gt;</code> element that has no <code>width</code> or <code>height</code> attribute.</p>

<p>You can also mix the three kinds of criteria into one invocation of <code>look_down</code>. The last example could also be:</p>

<pre><code>@largeimages = $element-&gt;look_down(
    '_tag'   =&gt; 'img',
    'width'  =&gt; qr//,
    'height' =&gt; qr//,
    sub { $_[0]-&gt;attr('width')  &gt; 100 or
          $_[0]-&gt;attr('height') &gt; 100 }
);</code></pre>

<p>This code also caters for any missing <code>width</code> or <code>height</code> attribute in an <code>&lt;img&gt;</code> element. The parameters <code>'width' =&gt; qr//</code> and <code>'height' =&gt; qr//</code> guarantee selection of only those <code>&lt;img&gt;</code> elements that have both <code>width</code> or <code>height</code> attributes. The code block checks these for the attribute values, when invoked.</p>

<p>The method <code>look_up()</code> looks for ancestors from an element by the same kinds of criteria of <code>look_down()</code>.</p>













<h3>Processing Multiple Files</h3>

<p>These methods provide great HTML parsing capability to grade the web page assignments. The grading program first builds the tree structures from the HTML files and stores them in an array <code>@trees</code>:</p>

<pre><code>my @trees;
foreach (@files) {
    print "  building tree for $_ ...\n" if $options{v};
    my $tree = HTML::TreeBuilder-&gt;new;
    $tree-&gt;parse_file($_);
    push( @trees, $tree );
}</code></pre>

<p>The subroutine <code>doitem()</code> iterates through the array of trees, applying a pass-in code block to look for particular HTML elements in each tree and accumulating the results of calling the code block. To provide detailed information and facilitate debugging during development, it calls the convenience subroutine <code>printd()</code> to display the HTML elements found with their corresponding file name when the verbose command line switch (<code>-v</code>) is set. Essentially, the code invokes this subroutine once for each kind of element in the requirement.</p>

<pre><code>sub doitem {
    my $func = shift;
    my $num  = 0;
    foreach my $i ( 0 .. $#files ) {
        my @elements = $func-&gt;( $files[$i], $trees[$i] );
        printd $files[$i], @elements;
        $num += @elements;
    }
    return $num;
}</code></pre>

<p>The code block passed into <code>doitem</code> is a subroutine that takes two parameters of a file name and its corresponding HTML tree and returns an array of selected elements in the tree. The following code block retrieves all HTML elements in italic, including the <code>&lt;i&gt;</code> elements (for example, <code>&lt;i&gt;text&lt;/i&gt;</code>) and elements with a <code>font-style</code> of <code>italic</code> (for example, <code>&lt;span STYLE="font-style: italic"&gt;text&lt;/span&gt;</code>).</p>

<pre><code>$n = doitem sub {
    my ( $file, $tree ) = @_;
    return ( $tree-&gt;find("i"),
        $tree-&gt;look_down( "style" =&gt; qr/font-style *: *italic/ ) );
    };

marking "Italicized text (2 points): "
  . ( ( $n &gt; 0 ) ? "good. 2" : "no italic text. 0"
);</code></pre>

<p>Two points are available for any italic text in the pages. The <code>marking</code> subroutine records grading in a string. At the end of the program, examining the string helps to calculate the total points.</p>

<p>Other requirements are marked in the same manner, though some selection code is more involved. A regular expression helps to select elements with non-default colors.</p>

<pre><code>my $pattern = qr/(^|[^-])color *: *rgb\( *[0-9]*, *[0-9]*, *[0-9]*\)/;
return $tree-&gt;look_down(
    "style" =&gt; $pattern,
    sub { $_[0]-&gt;as_trimmed_text ne "" }
);</code></pre>

<p>Nvu applies colors to text by the <code>color</code> style in the form of <code>rgb(R,G,B)</code> (for example, <code>&lt;span STYLE="color: rgb(0, 0, 255);"&gt;text&lt;/span&gt;</code>). The above code is slightly stricter than the italic code, as it also requires an element to contain some text. The method <code>as_trimmed_text()</code> of <code>HTML::Element</code> returns the textual content of an element with any leading and trailing spaces removed.</p>

<p>Nested invocations of <code>look_down()</code> locate linked graphics with a border. This selects any link (an <code>&lt;a&gt;</code> element) that encloses an image (an <code>&lt;img&gt;</code> element) that has a border.</p>

<pre><code>return $tree-&gt;look_down(
    "_tag" =&gt; "a",
    sub {
       $_[0]-&gt;look_down( "_tag" =&gt; "img", sub { hasBorder( $_[0] ) } );
    }
);</code></pre>

<p>Finding non-linked graphics is more interesting, as it involves both the methods <code>look_down()</code> and <code>look_up()</code>. It should only find images (<code>&lt;img&gt;</code> elements) that do not have a parent link (a <code>&lt;a&gt;</code> element) up the tree.</p>

<pre><code>return $tree-&gt;look_down(
    "_tag" =&gt; "img",
    sub { !$_[0]-&gt;look_up( "_tag" =&gt; "a" ) and hasBorder( $_[0] ); }
);</code></pre>

<p>Checking valid internal links requires passing <code>look_down()</code> a code block that excludes common external links by checking the <code>href</code> value against protocol names, and verifies the existence of the file linked in the web page.</p>

<pre><code>use File::Basename;
$n = doitem sub {
    my ( $file, $tree ) = @_;
    return $tree-&gt;look_down(
        "_tag" =&gt; "a",
        "href" =&gt; qr//,
        sub {
            !( $_[0]-&gt;attr("href") =~ /^ *(http:|https:|ftp:|mailto:)/)
            and -e dirname($file) . "/" . decodeURL( $_[0]-&gt;attr("href") );
        }
    );
};</code></pre>

<p>Nvu changes a page's text color by specifying the color components in the style of the <code>body</code> tag, like <code>&lt;body style="color: rgb(0, 0, 255);"&gt;</code>. A regular expression matches the style pattern and retrieves the three color components. Any non-zero color component denotes a non-default text color in a page.</p>

<pre><code>my $pattern = qr/(?:^|[^-])color *: *rgb\(( *[0-9]*),( *[0-9]*),( *[0-9]*)\)/;
return $tree-&gt;look_down(
    "_tag"  =&gt; "body",
    "style" =&gt; qr//,
    sub {
        $_[0]-&gt;attr("style") =~ $pattern and
        ( $1 != 0 or $2 != 0 or $3 != 0 );
    }
);</code></pre>

<p>With proper use of the methods <code>look_down()</code>, <code>look_up()</code>, and <code>as_trimmed_text()</code>, the code can locate and mark the existence of various required elements and any broken elements (images, internal links, or background images).</p>













<h3>Finishing Up</h3>

<p>The final requirement of the assignment is a pleasant look of the rendered pages. Unfortunately, <code>HTML::TreeBuilder</code> and its related modules do not analyze and quantify the visual appearance of a web page. Neither does any module that I know. OK, I would award marks for the appearance myself but still want Perl to help in the process--the program sets the default score and comment, and allows overriding them in flexible way. By using alternative regular expressions, I can accept the default, override the score only, or override both the score and comment.</p>

<pre><code>my $input = "";
do {
    print "$str1 [$str2]: ";
    $input = &lt;STDIN&gt;;
    $input =~ s/(^\s+|\s+$)//g;
} until ( $input =~ /(.*\.\s+\d+$|^\s*$|^\d+$)/ );

$input = $str2 if $input eq "";
if ( $input =~ /^\d+$/ ) {
    $n = $input;
    if ( $n == 10 ) {
        $input = "good looking, nice content. $n";
    }
    else {
        ( $input = $str2 ) =~ s/(\.\s*)\d+\s*$/$1$n/;
    }
}
marking "$str1 $input";</code></pre>

<p>Finally, the code examines the marking text string containing comments and scores for each requirement to calculate the total score of the assignment. Each line in that string is in a fixed format (for example, <code>"Italicized text (2 points): good. 0"</code>). Again, regular expressions retrieve and accumulate the maximum and awarded points.</p>

<pre><code>my ( $total, $score ) = ( 0, 0 );
while ( $marktext =~ /.*?\((\d+)\s+points\).*?\.\s+(\d+)/g )
{
    $total += $1;
    $score += $2;
}
marking "Total ($total points): $score";</code></pre>

<p>Depending on the command-line switches, the program may start a browser to show the first page so that I can look at the pages' appearance. It can also optionally write the grading comments and score to a text file which can be feedback for the student.</p>

<p>I can simply run the program in the directory containing the HTML files, or specify the set of HTML files in the command-line arguments. In the best case, I just let it grade the requirements and press <code>Enter</code> to accept the default marking for the appearance, and then jot down the total score and email the grading text file to the student.</p>

<h3>Conclusion</h3>

<p>I did not evaluate the time saved by the program against its developing effort. Anyway, the program makes the grading process more accurate and less prone to error, and it is more fun to spend time writing a Perl program and getting familiar with useful modules.</p>

<p>In fact, there are many other modules that could have been used in the program to provide even more automation. Had I read Wasserman's article "<a href="/pub/a/2005/04/21/win32ole.html">Automating Windows Applications with Win32::OLE</a>," the program would record the final score to an Excel file automatically. In addition, networking modules such as <a href="http://search.cpan.org/perldoc?Mail::Internet"><code>Mail::Internet</code></a>, <a href="http://search.cpan.org/perldoc?Mail::Mailer"><code>Mail::Mailer</code></a>, and <a href="http://search.cpan.org/perldoc?Mail::Folder"><code>Mail::Folder</code></a> could retrieve the assignment files from emails and send the feedback files to the students directly from  the program.</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-674" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/01/12/what_is_perl_6.html" rel="bookmark">What Is Perl 6</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author"><a class="fn url" href="http://www.modernperlbooks.com/">chromatic</a></span> on <abbr class="published" title="2006-01-12T00:00:00-08:00">January 12, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Perl 6 is the long-awaited redesign and reimplementation of the popular and venerable Perl programming language. It's not out yet--nor is there an official release date--but the design and implementations make continual progress.</p>

<h3>Why Perl 6</h3>

<p>Innumerable programmers, hackers, system administrators, hobbyists, and dabblers write Perl 5 quite successfully. The language doesn't have the marketing budget of large consulting companies, hardware manufacturers, or tool vendors pushing it, yet people still use it to get their jobs done.</p>

<p>Why argue with that success? Why redesign a language that's working for so many people and in so many domains? Sure, Perl 5 has some warts, but it does a lot of things very well.</p>

<h4>What's Right with Perl 5</h4>

<p>As Adam Turoff explained once, <a
href="http://use.perl.org/~ziggy/journal/26131">Perl has two subtle
advantages: <em>manipulexity</em> and <em>whipuptitude</em></a>. It's very
important to be able to solve the problem at hand simply and easily without
languages and tools and syntax getting in your way. That's whipuptitude.
Manipulexity is the ability to use simple tools and build a sufficiently
complex solution to a complex problem.</p>

<p>Not everyone who starts learning Perl for whipuptitude needs manipulexity
right away, if ever, but having a tool that supports both is amazingly useful.
That's where Perl's always aimed--making the easy things easy and the hard
things possible, even if you don't traditionally think of yourself as a
programmer.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1424" template="b/article_sidebar.view">
<!-- sidebar ends -->

<p>Many of Perl 5's other benefits fall out from this philosophy. For example, though the popular conception is that Perl 5 is mostly a procedural language, there are plenty of functional programming features available--iterators, higher-order functions, lexical closures, filters, and more. The (admittedly minimal) object system also has a surprising amount of flexibility. Several CPAN modules provide various types of encapsulation, access control, and dispatch. There are even refinements of the object system itself, exploring such techniques as prototype-based refinement, mixins, and traits.</p>

<p>There's more than one way to do it, but many of those ways are freely available and freely usable from the CPAN. The premier repository system of Perl libraries and components contains thousands of modules, from simple packagings of common idioms to huge interfaces to graphical packages, databases, and web servers. With few exceptions, the community of CPAN contributors have solved nearly any common problem you can think of (and many uncommon ones, too).</p>

<p>It's difficult to say whether Perl excels as a glue language because of the CPAN or that CPAN has succeeded because Perl excels as a glue language, but being able to munge data between two other programs, processes, libraries, or machines is highly useful. Perl's text processing powers have few peers. Sure, you <em>can</em> build the single perfect command-line consisting of several small CLI utilities, but it's rare to do it more cleanly or concisely than with Perl.</p>

<h4>What's Wrong with Perl 5</h4>

<p>Perl 5 isn't perfect, though, and some of its flaws are more apparent the closer Perl 6 comes to completion.</p>

<p>Perhaps the biggest imperfection of Perl 5 is its internals. Though much of the design is clever, there are also places of obsolescence and interdependence, as well as optimizations that no one remembers, but no one can delete without affecting too many other parts of the system. Refactoring an eleven-plus-year-old software project that runs on seventy-odd platforms and has to retain backwards compatibility with itself on many levels is daunting, and there are few people qualified to do it. It's also exceedingly difficult to recruit new people for such a task.</p>

<p>Backwards compatibility in general hampers Perl 5 in other ways. Even though stability of interface and behavior is good in many ways, baking in an almost-right idea makes it difficult to sell people on the absolutely right idea later, especially if it takes years to discover what the true solution really is. For example, the long-deprecated and long-denigrated pseudohash feature was, partly, a way to improve object orientation. However, the Perl 6 approach (using opaque objects) solves the same problem without introducing the complexity and performance problems that pseudohashes did.</p>

<p>As another example, it's much too late to remove formats from Perl 5 without breaking backwards compatibility from Perl 1. However, using formats requires the use of global variables (or scary trickery), with all of the associated maintainability and encapsulation problems.</p>

<p>This points to one of the most subtle flaws of Perl 5: its single implementation is its specification. Certainly there is a growing test suite that explores Perl's behavior in known situations, but too many of these tests exist to ensure that no one accidentally breaks an obscure feature of a particular implementation that no one really thought about but someone somewhere relies on in an important piece of code. You <em>could</em> recreate Perl from its tests--after a fashion.</p>













<p>Perl 6 will likely also use its test suite as its primary specification, but as Larry Wall puts it, "We're just trying to start with the right tests this time."</p>

<p>Even if the Perl 5 codebase <em>did</em> follow a specification, its design is inelegant in many places. It's also very difficult to expand. Many good ideas that would make code easier to write and maintain are too impractical to support. It's a good prototype, but it's not code that you would want to keep if you had the option to do something different.</p>

<p>From the language level, there are a few inconsistencies, as well. For example, why should sigils change depending on how you access internal data? (The canonical answer is "To specify context of the access," but there are other ways to mark the same.) When is a block a block, and when is it a hash reference? Why does <code>SUPER</code> method redispatch not respect the currently dispatched class of the invocant, but only the compiled class? How can you tell the indirect object notation's method name barewords from bareword class or function names?</p>

<p>It can be difficult to decide whether the problem with a certain feature is in the design or the implementation. Consider the desire to replace a built-in data structure with a user-defined object. Perl 5 requires you to use <code>tie</code> and <code>overload</code> to do so. To make this work, the internals check special flags on <em>every</em> data structure in <em>every</em> opcode to see if the current item has any magical behavior. This is ugly, slow, inflexible, and difficult to understand.</p>

<p>The Perl 6 solution is to allow multi-method dispatch, which not only removes conceptual complexity (at least, MMD is easier to explain than <code>tie</code>) but also provides the possibility of a cleaner implementation.</p>

<p>Perl's flexibility sometimes makes life difficult. In particular, there being multiple more-or-less equivalent ways to create objects gives people plenty of opportunities to do clever things they need to do, but it also means that people tend to choose the easiest (or sometimes cleverest) way to do something, not necessarily the best way to do something. It's not Perlish to allow only one way to perform a task, but there's no reason not to provide one really good and easy way to do something while providing the proper hooks and safety outlets to customize the solution cleanly.</p>

<p>Also, there are plenty of language optimizations that turned out to be wrong in the long term. Many of them were conventions--from pre-existing <code>awk</code>, shell, Unix, and regular expression cultures--that gave early Perl a familiarity and aided its initial growth. Yet now that Perl stands on its own, they can seem counter-productive.</p>

<p>Redesigning Perl means asking a lot of questions. Why is the method call operator two characters (one shifted), not a single dot? Why are strictures disabled by default in programs, not one-liners? Why does dereferencing a reference take so many characters? (Perl 5 overloaded curly braces in six different ways. If you can list four, you're doing well.) Why is evaluating a non-scalar container in scalar context so much less useful than it could be?</p>

<p>Once you accept that backwards compatibility is standing in the way of progress and resolve to change things for the better, you have a lot of opportunities to fix design and implementation decisions that turn out to have been bad--or at least, not completely correct.</p>

<h3>Advantages of Perl 6</h3>

<p>In exchange for breaking backwards compatibility, at least at the language level, Perl 6 offers plenty of high-powered language concepts that Perl 5 didn't support, including:</p>

<ul>
<li><a href="http://c2.com/cgi-bin/wiki?MultiMethods">Multimethods</a>
</li>

<li><a href="http://c2.com/cgi-bin/wiki?CoRoutine">Coroutines</a>
</li>

<li><a href="http://en.wikipedia.org/wiki/Continuation">Continuations</a>
</li>

<li>Useful threading</li>

<li>Junctions</li>

<li>Roles</li>

<li>Hyperoperators</li>

<li>Macros</li>

<li>An overridable and reusable grammar</li>

<li>Garbage collection</li>

<li>Improved <a href="http://c2.com/cgi-bin/wiki?ForeignFunctionInterface">foreign function interface</a></li>

<li>Module aliasing and versioning</li>

<li>Improved introspection</li>

<li>Extensible and overridable primitives</li>
</ul>

<h4>Better Internals</h4>

<p>The <a href="http://www.parrotcode.org/">Parrot project</a>, led by designer Chip Salzenberg and pumpking Leo Toetsch, is producing the new virtual machine for the official Perl 6 release.</p>

<p>Parrot is a new design and implementation not specifically tied to Perl 6. Its goal is to run almost any dynamic language efficiently. Because many of the designers have plenty of experience with the Perl 5 internals, Parrot tries to avoid the common mistakes and drawbacks there. One of the first and most important design decisions is extracting the logic of overridden container behavior from opcodes into the containers themselves. That is, where you might have a tied hash in Perl 5, all of the opcodes that deal with hashes have to check that the hash received is tied. In Parrot, each hash has a specific interface and all of the opcodes expect the PMC that they receive to implement that interface. (This is the standard "Replace conditional with polymorphism" refactoring.)</p>













<h4>Better Object Orientation</h4>

<p>The de facto OO technique in Perl 5 is blessing a hash and accessing the hash's members directly as attributes. This is quick and easy, but it has encapsulation, substitutability, and namespace clashing problems. Those problems all have solutions: witness several competing CPAN modules that solve them.</p>

<p>Perl 6 instead provides opaque objects by default, with language support for creating classes and instances and declaring class and instance attributes. It also provides multiple ways to customize class and object behavior, from instantiation to destruction. Where 95 percent of objects can happily use the defaults, the 5 percent customized classes will still work with the rest of the world.</p>

<p>Another compelling feature is language support for roles--this is a different way of describing and encapsulating specific behavior for objects apart from inheritance or mixins. In brief, a role encapsulates behavior that multiple classes can perform, so that a function or method signature can expect an object that does a role, rather than an object that inherits from a particular abstract base class. This has powerful effects on polymorphism and genericity. Having role support in the language and the core library will make large object-oriented systems easier to write and to maintain.</p>

<h4>Improved Consistency</h4>

<p>Sigils, the funny little markers at the start of variables, are invariant.</p>

<p>Return codes make sense, especially in exceptional cases.</p>

<p>Similar things look similar. Different things look different. Weird things look weird.</p>

<p>All blocks are closures; all closures are first-class data structures on which you can set or query properties, for example.</p>

<h4>Rules and Grammars</h4>

<p>One of Perl 5's most useful features is integrated regular expression support--except they're not all that regular anymore. Nearly every problem Perl 5 has in the whole (inconsistency, wrong shortcuts, difficult reusability, inflexible and impenetrable internals) shows up in the syntax and implementation of regular expressions.</p>

<p>Perl 6 simplifies regular expressions while adding more power, producing rules. You can reuse and combine rules to produce a grammar. If you apply a grammar to text (or, perhaps, any type of input including a recursive data structure), you receive a match tree.</p>

<p>That sounds quite a bit like what a parser and lexer do--so there's little surprise that Perl 6 has its own locally overridable grammar that allows you to make your own syntax changes and redefine the language when you really need to. Perl 5 supported a similar feature (source filters), but it was fragile, hard to use, and even harder to re-use in serious programs.</p>

<p>By making a clean break from regular expressions, the designers had the opportunity to re-examine the regex syntax. The new syntax is more consistent, so it's easier to type and to remember the syntaxes of common operations. There's also more consistency, so that similar features look similar.</p>

<p>Perl 6 has a Perl 5 compatibility layer, if you prefer quick and dirty and familiar--but give the new syntax a try, especially for projects where quick and dirty regular expressions were intractable (more than usual, anyway).</p>

<h3>Where is it Already?</h3>

<p>Larry announced the Perl 6 project at OSCON in 2000.  Why is it taking so
long?  There are several reasons.</p>

<p>First, Perl 5 isn't going anywhere.  If anything, the rate of patches and
changes to the code has increased.  Cleanups from Ponie and the <a
href="http://qa.perl.org/phalanx/">Phalanx project</a> continue to improve the
design and implementation, and new features from Perl 6 are making their way
into Perl 5.</p>

<p>Second, the opportunity to do the right thing without fear of breaking
backwards compatibility opened up a lot of possibilities for impressive new
features.  Reinventing regular expressions as rules and grammars, for example,
would have been difficult while retaining the flavor and syntax of
<code>awk</code> and Henry Spencer's original implementations.  The new power
and consistency makes rules well worth the reinvention.</p>

<p>Third, the project is still a volunteer project.  Though other languages
and platforms have major corporate support, only a handful of Perl 6 hackers
receive any form of funding to work on the project--and none of them on a
full-time basis.</p>

<p>If you want to write actual, working Perl 6 code, it's possible.  Pugs has
been able to run quite a bit of the language since last summer.  It will soon
connect directly to Parrot again.  When that happens, watch out!</p>

<h3>Learning More</h3>

<p>This article is merely an overview of some of the reasons for and features of Perl 6. There are plenty of details available online in writings of the designers, the mailing lists, and the source code repositories.</p>

<h4>Design Documents</h4>

<p>The <a href="http://dev.perl.org/perl6/">Perl 6 home page</a> holds links to most of the design documents for the language. In particular, Larry's <a href="http://dev.perl.org/perl6/doc/apocalypse.html">Perl 6 Apocalypses</a> explore a subject area in depth, identifying the problem and outlining his thinking about what the solution might be. Damian Conway's <a href="http://dev.perl.org/perl6/doc/exegesis.html">Perl 6 Exegeses</a> expand upon the idea, showing concrete examples written in actual Perl 6 code.</p>

<p>In the past several months, the design team has started to update the <a href="http://dev.perl.org/perl6/doc/synopsis.html">Perl 6 Synopses</a> instead. Perl 6 pumpking Patrick Michaud keeps these fresh with the current design. The Apocalypses and Exegeses remain online as interesting historical documents that take too long to write and revise as changes occur.</p>

<h4>Implementations</h4>

<p><a href="http://www.parrotcode.org/">Parrot</a> has monthly releases. The Parrot distribution includes the Parrot Grammar Engine (PGE), which is Patrick's implementation of rules and grammars, as well as several languages that target Parrot. The most complete implementation is for Tcl, though the Punie project (Perl 1 on Parrot) shows the entire suite of compiler tools.</p>

<p>Audrey (nee Autrijus) Tang's <a href="http://www.pugscode.org/">Pugs</a> is
an unofficial Perl 6 implementation, optimized for fun. As of the time of the
writing, it supported much of Perl 6, including junctions, multimethods, and
objects. It targets multiple back-ends, including Haskell, JavaScript, Perl 5,
and Parrot, and moves very quickly. Pugs is a great project in which to
participate--it's very easy to get a committer bit and start writing tests and
fixing bugs. It's currently the main prototype and reference implementation.
Time will tell what its role is in the final release.</p>

<p><a href="http://www.poniecode.org/">Ponie</a> is a port of Perl 5 to Parrot. It's a huge refactoring project with little glory but a lot of potential usefulness. C hackers are more than welcome.</p>

<h4>Discussion</h4>

<p>Most development discussion takes place on several <a href="http://dev.perl.org/perl6/lists/">Perl 6 mailing lists</a>:</p>

<ul>
<li><csperl file="mailmunge" arg_email="perl6-language-subscribe@perl.org" arg_display="perl6-language" /> discusses Perl 6, the language and features.</li>

<li><csperl file="mailmunge" arg_email="perl6-internals-subscribe@perl.org" arg_display="perl6-internals" /> discusses the design and implementation of Parrot and various languages targeting Parrot.</li>

<li><csperl file="mailmunge" arg_email="perl6-compiler-subscribe@perl.org" arg_display="perl6-compiler" /> discusses PGE, Pugs, and the interaction of various components of the compiler tools.</li>
</ul>

<p>The <code>#perl6</code> IRC channel on <a href="http://irc.freenode.net/">irc.freenode.net</a> talks about Pugs and Perl 6, while <code>#parrot</code> on <a href="http://irc.perl.org/">irc.perl.org</a> concentrates on Parrot. There is almost always someone around in <code>#perl6</code> to answer questions about Pugs or Perl 6.</p>

<p><a href="http://planetsix.perl.org/">Planet Perl Six</a> aggregates weblogs from several designers and developers of various related projects.</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-672" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/01/05/parsing.html" rel="bookmark">Lexing Your Data</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Curtis Poe</span> on <abbr class="published" title="2006-01-05T00:00:00-08:00">January  5, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<h3><code>s/(?&lt;!SHOOTING YOURSELF IN THE )FOOT/HEAD/g</code>
</h3>

<p>Most of us have tried at one time or another to use regular expressions to do things we shouldn't: parsing HTML, obfuscating code, washing dishes, etc. This is what the technical term "showing off" means. I've done it too:</p>

<pre><code>$html =~ s{
             (&lt;a\s(?:[^&gt;](?!href))*href\s*)
             (&amp;(&amp;[^;]+;)?(?:.(?!\3))+(?:\3)?)
             ([^&gt;]+&gt;)
          }
          {$1 . decode_entities($2) .  $4}gsexi;</code></pre>

<p>I was strutting like a peacock when I wrote that, followed quickly by eating crow when I ran it. I never did get that working right. I'm still not sure what I was trying to do. That regular expression forced me to learn how to use <a href="http://search.cpan.org/perldoc/HTML::TokeParser"><code>HTML::TokeParser</code></a>. More importantly, that was the regular expression that taught me how difficult regular expressions can be.</p>

<h4>The Problem with Regular Expressions</h4>

<p>Look at that regex again:</p>

<pre><code> /(&lt;a\s(?:[^&gt;](?!href))*href\s*)(&amp;(&amp;[^;]+;)?(?:.(?!\3))+(?:\3)?)([^&gt;]+&gt;)/</code></pre>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/754" template="b/article_sidebar.view">
<!-- sidebar ends -->

<p>Do you know that matches? Exactly? Are you <em>sure</em>? Even if it works, how easily can you modify it? If you don't know what it was trying to do (and to be fair, don't forget it's broken), how long did you spend trying to figure it out? When's the last time a single line of code gave you such fits?</p>

<p>The problem, of course, is that this regular expression is trying to do far more work than a single line of code is likely to do. When facing with a regular expression like that, there are a few things I like to do.</p>

<ul>
<li>Document it carefully.</li>

<li>Use the <code>/x</code> switch so I can expand it over several lines.</li>

<li>Possibly, encapsulate it in a subroutine.</li>
</ul>

<p>Sometimes, though, there's a fourth option: <em>lexing</em>.</p>

<h4>Lexing</h4>

<p>When developing code, we typically take a problem and break it down into a series of smaller problems that are easier to solve. Regular expressions are code and you can break them down into a series of smaller problems that are easier to solve. One technique is to use lexing to facilitate this.</p>

<p>Lexing is the act of breaking data down into discrete tokens and assigning meaning to those tokens. There's a bit of fudging in that statement, but it pretty much covers the basics.</p>

<p>Parsing typically follows lexing to convert the tokens into something more useful. Parsing is frequently the domain of some tool that applies a well-defined grammar to the lexed tokens.</p>

<p>Sometimes well-defined grammars are not practical for extracting and reporting information. There might not be a grammar available for a company's ad-hoc log file format. Other times you might find it easier to process the tokens manually then to spend the time writing a grammar. Still other times you might only care about part of the data you've lexed, not all of it. All three of these reasons apply to some problems.</p>

<h4>Parsing SQL</h4>

<p>Recently, on Perlmonks (<a href="http://perlmonks.org/index.pl?node_id=472684">parse a query string</a>), someone had some SQL to parse:</p>

<pre><code>select the_date as "date",
round(months_between(first_date,second_date),0) months_old
,product,extract(year from the_date) year
,case
  when a=b then 'c'
  else 'd'
  end tough_one
from ...
where ...</code></pre>

<p>The poster needed the alias for each column from that SQL. In this case, the aliases are <code>date</code>, <code>months_old</code>, <code>product</code>, <code>year</code>, and <code>tough_one</code>. Of course, this was only one example. There's actually plenty of generated SQL, all with subtle variations on the column aliases, so this is not a trivial task. What's interesting about this, though, is that we don't give a fig about anything except the column aliases. The rest of the text is merely there to help us find those aliases.</p>

<p>Your first thought might be to parse this with <a href="http://search.cpan.org/perldoc/SQL::Statement"><code>SQL::Statement</code></a>. As it turns out, this module does not handle <code>CASE</code> statements. Thus, you must figure out how to patch <code>SQL::Statement</code>, submit said patch, and hope it gets accepted and released in a timely fashion. (Note that <code>SQL::Statement</code> uses <a href="http://search.cpan.org/perldoc/SQL::Parser"><code>SQL::Parser</code></a>, so the latter is also not an option.)</p>

<p>Second, many of us have worked in environments where we have problems to solve in production <em>now</em>, but we still have to wait three weeks to get the necessary modules installed, if we can get them approved at all.</p>

<p>The most important reason, though, is even if <code>SQL::Statement</code> could handle this problem, this would be an awfully short article if you used it instead of a lexer.</p>













<h4>Lexing Basics</h4>

<p>As mentioned earlier, lexing is essentially the task of analyzing data and breaking it down into a series of easy-to-use tokens. While the data may be in other forms, usually this means analyzing strings. To give a trivial example, consider the expression:</p>

<pre><code>x = (3 + 2) / y</code></pre>

<p>When lexed, you might get a series of tokens, such as:</p>

<pre><code>my @tokens = (
  [ OP  =&gt; 'x' ],
  [ OP  =&gt; '=' ],
  [ OP  =&gt; '(' ],
  [ INT =&gt; '3' ],
  [ VAR =&gt; '+' ],
  [ INT =&gt; '2' ],
  [ OP  =&gt; ')' ],
  [ OP  =&gt; '/' ],
  [ VAR =&gt; 'y' ],
);</code></pre>

<p>With a proper grammar, you could then read this series of tokens and take actions based upon their values, perhaps to build a simple language interpreter or translate this code into another programming language. Even without a grammar, you can find these tokens useful.</p>

<h4>Identifying Tokens</h4>

<p>The first step in building a lexer is identifying the tokens you wish to parse. Look again at the SQL.</p>

<pre><code>select the_date as "date",
round(months_between(first_date,second_date),0) months_old
,product,extract(year from the_date) year
,case
  when a=b then 'c'
    else 'd'
  end tough_one
from ...
where ...</code></pre>

<p>There's nothing really to care about anything after the <code>from</code> keyword. In looking at this closer, everything you do care about is immediately prior to a comma or the <code>from</code> keyword. However, splitting on commas isn't enough, as there are some commas embedded in function parentheses.</p>

<p>The first thing to do is to identify the various things you can match with simple regular expressions.</p>

<p>These "things" appear to be parentheses, commas, operators, keywords, and random text. A first pass at it might look something like this:</p>

<pre><code>my $lparen  = qr/\(/;
my $rparen  = qr/\)/;
my $keyword = qr/(?i:select|from|as)/; # this is all this problem needs
my $comma   = qr/,/;
my $text    = qr/(?:\w+|'\w+'|"\w+")/;
my $op      = qr{[-=+*/&lt;&gt;]};</code></pre>

<p>The text matching is somewhat naive and you might want <a href="http://search.cpan.org/perldoc/Regexp::Common"><code>Regexp::Common</code></a> for some of the regular expressions, but keep this simple for now.</p>

<p>The operators are a bit more involved. Assume that some SQL might have math statements embedded in them.</p>

<p>Now create the actual lexer. One way to do this is to make your own. It might look something like this:</p>

<pre><code>sub lexer {
    my $sql = shift;
    return sub {
        LEXER: {
            return ['KEYWORD', $1] if $sql =~ /\G ($keyword) /gcx;
            return ['COMMA',   ''] if $sql =~ /\G ($comma)   /gcx;
            return ['OP',      $1] if $sql =~ /\G ($op)      /gcx;
            return ['PAREN',    1] if $sql =~ /\G $lparen    /gcx;
            return ['PAREN',   -1] if $sql =~ /\G $rparen    /gcx;
            return ['TEXT',    $1] if $sql =~ /\G ($text)    /gcx;
            redo LEXER             if $sql =~ /\G \s+        /gcx;
        }
    };
}

my $lexer = lexer($sql);

while (defined (my $token = $lexer-&gt;())) {
    # do something with the token
}</code></pre>

<p>Without going into the detail of how that works, it's fair to say that this is not the best solution. By looking at <a href="http://perlmonks.org/index.pl?node_id=472701">the original Perlmonks post</a>, you should find that you need to make two passes through the data to extract what you want. I've left the explanation an exercise for the reader.</p>













<p>To make this simpler, use the <a href="http://search.cpan.org/perldoc/HOP::Lexer"><code>HOP::Lexer</code></a> module from the CPAN. This module, described by Mark Jason Dominus in his book <em>Higher Order Perl</em>, makes creating lexers a rather trivial task and makes them a bit more powerful than the example. Here's the new code:</p>

<pre><code>use HOP::Lexer 'make_lexer';
my @sql   = $sql;
my $lexer = make_lexer(
    sub { shift @sql },
    [ 'KEYWORD', qr/(?i:select|from|as)/          ],
    [ 'COMMA',   qr/,/                            ],
    [ 'OP',      qr{[-=+*/]}                      ],
    [ 'PAREN',   qr/\(/,      sub { [shift,  1] } ],
    [ 'PAREN',   qr/\)/,      sub { [shift, -1] } ],
    [ 'TEXT',    qr/(?:\w+|'\w+'|"\w+")/, \&amp;text  ],
    [ 'SPACE',   qr/\s*/,     sub {}              ],
);

sub text {
    my ($label, $value) = @_;
    $value =~ s/^["']//;
    $value =~ s/["']$//;
    return [ $label, $value ];
}</code></pre>

<p>This certainly doesn't look any easier to read, but bear with me.</p>

<p>The <code>make_lexer</code> subroutine takes as its first argument an iterator, which returns the text to match on every call. In this case, you only have one snippet of text to match, so merely shift it off of an array. If you were reading lines from a log file, the iterator would be quite handy.</p>

<p>After the first argument comes a series of array references. Each reference takes two mandatory and one optional argument(s):</p>

<pre><code>[ $label, $pattern, $optional_subroutine ]</code></pre>

<p>The <code>$label</code> is the name of the token. The pattern should match whatever the label identifies. The third argument, a subroutine reference, takes as arguments the label and the <em>text</em> the label matched, and returns whatever you wish for a token.</p>

<p>Consider how you typically use the <code>make_lexer</code> subroutine.</p>

<pre><code>[ 'KEYWORD', qr/(?i:select|from|as)/ ],</code></pre>

<p>Here's an example of how to transform the data before making the token:</p>

<pre><code>[ 'TEXT', qr/(?:\w+|'\w+'|"\w+")/, \&amp;text  ],</code></pre>

<p>As mentioned previously, the regular expression might be naive, but leave that for now and focus on the <code>&amp;text</code> subroutine.</p>

<pre><code>sub text {
    my ($label, $value) = @_;
    $value =~ s/^["']//;
    $value =~ s/["']$//;
    return [ $label, $value ];
}</code></pre>

<p>This says, "Take the label and the value, strip leading and trailing quotes from the value and return them in an array reference."</p>

<p>To strip the white space you don't care about, simply return nothing:</p>

<pre><code> 'SPACE', qr/\s*/, sub {} ],</code></pre>

<p>Now that you have your lexer, put it to work. Remember that column aliases are the <code>TEXT</code> not in parentheses, but immediately prior to commas or the <code>from</code> keyword. How do we know if you're inside of parentheses? Cheat a little bit:</p>

<pre><code>[ 'PAREN', qr/\(/, sub { [shift,  1] } ],
[ 'PAREN', qr/\)/, sub { [shift, -1] } ],</code></pre>

<p>With that, you can add a one whenever you get to an opening parenthesis and subtract it when you get to a closing one. Whenever the result is zero, you know that you're outside of parentheses.</p>

<p>To get the tokens, call the <code>$lexer</code> iterator repeatedly.</p>

<pre><code>while ( defined (my $token = $lexer-&gt;() ) { ... }</code></pre>

<p>The tokens look like this:</p>

<pre><code>[  'KEYWORD',      'select' ]
[  'TEXT',       'the_date' ]
[  'KEYWORD',          'as' ]
[  'TEXT',           'date' ]
[  'COMMA',             ',' ]
[  'TEXT',          'round' ]
[  'PAREN',               1 ]
[  'TEXT', 'months_between' ]
[  'PAREN',               1 ]</code></pre>

<p>And so on.</p>













<p>Here's how to process the tokens:</p>

<pre><code> 1:  my $inside_parens = 0;
 2:  while ( defined (my $token = $lexer-&gt;()) ) {
 3:      my ($label, $value) = @$token;
 4:      $inside_parens += $value if 'PAREN' eq $label;
 5:      next if $inside_parens || 'TEXT' ne $label;
 6:      if (defined (my $next = $lexer-&gt;('peek'))) {
 7:          my ($next_label, $next_value) = @$next;
 8:          if ('COMMA' eq $next_label) {
 9:              print "$value\n";
10:          }
11:          elsif ('KEYWORD' eq $next_label &amp;&amp; 'from' eq $next_value) {
12:              print "$value\n";
13:              last; # we're done
14:          }
15:      }
16:  }</code></pre>

<p>This is pretty straightforward, but there are some tricky bits. Each token is a two-element array reference, so line 3 makes the label and value fairly explicit. Lines 4 and 5 use the "cheat" for handling parentheses. Line 5 also skips anything that isn't text and therefore cannot be a column alias.</p>

<p>Line 6 is a bit odd. In <code>HOP::Lexer</code>, passing the string <code>peek</code> to the lexer will return the next token without actually advancing the <code>$lexer</code> iterator. From there, it's straightforward logic to find out if the value is a column alias that matches the criteria.</p>

<p>Putting all of this together makes:</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;
use HOP::Lexer 'make_lexer';

my $sql = &lt;&lt;END_SQL;
select the_date as "date",
round(months_between(first_date,second_date),0) months_old
,product,extract(year from the_date) year
,case
  when a=b then 'c'
    else 'd'
      end tough_one
      from XXX
END_SQL

my @sql   = $sql;
my $lexer = make_lexer(
    sub { shift @sql },
    [ 'KEYWORD', qr/(?i:select|from|as)/          ],
    [ 'COMMA',   qr/,/                            ],
    [ 'OP',      qr{[-=+*/]}                      ],
    [ 'PAREN',   qr/\(/,      sub { [shift,  1] } ],
    [ 'PAREN',   qr/\)/,      sub { [shift, -1] } ],
    [ 'TEXT',    qr/(?:\w+|'\w+'|"\w+")/, \&amp;text  ],
    [ 'SPACE',   qr/\s*/,     sub {}              ],
);

sub text {
    my ( $label, $value ) = @_;
    $value =~ s/^["']//;
    $value =~ s/["']$//;
    return [ $label, $value ];
}

my $inside_parens = 0;
while ( defined ( my $token = $lexer-&gt;() ) ) {
    my ( $label, $value ) = @$token;
    $inside_parens += $value if 'PAREN' eq $label;
    next if $inside_parens || 'TEXT' ne $label;
    if ( defined ( my $next = $lexer-&gt;('peek') ) ) {
        my ( $next_label, $next_value ) = @$next;
        if ( 'COMMA' eq $next_label ) {
            print "$value\n";
        }
        elsif ( 'KEYWORD' eq $next_label &amp;&amp; 'from' eq $next_value ) {
            print "$value\n";
            last; # we're done
        }
    }
}</code></pre>

<p>That prints out the column aliases:</p>

<pre><code>date
months_old
product
year
tough_one</code></pre>

<p>So are you done? No, probably not. What you really need now are many other examples of the SQL generated in the first problem statement. Maybe the <code>&amp;text</code> subroutine is naive. Maybe there are other operators you forgot. Maybe there are floating-point numbers embedded in the SQL. When you have to lex data by hand, fine-tuning the lexer to match your actual data can take a few tries.</p>

<p>It's also important to note that precedence is very important here. <code>&amp;make_lexer</code> evaluates each array reference passed in the order it receives them. If you passed the <code>TEXT</code> array reference before the <code>KEYWORD</code> array reference, the <code>TEXT</code> regular expression would match keywords before the <code>KEYWORD</code> could, thus generating spurious results.</p>

<p>Happy lexing!</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/2005/12/">&laquo; December 2005</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/2006/02/">February 2006 &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2014/02/">February 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2014/01/">January 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/10/">October 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/01/">January 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/12/">December 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/11/">November 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/10/">October 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/08/">August 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/06/">June 2012 (11)</a></li>
        
    
        
            <li><a href="/pub/2012/05/">May 2012 (18)</a></li>
        
    
        
            <li><a href="/pub/2012/04/">April 2012 (17)</a></li>
        
    
        
            <li><a href="/pub/2012/02/">February 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/12/">December 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/09/">September 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/08/">August 2011 (2)</a></li>
        
    
        
            <li><a href="/pub/2011/06/">June 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/05/">May 2011 (3)</a></li>
        
    
        
            <li><a href="/pub/2011/04/">April 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/03/">March 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/02/">February 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/01/">January 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/11/">November 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/10/">October 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/09/">September 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/08/">August 2010 (3)</a></li>
        
    
        
            <li><a href="/pub/2010/07/">July 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/04/">April 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/03/">March 2010 (4)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.13-en" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

            <div class="widget-creative-commons widget">
                <div class="widget-content">
                    This blog is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons License</a>.
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
