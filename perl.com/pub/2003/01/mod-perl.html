<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    
    <link rel="prev bookmark" href="/pub/2002/12/hohoho.html" title="How Perl Powers Christmas" />
    <link rel="next bookmark" href="/pub/2003/01/20020308.html" title="This week on Perl 6, weeks ending 2003-01-05" />
    
    
    <title>Improving mod_perl Sites' Performance: Part 6 - Perl.com</title>
</head>
<body id="perl-com" class="mt-entry-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <div id="entry-1044" class="entry-asset asset hentry">
                                <div class="asset-header">
                                    <h1 id="page-title" class="asset-name entry-title">Improving mod_perl Sites' Performance: Part 6</h1>
                                    <div class="asset-meta">
                                        <span class="byline">

                                            By <span class="vcard author">Stas Bekman</span> on <abbr class="published" title="2003-01-07T00:00:00-08:00">January  7, 2003 12:00 AM</abbr>

                                        </span>


                                    </div>
                                </div>
                                <div class="asset-content entry-content">

                                    <div class="asset-body">
                                        
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p>It's desirable to avoid forking under <code>mod_perl</code>, as when you do, 
you are forking the entire Apache server -- lock, stock and barrel. Not only is 
your Perl code and Perl interpreter being duplicated, but so is 
<code>mod_ssl</code>, <code>mod_rewrite</code>, <code>mod_log</code>, 
<code>mod_proxy</code>, <code>mod_speling</code> (it's not a typo!) or whatever 
modules you have used in your server, all the core routines.</p>
<p>Modern operating systems come with a light version of fork, which adds a 
little overhead when called, since it was optimized to do the absolute minimum 
of memory pages duplications. The <em>copy-on-write</em> technique is what 
allows it to do so. The gist of this technique is as follows: The parent 
process' memory pages aren't immediately copied to the child's space on fork(); 
this is done only when the child or the parent modifies the data in some memory 
pages. Before the pages get modified, they get marked as dirty and the child has 
no choice but to copy the pages that are to be modified since they cannot be 
shared any more.</p>
<p>If you need to call a Perl program from your <code>mod_perl</code> code, then it's 
better to try to covert the program into a module and call it as a function 
without spawning a special process to do that. Of course, if you cannot do that 
or the program is not written in Perl, then you have to call via 
<code>system()</code> or its equivalent, which spawns a new process. If the 
program is written in C, then you can try to write a Perl glue code with help of XS 
or SWIG architectures, and then the program will be executed as a Perl 
subroutine.</p>
<p>Also, by trying to spawn a sub-process, you might be trying to do the 
<em>&quot;wrong thing&quot;</em>. If what you really want is to send information to the 
browser and then do some post-processing, then look into the 
<code>PerlCleanupHandler</code> directive. The latter allows you to tell the 
child process after request has been processed and user has received the 
response. This doesn't release the <code>mod_perl</code> process to serve other 
requests, but it allows you to send the response to the client faster. If this 
is the situation and you need to run some cleanup code, then you may want to register 
this code during the request processing stage like so:</p><pre><code>  my $r = shift;
  $r-&gt;register_cleanup(\&amp;do_cleanup);
  sub do_cleanup{ #some clean-up code here }</code></pre>
<p>But when a long-term process needs to be spawned, there is not much choice 
but to use fork(). We cannot just run this process within the Apache 
process because it'll keep the Apache process busy, instead of allowing it 
to do the job it was designed to do. Also, if Apache stops, then the long-term 
process might be terminated as well unless coded properly to detach from 
Apache's process group.</p>

<csperl file="grab" domain="on" record="b/832" template="b/article_sidebar2.view">

<p>In the following sections, I'm going to discuss how to properly spawn new 
processes under <code>mod_perl</code>.</p>

<h3><a name="forking_a_new_process">Forking a New Process</a></h3>
<p>This is a typical way to call <code>fork()</code> under 
<code>mod_perl</code>:</p><pre><code>  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
    # some code comes here
    CORE::exit(0);
  }
  # possibly more code here usually run by the parent</code></pre>
<p>When using fork(), you should check its return value, because if it returns 
<code>undef</code>, it means that the call was unsuccessful and no process was 
spawned; something that can happen when the system is running too many processes 
and cannot spawn new ones.</p>
<p>When the process is successfully forked, the parent receives the PID of the 
newly spawned child as a returned value of the <code>fork()</code> call and the 
child receives 0. Now the program splits into two. In the above example, the code 
inside the first block after <em>if</em> will be executed by the parent and the 
code inside the first block after <em>else</em> will be executed by the child 
process.</p>
<p>It's important not to forget to explicitly call <code>exit()</code> at the 
end of the child code when forking - if you don't and there is some code outside 
the <em>if/else block</em>, then the child process will execute it as well. But under 
<code>mod_perl</code> there is another nuance: You must use 
<code>CORE::exit()</code> and not <code>exit()</code>, which would be 
automatically overriden by <code>Apache::exit()</code> if used in conjunction 
with <code>Apache::Registry</code> and similar modules. We actually do want the 
spawned process to quit when its work is done, otherwise, it'll just stay alive, 
use resources and do nothing.</p>
<p>The parent process usually completes its execution path and enters the pool 
of free servers to wait for a new assignment. If the execution path is to be 
aborted earlier for some reason, then one should use Apache::exit() or die(). In the 
case of <code>Apache::Registry</code> or <code>Apache::PerlRun</code> handlers, a 
simple <code>exit()</code> will do the correct thing.</p>
<p>The child shares with parent its memory pages until it has to modify some of 
them, which triggers a <em>copy-on-write</em> process that copies these pages 
to the child's domain before the child is allowed to modify them. But this all 
happens afterward. At the moment the <code>fork()</code> call is executed, the 
only work to be done before the child process goes on its separate way is to set 
up the page tables for the virtual memory, which imposes almost no delay at 
all.</p>

<h3><a name="freeing_the_parent_process">Freeing the Parent Process</a></h3>
<p>In the child code, you must also close all pipes to the connection socket 
that were opened by the parent process (i.e. <code>STDIN</code> and 
<code>STDOUT</code>) and inherited by the child, so the parent will be able to 
complete the request and free itself for serving other requests. If you need the 
<code>STDIN</code> and/or <code>STDOUT</code> streams, then you should reopen them. 
You may need to close or reopen the <code>STDERR</code> filehandle. It's opened 
to append to the <em>error_log</em> file as inherited from its parent, so 
chances are that you will want to leave it untouched.</p>
<p>Under <code>mod_perl</code>, the spawned process also inherits a file 
descriptor that's tied to the socket through which all communication 
between the server and the client occur. Therefore, we need to free this stream 
in the forked process. If we don't do that, then the server cannot be restarted while 
the spawned process is still running. If an attempt is made to restart the 
server, then you will get the following error:</p><pre><code>  [Mon Dec 11 19:04:13 2000] [crit] 
  (98)Address already in use: make_sock:
    could not bind to address 127.0.0.1 port 8000</code></pre>
<p><code>Apache::SubProcess</code> comes to our aid and provides a method 
<code>cleanup_for_exec()</code>, which takes care of closing this file 
descriptor.</p>
<p>So the simplest way to free the parent process is to close all three 
<code>STD*</code> streams if we don't need them, and untie the Apache socket. In 
addition, you may want to change the process' current directory to <em>/</em> so 
the forked process won't keep the mounted partition busy, if this is to be 
unmounted at a later time. To summarize all this issues, here is an example of 
the fork that takes care of freeing the parent process.</p><pre><code>  use Apache::SubProcess;
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
      $r-&gt;cleanup_for_exec(); # untie the socket
      chdir '/' or die "Can't chdir to /: $!";
      close STDIN;
      close STDOUT;
      close STDERR;
  
    # some code comes here
  
      CORE::exit(0);
  }
  # possibly more code here usually run by the parent</code></pre>
<p>Of course, between the freeing-parent code and child-process termination, 
the real code is to be placed.</p>

<h3><a name="detaching_the_forked_process">Detaching the Forked Process</a></h3>
<p>Now what happens if the forked process is running and we decide that we need 
to restart the Web server? This forked process will be aborted, since when the 
parent process dies during the restart, it'll kill its child processes as well. 
In order to avoid this, we need to detach the process from its parent session by 
opening a new session. We do this with help of <code>setsid()</code> system 
call, provided by the <code>POSIX</code> module:</p><pre><code>  use POSIX 'setsid';
  
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
      setsid or die "Can't start a new session: $!";
      ...
  }</code></pre>
<p>Now the spawned child process has a life of its own, and it doesn't depend on 
the parent any longer.</p>

<h3><a name="avoiding_zombie_processes">Avoiding Zombie Processes</a></h3>
<p>Now let's talk about zombie processes.</p>
<p>Normally, every process has its parent. Many processes are children of the 
<code>init</code> process, whose <code>PID</code> is <code>1</code>. When you 
fork a process, you must <code>wait()</code> or <code>waitpid()</code> for it to 
finish. If you don't <code>wait()</code> for it, then it becomes a zombie.</p>
<p>A zombie is a process that doesn't have a parent. When the child quits, it 
reports the termination to its parent. If no parent wait()s to collect the exit 
status of the child, then it gets <em>&quot;confused&quot;</em> and becomes a ghost process. 
This process can be seen as a process, but not killed. It will be killed only 
when you stop the parent process that spawned it!</p>
<p>Generally, the <code>ps(1)</code> utility displays these processes with the 
<code>&lt;defunct&gt;</code> tag, and you will see the zombies counter increment 
when doing top(). These zombie processes can take up system resources and are 
generally undesirable.</p>
<p>So the proper way to do a fork is:</p><pre><code>  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  defined (my $kid = fork) or die "Cannot fork: $!";
  if ($kid) {
    waitpid($kid,0);
    print "Parent has finished\n";
  } else {
      # do something
      CORE::exit(0);
  }</code></pre>
<p>In most cases, the only reason you would want to fork is when you need to 
spawn a process that will take a long time to complete. So if the Apache process 
that spawns this new child process has to wait for it to finish, then you have gained 
nothing. You can neither wait for its completion (because you don't have the 
time to), nor continue because you will get yet another zombie process. This is 
called a blocking call, since the process is blocked to do anything else before 
this call gets completed.</p>
<p>The simplest solution is to ignore your dead children. Just add this line 
before the <code>fork()</code> call:</p><pre><code>  $SIG{CHLD} = 'IGNORE';</code></pre>
<p>When you set the <code>CHLD</code> (<code>SIGCHLD</code> in C) signal handler 
to <code>'IGNORE'</code>, all the processes will be collected by the 
<code>init</code> process and are therefore prevented from becoming zombies. 
This doesn't work everywhere, however. It proved to work at least on the Linux 
OS.</p>
<p>Note that you cannot localize this setting with <code>local()</code>. If you 
do, then it won't have the desired effect.</p>
<p>So now the code would look like this:</p><pre><code>  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  $SIG{CHLD} = 'IGNORE';
  
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    print "Parent has finished\n";
  } else {
      # do something time-consuming
      CORE::exit(0);
  }</code></pre>
<p>Note that <code>waitpid()</code> call is gone. The 
$SIG{CHLD}&nbsp;=&nbsp;'IGNORE'; statement protects us from zombies, as 
explained above.</p>
<p>Another, more portable but slightly more expensive solution, is to use a 
double fork approach.</p><pre><code>  my $r = shift;
  $r-&gt;send_http_header('text/plain');
  
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    waitpid($kid,0);
  } else {
    defined (my $grandkid = fork) or die "Kid cannot fork: $!\n";
    if ($grandkid) {
      CORE::exit(0);
    } else {
      # code here
      # do something long lasting
      CORE::exit(0);
    }
  }</code></pre>
<p><code>$grandkid</code> becomes a <em>&quot;child of init&quot;</em>, i.e. the child 
of the process whose PID is 1.</p>
<p>Note that the previous two solutions do allow you to know the exit status of 
the process, but in my example I didn't care about it.</p>
<p>Another solution is to use a different <em>SIGCHLD</em> handler:</p><pre><code>  use POSIX 'WNOHANG';
  $SIG{CHLD} = sub { while( waitpid(-1,WNOHANG)&gt;0 ) {} };</code></pre>
<p>This is useful when you <code>fork()</code> more than one process. The 
handler could call <code>wait()</code> as well, but for a variety of reasons 
involving the handling of stopped processes and the rare event when two 
children exit at nearly the same moment, the best technique is to call 
<code>waitpid()</code> in a tight loop with a first argument of <code>-1</code> 
and a second argument of <code>WNOHANG</code>. Together, these arguments tell 
<code>waitpid()</code> to reap the next child that's available, and prevent the 
call from blocking if there happens to be no child ready for reaping. The 
handler will loop until <code>waitpid()</code> returns a negative number or 
zero, indicating that no additional reapable children remain.</p>
<p>While you test and debug your code that uses one of the above examples, you 
might want to write some debug information to the error_log file so you know 
what happens.</p>
<p>Read <em>perlipc</em> manpage for more information about signal handlers.</p>
















<h3><a name="a_complete_fork_example">A Complete Fork Example</a></h3>
<p>Now let's put all the bits of code together and show a well-written fork code 
that solves all the problems discussed so far. I will use an 
&lt;Apache::Registry&gt; script for this purpose:</p><pre><code>  proper_fork1.pl
  ---------------
  use strict;
  use POSIX 'setsid';
  use Apache::SubProcess;
  
  my $r = shift;
  $r-&gt;send_http_header("text/plain");
  
  $SIG{CHLD} = 'IGNORE';
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    print "Parent $$ has finished, kid's PID: $kid\n";
  } else {
      $r-&gt;cleanup_for_exec(); # untie the socket
      chdir '/'                or die "Can't chdir to /: $!";
      open STDIN, '/dev/null'  or die "Can't read /dev/null: $!";
      open STDOUT, '&gt;/dev/null'
          or die "Can't write to /dev/null: $!";
      open STDERR, '&gt;/tmp/log' or die "Can't write to /tmp/log: $!";
      setsid or die "Can't start a new session: $!";
  
      select STDERR;
      local $| = 1;
      warn "started\n";
      # do something time-consuming
      sleep 1, warn "$_\n" for 1..20;
      warn "completed\n";
  
      CORE::exit(0); # terminate the process
  }</code></pre>
<p>The script starts with the usual declaration of the strict mode, loading the 
<code>POSIX</code> and <code>Apache::SubProcess</code> modules and importing of 
the <code>setsid()</code> symbol from the <code>POSIX</code> package.</p>
<p>The HTTP header is sent next, with the <em>Content-type</em> of 
<em>text/plain</em>. The gets ready to ignore the child, to avoid zombies and 
the fork is called.</p>
<p>The program gets its personality split after <code>fork</code> and the 
<code>if</code> conditional evaluates to a true value for the parent process, 
and to a false value for the child process; the first block is executed by the 
parent and the second by the child.</p>
<p>The parent process announces his PID and the PID of the spawned process and 
finishes its block. If there will be any code outside, then it will be executed by the 
parent as well.</p>
<p>The child process starts its code by disconnecting from the socket, changing 
its current directory to <code>/</code>, opening the STDIN and STDOUT streams to 
<em>/dev/null</em>, which in effect closes them both before opening. In fact, in 
this example we don't need neither of these, so I could just 
<code>close()</code> both. The child process completes its disengagement from 
the parent process by opening the STDERR stream to <em>/tmp/log</em>, so it 
could write there, and creating a new session with help of setsid(). Now the 
child process has nothing to do with the parent process and can do the actual 
processing that it has to do. In our example, it performs a simple series of 
warnings, which are logged into <em>/tmp/log</em>:</p><pre><code>      select STDERR;
      local $|=1;
      warn "started\n";
      # do something time-consuming
      sleep 1, warn "$_\n" for 1..20;
      warn "completed\n";</code></pre>
<p>The localized setting of <code>$|=1</code> is there, so we can see the output 
generated by the program immediately. In fact, it's not required when the output 
is generated by warn().</p>
<p>Finally, the child process terminates by calling:</p><pre><code>      CORE::exit(0);</code></pre>
<p>which makes sure that it won't get out of the block and run some code that 
it's not supposed to run.</p>
<p>This code example will allow you to verify that indeed the spawned child 
process has its own life, and its parent is free as well. Simply issue a request 
that will run this script, watch that the warnings are started to be written 
into the <em>/tmp/log</em> file and issue a complete server stop and start. If 
everything is correct, then the server will successfully restart and the long-term 
process will still be running. You will know that it's still running if the 
warnings will still be printed into the <em>/tmp/log</em> file. You may need to 
raise the number of warnings to do above 20, to make sure that you don't miss 
the end of the run.</p>
<p>If there are only five warnings to be printed, then you should see the following 
output in this file:</p><pre><code>  started
  1
  2
  3
  4
  5
  completed</code></pre>

<h3><a name="starting_a_long_running_external_program">Starting a Long-Running 
External Program</a></h3>
<p>But what happens if we cannot just run a Perl code from the spawned process 
and we have a compiled utility, i.e. a program written in C. Or we have a Perl 
program that cannot be easily converted into a module, and thus called as a 
function. Of course, in this case, we have to use system(), exec(), 
<code>qx()</code> or <code>``</code> (back ticks) to start it.</p>
<p>When using any of these methods and when the <em>Taint</em> mode is enabled, 
we must at least add the following code to untaint the <em>PATH</em> environment 
variable and delete a few other insecure environment variables. This information 
can be found in the <em>perlsec</em> manpage.</p><pre><code>  $ENV{'PATH'} = '/bin:/usr/bin';
  delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};</code></pre>
<p>Now all we have to do is to reuse the code from the previous section.</p>
<p>First, we move the core program into the <em>external.pl</em> file, add the 
shebang first line so the program will be executed by Perl, tell the program to 
run under <em>Taint</em> mode (-T) and possibly enable the <em>warnings</em> 
mode (-w) and make it executable:</p><pre><code>  external.pl
  -----------
  #!/usr/bin/perl -Tw
  
  open STDIN, '/dev/null'  or die "Can't read /dev/null: $!";
  open STDOUT, '&gt;/dev/null'
      or die "Can't write to /dev/null: $!";
  open STDERR, '&gt;/tmp/log' or die "Can't write to /tmp/log: $!";
  
  select STDERR;
  local $|=1;
  warn "started\n";
  # do something time-consuming
  sleep 1, warn "$_\n" for 1..20;
  warn "completed\n";</code></pre>
<p>Now we replace the code that moved into the external program with 
<code>exec()</code> to call it:</p><pre><code>  proper_fork_exec.pl
  -------------------
  use strict;
  use POSIX 'setsid';
  use Apache::SubProcess;
  
  $ENV{'PATH'} = '/bin:/usr/bin';
  delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
  
  my $r = shift;
  $r-&gt;send_http_header("text/html");
  
  $SIG{CHLD} = 'IGNORE';
  
  defined (my $kid = fork) or die "Cannot fork: $!\n";
  if ($kid) {
    print "Parent has finished, kid's PID: $kid\n";
  } else {
      $r-&gt;cleanup_for_exec(); # untie the socket
      chdir '/'                or die "Can't chdir to /: $!";
      open STDIN, '/dev/null'  or die "Can't read /dev/null: $!";
      open STDOUT, '&gt;/dev/null'
          or die "Can't write to /dev/null: $!";
      open STDERR, '&gt;&amp;STDOUT'  or die "Can't dup stdout: $!";
      setsid or die "Can't start a new session: $!";
  
      exec "/home/httpd/perl/external.pl" or die "Cannot execute exec: $!";
  }</code></pre>
<p>Notice that <code>exec()</code> never returns unless it fails to start the 
process. Therefore, you shouldn't put any code after exec()--it will be not 
executed in the case of success. Use <code>system()</code> or back-ticks instead 
if you want to continue doing other things in the process. But then you probably 
will want to terminate the process after the program has finished. So you will 
have to write:</p><pre><code>      system "/home/httpd/perl/external.pl" or die "Cannot execute system: $!";
      CORE::exit(0);</code></pre>
<p>Another important nuance is that we have to close all <code>STD*</code> 
streams in the forked process, even if the called program does that.</p>
<p>If the external program is written in Perl, then you may pass complicated data 
structures to it using one of the methods to serialize Perl data and then to 
restore it. The <code>Storable</code> and <code>FreezeThaw</code> modules come 
handy. Let's say that we have program <em>master.pl</em> calling program 
<em>slave.pl</em>:</p><pre><code>  master.pl
  ---------
  # we are within the C&lt;mod_perl&gt; code
  use Storable ();
  my @params = (foo =&gt; 1, bar =&gt; 2);
  my $params = Storable::freeze(\@params);
  exec "./slave.pl", $params or die "Cannot execute exec: $!";</code></pre><pre><code>  slave.pl
  --------
  #!/usr/bin/perl -w
  use Storable ();
  my @params = @ARGV ? @{ Storable::thaw(shift)||[] } : ();
  # do something</code></pre>
<p>As you can see, <em>master.pl</em> serializes the <code>@params</code> data 
structure with <code>Storable::freeze</code> and passes it to <em>slave.pl</em> 
as a single argument. <em>slave.pl</em> restores it with 
<code>Storable::thaw</code>, by shifting the first value of the 
<code>ARGV</code> array if available. The <code>FreezeThaw</code> module does a 
similar thing.</p>

<h3><a name="starting_a_short_running_external_program">Starting a Short-Running 
External Program</a></h3>
<p>Sometimes you need to call an external program and you cannot continue before 
this program completes its run and optionally returns some result. In this case, 
the fork solution doesn't help. But we have a few ways to execute this program. 
First using system():</p><pre><code>  system "perl -e 'print 5+5'"</code></pre>
<p>We believe that you will never call the Perl interperter for doing this 
simple calculation, but for the sake of a simple example it's good enough.</p>
<p>The problem with this approach is that we cannot get the results printed to 
<code>STDOUT</code>, and that's where back-ticks or <code>qx()</code> help. If you use either:</p><pre><code>  my $result = `perl -e 'print 5+5'`;</code></pre>
<p>or:</p><pre><code>  my $result = qx{perl -e 'print 5+5'};</code></pre>
<p>the whole output of the external program will be stored in the 
<code>$result</code> variable.</p>
<p>Of course, you can use other solutions, such as opening a pipe (<code>|</code> to 
the program) if you need to submit many arguments and more evolved solutions 
provided by other Perl modules like <code>IPC::Open2</code>, which allows to open 
a process for both reading and writing.</p>

<h3><a name="executing_system()_or_exec()_in_the_right_way">Executing 
<code>system()</code> or <code>exec()</code> in the Right Way</a></h3>
<p>The <code>exec()</code> and <code>system()</code> system calls behave 
identically in the way they spawn a program. For example, let's use 
<code>system()</code>. Consider the following code:</p><pre><code>  system("echo","Hi");</code></pre>
<p>Perl will use the first argument as a program to execute, find 
<code>/bin/echo</code> along the search path, invoke it directly and pass the 
<em>Hi</em> string as an argument.</p>
<p>Perl's <code>system()</code> is <strong>not</strong> the 
<code>system(3)</code> call (from the C-library). This is how the arguments to 
<code>system()</code> get interpreted. When there is a single argument to 
system(), it'll be checked for having shell metacharacters first (like 
<code>*</code>,<code>?</code>), and if there are any--Perl interpreter invokes a 
real shell program (/bin/sh&nbsp;-c on Unix platforms). If you pass a list of 
arguments to system(), then they will be not checked for metacharacters, but split 
into words if required and passed directly to the C-level <code>execvp()</code> 
system call, which is more efficient. That's a <em>very</em> nice optimization. 
In other words, only if you do:</p><pre><code>  system "sh -c 'echo *'"</code></pre>
<p>will the operating system actually <code>exec()</code> a copy of 
<code>/bin/sh</code> to parse your command. But even then, since <em>sh</em> is 
almost certainly already running somewhere, the system will notice that (via the 
disk inode reference) and replace your virtual memory page table with one 
pointing to the existing program code plus your data space, thus will not create 
this overhead.</p>



<h3><a name="references">References</a></h3>
<ul>
  <li>The <code>mod_perl</code> site's URL: <a 
  href="http://perl.apache.org/">http://perl.apache.org/</a> </li>
  
  <li><code>Apache-SubProcess</code> <a 
  href="http://search.cpan.org/search?dist=Apache-SubProcess">http://search.cpan.org/search?dist=Apache-SubProcess</a> </li>

  
  <li><code>Storable</code> <a 
  href="http://search.cpan.org/search?dist=Storable">http://search.cpan.org/search?dist=Storable</a> 

  </li></ul>


                                    </div>


                                </div>
                                <div class="asset-footer">

    
                                    <div class="entry-categories">
                                        <h4>Categories<span class="delimiter">:</span></h4>
                                        <ul>
                                            <li><a href="/pub/mod-perl/" rel="tag">mod_perl</a></li>
                                        </ul>
                                    </div>
    


                                    <div class="entry-tags">
                                        <h4>Tags<span class="delimiter">:</span></h4>
                                        <ul>
                                            <li><a href="javascript:void(0)" onclick="location.href='http://www.perl.com/mt-search.cgi?blog_id=2&amp;tag=mod_perl%20fork&amp;limit=20';return false;" rel="tag">mod_perl fork</a></li>
                                        </ul>
                                    </div>

                                </div>
                            </div>


                    
                    


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2010/07/">July 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
