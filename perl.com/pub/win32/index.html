<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Win32 Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Win32</em> Category</h1>






                            
                            <div id="entry-650" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/01/painless-ppm.html" rel="bookmark">Painless Windows Module Installation with PPM</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Josh Stroschein</span> on <abbr class="published" title="2007-01-11T00:00:00-08:00">January 11, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>I have recently been working on an installation package for the Microsoft Windows series of operating systems (Windows 2000 and newer). One of the primary components of this installation package is the installation of ActiveState's distribution of Perl, known as ActivePerl 5.6, and supporting Perl modules.</p>

<p>I chose Perl for its versatility in the automation of system maintenance. This versatility is largely due to the continued development and support of the numerous modules available on the Comprehensive Perl Archive Network (CPAN). These modules help make Perl a very capable solution to many of the programming obstacles I faced. The choice of Perl had a nice complement in the nearly seamless installation of many of these modules by using a small program provided with ActivePerl called the Perl Package Manager (PPM). PPM is a command-line driven tool that allows programmers to search for and install Perl modules from a wide variety of locations. PPM is only available with the Windows distributions of ActivePerl; hence this article will focus on a Windows environment.</p>

<p>The ActivePerl distribution comes bundled with many popular Perl modules such as <a href="http://search.cpan.org/perldoc?LWP">LWP</a>, which is a module that provides an API to the World Wide Web, and <a href="http://search.cpan.org/perldoc?DBI">DBI</a>, which is an API for database interaction. A visit to search.cpan.org will give you an idea of the tremendous amount of modules available. Try executing a search on CPAN and you will typically receive a modest sized list of modules for whatever you are searching. Installing modules with PPM and Internet access is typically straight-forward; therefore I will not cover those details in-depth. However, this is the point during development where I began to run into problems.</p>

<h3>About Repositories</h3>

<p>My installation package relies heavily on modules not included with the standard ActivePerl distribution. Because I had to assume that the user would not have access to the Internet, my installation package needed to be self-sufficient. PPM's default configuration accesses repositories maintained by ActiveState. Therefore, I needed to develop a way to install Perl modules during an automated installation without access to the Internet.</p>

<p>A <em>repository</em> is essentially a collection of files that provides the necessary information for the PPM program to find, download, and install Perl modules. The use of the word repository tends to get a little confusing. Each PC that PPM runs on has to have a repository configured on it in order to search for modules. It's possible to create a local repository that accessible only on the local machine. It can provide the modules locally or reference another repository located on a server. A web server can host a repository that allows wider access to its modules. This type of repository does not even need the PPM program available to function as long as its' sole purpose is to simply serve modules. Other repositories can link to it to search for modules.</p>

<p>I eventually came up with a couple of viable solutions. The first solution I looked at involved downloading the source code of the modules. These modules typically come in a <em>.tar.gz</em> format. After unzipping and untaring them, I needed to use Nmake to build and install each one. The further I attempted to develop this solution, the more problems I encountered. Having approximately seven modules that I needed to install, this solution required building all of them individually. Because my installation package was completely automated, I needed to accomplish this from a Windows batch file. As I quickly found out, the less I needed to do in a batch file the better! This also raised another issue: the availability of programs outside of my installation package. In this case I would have needed Nmake, which is the Windows equivalent of the Unix Make program, to build and install modules. If the system that the installation package is running on did not have Nmake installed and available in the system path, then I became responsible for locating it on each individual system. The challenges began to compound; I knew there had to be an easier way.</p>

<p>I recalled reading in the ActiveState documentation that the PPM program supports the creation and use of local repositories. After doing some further research, I concluded that I could setup a local repository and bundle the modules in their <em>.tar.gz</em> format with the installation package. I could then use the PPM program, through the use of a batch file, to automate the installation of those modules. This solution would eliminate the need for Internet access, keeping my installation package completely autonomous. It would also provide a dependable solution for building and installing the modules during the installation that did not require any user interaction or outside programs.</p>

<csperl file="grab" domain="on" record="b/2398" template="b/article_sidebar2.view">













<h3>Using PPM</h3>

<p>Before I begin discussing my solution, it's worth covering some basics of the PPM program. To run the PPM program type at a command line:</p>

<pre><code>C:\&gt; <strong>ppm</strong>
PPM - Programmer's Package Manager version 3.2.
Copyright (c) 2001 ActiveState Corp. All Rights Reserved.
ppm&gt;</code></pre>

<p>This, of course, assumes that you have the ActivePerl distribution installed on your system and the PPM program registered in your system path. If typing PPM at the command line yields no results, find it in the <em>bin\</em> directory of your ActivePerl installation. ActivePerl installs to <em>C:\Perl\bin\</em> by default. Change to that directory and then type:</p>

<pre><code>C:\Perl\bin&gt; <strong>ppm</strong></code></pre>

<p>You know you are in the PPM program when the command prompt turns into a <code>ppm&gt;</code> prompt. Once inside the program you can display all of the repositories available on that system by typing:</p>

<pre><code>ppm&gt; <strong>rep</strong>
Repositories:
[1] ActiveState Package Repository
[2] ActiveState PPM2 Repository</code></pre>

<p>With a default installation you will see a couple of repositories that begin with ActiveState. These are the ones I mentioned earlier. They are the default repositories that ActiveState maintains. If you are connected to the Internet you can execute a search by typing:</p>

<pre><code><strong>search &lt;Module Name&gt;</strong></code></pre>

<p>If your search produces results, the result will be a list referencing each match by a number, the package name, and a brief description. Here is a search for everything in one of my local repositories:</p>

<pre><code>ppm&gt; <strong>search *</strong>
Searching in Active Repositories
  1. Crypt::Blowfish    [2.10] Crypt::Blowfish
  2. Date-Formatter [0.04] A simple Date and Time formatting object
  3. DBD-Mysql [2.04.1] MySQL drivers for the Perl5 Database Interface ~
  4. DBI [1.14] Database independent interface for Perl
  5. libwww-perl [5.48] Library for WWW access in Perl
  6. Win32-Daemon    [0.2003.~ The Win32::Daemon extension for Win32 X86. Allo~</code></pre>

<p>Installing a module is just as easy. However, before you can install a module, the PPM program needs to create a reference to it. Accomplish this by searching for the module. Upon completion of the search you can refer to the module by the number that corresponds to it. To install the module at position one, in this case <code><a href="http://search.cpan.org/perldoc?Crypt::Blowfish">Crypt::Blowfish</a></code>, in the previous results list type:</p>

<pre><code>ppm&gt; <strong>install 1</strong></code></pre>

<p>The PPM program will let you know if the module installed successfully or failed. PPM offers other commands to make managing your modules easier. However, this is all I needed for my solution... except for creating a local repository.</p>

<h3>Creating a Local Repository</h3>

<p>There are a few basic elements to a local repository: the directory structure, the PPD files, and the modules. Initially, the PPM program gave me some difficulties locating the modules I needed to install. By trial and error, I discovered that the problem was the directory structure in which I had set up my repository. A repository needs two directories, one to house the PPD files and the other to contain the actual modules in their <em>.tar.gz</em> format. Because the most common architecture for these installations is the x86 architecture, I created a directory named <em>packages</em> with a subdirectory named <em>x86</em>. The important thing about the directory structure is that the actual modules go into a subdirectory. This is opposed to housing the PPD files in one location and then storing the actual modules in an entirely different location in the file system.</p>

<p>As I have mentioned earlier, this installation package was designed for Windows 2000 and later. I encountered numerous problems with the PPD files not being able to reference module locations based on an absolute path. I also encountered random errors when I used a relative path to a location other than a direct subdirectory. So where does the PPM program find this information?</p>

<p>A PPD file is nothing more than an XML document. This XML document contains all the information needed by the PPM program to install a module. Here is an example PPD file for the libwww module:</p>

<pre><code>&lt;SOFTPKG NAME="libwww-perl" VERSION="5,48,0,0"&gt;
 &lt;TITLE&gt;libwww-perl&lt;/TITLE&gt;
 &lt;ABSTRACT&gt;Library for WWW access in Perl&lt;/ABSTRACT&gt;
 &lt;AUTHOR&gt;Gisle Aas&lt;/AUTHOR&gt;
 &lt;IMPLEMENTATION&gt;
  &lt;DEPENDENCY NAME="Digest-MD5" VERSION="0,0,0,0" /&gt;
  &lt;DEPENDENCY NAME="HTML-Parser" VERSION="0,0,0,0" /&gt;
  &lt;DEPENDENCY NAME="MIME-Base64" VERSION="2,1,0,0" /&gt;
  &lt;DEPENDENCY NAME="libnet" VERSION="0,0,0,0" /&gt;
  &lt;DEPENDENCY NAME="URI" VERSION="1,03,0,0" /&gt;
  &lt;OS NAME="MSWin32" /&gt;
  &lt;ARCHITECTURE NAME="MSWin32-x86-object" /&gt;
  &lt;CODEBASE HREF="x86/libwww-perl.tar.gz" /&gt;
 &lt;/IMPLEMENTATION&gt;
&lt;/SOFTPKG&gt;</code></pre>

<p>Notice the <code>name</code> attribute in the <code>&lt;softpkg&gt;</code> element. The PPM program queries this attribute's value when you perform a search. The <code>&lt;implementation&gt;</code> element also includes some very important attributes. Inside this element you can declare dependencies inside <code>&lt;dependency&gt;</code> elements. This example PPD file includes several dependencies that must be met in order for this package to install successfully. The PPM program will check the system for the installation of these modules and, much like installing a Linux RPM, will fail if it can not find them on the system.</p>

<p>One of the most important elements in the PPD file is the <code>&lt;codebase&gt;</code> element. The <code>HREF</code> attribute directs the PPM program to the location of the module. Remember the packages directory? Fill the <em>x86</em> directory with the <em>.tar.gz</em> download of the modules you want in your repository. Then supply the relative path to them in the <code>HREF</code> attribute so that the PPM program will be able to locate them. You may also use URL to refer to a location on the web or on a local network. It's entirely possible to create a local repository that only references modules located on other servers, instead of supplying all the modules locally. By supplying a URL, your repository could point the PPM program to another location on a network or over the Web.</p>

<p>I experimented with this tag quite extensively. The biggest problem that I encountered was trying to reference a module in the <code>HREF</code> tag by its absolute path. On certain versions of Windows, the PPM program would always fail, citing a variety of errors. Once I created the appropriate directory structure and supplied the PPM program with a relative path, it found the modules successfully. Visit ActiveState's website for a complete breakdown of the PPD file structure and all of the supported elements.</p>

<p>You should now be able to create your own PPD files. Just keep in mind that if you can not build the module on your system by the standard:</p>

<pre><code>perl Makefile.PL
nmake
nmake test
nmake install</code></pre>

<p>... approach, then PPM will probably not be able to install them successfully either. PPMs exist to ease the installation of modules successfully built and tested in a Windows environment.</p>

<p>For each module that you want in your repository, create a PPD. The example provides a good starting template for a PPD file. From a blank text document, insert the corresponding data in XML format. Once you've inserted the relevant information, save the file with a logical name and the <em>.ppd</em> extension. I typically use a name that closely mimics the one used in the <code>&lt;title&gt;</code> element. The PPD files must go in your repository's <em>packages</em> directory. Once you have created all of the PPD files and downloaded the modules into the <em>x86</em> directory, you're ready to set up the repository in PPM.</p>













<h3>Registering a Repository</h3>

<p>Creating a local repository requires just a few commands. From within the PPM program type:</p>

<pre><code>rep add &lt;name&gt; &lt;location&gt;</code></pre>

<p>Suppose that you have created the packages directory at <em>C:\Perl\bin\packages</em>. You have also created the <em>x86</em> directory inside the <em>packages</em> directory: <em>C:\Perl\bin\packages\x86</em>. When you perform a search with PPM, it queries the PPD files. More specifically, it queries the metadata inside the XML of the PPD file, matching the <code>title</code> tag against your search. Executing:</p>

<pre><code>ppm&gt; <strong>rep add MyRep C:\Perl\bin\packages</strong></code></pre>

<p>... creates a repository named MyRep that uses PPD files in the <em>packages</em> directory. After this command completes, check to see that it's now in the repository list:</p>

<pre><code>ppm&gt; <strong>rep</strong>
Repositories:
[1] ActiveState Package Repository
[2] ActiveState PPM2 Repository
[3] MyRep</code></pre>

<p>This will return a list of all the available repositories. You should now see the repository that you just created, which will be set to active by default. The numbers in the list serves two purposes: the first is to define the order in which the search executes. PPM searches first the repository at position one, followed by two, and so forth. Second, it eases the management of the repositories much in the same way it eases installing modules. Instead of referring to a repository by name, you can refer to it by its number.</p>

<h3>A More Public Repository</h3>

<p>The new local repository is only accessible by the machine where it resides. If desired, you can modify the PPD files and the steps involved in creating a repository to use an HTTP-based repository over a local network. You could use this repository outside of an installation package to manage and provide module access over a large network. For a straight-forward HTTP-based repository, all you need is a web-server accessible to a local Intranet or over the Internet.</p>

<p>Even though I did not implement an HTTP-based repository, is well worth covering a simple setup. This essentially involves creating two repositories: one on the server and the other on any PC. I chose the Windows version of the Apache 2 web server. After a default installation of Apache 2, I configured it as a repository. There are only a couple of steps involved to accomplish this.</p>

<p>By default, Apache serves its pages from <em>C:\Program Files\Apache2\htdocs.</em>. I created the repository directories as previously discussed: <em>C:\Program Files\Apache2\htdocs\packages\x86</em>. As long as the <em>packages</em> directory is web-accessible, it will allow the server to act as a simple web-based repository. If you don't plan to run PPM on the server then the ActivePerl installation is not even necessary. Now when you create a repository, if you supply the url to the server instead of a directory path it will access the repository over the network or Internet. To create a web-based repository in PPM, type:</p>

<pre><code>ppm&gt; <strong>rep add &lt;name&gt; &lt;url&gt;</strong></code></pre>

<p>Now the PPM program on that machine will be able to search the modules available on the repository located at the specified URL.</p>

<p>In order to test the installation of the repository, I usually disable the other repositories. There are multiple ways to do this, but I find it easiest to turn off the repositories. This keeps the repository available on the system; however, PPM will not use them when you perform a search. To disable searching of the repository at position two, type:</p>

<pre><code>ppm&gt; <strong>rep off 2</strong>
Repositories:
[1] ActiveState Package Repository
[2] MyRep
[ ] ActiveState PPM2 Repository</code></pre>

<p>You can also remove a repository from your system:</p>

<pre><code>ppm&gt; <strong>rep delete &lt;name or num&gt;</strong></code></pre>

<p>This will completely remove that repository from the system. Removing a repository is safe if you are confident that you will not use that repository again.</p>

<p>Maybe you are not sure if a repository is active. Listing the repositories on your system will provide the information you need to know if a repository is active:</p>

<pre><code>ppm&gt; <strong>rep</strong>
[1] ActiveState Package Repository
[2] MyRep
[ ] ActiveState PPM2 Repository</code></pre>

<p>If there is not a number assigned to a repository, then it is not active. In this example, the ActiveState PPM2 Repository is still configured on the system but it is not active, so PPM will not search through it. To begin searching it again, all you need to do is to reactivate it:</p>

<pre><code>ppm&gt; <strong>rep on ActiveState PPM2 Repository</strong></code></pre>

<h3>Conclusion</h3>

<p>PPM is a small but useful program for managing Perl modules needed on your systems. It provides a simple command line interface and the capability to customize the way it searches for modules. PPM allowed me to install the modules I needed without relying on Internet access. This led to the creation of an installation package that was truly Internet independent. It also enabled me to create an installation package that was completely automated, requiring no user interaction.</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-850" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/12/client-side-success.html" rel="bookmark">Perl Success Story: Client-Side Collection and Reporting</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Jiann Wang</span> on <abbr class="published" title="2005-12-01T00:00:00-08:00">December  1, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Accurate software inventory management is critical to any organization. Without an accurate software inventory, organizations may either be out of compliance with their vendor licensing agreements or they may be paying extra for licenses that they do not need.</p>

<p>Hitachi Global Storage Technologies (Hitachi GST) formed in 2003 as a result of the strategic combination of Hitachi and IBM's storage technology businesses. The company offers customers worldwide a comprehensive range of hard disk drives for desktop computers, high-performance servers, and mobile devices. With offices and manufacturing facilities spanning the globe, deployment of the corporate business intelligence (BI) tool suite is extensive. The company uses BI tools throughout the business, from manufacturing to sales and warranty operations, for analysis of data that reside in operational data stores and data warehouses. With each new manufacturing site comes requests for additional licenses.</p>

<h3>A Business Intelligence Problem</h3>

<p>To avoid unnecessary spending on licenses, the company needs a detailed assessment of both the number and type of licenses actually deployed at the various sites. We operate in a highly competitive environment in the technology industry and can ill afford to continue purchasing unnecessary licenses. An effort was started to determine how we deploy the current pool of licenses. The initial effort to perform a software inventory for the BI tool involved a manual inventory by each site owner or application owner. As expected, the results returned appear to indicate a significant under-licensing with one of the products from the BI suite. Looking at the raw information sent in by each owner, we had speculated that we double-counted some users and that some users may be misreporting the client that they have installed on their system, thus driving up the license count for the respective product.</p>

<csperl file="grab" domain="on" record="b/1795" template="b/article_sidebar.view">

<p>Based on the preliminary analysis of the information collected, it became evident that we needed to deploy a software inventory tool to assess each workstation and determine what users have actually installed on their machines. The corporate software asset management tool was not a viable option, because it had limited deployment, with some organizations maintaining software inventory using manual methods. The licensing issues of deploying a commercial tool, along with the customizations needed in order to accurately capture the different types of licenses, would be prohibitive from both a time and cost perspective.</p>

<p>In order to generate an accurate license count, the software inventory tool must be able to detect the different types of BI clients that may be installed on a given PC. The release information of each version is also important. We can use this information to determine which users need upgrades to the latest supported release. Our license entitlement limits the number of each type of client from the BI suite that we can deploy across the enterprise. To further complicate matters, there are two different types of client-server tools that use the same binary, with no easy way to distinguish between them by looking at the installed applications listing in Windows. The difference in cost between these two tools is approximately $3,400 per license, so it is imperative that the inventory count is correct for each specific type of client. In addition, a web-based version of the BI tool is available as a plugin. However, the plugin version information is inaccurate in the binary file and the client-server tool version is incomplete in the registry. In preliminary tests of a commercial tool, it was unable to distinguish between the two types of clients and missed the web plugin altogether.</p>

<h3>The Design of a Solution</h3>

<p>Given this challenge, we had to develop a custom solution to address the problem. I had previously used Perl to develop an automated software delivery and installation solution on the Windows platform, and some of what I had already developed was very similar to what we needed. Leveraging this prior experience reduced the amount of time and effort needed for development of the software inventory solution to address our immediate needs.</p>

<p>The solution criteria that we set forth required that the client inventory tool must be relatively compact and not require any installation. The tool also must be a self-contained executable that a user can download and run on their client. If a tool is difficult to use or install, this severely curtails its adoption and use. The user population is spread across multiple locales, including Japan, South Korea, Taiwan, Singapore, Thailand, the United Kingdom, and the United States, so the tool must be simple to understand and must avoid complex procedures.</p>

<p>Each user also needs to authenticate against the corporate LDAP directory to ensure that their results are accurately recorded and ensure the authenticity of the result. In addition, the inventory results must be collected and stored on a central server to ease management of the inventory process. The results must also be readily accessible to all users and owners so they can see where they stand in comparison to what they had originally reported.</p>

<p>The solution involves a client tool and a server-side application. The combination of the two must authenticate the user against the corporate enterprise directory, inventory the client system, log the results, and record the results in a DB2 back-end database. The data stored in the DB2 back-end database is useful for generating both summary and detail reports via the Web. The specific modules used in the development of the solution included <code>Win32::OLE</code>, <code>Win32::GUI</code>, <code>Win32::File::VersionInfo</code>, <code>Win32::TieRegistry</code>, <code>IO::Socket</code>, <code>CGI</code>, <code>DBI</code>, <code>DBD::DB2</code>, and <code>Net::LDAP</code>.</p>













<h3>Building the Client</h3>

<p>Development started with the client component first. Because most end users are averse to command-line tools, we had to develop a GUI of sorts to guide the user through the authentication and inventory steps. In addition, the GUI could display error messages to the user. We used <code>Win32::GUI</code> to create the prompts as well as data entry dialog boxes. The GUI captures the information entered and passes it to the central server using HTTP.</p>

<p>All communications between the client and server use HTTP because coding the client to work directly with the LDAP server and the database server would have made troubleshooting any problems experienced by clients in distant locations inordinately difficult. In a situation such as this, we wanted a single controlled point of failure, as depicted in Figure 1. By using HTTP and a central-server-based application to broker requests, we can isolate problems on the client side to only HTTP-related transport issues.</p>

<p><img src="/pub/2005/12/01/graphics/figure1.gif" width="474" height="205" alt="The authentication process" /><br />
<em>Figure 1. The authentication process</em>
</p>

<p>The user that is running the inventory tool must authenticate first. This is important, as we need to track who has or has not reported their results based on the initial manual inventory information. We use <code>Net::LDAP</code> to perform the authentication against our LDAP server. The application prompts users for their intranet IDs and passwords, and the client passes this information to the server application so that it can issue a bind against the LDAP server. If the information provided by the user does not yield a successful bind, then the client requests that the user reenter his or her login information. Figure 1 depicts this authentication process.</p>

<p>To authenticate a user via LDAP using <code>Net::LDAP</code>, the server uses the user's intranet ID to prepare the distinguished name (DN). The DN is the unique identifier for the user's record in the LDAP directory. In order to perform the initial lookup, the server issues an anonymous bind against the LDAP directory and performs a search using the intranet ID provided. The search returns only the <code>uid</code>, which is the unique record identifier in our implementation of the corporate directory. After the server obtains this, it forms a DN string and issues another bind again using the password provided. If the bind is successful, the return code is undefined and the client proceeds to inventory the system.</p>

<p>Most software applications leave some type of signature in the system registry on a client system, and the BI tool suite deployed at Hitachi GST is no exception. I knew that the software leaves specific signatures when installed on a client system. This information is in the system registry under both the <code>HKEY_LOCAL_MACHINE</code> and <code>HKEY_CURRENT_USER</code> registry entries. We use <code>Win32::TieRegistry</code> to retrieve registry values for determining the type of client that is installed, as well as the binary install location and install key used. <code>Win32::TieRegistry</code> makes it extremely easy to access and modify registry values.</p>

<p>The exact version of the BI client deployed is not accurate in the system registry as we also want to determine the specific point release deployed on the client systems. To achieve this, we use <code>Win32::File::VersionInfo</code> to extract the <code>ProductVersion</code> information from the binary files. Looking at the properties for the file in Windows Explorer for the BI web client binary, we can clearly see that the <code>FileVersion</code> information in the executable is incorrect. We settled on using <code>ProductVersion</code> instead.</p>

<p>In addition to checking the various client versions that may be installed, the tool must also log the client machine serial number. We achieved this by using <code>Win32::OLE</code> and querying information from the <code>Win32_BIOS</code> WMI class. Because some users may have multiple workstations or laptops, we use the machine serial to differentiate multiple entries logged by a single user. The WMI classes yield a wealth of information. Extending the features of this tool simply requires querying additional WMI classes to obtain additional hardware information, such as hard disk, CPU, and memory.</p>

<h3>Deploying the Client</h3>

<p>Once we developed and tested the client code, we had to package the script itself. Not every client machine has Perl installed. Even if they did have Perl installed, there is no guarantee that the appropriate modules needed by the application are available on the target systems. To package the final script into a single executable file, we used PerlApp from ActiveState's PDK to compile the script and the associated modules. This allowed us to neatly package and deploy the client as a single executable that users can run from their client system without performing any type of installation or setup.</p>

<p>When all of the requisite information is collected on the client machine, it passes back to the server which records it on the server's local file system first. This initial logging allows us to capture the client inventory results even if the database server is down. The logged results are easy to import into the database, should there be an unexpected database outage. The <code>CGI</code> module handles the information passed from the client to the server, and <code>DBI</code> and <code>DBD::DB2</code> handle the database connection. DB2 is the RDBMS of choice in our environment, and we were able to leverage an existing DB2 database environment, which further reduced the time to deployment.</p>













<h3>Learning from the Process</h3>

<p>All of this information that we collect is of little use if it is not easily accessible for analysis. We also wrote a script to retrieve and format information from the database and present it via the Web. This allowed users and application owners to see the current inventory status of their users, and also help them to determine which users still need to run the client inventory tool to complete their assessment. The script provides summary, detail, and exception views. With reports available through the Web, users can access it from any web browser, regardless of the user's geographic location. This empowers everyone involved to see the results in near real time.</p>

<p>Upon deployment of the tool, we then recorded and summarized user inventory information automatically. Some interesting results came to light. It became apparent that up to $163,000 worth of additional license purchases were unnecessary, as the existing pool of licenses had not been depleted (as we believed earlier), based on the manual inventory results submitted. Also, with the client inventory tool being an internally developed tool, there were no licensing costs for distributing it at various sites.</p>

<p>The client- and server-side components took two weeks to develop. We formed test cases before writing the code in order to minimize functional issues during final testing in the field, as well as to ensure that we did not overlook critical features and integration issues during the development process. Ultimately, as illustrated in Figure 2, the client and the various server components must work together as an integrated system.</p>

<p><img src="/pub/2005/12/01/graphics/figure2.gif" width="402" height="320" alt="The client and server working together" /><br />
<em>Figure 2. The client and server working together</em>
</p>

<p>The use of virtual machine software was also instrumental for testing and reduced overall development time. It allowed me to simulate client environments and test client code without having to use a physical machine for each version of the BI application. Using undo disks, I was able to return the VMs to a prior state very quickly without manually uninstalling the various BI tools from the VM. We initially tested the inventory tool in Singapore, Japan, and the U.S., and this testing confirmed that the tool was able to perform well even though users were spread across remote geographic locations.</p>

<p>Although we developed this tool for a one-time inventory of the number of BI clients deployed in the field, it also has a role going forward in helping to maintain an accurate picture of the licenses deployed. Possible enhancements include converting the tool so that we can install it as a service to run without user intervention for periodic updates of client inventory data from identified clients, auto-conversion of licensing from one client class to another, and automatic uninstall of clients, should the user decide that he or she no longer needs it. In staying with the near-zero client management paradigm, we can extend the client to contain auto-update features by checking the local version and verifying it against the latest published version on a central server.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-814" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/08/win32guitest.html" rel="bookmark">Automated GUI Testing</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">George Nistorica</span> on <abbr class="published" title="2005-08-11T00:00:00-08:00">August 11, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />

<p>You use Perl at work.  Sometimes you are unhappy because there is one
application you always have to click on and fill all those input boxes.  It's
very boring.  Why not let Perl do that while you go grab a coffee?  Also, maybe
you sometimes feel frustrated that you need to start that nice app and want
someone else type in for you.  Let Perl do that, too.</p>

<h3>Why Perl?</h3>

<p>Simply put: because you like Perl.</p>

<p>The long story is that there are all sorts of software packages that you may use to
automate graphical applications. Are they really good fits for what you want to
do?</p>

<p>Windows has many libraries that help you automate such things, but
do the applications you use support those automation libraries?  Too many do
not. Moreover, is this enough for you to say you have tested a certain GUI
feature? If not, read on.</p>

<h3>What You Need</h3>

<p>You need a working installation of Perl, with Perl/Tk included.  I recommend
<a href="http://www.activestate.com/">ActiveState</a>'s ActivePerl.  You also
need the <a
href="http://search.cpan.org/dist/Win32-GuiTest/">Win32::GuiTest</a> module.
Install it from the CPAN or, ideally, through PPM.</p>

<h3>Example Code</h3>
<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1796" template="b/article_sidebar.view">
<!-- sidebar ends -->
<p>Download the <a href="/2005/08/11/examples/tester.pl"><i>tester.pl</i></a> and the
<a href="/2005/08/11/examples/tested.pl"><i>tested.pl</i></a> programs. They 
need to both be in the same directory. First run the <i>tested.pl</i>
program in order to see the windows it has and how it looks. The program does
nothing by itself; it just serves as a &quot;run&quot; application.
<i>tester.pl</i> is more interesting.  It spawns <i>tested.pl</i>
and starts sending it input (mouse moves, mouse clicks, and keystrokes).</p>

<p>I tested these two programs on Windows 2000 Professional and Windows XP Home
Edition using ActiveState's distribution of Perl.</p>

<p>The <i>tested.pl</i> program is just a dummy GUI used to demonstrate
the examples.  It uses Tk, so although it is a Win32 GUI, it isn't a native
one. This has the effect that not all of the functions you can use with
Win32::GuiTest will work as you would expect them to work against a native
Win32 GUI.  Fortunately, there are workarounds.</p>

<h3>A Few Words About Windows</h3>

<p>Graphical user interfaces manage windows. Windows are just reusable objects
with which users can interact. Almost all GUIs have more than just one window.
I use &quot;window&quot; just as a generic term for any graphical object that an
application may produce. This means that &quot;window&quot; is an abstract term
after all.</p>

<p>Windows have common elements that you need to consider before writing a
program that interacts with a GUI.</p>

<ul>

<li>Each window belongs to a window class (making it possible to search them by
class).</li>

<li>Windows have an organizational hierarchy; every GUI has at least one root
window, and every window may have child windows. Windows form a tree. This
makes them searchable (by class or not) in depth: start from a root window and
search among its siblings.</li>

<li>Some windows have text attached to them. This is useful to identify
windows.</li>

<li>Windows have an numeric ID that uniquely identifies them.</li>

</ul>

<p>This means that you can identify windows by any of their text, class, and
parent window attributes. You can also pinpoint a window by its ID.</p>

<h3>Finding Windows</h3>

<p>When testing a GUI, first make sure the application you want to test has
started. To do this, use the Win32::GuiTest exported function named
<code>FindWindowLike()</code>.  Remember that hierarchy of Windows?  If you
search for an <em>Edit</em> window, you may find it in the wrong place. That
There can be multiple different GUIs started that <em>have</em> editor windows.
There should be a way to differentiate between these hypothetical editor windows--and the hierarchical organization of windows helps.</p>

<p>First look for the main window of the application, and then 
descend the hierarchy (that you have to know beforehand) until you reach the desired window.</p>

<p>How can you know the windows hierarchy? There are two main ways.  If you
have written the GUI yourself or have access to its sources and have enough
experience, you may find out what the hierarchy of windows is.  Unfortunately,
that's quite tricky and prone to error.</p>

<p>Another much simpler way to do this on Windows platforms is to use the free
<a href="http://www.catch22.net/software/winspy.asp">WinSpy++</a> program.
Basically, it allows you to <a
href="http://www.piotrkaluski.com/files/winguitest/docs/ch02.html">peek at an
application's window structure</a>.</p>

<p>When you use WinSpy++ to look at an application windowing structure, you
will notice that every window has a numeric handle, expressed in hex.  However,
Perl expresses in decimal.  This will come up again in a moment.</p>













<p>The syntax for <code>FindWindowLike</code> is:
<code>FindWindowLike($window,$titleregex,$classregex,$childid,
  $maxlevel)</code>.
It returns a list of found windows. The parameters are:</p>

<ul>

<li><p><code>$window</code></p>

<p>This is the (numeric) handle of the parent window to search under (remember
the hierarchical organization of windows in a GUI).  You may use <em>undef</em>
in order to search for all windows.</p>

<p><em>$window</em> should be a decimal value, so if you know the window's hex
handle (as displayed by WinSpy++) you need to convert it.</p></li>

<li><p><code>$titleregex</code></p>

<p>This is the most often used parameter. It is a regular expression for
<code>FindWindowLike</code> to match against window titles to find the
appropriate window(s).</p></li>

<li><p><code>$classregex</code></p> 

<p>This matches against a window class.  Suppose that you want to find all
buttons in an application. Use the function like this:</p>

<pre><code>my @windows = FindWindowLike(undef,&quot;&quot;,&quot;Button&quot;);</code></pre>

<p><code>Note:</code> if you don't care what the class of the window is, do not
omit the <code>$classregex</code> parameter.  Instead, use an empty string.</p>
Currently the <code>FindWindowLike()</code> function does not check if
<code>$classregex</code> is undefined, so you will end up with a lot of Perl
warnings.</p></li>

<li><p><code>$childid</code></p>

<p>If you pass this argument, then the function will match all windows with
this ID.</p></li>

<li><p><code>$maxlevel</code></p>

<p>Maximum depth level to match windows.</p></li>

</ul>

<p>As you may have noticed, the <code>tested</code> program has a title that
matches the string &quot;Tested&quot;. Thus, the <code>tester</code> starts by searching
windows matching this title:</p>

<pre><code>@windows = FindWindowLike( undef, &quot;Tested&quot;, &quot;&quot; );</code></pre>

<p><em>@windows</em> will contain a list of window IDs that have a title
matching the string. The point here is that you probably don't want the
<code>tested</code> program to start more than once simultaneously.</p>

<pre><code>if ( @windows &gt; 1 ) {
     print &quot;* The \&quot;tested\&quot; program is started more than once!\n&quot;;
     ...
 }</code></pre>

<p>If there is no <code>tested</code> application already running, the program
can start it and repeat the procedure, searching for windows that match our
criteria (they contain the string &quot;Tested&quot; in their titles). If it's running just
once, its ID is <code>$windows[0]</code>. In fact, this is the root window of
the application.</p>

<p>There's no point in going further with the program if the GUI hasn't
started, so the code checks this:</p>

<pre><code>unless ( @windows ) {
     print &quot;* The program hasn't started!\n&quot;;
     exit 1;
 }</code></pre>

<h3>Setting a Specific Window to Foreground</h3>

<p>Finding a window is sometimes not enough. Often, you need to send some input
to the window. Obviously, the window should be in the foreground.  The
appropriate functions are <code>SetActiveWindow()</code> and
<code>SetForegroundWindow()</code>.</p>

<p>Because of the way windows work under Win32, this may be trickier than it
seems.  Basically, if the caller is not in the foreground, it can not give
another window &quot;focus.&quot;  MSDN explains this in the documentation of the <a
href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/setforegroundwindow.asp"><code>SetForegroundWindow</code></a>
and <a
href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/setactivewindow.asp"><code>SetActiveWindow</code></a>
functions.</p>

<p>While this behavior is easy to explain if you consider that you usually
don't want applications that run in background to be able to annoy you (at
least) by grabbing focus, there is at least one drawback. If you are
running  a GUI (perhaps remotely) to which you will send sensitive input for
some reason, you may send those secrets to another, possibly malicious,
application if the tested application does not have focus!</p>

<p>Another problem is in running tester programs remotely, or at regular
intervals. Suppose that your tester program spawns the tested program, then
starts sending it events (mouse events and/or keystrokes). If the computer is
in a &quot;locked&quot; state, according to Microsoft documentation, no application can
be in the foreground. You may have unexpected results.</p>

<p>If the GUI you are automating receives sensitive input (such as passwords),
you have to find a means to &quot;isolate&quot; that machine's input/output devices, such
as keyboard/mouse/monitor, so that no one unauthorized can peek at what your
Perl program is typing in.  Good luck.</p>

<p>In my opinion, every time you send input to a GUI, the Win32::GuiTest
program should check if the application is in the foreground. If it isn't, it
should try to bring it to the front. If it can't do that, it should fail and
not continue.</p>













<p>Here's a sample routine that <i>tester.pl</i> uses:</p>

<pre><code> sub bring_window_to_front {
     my $window  = shift;
     my $success = 1;

     if ( SetActiveWindow($window) ) {
         print &quot;* Successfully set the window id: $window active\n&quot;;
     }
     else {
         print &quot;* Could not set the window id: $window active\n&quot;;
         $success = 0;
     }
     if ( SetForegroundWindow($window) ) {
         print &quot;* Window id: $window brought to foreground\n&quot;;
     }
     else {
         print &quot;* Window id: $window could not be brought to foreground\n&quot;;
         $success = 0;
     }

     return $success;
 }</code></pre>

<p>In case you don't want to bring a window to front but expect it to be in
front, use <code>GetForegroundWindow()</code>. That way, you can just check the
return value with a window ID and find out if it is in front.</p>

<h3>Key Pressing</h3>

<p>You have found your window and have made sure that it has focus.  What
next?</p>

<p>It's time to send data to the window.  This is the purpose of the
<code>SendKeys()</code> function.  You can send to an application not only
basic keypresses, but combinations of keys too. Here's an example from the
<i>tester.pl</i> program:</p>

<pre><code>my @keys = ( &quot;%{F}&quot;, &quot;{RIGHT}&quot;, &quot;E&quot;, );
for my $key (@keys) {
    SendKeys( $key, $pause_between_keypress );
}</code></pre>

<p>The code starts with an array containing the keypresses. Note the format of
the first three elements. The keypresses are: <code>Alt</code>+<code>F</code>, right arrow, and <code>E</code>.  With the
application open, this navigates the menu in order to open the editor.</p>

<p>For a full listing of &quot;special&quot; keystrokes or combinations of keys, consult
the function's documentation.</p>

<h3>Finding Text in Your Application</h3>

<p>You may want to learn how you can &quot;read&quot; text written in GUI windows.
Unfortunately, you can't read everything.  You <em>can</em> read the text
written in the title of windows (useful for identifying a window by its
title).  You can also read text in <code>Edit</code> class windows; for example, the part of
Internet Explorer where you type in a URL, or the list items in a <code>ListBox</code>. There
may be other window classes from where you can fetch text; just verify with
WinSpy++ whether you can &quot;read&quot; from a window, before writing your program, in order
to avoid frustration.</p>

<p>Remember that you can't (at least now) read everything written in a
window. Maybe a future version of Win32::GuiTest will provide a means by which
to fetch text from a window, no matter what class that window is.   In my humble
opinion, it would be an awesome feature.</p>

<p>The two functions useful for grabbing text are <code>GetWindowText()</code>
and <code>WMGetText()</code>.  Both take as a parameter the window ID:</p>

<pre><code>$text = GetWindowText($window);
$text = WMGetText($window);</code></pre>

<h3>Pushing Buttons</h3>

<p>Pushing buttons can be tricky. The syntax is
<code>PushButton($button[,$delay])</code>, and the variable
<code>$button</code> can be either the text of the button (its caption) or the
button ID.  As Piotr Kaluski points out in "<a
href="http://www.piotrkaluski.com/files/automation/gui/carfl_pushcb.html">Be
Careful with <code>PushChildButton</code></a>," you sometimes want to specify a button ID,
but instead the function matches a button having text like the one you used in
the regexp.  He posted <a
href="http://groups.yahoo.com/group/perlguitest/message/876?threaded=1">a patch
to the <i>perlguitest</i> mailing list</a>.</p>

<p>Also note that when using Tk, as I do in this example, you can't identify
buttons by their text--you need to use their IDs (if you know them).  With
native Win32 applications, you can identify buttons by their text. To check the
differences, use WinSpy++ to look at a Tk button's caption and a native
Win32 button's caption.</p>

<p>Although <code>PushButton()</code> works fine on native Win32 buttons, I
couldn't make it work on my Tk application, so in <i>tester.pl</i>, I
use a trick in the <code>push_button()</code> subroutine:</p>

<pre><code>sub push_button {
    my $parent_window_title = shift;
    my @button;
    my @window;

    SendKeys(&quot;%{F}&quot;);
    SendKeys(&quot;O&quot;);
    sleep 1;

    @window = FindWindowLike( undef, $parent_window_title, &quot;&quot; );

    if ( !bring_window_to_front( $window[0] ) ) {
        print &quot;* Could not bring to front $window[0]\n&quot;;
    }

    @button = FindWindowLike( $window[0], &quot;&quot;, &quot;Button&quot; );
    sleep 1;

    print &quot;* Trying to push button id: $button[0]\n&quot;;
    PushChildButton( $window[0], $button[0], 0.25 );
    sleep 1;

    click_on_the_middle_of_window( $button[0] );
}</code></pre>

<p>Notice that the function depends on the <i>tested.pl</i> application,
as it has hard-coded the way to spawn the <code>Button</code> window (by
navigating the menu using keystrokes). It is easy to adapt it to be more
flexible and to be less coupled with the rest of the code.</p>













<p>After sending the right combination of keys (<code>Alt</code>+<code>F</code>, <code>O</code>), the code expects
that the window containing the <code>Button</code> will pop up.  Then it uses
<code>FindWindowLike()</code> again, using as a search item the title of the
window containing the button (in this case, <code>here</code>). Remember what I said
about the windows hierarchy?</p>

<p>Next, it ensures that the <code>Button</code> window has the focus, although this is not
entirely necessary at this point.  After bringing the window to the front, the code
searches for a button in the window (I already know that there's only one
button there).</p>

<pre><code>@button = FindWindowLike( $window[0], &quot;&quot;, &quot;Button&quot; );</code></pre>

<p>This narrows down the search: &quot;Search for a window of the class
<code>Button</code> under the window that has the ID <code>$window[0]</code>,&quot;
the window having the ID in <code>$window[0]</code> having been previously found by
its title.</p>

<pre><code>PushChildButton( $window[0], $button[0], 0.25 );</code></pre>

<p>is here just for the power of example, as it doesn't work for the Tk button.
It would work for a native Win32 button.</p>

<p>The trick is that the code can still push it using the mouse! Having the
button ID, as returned by <code>FindWindowLike()</code>, the code calls the
<code>click_on_the_middle_of_window</code> function.</p>

<pre><code>sub click_on_the_middle_of_window {
    my $window = shift;
 
    print &quot;* Moving the mouse over the window id: $window\n&quot;;
 
    my ( $left, $top, $right, $bottom ) = GetWindowRect($window);
 
    MouseMoveAbsPix( ( $right + $left ) / 2, ( $top + $bottom ) / 2 );
 
    sleep(1);
 
    print &quot;* Left Clicking on the window id: $window\n&quot;;
    SendMouse(&quot;{LeftClick}&quot;);
    sleep(1);
}</code></pre>

<p>The function takes a window ID as its parameter, searches its rectangle
using <code>GetWindowRect()</code>, and then moves the mouse pointer right in the
middle of it with <code>MouseMoveAbsPix()</code>.</p>

<p>With the pointer over the button, sending <code>LeftClick</code> presses the
button.</p>

<h3>Moving Around with the Mouse</h3>

<p>As seen earlier, moving the mouse is straightforward: just use
<code>MouseMoveAbsPix()</code>. It takes as parameters the coordinates where
you want the pointer to be (horizontal and vertical positions) in pixels.</p>

<p>It is useful to use other two functions in conjunction:
<code>SendMouse()</code> and <code>GetWindowRect()</code>.</p>

<p><code>SendMouse</code> sends a mouse action to the <code>Desktop</code>. It takes only
one parameter: a mouse action such as <code>{LeftDown}</code>,
<code>{LeftUp}</code>, or <code>{LeftClick}</code>. For more details, see the
function's documentation.</p>

<p>You can also move the mouse wheel using <code>MouseMoveWheel()</code>. It
takes a positive or a negative argument, indicating the direction of the
motion.</p>

<p>To send an action, you need to know where we send it. Usually you will move
the mouse pointer over a window. <code>GetWindowRect()</code> is useful to find the
coordinates of a window.</p>

<p>It can be simpler to create a wrapper around these three functions in order
to move the mouse pointer over a selected window, and then generate a mouse action, as I did
with <code>click_on_the_middle_of_window()</code>.</p>

<h3>Further Reading</h3>

<p>Here are some links you may find useful.</p>

<ul>

<li><a href="http://search.cpan.org/perldoc?Win32::GuiTest">Win32::GuiTest
documentation</a></li>

<li><a
href="http://search.cpan.org/perldoc?Win32::GuiTest::Examples">Win32::GuiTest::Examples</a></li>

<li>The <a href="http://groups.yahoo.com/group/perlguitest/">PerlGuiTest group</a>
on Yahoo; this is quite an active group.</li>

<li><a
href="http://www.piotrkaluski.com/files/winguitest/docs/index.html">Win32::GuiTest
extended tutorial</a></li>

</ul>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/webcgi/">&laquo; Web/CGI</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/xml/">XML &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
