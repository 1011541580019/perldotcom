<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Web Development Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Web Development</em> Category</h1>






                            
                            <div id="entry-644" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2008/04/using-amazon-s3-from-perl.html" rel="bookmark">Using Amazon S3 from Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Abel Lin</span> on <abbr class="published" title="2008-04-08T00:00:00-08:00">April  8, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Data management is a critical and challenging aspect for any online resource. With exponentially growing data sizes and popularity of rich media, even small online resources must effectively manage and distribute a significant amount of data. Moreover, the peace of mind associated with an additional offsite data storage resource is invaluable to everyone involved.</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a>, we manage a growing inventory of GPS and general GIS (Geography Information Systems) data and web content (text, images, videos, etc.) for the end users. In addition, we must also effectively manage daily snapshots, backups, as well as multiple development versions of our web site and supporting software. For any small organization, this can add up to significant costs -- not only as an initial monetary investment but also in terms of ongoing labor costs for maintenance and administration.</p>

<p>Amazon Simple Storage Service (S3) was released specifically to address the problem of data management for online resources -- with the aim to provide "reliable, fast, inexpensive data storage infrastructure that Amazon uses to run its own global network of web sites." Amazon S3 provides a web service interface that allows developers to store and retrieve any amount of data. S3 is attractive to companies like SundayMorningRides.com as it frees us from upfront costs and the ongoing costs of purchasing, administration, maintenance, and scaling our own storage servers.</p>

<p>This article covers the Perl, REST, and the Amazon S3 REST module, walking through the development of a collection of Perl-based tools for UNIX command-line based interaction to Amazon S3. I'll also show how to set access permissions so that you can serve images or other data directly to your site from Amazon S3.</p>

<h4>A Bit on Web Services</h4>

<p>Web services have become the de-facto method of exposing information and, well, services via the Web. Intrinsically, web services provide a means of interaction between two networked resources. Amazon S3 is accessible via both Simple Object Access Protocol (SOAP) or representational state transfer (REST).</p>

<p>The SOAP interface organizes features into custom-built operations, similar to remote objects when using Java Remote Method Invocation (RMI) or Common Object Resource Broker Architecture (CORBA). Unlike RMI or CORBA, SOAP uses XML embedded in the body of HTTP requests as the application protocol.</p>

<p>Like SOAP, REST also uses HTTP for transport. Unlike SOAP, REST operations are the standard HTTP operations -- GET, POST, PUT, and DELETE. I think of REST operations in terms of the CRUD semantics associated with relational databases: POST is Create, GET is Retrieve, PUT is Update, and DELETE is Delete.</p>

<h4>"Storage for the Internet"</h4>

<p>Amazon S3 represents the data space in three core concepts: <em>objects</em>, <em>buckets</em>, and <em>keys</em>.</p>

<ul>
<li>Objects are the base level entities within Amazon S3. They consist of both object data and metadata. This metadata is a set of name-attribute pairs defined in the HTTP header.</li>

<li>Buckets are collections of objects. There is no limit to the number of objects in a bucket, but each developer is limited to 100 buckets.</li>

<li>Keys are unique identifiers for objects.</li>
</ul>

<p>Without wading through the details, I tend think of buckets as folders, objects as files, and keys as filenames. The purpose of this abstraction is to create a unique HTTP namespace for every object.</p>

<p>I'll assume that you have already signed up for <a href="http://aws.amazon.com/s3">Amazon S3</a> and received your Access Key ID and Secret Access Key. If not, please do so.</p>

<p>Please note that the <code>S3::*</code> modules aren't the only Perl modules available for connecting to Amazon S3.  In particular, <a href="http://search.cpan.org/perldoc?Net::Amazon::S3">Net::Amazon::S3</a> hides a lot of the details of the S3 service for you.  For now, I'm going to use a simpler module to explain how the service works internally.</p>

<h4>Connecting, Creating, and Listing Buckets</h4>

<p>Connecting to Amazon S3 is as simple as supplying your Access Key ID and your Secret Access Key to create a connection, called here <code>$conn</code>. Here's how to create and list the contents of a bucket as well as list all buckets.</p>

<pre><code>#!/usr/bin/perl

use S3::AWSAuthConnection;
use S3::QueryStringAuthGenerator;

use Data::Dumper;

my $AWS_ACCESS_KEY_ID     = 'YOUR ACCESS KEY';
my $AWS_SECRET_ACCESS_KEY = 'YOUR SECRET KEY';

my $conn = S3::AWSAuthConnection-&gt;new($AWS_ACCESS_KEY_ID,
                                      $AWS_SECRET_ACCESS_KEY);

my $BUCKET = "foo";

print "creating bucket $BUCKET \n";
print $conn-&gt;create_bucket($BUCKET)-&gt;message, "\n";

print "listing bucket $BUCKET \n";
print Dumper @{$conn-&gt;list_bucket($BUCKET)-&gt;entries}, "\n";

print "listing all my buckets \n";
print Dumper @{$conn-&gt;list_all_my_buckets()-&gt;entries}, "\n";</code></pre>

<p>Because every S3 action takes place over HTTP, it is good practice to check for a 200 response.</p>

<pre><code>my $response = $conn-&gt;create_bucket($BUCKET);
if ($response-&gt;http_response-&gt;code == 200) {
    # Good
} else {
    # Not Good
}</code></pre>

<p>As you can see from the output, the results come back in a hash. I've used <a href="http://search.cpan.org/perldoc?Data::Dumper">Data::Dumper</a> as a convenient way to view the contents. If you are running this for the first time, you will obviously not see anything listed in the bucket.</p>

<pre><code>listing bucket foo
$VAR1 = {
          'Owner' =&gt; {
                     'ID' =&gt; 'xxxxx',
                     'DisplayName' =&gt; 'xxxxx'
                   },
          'Size' =&gt; '66810',
          'ETag' =&gt; '"xxxxx"',
          'StorageClass' =&gt; 'STANDARD',
          'Key' =&gt; 'key',
          'LastModified' =&gt; '2007-12-18T22:08:09.000Z'
        };
$VAR4 = '
';
listing all my buckets
$VAR1 = {
          'CreationDate' =&gt; '2007-11-28T17:31:48.000Z',
          'Name' =&gt; 'foo'
        };
';</code></pre>













<h4>Writing an Object</h4>

<p>Writing an object is simply a matter of using the HTTP PUT method. Be aware that there is nothing to prevent you from overwriting an existing object; Amazon S3 will automatically update the object with the more recent write request. Also, it's currently not possible to append to or otherwise modify an object in place without replacing it.</p>

<pre><code>my %headers = (
    'Content-Type' =&gt; 'text/plain'
);
$response = $conn-&gt;put( $BUCKET, $KEY, S3Object-&gt;new("this is a test"),
                        \%headers);</code></pre>

<p>Likewise, you can read a file from STDIN:</p>

<pre><code>my %headers;

FILE: while(1) {
    my $n = sysread(STDIN, $data, 1024 * 1024, length($data));
    if ($n &lt; 0) {
        print STDERR "Error reading input: $!\n";
        exit 1;
    }
    last FILE if $n == 0;
}
$response = $conn-&gt;put("$BUCKET", "$KEY", $data, \%headers);</code></pre>

<p>To add custom metadata, simply add to the <code>S3Object</code>:</p>

<pre><code>S3Object-&gt;new("this is a test", { name =&gt; "attribute" })</code></pre>

<p>By default, every object has private access control when written. This allows only the user that stored the object to read it back. You can change these settings. Also, note that each object can hold a maximum of 5 GB of data.</p>

<p>You are probably wondering if it is also possible to upload via a standard HTTP POST. The folks at Amazon are working on it as we speak -- see <a href="http://developer.amazonwebservices.com/connect/thread.jspa?threadID=18616&amp;tstart=0">HTTP POST beta discussion</a> for more information. Until that's finished, you'll have to perform web-based uploads via an intermediate server.</p>

<h4>Reading an Object</h4>

<p>Like writing objects, there are several ways to read data from Amazon S3. One way is to generate a temporary URL to use with your favorite client (for example, wget or Curl) or even a browser to view or retrieve the object. All you have to do is generate the URL used to make the REST call.</p>

<pre><code>my $generator = S3::QueryStringAuthGenerator-&gt;new($AWS_ACCESS_KEY_ID,
    $AWS_SECRET_ACCESS_KEY);</code></pre>

<p>...and then perform a simple HTTP GET request. This is a great trick if all you want to do is temporarily view or verify the data.</p>

<pre><code>$generator-&gt;expires_in(60);
my $url = $generator-&gt;get($BUCKET, "$KEY");
print "$url \n";</code></pre>

<p>You can also programmatically read the data directly from the initial connection. This is handy if you have to perform additional processing of the data.</p>

<pre><code>my $response = $conn-&gt;get("$BUCKET", "$KEY");
my $data     = $response-&gt;object-&gt;data;</code></pre>

<p>Another cool feature is <a href="http://docs.amazonwebservices.com/AmazonS3/2006-03-01/">the ability to use BitTorrent to download files from Amazon S3</a> . You can access any object that has anonymous access privileges via BitTorrent.</p>

<h4>Delete an Object</h4>

<p>By now you probably have the hang of the process. If you're going to create objects, you're probably going to have to delete them at some point.</p>

<pre><code>$conn-&gt;delete("$BUCKET", "$KEY");</code></pre>

<h4>Set Access Permissions and Publish to a Website</h4>

<p>As you may have noticed from the previous examples, all Amazon S3 objects access goes through HTTP. This makes Amazon S3 particularly useful as a online repository. In particular, it's useful to manage and serve website media. You could almost imagine Amazon S3 serving as mini Content Delivery Network for media on your website. This example will demonstrate how to build a very simple online page where the images are served dynamically via Amazon S3.</p>

<p>The first thing to do us to upload some images and set the ACL permissions to public. I've modified the previous example with one difference. To make objects publicly readable, include the header <code>x-amz-acl: public-read</code> with the HTTP PUT request.</p>

<pre><code>my %headers = (
    'x-amz-acl' =&gt; 'public-read',
);</code></pre>

<p>Additional ACL permissions include:</p>

<ul>
<li>private (default setting if left blank)</li>

<li>public-read</li>

<li>public-read-write</li>

<li>authenticated-read</li>
</ul>

<p>Now you know enough to put together a small script that will automatically display all images in the bucket to a web page (you'll probably want to spruce up the formatting).</p>

<pre><code>...
my $BUCKET   = "foobar";
my $response = $conn-&gt;list_bucket("$BUCKET");

for my $entry (@{$response-&gt;entries}) {
    my $public_url   = $generator-&gt;get($BUCKET, $entry-&gt;{Key});
    my ($url, undef) = split (/\?/, $public_url);
    $images         .= "&lt;img src=\"$url\"&gt;&lt;br /&gt;";
}
($webpage =  &lt;&lt;"WEBPAGE");
&lt;html&gt;&lt;body&gt;$images&lt;/body&gt;&lt;/html&gt;
WEBPAGE
print $q-&gt;header();
print $webpage;</code></pre>

<p>To add images to this web page, upload more files into the bucket and they will automatically appear the next time you load the page.</p>

<p>It's also simple to link to media one at a time for a webpage. If you examine the HTML generated by this example, you'll see that all Amazon S3 URLs have the basic form <code>http://<em>bucketname</em>.s3.amazon.com/<em>objectname</em></code>. Also note that the namespace for buckets is shared with all Amazon S3 users. You may have already picked up on this.</p>

<h3>Conclusion</h3>

<p>Amazon S3 is a great tool that can help with the data management needs of all sized organizations by offering cheap and unlimited storage. For personal use, it's a great tool for backups (also good for organizations) and general file storage. It's also a great tool for collaboration. Instead of emailing files around, just upload a file and set the proper access controls -- no more dealing with 10 MB attachment restrictions!</p>

<p>At <a href="http://www.sundaymorningrides.com/">SundayMorningRides.com</a> we use S3 as part of our web serving infrastructure to reduce the load on our hardware when serving media content.</p>

<p>When combined with other Amazon Web Services such as SimpleDB (for structured data queries) and Elastic Compute Cloud (for data processing) it's easy to envision a low cost solution for web-scale computing and data management.</p>

<h4>More Resources and References</h4>

<ul>
<li><a href="http://aws.amazon.com/s3">Amazon S3 Homepage</a>
</li>

<li><a href="http://developer.amazonwebservices.com/">Amazon Webservices Developer Connection</a>
</li>

<li><a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=133&amp;categoryID=47">Amazon S3 Library for REST in Perl</a>
</li>

<li><a href="http://aws.typepad.com/">Amazon Web Services Blog</a>
</li>
</ul>





        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-642" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2008/03/reverse-callback-templating.html" rel="bookmark">Reverse Callback Templating</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">James Robson</span> on <abbr class="published" title="2008-03-14T00:00:00-08:00">March 14, 2008 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>Programmers have long recognized that separating code logic from presentation is good. The Perl community has produced many fine systems for doing just this. While there are many systems, they largely fall within two execution models, <em>pipeline</em> and <em>callback</em> (as noted by Perrin Harkins in <a href="/pub/a/2001/08/21/templating.html">Choosing a Templating System</a>). <a href="http://search.cpan.org/perldoc?HTML::Template">HTML::Template</a> and <a href="http://www.template-toolkit.org/">Template Toolkit</a> are in the pipeline category. Their templates consist of simple presentation logic in the form of loops and conditionals and template variables. The Perl program does its work, then loads and renders the appropriate template, as if data were flowing through a pipeline. <a href="http://www.masonhq.com/">Mason</a> and <a href="http://perl.apache.org/embperl/">Embperl</a> fall into the callback category. They mix code in with the template markup, and the template "calls back" to Perl when it encounters program logic.</p>

<p>A third execution model exists: the <em>reverse callback</em> model. Template and code files are separate, just like in the pipeline approach. Instead of using a mini-language to handle display logic, however, the template consists of named sections. Perl executes and calls a specific section of the template at the appropriate time, rendering it. Effectively, this is the opposite of the callback method, which wraps Perl logic around portions (or sections) of a template in a single file. Reverse callback uses Perl statements to load, or call, specific portions of the the template. This approach has a few distinct advantages.</p>

<h3>A Reverse Callback Example</h3>

<p>Suppose that you have a simple data structure you are dying to output as pretty HTML.</p>

<pre><code>my @goods = (
    "oxfords,Brown leather,\$85,0",
    "hiking,All sizes,\$55,7",
    "tennis shoes,Women's sizes,\$35,15",
    "flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>First, you need an HTML template with the appropriate sections defined. Sections are of vital importance; they enable <code>Template::Recall</code> to keep the logic squarely in the code. <code>Template::Recall</code> uses the default pattern <code>/[\s*=+\s*\w+\s*=+\s*]/</code> (to match, for example, <code>[==== section_name ====]</code>) to determine sections in a single file. The start of one section denotes the end of another. This is because <code>Template::Recall</code> uses a <code>split()</code> operation based on the above regex, saving the <code>\w+</code> as the section key in an internal data structure.</p>

<pre><code>[ =================== header ===================]

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;my site - [' title ']&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h4&gt;The date is [' date ']&lt;/h4&gt;



&lt;table border="1"&gt;

    &lt;tr&gt;
        &lt;th&gt;Shoe&lt;/th&gt;
        &lt;th&gt;Details&lt;/th&gt;
        &lt;th&gt;Price&lt;/th&gt;
        &lt;th&gt;Quantity&lt;/th&gt;
    &lt;/tr&gt;

[ =================== product_row =================== ]
    &lt;tr&gt;
        &lt;td&gt;[' shoe ']&lt;/td&gt;
        &lt;td&gt;[' details ']&lt;/td&gt;
        &lt;td&gt;[' price ']&lt;/td&gt;
        &lt;td&gt;[' quantity ']&lt;/td&gt;
    &lt;/tr&gt;


[= footer =]
&lt;/table&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This template is quite simple. It has three sections, a "header," "product_row," and "footer." The sections essentially give away how the program logic is going to work. A driver program would call header and footer only once during program execution (start and end, respectively). product_row will be called multiple times during iteration over an array.</p>

<p>Names contained within the delimeters <code>['</code> and <code>']</code> are template variables for replacement during rendering. For example, <code>[' date ']</code> will be replaced by the current date when the program executes.</p>

<p>The driver code must first instantiate a new Template::Recall object, <code>$tr</code>, and pass it the path of the template, which I've saved as the file <em>template1.html</em>.</p>

<pre><code>use Template::Recall;

my $tr = Template::Recall-&gt;new( template_path =&gt; 'template1.html');</code></pre>

<p>With <code>$tr</code> created, the template sections are loaded and ready for use. The obvious first step is to render the header section with the <code>render()</code> method. <code>render()</code> takes the name of the section to process, and optionally, a hash of names and values to replace in that section. There are two template variables in the header section, <code>[' title ']</code> and <code>[' date ']</code>, so the call looks like:</p>

<pre><code>print $tr-&gt;render( 'header', { title =&gt; 'MyStore', date =&gt; scalar(localtime) } );</code></pre>

<p>The names used in the hash must match the names of the template variables in the section you intend to render. For example, <code>date =&gt; scalar(localtime)</code> means that <code>[' date ']</code> in the header section will be dynamically replaced by the value produced by <code>scalar(localtime)</code>.</p>

<p>You probably noticed from the template that the header section created the start of an HTML table. This is a fine time to render <code>@goods</code> as the table's rows.</p>

<pre><code>for my $good (@goods)
{
    my @attr     = split(/,/, $good);
    my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];

    my %row      = (
        shoe     =&gt; $attr[0],
        details  =&gt; $attr[1],
        price    =&gt; $attr[2],
        quantity =&gt; $quantity,
    );

    print $tr-&gt;render('product_row', \%row);
}</code></pre>

<p>In actual code, this array would likely come from a database. For each row, the driver makes necessary logical decisions (such as displaying "Out of stock" if the quantity equals "0"), then calls <code>$tr-&gt;render()</code> to replace the placeholders in the template section with the values from <code>%row</code>.</p>

<p>Finally, the driver renders the footer of the HTML output. There are no template variables to replace, so there's no need to pass in a hash.</p>

<pre><code>print $tr-&gt;render('footer');</code></pre>

<p>The result is this nice little output of footwear inventory:</p>

<h4>The date is Fri Aug 10 14:22:30 2007</h4>

<table>
<tr>
<th>Shoe</th>
<th>Details</th>
<th>Price</th>
<th>Quantity</th>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>
</table>

<h3>The Logic Is in the Code</h3>

<p>What happens if you extend your shoe data slightly, to add categories? For instance, what if <code>@goods</code> looks like:</p>

<pre><code>my @goods = (
    "dress,oxfords,Brown leather,\$85,0",
    "sports,hiking,All sizes,\$55,7",
    "sports,tennis shoes,Women's sizes,\$35,15",
    "recreation,flip flops,Colors of the rainbow,\$7,90"
    );</code></pre>

<p>The output now needs grouping, which implies the use of nested loops. One loop can output the category header -- sports, dress, or recreation shoes -- and another will output the details of each shoe in that category.</p>

<p>To handle this in HTML::Template, you would generally build a nested data structure of anonymous arrays and hashes, and then process it against nested <code>&lt;TMPL_LOOP&gt;</code> directives in the template. Template::Recall logic remains in the code, you would build a nested loop structure in Perl that calls the appropriate sections. You can also use a hash to render the category sections as keys and detail sections as values in a single pass, and output them together using <code>join</code>.</p>

<p>The template needs some modification:</p>

<pre><code>[====== table_start ====]
&lt;table border="1"&gt;
[====== category =======]
&lt;tr&gt;&lt;td colspan="4"&gt;&lt;b&gt;['category']&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
[====== detail ======]
&lt;tr&gt;&lt;td&gt;['shoe']&lt;/td&gt;&lt;td&gt;['detail']&lt;/td&gt;&lt;td&gt;['price']&lt;/td&gt;&lt;td&gt;['quantity']&lt;/td&gt;&lt;/tr&gt;
[======= table_end ====]
&lt;/table&gt;</code></pre>

<p>This template now has a section called "category," a single table row that spans all columns. The "detail" section is pretty much the same as in the previous.</p>

<pre><code>my %inventory;

for my $good (@goods) {
    my @attr = split(/,/, $good);
    my $q    = $attr[4] == 0 ? 'Out of stock' : $attr[4];

    $inventory{ $tr-&gt;render('category', { category =&gt; $attr[0] } ) } .=
        $tr-&gt;render('detail',
            {
                shoe     =&gt; $attr[1],
                detail   =&gt; $attr[2],
                price    =&gt; $attr[3],
                quantity =&gt; $q,
            } );
}

print $tr-&gt;render('table_start') .
    join('', %inventory) .
    $tr-&gt;render('table_end');</code></pre>

<p>This loop looks surprisingly similar to the first example, doesn't it? That's because it is. Instead of printing each row, however, this code renders the first column in <code>@goods</code> against the category template section, and then storing the output as a key in <code>%inventory</code>. In the same iteration, it renders the remaining columns against the detail section and appends to the value of that key.</p>

<p>After storing the rendered sections in this way to <code>%inventory</code>, the code prints everything with a single statement, using <code>join</code> to print all the values in <code>%inventory</code>, including keys. The output is:</p>

<table>
<tr>
<td><strong>recreation</strong>
</td>
</tr>

<tr>
<td>flip flops</td>
<td>Colors of the rainbow</td>
<td>$7</td>
<td>90</td>
</tr>

<tr>
<td><strong>sports</strong>
</td>
</tr>

<tr>
<td>hiking</td>
<td>All sizes</td>
<td>$55</td>
<td>7</td>
</tr>

<tr>
<td>tennis shoes</td>
<td>Women's sizes</td>
<td>$35</td>
<td>15</td>
</tr>

<tr>
<td><strong>dress</strong>
</td>
</tr>

<tr>
<td>oxfords</td>
<td>Brown leather</td>
<td>$85</td>
<td>Out of stock</td>
</tr>
</table>

<p>The code also handles conditional output. Suppose that at your growing online shoe emporium you provide special deals to customers who have bought over a certain dollar amount. As they browse your shoe inventory, these deals appear.</p>

<pre><code>if ( $customer-&gt;is_elite ) {
    print $tr-&gt;render('special_deals', get_deals('elite') );
}
else {
    print $tr-&gt;render('standard_deals', get_deals() );
}</code></pre>

<p>What about producing XML output? This usually requires a separate template? You can conditionally load a <em>.xml</em> or <em>.html</em> template:</p>

<pre><code>my $tr;
if ( $q-&gt;param('fmt') eq 'xml' ) {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.xml' );
}
else {
    $tr = Template::Recall-&gt;new( template_path =&gt; 'inventory.html' );
}</code></pre>

<p>Perl provides everything you need to handle model, controller, <em>and</em> view logic. Template::Recall capitalizes on this and helps to make projects code driven.</p>

<h3>Template Model Comparison</h3>

<p>It's important to note a few things that occurred in these examples -- or failed to occur, rather. First, there's no mixture of code and template markup. All template access occurs through the method call <code>$tr-&gt;render()</code>. This is strong separation of concerns (SOC), just like the pipeline model, and unlike the callback model, which mixes template markup and code in the same file. Not only does strong SOC provide good code organization, it also keeps designers from having to sift through code to change markup. Consider using Mason to output the rows of <code>@goods</code>.</p>

<pre><code>% for my $good (@goods) {
%  my @attr     = split(/,/, $good);
%  my $quantity = $attr[3] eq '0' ? 'Out of stock' : $attr[3];
&lt;tr&gt;
&lt;td&gt;&lt;% $attr[0] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[1] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $attr[2] %&gt;&lt;/td&gt;
&lt;td&gt;&lt;% $quantity %&gt;&lt;/td&gt;
&lt;/tr&gt;
% }</code></pre>

<p>This is an efficient approach, and easy enough for a programmer to walk through. It becomes difficult to maintain though, when designers are involved, if for no other reason than because a designer and a programmer need to access the same file to do their respective work. Design changes and code changes will not always share the same schedule because they belong to different domains. It also means that in order to switch templates, say to output XML or text (or both), you have to add more and more conditionals and templates to the code, making it increasingly difficult to read.</p>

<p>The other thing that did not occur in this example is the leaking of any kind of logic (presentation or otherwise) into the template. Consider that HTML::Template would have to insert the <code>&lt;TMPL_LOOP&gt;</code> statement in the template in order to output the rows of <code>@goods</code>.</p>

<pre><code>    &lt;TMPL_LOOP NAME="PRODUCT"&gt;
    &lt;tr&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=SHOE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=DETAILS&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=PRICE&gt;&lt;/td&gt;
    &lt;td&gt;&lt;TMPL_VAR NAME=QUANTITY&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/TMPL_LOOP&gt;</code></pre>

<p>That's not a big deal, really. If you care about line count, this only requires one extra line over the Template::Recall version, and that's the the closing tag <code>&lt;/TMPL_LOOP&gt;</code>. Nonetheless, the template now states some of the logic for the application. Sure, it's only presentation logic, but it's logic nonetheless. HTML::Template also provides <code>&lt;TMPL_IF&gt;</code> for displaying items conditionally, and <code>&lt;TMPL_INCLUDE&gt;</code> for including other templates. Again, this is logic contained in the template files.</p>

<p>Template::Recall keeps as much logic as possible in the code. If you need to display something conditionally, use Perl's <code>if</code> statement. If you need to include other templates, load them using a Template::Recall object. Whereas the pipeline models likely work better for projects with a fairly sophisticated design team, Template::Recall tries to be the programmer's friend and let him or her steer from the most comfortable place, the code.</p>

<p>There is also a subtle cost to using the pipeline model for a simple loop like that above. Consider this HTML::Template footwear data code:</p>

<pre><code>my $template = HTML::Template-&gt;new(filename =&gt; template1.tmpl');

my @output;

for my $good (@goods)
{
    my @attr = split(/,/, $_);
    my %row  = (
        SHOE     =&gt; $attr[0],
        DETAILS  =&gt; $attr[1],
        PRICE    =&gt; $attr[2],
        QUANTITY =&gt; $attr[3],
    );
    push( @output, \%row );
}

$template-&gt;param(PRODUCT =&gt; \@output);

print $template-&gt;output();</code></pre>

<p>The code iterates over <code>@goods</code> and builds a second array, <code>@output</code>, with the rows as hash references. Then the template iterates over <code>@output</code> within <code>&lt;TMPL_LOOP&gt;</code>. That's walking over the same data twice. Template sections do not suffer this cost, because you can output the data immediately, as you get it:</p>

<pre><code>print $tr-&gt;render('product_row', \%row);</code></pre>

<p>This is essentially what happens with Mason (or JSP/PHP/ASP for that matter). The main difference is that Template::Recall renders the section through a method call rather than mixing code and template.</p>

<p>Template::Recall, by using sectioned templates, combines the efficiency of the callback model with the strong, clean separation of concerns inherent in the pipeline model, and perhaps gets the best of both worlds.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-652" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2007/02/htmltemplate-widgets.html" rel="bookmark">Advanced HTML::Template: Widgets</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Philipp Janert</span> on <abbr class="published" title="2007-02-01T00:00:00-08:00">February  1, 2007 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->

<p>My previous article, looked at <a href="/pub/a/2006/11/30/html-template-filters.html">extending <code>HTML::Template</code> through custom tags and filters</a>. This article looks at ways to manage large, more complex pages, by bundling <a href="http://search.cpan.org/perldoc?HTML::Template"><code>HTML::Template</code></a> into something like GUI "widgets" (or "controls").</p>

<p>Imagine you have a basic page layout following the standard setup, with a header, a lefthand navbar, and the main body in the bottom right. The header and navbar are the same for all pages of the site, but of course the main body differs from page to page:</p>

<table border="2">
<tr>
<td colspan="2">Header</td>
</tr>

<tr>
<td>Navbar</td>
<td>
<p>Body</p>
</td>
</tr>
</table>

<p>Naturally, you don't want to repeat the information for the header and the navbar explicitly on each page. Furthermore, if the HTML for the navbar changes, you don't want to have to modify each and every page. The <code>&lt;TMPL_INCLUDE&gt;</code> tag can help in this situation.</p>

<p>Create separate files for header and navbar, then include them in the template for each page (by convention, I use the filename extension <em>.tpf</em> for page <em>f</em>ragments, to distinguish them from full-page templates: <em>.tpl</em>):</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
    &lt;tr colspan="2"&gt;
      &lt;td&gt;&lt;TMPL_INCLUDE NAME=header.tpf&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;TMPL_INCLUDE NAME=navbar.tpf&gt;&lt;/td&gt;
      &lt;td&gt; 
        &lt;!-- Body goes here! --&gt;
        ...
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Now <code>HTML::Template</code> will include the page fragments for the header and navbar in the page when it evaluates the template. Changes to either of the fragments will affect the entire site immediately.</p>

<p>(For simplicity of presentation, I am going to use the old familiar <code>&lt;table&gt;</code> method to fix the layout--this article is about <code>HTML::Template</code>, not CSS positioning!)</p>

<p>Note that both the header and the navbar may include other <code>HTML::Template</code> tags, such as <code>&lt;TMPL_VAR&gt;</code> or <code>&lt;TMPL_LOOP&gt;</code>: file fragment inclusion occurs <em>before</em> tag substitution. If you need dynamic content in either header or navbar, all you need to do is set the value of the corresponding parameter using the <code>param()</code> function before evaluating the template.</p>

<h3>Better Encapsulation through Widgets</h3>

<p>If there are only a few dynamic parameters in header and navbar, you can simply assign values to them together with the parameters required by the main body of the page. However, if the header and navbar themselves become sufficiently complicated, you probably don't want to repeat their parameter-setting logic with the actual Perl code managing the main business logic for each page of our site. Instead, you can control them through an API.</p>

<p>To establish a Perl API for a page fragment, hide the entire template handling, including parameter setting and template substitution, in a subroutine. The subroutine takes several parameters and returns a string containing the fully expanded HTML code corresponding to the page fragment. You can then include this string in the current page through a simple <code>&lt;TMPL_VAR&gt;</code> tag.</p>

<p>As an example, consider a navbar that contains the username of the currently logged-in user.</p>

<p>Here is the page-fragment template for the navbar:</p>

<pre><code>Current User: &lt;TMPL_VAR NAME=login&gt;
&lt;br /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="page1.html"&gt;Page 1&lt;/a&gt;
  &lt;li&gt;&lt;a href="page2.html"&gt;Page 2&lt;/a&gt;
  &lt;li&gt;&lt;a href="page3.html"&gt;Page 3&lt;/a&gt;
&lt;/ul&gt;</code></pre>

<p>For this example, the corresponding subroutine is very simple. It's easy to imagine a situation where the navbar requires some complex logic that you are glad to hide behind a function call--for instance, when the selection of links depends on the permissions (found through a DB call) of the logged-in user.</p>

<p>Demonstrating the principle is straightforward; find the template fragment, set the required parameter, and render the template:</p>

<pre><code>sub navbar { 
  my ( $login ) = shift;

  my $tpl = HTML::Template-&gt;new( filename =&gt; 'navbar.tpf' );
  $tpl-&gt;param( login =&gt; $login );
  return $tpl-&gt;output();
}</code></pre>

<p>The master-page template then includes the navbar string using a <code>&lt;TMPL_VAR&gt;</code> tag. (Note the header inclusion through a <code>&lt;TMPL_INCLUDE&gt;</code> tag.)</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
    &lt;tr colspan="2"&gt;
      &lt;td&gt;&lt;TMPL_INCLUDE NAME=header.tpf&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;TMPL_VAR NAME=navbar&gt;&lt;/td&gt;
      &lt;td&gt; 
        &lt;!-- Body goes here! --&gt;
        ...
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>This approach provides pretty good encapsulation: the code calling the <code>navbar()</code> routine does not need to know anything about its implementation--in fact, the subroutine can be in a separate module entirely. It is not far-fetched to imagine a shared module for all reusable page fragments used on the site.</p>













<h3>Building Pages Inside Out</h3>

<p>This development model still uses a separate, top-level template file for each page. All shared parts of the page are then included in this master template.</p>

<p>The widget approach can go a step further to do away entirely with the notion of having a separate master template for each page, by turning even the <em>main body</em> of the page into a widget or a collection of widgets. At this point, there may be only a single top-level template:</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
    &lt;tr colspan="2"&gt;
      &lt;td&gt;&lt;TMPL_INCLUDE NAME=header.tpf&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;TMPL_VAR NAME=navbar&gt;&lt;/td&gt;
      &lt;td&gt;&lt;TMPL_VAR NAME=mainbody&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>A central Perl "controller" component dispatches page requests to the appropriate main-body widget (assuming you specify destination pages through a request parameter called <code>action</code>):</p>

<pre><code>use CGI;
use HTML::Template;

my $q = CGI-&gt;new;
my $action = $q-&gt;param( 'action' );

# Dispatch to the desired main function
my $body_string = '';
if(    $action eq 'act1' ) { $body_string = act1( $q ); }
elsif( $action eq 'act2' ) { $body_string = act2( $q ); }
elsif( $action eq 'act3' ) { $body_string = act3( $q ); }

# Pull the current user from the query object and pass to the navbar
my $navbar_string = navbar( $q-&gt;param( 'login' ) );

# Set the rendered navbar and mainbody in the master template
my $tpl = HTML::Template-&gt;new( filename =&gt; 'tmpl3.tpl' );
$tpl-&gt;param( mainbody =&gt; $body_string );
$tpl-&gt;param( navbar   =&gt; $navbar_string );

print $q-&gt;header(), $tpl-&gt;output;

sub navbar { ... }

sub act1{ ... }
sub act2{ ... }
sub act3{ ... }</code></pre>

<h3>A Drop-down Widget</h3>

<p>At this point, you may ask why you still need a template for the page fragment at all. Well, you don't--unless you find it convenient, of course.</p>

<p>There are two reasons to use a template: as a more suitable method of generating HTML than having to program a whole bunch of <code>print</code> statements, and to ensure separation of presentation from behavior. By encapsulating the nitty-gritty of HTML generation behind an API, you achieve the latter. How you go about the former depends entirely on the context. If you need to generate a lot of straight up HTML, with lots of <code>&lt;table&gt;</code>, <code>&lt;img&gt;</code>, and <code>&lt;form&gt;</code> tags, a template fragment makes perfect sense. But if it is actually easier to program the <code>print</code> statements yourself, there is nothing wrong with that--by encapsulating the HTML generation in a subroutine, you still achieve separation of presentation and main control flow and business logic.</p>

<p>As a classic example for something that is hard to express as a template, consider a drop-down menu with a default that has to be set programmatically. Attempting to do this using a template leads to a mess of template loops and conditionals. However, doing it in a widget subroutine is clean and easy, in particular if you use the appropriate functions from the standard <code>CGI</code> module:</p>

<pre><code>sub color_select {
  my ( $default_color ) = @_;

  my @colors = qw( red green blue yellow cyan magenta );

  return popup_menu( 'color_select', \@colors, $default_color );
}</code></pre>

<p>Include the string returned by this subroutine in a page template using <code>&lt;TMPL_VAR&gt;</code> tags as discussed previously.</p>

<h3>Conclusion</h3>

<p>This concludes a brief overview of some useful techniques for using <code>HTML::Template</code> that go beyond straight up variable replacement. I hope you enjoyed the trip.</p>

<p>There remains the question of when all of this is useful and suitable. To me, the beauty of <code>HTML::Template</code> is its utter simplicity. There isn't much in the way of creature comforts or "framework" features (such as forms processing or automated request dispatch). On the other hand, there is virtually <em>no</em> overhead: it's possible to understand the basic ideas of <code>HTML::Template</code> in five minutes or fewer, and it's easy to add to any simple CGI script. You don't need to design the project around the framework (as is often the case with more powerful but inevitably more complex toolsets). In fact, <code>HTML::Template</code> is so trivial to use that I use it in any CGI script that produces more than, say, 10 to 15 lines of HTML output. It's just convenient.</p>

<p>Filters and "widgets" as described in this series are easy ways to add some convenience features that are missing from <code>HTML::Template</code>. By bundling some repetitive code segments into a custom tag or a widget, you can keep both the code and template cleaner and simpler while at the same time continuing to enjoy the low overhead of <code>HTML::Template</code>.</p>

<p>However, there is only so much lipstick you can put on a pig. When you find ourselves building extensive libraries of custom tags or specific widgets, maybe you want to look more deeply into one of the existing frameworks for Perl web development, such as <a href="http://search.cpan.org/perldoc?Perl::Mason%3C/a%3E%3Ccode%3EPerl::Mason%3C/code%3E%20or%3Ca%20href=">the Template Toolkit</a>.</p>

<p>Of course, as long as you are happy with <code>HTML::Template</code> and it works for you, there is no reason to change. It works for me--and very well indeed.</p>

<div style="border: 1px solid #777777; width: 95%; 
background-color:#f0f0f0; padding:8px; margin:5px 5px;">
<h4>Sidebar: Three Hidden Gems</h4>

<p><code>HTML::Template</code> has several useful and often overlooked minor features and options, (despite being clearly documented in POD). I want to point out three of the ones that are most commonly useful--all of which, by default, are (unfortunately, I think) turned <em>off</em>.</p>

<h5>Permit Unused Parameters</h5>

<pre><code>my $tpl = HTML::Template-&gt;new( filename =&gt; '...', die_on_bad_params =&gt; 0 );</code></pre>

<p>HTML::Template will die when it encounters an unused parameter in the template. In other words, if you set a parameter with <code>$tpl-&gt;param()</code>, but there is no corresponding <code>&lt;TMPL_VAR&gt;</code> in the template, template processing will fail by default. Setting the option <code>die_on_bad_params</code> to <code>0</code> disables this behavior.</p>

<h5>Make Global Variables Visible In Loops</h5>

<pre><code>my $tpl = HTML::Template-&gt;new( filename =&gt; '...', global_vars =&gt; 1 );</code></pre>

<p>By default, template loops open up a new scope, which makes all template parameters from outside the loop invisible within the loop. In particular, code like this will (by default) not work as expected:</p>

<pre><code>Verbosity level: &lt;TMPL_VAR NAME=isVerbose&gt;
&lt;ul&gt;
&lt;TMPL_LOOP NAME=rows&gt;
  &lt;li&gt;&lt;TMPL_VAR NAME=rowitem&gt;
    &lt;TMPL_IF NAME=isVerbose&gt;
      ... &lt;!-- print additional, 'verbose' info --&gt;
    &lt;/TMPL_IF&gt;
&lt;/TMPL_LOOP&gt;
&lt;/ul&gt;</code></pre>

<p>The <code>verbose</code> parameter, defined <em>outside</em> the loop scope will by default <em>not</em> be visible within the loop. Change this by setting the option <code>global_vars</code> to <code>1</code>.</p>

<h5>Special Loop Variables</h5>

<pre>my $tpl = HTML::Template-&gt;new( filename =&gt; '...', loop_context_vars =&gt; 1 );</pre>

<p>Finally, enable a very useful little feature by setting <code>loop_context_vars</code> to <code>1</code>. This defines several Boolean variables within each loop; they take on the appropriate value for each row:</p>

<ul>
<li><code>__first__</code>
</li>

<li><code>__inner__</code>
</li>

<li><code>__last__</code>
</li>

<li><code>__odd__</code>
</li>

<li><code>__even__</code>
</li>
</ul>

<p>There is also an integer variable <code>__counter__</code>, which is incremented for each row. Note that <code>__counter__</code> starts at <code>1</code>, in contrast to Perl arrays!</p>

<p>These variables are extremely useful in a variety of ways. For example, they make it easy to give every other row in a table a different background color to improve legibility. Together with filters (as described in my previous article), this allows for rather elegant template code:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;style type="text/css"&gt;
    .odd  { background-color: yellow }
    .even { background-color: cyan }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;table&gt;
  &lt;TMPL_LOOP NAME=rows&gt;
    &lt;CSTM_ROW EVEN=even ODD=odd&gt;
      &lt;td&gt; &lt;TMPL_VAR NAME=__counter__&gt; Cell contents... &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/TMPL_LOOP&gt;
  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The appropriate filter for the new custom tag is:</p>

<pre><code>sub cstmrow_filter {
  my $text_ref = shift;
  $$text_ref =~ s/&lt;CSTM_ROW\s+EVEN=(.+)\s+ODD=(.*)\s*&gt;
                 /&lt;TMPL_IF NAME=__odd__&gt;
                    &lt;tr class="$1"&gt;
                  &lt;TMPL_ELSE&gt;
                    &lt;tr class="$2"&gt;
                  &lt;\/TMPL_IF&gt;
                 /gx;
}</code></pre>

<p>Note that, as implemented, the <code>EVEN</code> attribute must precede the <code>ODD</code> attribute in the <code>&lt;CSTM_ROW&gt;</code> tag.</p>
</div>








        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/version-control-systems/">&laquo; Version Control Systems</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/web-management/">Web Management &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
