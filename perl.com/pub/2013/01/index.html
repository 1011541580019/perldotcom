<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.13-en" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>
<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="/pub/">
<dc:title>Perl.com</dc:title>
<dc:description>news and views of the Perl programming language</dc:description>
<license rdf:resource="http://creativecommons.org/licenses/by-nc-nd/3.0/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-nc-nd/3.0/">
</License>
</rdf:RDF>
-->

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
<script type='text/javascript' src='http://partner.googleadservices.com/gampad/google_service.js'></script>
<script type='text/javascript'>
GS_googleAddAdSenseService("ca-pub-4136420132070439");
GS_googleEnableAllServices();
</script>
<script type='text/javascript'>
GA_googleAddSlot("ca-pub-4136420132070439", "Perl_728x90");
</script>
<script type='text/javascript'>GA_googleFetchAds();</script>
    <title>Perl.com: January 2013 Archives</title>


    <link rel="prev" href="/pub/2012/12/" title="December 2012" />
    <link rel="next" href="/pub/2013/10/" title="October 2013" />

</head>
<body id="perl-com" class="mt-archive-listing mt-datebased-monthly-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <span id="top_advert"> 
<!-- Put any landscape advert in here -->
<!-- Perl_728x90 -->
<script type='text/javascript'>
GA_googleFillSlot("Perl_728x90");
</script>
        </span> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description">news and views of the Perl programming language</div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <h1 id="page-title" class="archive-title">January 2013 Archives</h1>





                            
                            <div id="entry-2081" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2013/01/lexing-and-parsing-continued.html" rel="bookmark">Lexing and Parsing Continued</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author"><a class="fn url" href="http://savage.net.au/index.html">Ron Savage</a></span> on <abbr class="published" title="2013-01-31T18:50:54-08:00">January 31, 2013  6:50 PM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>This article is the second part of a series which started with <a
    href="/pub/2012/10/an-overview-of-lexing-and-parsing.html">An
    Overview of Lexing and Parsing</a>. That article aimed to discuss lexing
and parsing in general terms, while trying to minimize the amount on how to
actually use Marpa::R2 to do the work. In the end, however, it did have quite a
few specifics. This article has yet more detail with regard to working with
both a lexer and a parser. BTW, Marpa's blog</p>

<p>(For more information, see the Marpa blog or download the example files for this article.)</p>

<h3>Brief Recap: The Two Grammars</h3>

<p>Article 1 defined the first sub-grammar as the one which identifies tokens and the second sub-grammar as the one which specifies which combinations of tokens are legal within the target language. As I use these terms, the lexer implements the first sub-grammar and the parser implements the second.</p>

<h3>Some Context</h3>

<p>Consider this image:</p>

<div class="HTML">

<img src="http://savage.net.au/Ron/html/graphviz2.marpa/teamwork.svg" /></div>

<p>It's actually a copy of the image of a manual page for <a
    href="http://search.cpan.org/perldoc?Graph::Easy">Graph::Easy</a>. Note: My
module <a
    href="http://search.cpan.org/perldoc?Graph::Easy::Marpa">Graph::Easy::Marpa</a>
is a complete re-write of <code>Graph::Easy</code>. After I offered to take
over maintenance of the latter, I found the code so complex I literally
couldn't understand any of it.</p>

<p>There are three ways (of interest to us) to specify the contents of this image:</p>

<ul>

<li>As a Perl program using the <a href="http://search.cpan.org/perldoc?GraphViz2">GraphViz2</a> module</li>

<p>This is <em>teamwork.pl</em>:</p>

<pre><code>    #!/usr/bin/env perl

    use strict;
    use warnings;

    use GraphViz2;

    # ---------------

    my($graph) = GraphViz2 -&gt; new
        (
        graph  =&gt; {rankdir =&gt; &#39;LR&#39;},
        edge   =&gt; {color =&gt; &#39;grey&#39;},
        logger =&gt; &#39;&#39;,
        );

    $graph -&gt; default_node(fontsize =&gt; &#39;12pt&#39;, shape =&gt; &#39;rectangle&#39;,
                           style    =&gt; &#39;filled, solid&#39;);

    $graph -&gt; add_node(name =&gt; &#39;Teamwork&#39;, fillcolor =&gt; &#39;red&#39;);
    $graph -&gt; add_node(name =&gt; &#39;Victory&#39;,  fillcolor =&gt; &#39;yellow&#39;);

    # The dir attribute makes the arrowhead appear.

    $graph -&gt; add_edge(dir =&gt; &#39;forward&#39;, from  =&gt; &#39;Teamwork&#39;,
                       to  =&gt; &#39;Victory&#39;, label =&gt; &#39;is the key to&#39;);

    my($format)      = shift || &#39;svg&#39;;
    my($output_file) = shift || &quot;teamwork.$format&quot;;

    $graph -&gt; run(format =&gt; $format, output_file =&gt; $output_file);</code></pre>

<li>As a Graphviz DOT file written in a little language</li>

<p>This approach uses the <code>Graph::Easy</code> language invented by the author (Tels) of the <code>Graph::Easy</code> Perl module. Call this <em>teamwork.easy</em>. It's actually input for <code>Graph::Easy::Marpa</code>:</p>

<pre><code>    graph {rankdir: LR}
    node {fontsize: 12pt; shape: rectangle; style: filled, solid}
    [Teamwork]{fillcolor: yellow}
    -&gt; {label: is the key to}
    [Victory]{fillcolor: red}</code></pre>

<p>Note: In some rare cases, the syntax supported by <code>Graph::Easy::Marpa</code> will not be exactly identical to the syntax supported by the original <code>Graph::Easy</code>.</p>

<li>As a DOT file</li>

<p>Call this <em>teamwork.dot</em>:</p>

<pre><code>    digraph Perl
    {
    graph [ rankdir=&quot;LR&quot; ]
    node  [ fontsize=&quot;12pt&quot; shape=&quot;rectangle&quot; style=&quot;filled, solid&quot; ]
    edge  [ color=&quot;grey&quot; ]
    &quot;Teamwork&quot; [ fillcolor=&quot;yellow&quot; ]
    &quot;Victory&quot;  [ fillcolor=&quot;red&quot; ]
    &quot;Teamwork&quot; -&gt; &quot;Victory&quot; [ label=&quot;is the key to&quot; ]
    }</code></pre>

</ul>

<p>This article is about using <code>GraphViz2::Marpa</code> to parse DOT files.</p>

<p>Of course the Graphviz package itself provides a set of programs which parse DOT files in order to render them into many different formats. Why then would someone write a new parser for DOT? One reason is to practice your Marpa skills. Another is, perhaps, to write an on-line editor for Graphviz files.</p>

<p>Alternately you might provide add-on services to the Graphviz package. For instance, some users might want to find all clusters of nodes, where a cluster is a set of nodes connected to each other, but not connected to any nodes outside the cluster. Yet other uses might want to find all paths of a given length emanating from a given node.</p>

<p>I myself have written algorithms which provide these last two features. See the module <a href="http://search.cpan.org/perldoc?GraphViz2::Marpa::PathUtils">GraphViz2::Marpa::PathUtils</a> and the <a href="http://savage.net.au/Perl-modules/html/graphviz2.pathutils/index.html">PathUtils demo page</a>.</p>

<p>But back to using <code>Marpa::R2</code> from within <code>GraphViz2::Marpa</code>.</p>

<h2>Scripts for Testing</h2>

<p>The code being developed obviously needs to be tested thoroughly, because any such little language has many ways to get things right and a horrendously large number of ways to get things slightly wrong, or worse. Luckily, because graphs specified in DOT can be very brief, it's a simple matter to make up many samples. Further, other more complex samples can be copied from the Graphviz distro's <em>graphs/directed/</em> and <em>graphs/undirected/</em> directories.</p>

<p>The <code>GraphViz2::Marpa</code> distro I developed includes with 86 <em>data/*.gv</em> (input) files and the 79 corresponding <em>data/*.lex</em>, <em>data/*.parse</em>, <em>data/*.rend</em>, and <em>html/*.svg</em> (output) files. The missing files are due to deliberate errors in the input files, so they do not have output files. The distribution also includes obvious scripts such as <em>lex.pl</em> (lex a file), <em>parse.pl</em> (parse a lexed file), rend.pl (render a parsed file back into DOT), and one named vaguely after the package, <em>g2m.pl</em>, which runs the lexer and the parser.</p>

<p>Why a rend.pl? If the code <em>can't</em> reconstruct the input DOT file, something got lost in translation....</p>

<p>The distribution also includes scripts which operate on a set of files.</p>

<ul>

<li><em>data/*.gv</em> -&gt; <em>dot2lex.pl</em> -&gt; runs <em>lex.pl</em> once per file -&gt; <em>data/*.lex</em> (CSV files).</li>

<li><em>data/*.lex</em> -&gt; <em>lex2parse.pl</em> -&gt; runs <em>parse.pl</em> once per file -&gt; <em>data/*.parse</em> (CSV files).</li>

<li><em>data/*.parse</em> -&gt; <em>parse2rend.pl</em> -&gt; runs <em>rend.pl</em> once per file -&gt; <em>data/*.rend</em> (dot files).</li>

<li><em>data/*.rend</em> -&gt; <em>rend2svg.pl</em> -&gt; <em>html/*.svg</em>.</li>

</ul>

<p>Finally, <em>generate.demo.pl</em> creates <a href="http://savage.net.au/Perl-modules/html/graphviz2.marpa/">the GraphViz2 Marpa demo page</a>.</p>

<p>Normal users will use <em>g2m.pl</em> exclusively. The other scripts help developers with testing. See the <a href="http://savage.net.au/Perl-modules/html/GraphViz2/Marpa.html#Scripts">GraphViz2 Marpa scripts documentation</a> for more information.</p>

<h3>Some Modules</h3>

<p><a
    href="http://search.cpan.org/perldoc?GraphViz2:Marpa::Lexer::DFA">GraphViz2::Marpa::Lexer::DFA</a>
is a wrapper around <a
    href="http://search.cpan.org/perldoc?Set::FA::Element">Set::FA::Element</a>.
It has various tasks to do:</p>

<ul>

<li>Process the State Transition Table (STT)</li>

<p>The <a href="http://savage.net.au/Perl-modules/html/graphviz2.marpa/stt.html">STT</a> comes in via <code>GraphViz2::Marpa::Lexer</code>, which produced it from within its own source code or an external CSV file. The lexer has already validated the structure of the STT's data.</p>

<li>Transform the STT from the input form (spreadsheet/CSV file) into what Set::FA::Element expects</li>

<li>Set up the logger</li>

<p>In truth, it gets this from its caller, GraphViz2::Marpa::Lexer.</p>

<li>Provide the code for all the functions which handle enter-state and exit-state events</li>

<p>This is the code which can apply checking above and beyond what was built into the set of regexps which came from the spreadsheet. For example, I could have used Perl's <code>\w</code> instead of <code>/[a-zA-Z_][a-zA-Z_0-9]*/</code> to find alphanumeric tokens, and at this point rejected those starting with a digit, because <a href="http://www.graphviz.org/content/dot-language">DOT</a> imposes that restriction.</p>

<p>Most importantly, this code stockpiles the tokens themselves with metadata to identify the type of each token (hence the <em>two</em> columns in the upcoming sample <em>data/27.lex</em> just below).</p>

<li>Run the DFA</li>

<li>Check the result of that run</li>

<p>Did the DFA end up in an accepting state? Yes is okay and no is an error.</p>

</ul>

<p>Here is some sample data which ships with <code>GraphViz2::Marpa</code>, formatted for maximum clarity:</p>

<ul>

<li>A DOT file, <em>data/27.gv</em>, which is input to the lexer:</li>

<pre><code>    digraph graph_27
    {
        node_27_1
        [
            color     = red
            fontcolor = green
        ]
        node_27_2
        [
            color     = green
            fontcolor = red
        ]
        node_27_1 -&gt; node_27_2
    }</code></pre>

<li>A token file, <em>data/27.lex</em>, which is output from the lexer:</li>

<pre><code>    &quot;type&quot;,&quot;value&quot;
    strict          , &quot;no&quot;
    digraph         , &quot;yes&quot;
    graph_id        , &quot;graph_27&quot;
    start_scope     , &quot;1&quot;
    node_id         , &quot;node_27_1&quot;
    open_bracket    , &quot;[&quot;
    attribute_id    , &quot;color&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;red&quot;
    attribute_id    , &quot;fontcolor&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;green&quot;
    close_bracket   , &quot;]&quot;
    node_id         , &quot;node_27_2&quot;
    open_bracket    , &quot;[&quot;
    attribute_id    , &quot;color&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;green&quot;
    attribute_id    , &quot;fontcolor&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;red&quot;
    close_bracket   , &quot;]&quot;
    node_id         , &quot;node_27_1&quot;
    edge_id         , &quot;-&gt;&quot;
    node_id         , &quot;node_27_2&quot;
    end_scope       , &quot;1&quot;</code></pre>

</ul>

<p>You can see the details on <a href="http://savage.net.au/Perl-modules/html/graphviz2.marpa/">the GraphViz2 Marpa demo page</a>.</p>

<h2>Some Notes on the STT</h2>

<p>Firstly, note that the code allows whole-line comments (matching <code>m!^(?:#|//)!</code>. These lines are discarded when the input file is read, and so do not appear in the STT.</p>

<h3>Working With An Incomplete BNF</h3>

<p>Suppose you've gone to all of the work to find or create a BNF (<a
    href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Backus-Naur
    Form</a>) grammar for your input language. You might encounter the
situation where you can use BNF to specify your language in general, but not
precisely in every situation. DOT is one offender.</p>

<p>DOT IDs can be surrounded by double-quotes, and in some case <em>must</em> be surrounded by double-quotes. To be more specific, if we regard an attribute declaration to be of the form <code>key=value</code>, <em>both</em> the key and the value can be embedded in double-quotes, and sometimes the value <em>must</em> be.</p>

<p>Even worse, IDs can be attributes. For instance, you might want your font color to be green. That appears to be simple, but note: attributes <em>must</em> be attached to some component of the graph, something like <code>node_27_1 [fontcolor = green]</code>.</p>

<p>Here's the pain. In DOT, the <em>thing</em> to which the attribute belongs <em>may be omitted</em> as implied. That is, the name of the thing's owner is <em>optional</em>. For instance, you might want a graph which is six inches square. Here's how you can specify that requirement:</p>

<ul>

<li><code>graph [size = "6,6"]</code></li>

<p>The double-quotes are mandatory in this context.</p>

<li><code>[size = "6,6"]</code></li>

<p>This also works.</p>

<li><code>size = "6,6"</code></li>

<p>So does this.</p>

</ul>

<p>But wait, there's more! The <em>value</em> of the attribute can be omitted, if it's true. Hence the distro, and the demo page, have a set of tests, called <em>data/42.*.gv</em>, which test that feature of the code. Grrrr.</p>

<p>All this means is that when the terminator of the attribute declaration (in the input stream) is detected, and we switch states from <code>within-attribute</code> to <code>after-attribute</code>, the code which emits output from the lexer has to have some knowledge of what the hell is going on, so that it can pretend it received the first of these three forms even if it received the second or third form. It <em>must</em> output <code>graph</code> (the graph as a whole) as the owner of the attribute in question.</p>

<p>As you've seen, any attribute declaration can contain a set of attribute <code>key=value</code> pairs as in <code>node_27_2 [ color = green fontcolor = red ]</code>.</p>

<p>You can't solve this with regexps, unless you have amazing superpowers and don't care if anyone else can maintain your code. Instead, be prepared to add code in two places:</p>

<ul>

<li>At switch of state</li>

<li>After all input has been parsed</li>

<p>Indeed, </code>GraphViz2::Marpa::Lexer::DFA</code> contains a long sub,
<code>_clean_up()</code>, which repeatedly fiddles the array of detected
tokens, fixing up the list before it's fit to inflict on the parser.</p>

</ul>

<h3>Understanding the State Transition Table</h3>

<p>I included this diagram in the first article:</p>

<pre><code>             DOT&#39;s Grammar
                  |
                  V
        ---------------------
        |                   |
     strict                 |
        |                   |
        ---------------------
                  |
                  V
        ---------------------
        |                   |
     digraph     or       graph
        |                   |
        ---------------------
                  |
                  V
        ---------------------
        |                   |
       $id                  |
        |                   |
        ---------------------
                  |
                  V
                {...}</code></pre>

<p>A dot file starts with an optional <code>strict</code>, followed by either
<code>graph</code> or <code>digraph</code>. (Here <code>di</code> stands for
directed, meaning edges between nodes have arrowheads on them. Yes, there are
many attributes which can be attached to edges. See <a
    href="http://www.graphviz.org/content/attrs">http://www.graphviz.org/content/attrs</a>
and look for an <code>E</code> (edge) in the second column of the table of
attribute names).</p>

<p>The <code>/(di|)graph/</code> is in turn followed by an optional ID.</p>

<h4>Line One</h4>

<p>From the first non-heading line of the STT, you can see how I ended up with:</p>

<ul>

<li>A start state flag =&gt; <code>Yes</code></li>

<p>The state defined on this line is the start state.</p>

<li>An accept flag =&gt; <code>''</code></li>

<p>Because the initial state can't be an accepting start, this column--in the row--must be empty.</p>

<p>Later STT states have <code>Yes</code> in this column.</p>

<li>A state name =&gt; <code>initial</code></li>

<p>I chose to call it <code>initial</code>. Other people call it <code>start</code>.</p>

<li>An event =&gt; <code>strict</code></li>

<p>This--although it might not yet be clear--is actually a regexp, <code>/(?:strict)/</code>. The DFA adds the do-not-capture prefix <code>/(?:</code> and suffix <code>)/</code>.</p>

<li>A next state =&gt; <code>graph</code></li>

<p>This is the state to which to jump if a match occurs. Here, match means a match between the regexp (event) in the previous column and the head of the input stream.</p>

<li>An entry function =&gt; <code>''</code></li>

<p>I don't use it here, but if I did, it would mean to call a particular function when entering the named state.</p>

<li>An exit function =&gt; <code>save_prefix</code></li>

<p>Similar to the entry function, this says to call a particular function when exiting the named state.</p>

<li>A regexp =&gt; <code>(?:"[^"]*"|<\s*<.*?</code>\s*>|[a-zA-Z_][a-zA-Z_0-9]*|-?(?:\.[0-9]+|[0-9]+(?:\.[0-9])*))></li>

<p>I can save a set of regexps in this column and use spreadsheet formula elsewhere to refer to them.</p>

<li>An interpretation =&gt; <code>ID</code></li>

<p>These are my notes to myself. This one says that regexp in the previous column specifies what an ID must match in the DOT language.</p>

</ul>

<h4>Line Two</h4>

<p>The event in the second line, <code>/(?:graph|digraph)/</code>, indicates what to do if the <code>strict</code> is absent from the input stream.</p>

<p>To clarify this point, recall that the DFA matches entries in the Event column one at a time, from the first listed against the name of the state--here, <code>/(?:strict)/</code>--down to the last for the given state--here, <code>/(?:\s+)/</code>. The first regexp to match wins, in that the first regexp to match will triggersthe <em>exit</em> state logic and that its entry in the Next column specifies the next state to enter, which in turn specifies the (next) state's <em>entry</em> function to call, if any.</p>

<p>If <code>strict</code> is not at the head of the input stream, and it can definitely be absent, as is seen in the above diagram, this regexp--<code>/(?:graph|digraph)/</code>--is the next one tested by the DFA's logic.</p>

<h4>Line Three</h4>

<p>The hard-to-read regexp <code>\/\*.*\*\/</code> says to skip C-language-style multi-line (<code>/* ... */</code>) comments. The skip takes place because the Next state is <code>initial</code>, the current state. In other words, discard any text at the head of the input stream which this regexp will gobble.</p>

<p>Why does it get discarded? That's the way <code>Set::FA::Element</code>
operates. Looping <em>within</em> a state does <em>not</em> trigger the
exit-state and enter-state functions, and so there is no opportunity to
stockpile the matched text. That's good in this case. There's no reason to save
it, because it's a comment.</p>

<p>Think about the implications for a moment. Once the code has discarded a comment (or anything else), you can never recreate the verbatim input stream from the stockpiled text. Hence you should only discard something once you fully understand the consequences. If you're parsing code to execute it (whatever that means), fine. If you're writing a pretty printer or indenter, you cannot discard comments.</p>

<p>Lastly, we can say this regexp is used often, meaning we accept such comments at many places in the input stream.</p>

<h4>Line Four</h4>

<p>The regexp <code>\s+</code> says to skip spaces (in front of or between interesting tokens). As with the previous line, we skip to the very same state.</p>

<p>This state has four regexps attached to it.</p>

<h3>More States</h3>

<p>Re-examining the STT shows two introductory states, for input with and without a (leading) <code>strict</code>. I've called these states by the arbitrary names <code>initial</code> and <code>graph</code>.</p>

<p>If the initial <code>strict</code> is present, state <code>initial</code> handles it (in the exit function) and jumps to state <code>graph</code> to handle what comes next. If, however, <code>strict</code> is absent, state <code>initial</code> still handles the input, but then jumps to state <code>graph_id</code>.</p>

<p>A (repeated) word of warning about <code>Set::FA::Element</code>. A loop
<em>within</em> a state does <em>not</em> trigger the exit-state and
enter-state functions. Sometimes this can actually be rather unfortunate. You
can see elsewhere in the STT where I have had to use pairs of
almost-identically named states (such as <code>statement_list_1</code> and
<code>statement_list_2</code>), and designed the logic to rock the STT back and
forth between them, just to allow the state machine to gobble up certain input
sequences. You may have to use this technique yourself. Be aware of it.</p>

<p>Proceeding in this fashion, driven by the BNF of the input language, eventually you can construct the whole STT. Each time a new enter-state or exit-state function is needed, write the code, then run a small demo to test it. There is no substitute for that testing.</p>

<h4>The <code>graph</code> State</h4>

<p>You reach this state simply by the absence of a leading <code>strict</code> in the input stream. Apart from not bothering to cater for comments (as did the <code>initial</code> state), this state is really the same as the <code>initial</code> state.</p>

<p>A few paragraphs back I warned about a feature designed into Set::FA::Element, looping within a state. That fact is why the <code>graph</code> state exists. If the <code>initial</code> state could have looped to itself upon detecting <code>strict</code>, <em>and</em> executed the exit or entry functions, there would be no need for the <code>graph</code> state.</p>

<h4>The <code>graph_id</code> State</h4>

<p>Next, look for an optional graph id, at the current head of the input stream (because anything which matched previously is gone).</p>

<p>Here's the first use of a formula: Cell H2 contains
<code>(?:"[^"]*"|&lt;[^&gt;]*&gt;|[a-zA-Z_][a-zA-Z_0-9]*|-?(?:\.[0-9]+|[0-9]+(?:\.[0-9])*))</code>.
This accepts a double-quoted ID, or an ID quoted with <code>&lt;</code> and
<code>&gt;</code>, or an alphanumeric (but not starting with a digit) ID, or a
number.</p>

<p>When the code sees such a token, it jumps to the <code>open_brace</code> state, meaning the very next non-whitespace character had better (barring comments) be a <code>{</code>, or there's an error, so the code will die. Otherwise, it accepts <code>{</code> without an ID and jumps to the <code>statement_list_1</code> state, or discards comments and spaces by looping within the <code>graph_id</code> state.</p>

<h4>The Remaining States</h4>

<p>What follows in the STT gets complex, but in reality is more of the same. Several things should be clear by now:</p>

<ul>

<li>The development of the STT is iterative</li>

<li>You need lots of tiny but different test data files, to test these steps</li>

<li>You need quite a lot of patience, which, unfortunately, can't be downloaded from the internet...</li>

</ul>

<h2>Lexer Actions (Callbacks)</h2>

<p>Matching something with a DFA only makes sense if you can capture the matched text for processing. Hence the use of state-exit and state-entry callback functions. In these functions, you must decide what text to output for each recognized input token.</p>

<p>To help with this, I use a method called <code>items()</code>, accessed in each function via <code>$myself</code>. This method manages an stack (array) of items of type <code>Set::Array</code>. Each element in this array is a hashref:</p>

<pre><code>    {
        count =&gt; $integer, # 1 .. N.
        name  =&gt; &#39;&#39;,       # Unused.
        type  =&gt; $string,  # The type of the token.
        value =&gt; $value,   # The value from the input stream.
    }</code></pre>

<p>Whenever a token is recognized, push a new item onto the stack. The value of the <code>type</code> string is the result of the DFA's work identifying the token. This identification process uses the first of the two sub-grammars mentioned in the first article.</p>

<h3>A long Exit-state Function</h3>

<p>The <code>save_prefix</code> function looks like:</p>

<pre><code>    # Warning: This is a function (i.e. not a method).

    sub save_prefix
    {
        my($dfa)   = @_;
        my($match) = trim($dfa -&gt; match);

        # Upon each call, $match will be 1 of:
        # * strict.
        # * digraph.
        # * graph.

        # Note: Because this is a function, $myself is a global alias to $self.

        $myself -&gt; log(debug =&gt; &quot;save_prefix($match)&quot;);

        # Input     =&gt; Output (a new item, i.e. a hashref):
        # o strict  =&gt; {name =&gt; strict,  value =&gt; yes}.
        # o digraph =&gt; {name =&gt; digraph, value =&gt; yes}.
        # o graph   =&gt; {name =&gt; digraph, value =&gt; no}.

        if ($match eq &#39;strict&#39;)
        {
            $myself -&gt; new_item($match, &#39;yes&#39;);
        }
        else
        {
            # If the first token is &#39;(di)graph&#39; (i.e. there was no &#39;strict&#39;),
            # jam a &#39;strict&#39; into the output stream.

            if ($myself -&gt; items -&gt; length == 0) # Output stream is empty.
            {
                $myself -&gt; new_item(&#39;strict&#39;, &#39;no&#39;);
            }

            $myself -&gt; new_item(&#39;digraph&#39;, $match eq &#39;digraph&#39; ? &#39;yes&#39; : &#39;no&#39;);
        }

    } # End of save_prefix.</code></pre>

<h3>A tiny Exit-state Function</h3>

<p>Here's one of the shorter exit functions, attached in the STT to the <code>open_brace</code> and <code>start_statement</code> states:</p>

<pre><code>    sub start_statements
    {
        my($dfa) = @_;

        $myself -&gt; new_item(&#39;open_brace&#39;, $myself -&gt; increment_brace_count);

    } # End of start_statements.</code></pre>

<p>The code to push a new item onto the stack is just:</p>

<pre><code>    sub new_item
    {
        my($self, $type, $value) = @_;

        $self -&gt; items -&gt; push
            ({
                count =&gt; $self -&gt; increment_item_count,
                name  =&gt; &#39;&#39;,
                type  =&gt; $type,
                value =&gt; $value,
             });

    } # End of new_item.</code></pre>

<h2>Using Marpa in the Lexer</h2>

<p>Yes, you can use Marpa in the lexer, as discussed in the first article. I prefer to use a spreadsheet full of regexps--but enough of the lexer. It's time to discuss the parser.</p>

<h2>The Parser's Structure</h2>

<p>The parser incorporates the second sub-grammar and uses <code>Marpa::R2</code> to validate the output from the lexer against this grammar. The parser's structure is very similar to that of the lexer:</p>

<ul>

<li>Initialize using the parameters to <code>new()</code></li>

<li>Declare the grammar</li>

<li>Run Marpa</li>

<li>Save the output</li>

</ul>

<h2>Marpa Actions (Callbacks)</h2>

<p>As with the lexer, the parser works via callbacks, which are functions named within the grammar and called by <code>Marpa::R2</code> whenever the input sequence of lexed items matches some component of the grammar. Consider these four <em>rule descriptors</em> in the grammar declared in <code>GraphViz2::Marpa::Parser</code>'s <code>grammar()</code> method:</p>

<pre><code>    [
    ...
    {   # Prolog stuff.
        lhs =&gt; &#39;prolog_definition&#39;,
        rhs =&gt; [qw/strict_definition digraph_definition graph_id_definition/],
    },
    {
        lhs    =&gt; &#39;strict_definition&#39;,
        rhs    =&gt; [qw/strict/],
        action =&gt; &#39;strict&#39;, # &lt;== Callback.
    },
    {
        lhs    =&gt; &#39;digraph_definition&#39;,
        rhs    =&gt; [qw/digraph/],
        action =&gt; &#39;digraph&#39;, # &lt;== Callback.
    },
    {
        lhs    =&gt; &#39;graph_id_definition&#39;,
        rhs    =&gt; [qw/graph_id/],
        action =&gt; &#39;graph_id&#39;, # &lt;== Callback. See sub graph_id() just below.
    },
    ...
    ]</code></pre>

<p>In each case the <code>lhs</code> is a name I've chosen so that I can refer to each rule descriptor in other rule descriptors. That's how I chain rules together to make a tree structure. (See the <em>Chains and Trees</em> section of the previous article.)</p>

<p>This grammar fragment expects the input stream of items from the lexer to consist (at the start of the stream, actually) of three components: a strict thingy, a digraph thingy, and a graph_id thingy. Because I wrote the lexer, I can ensure that this is exactly what the lexer produces.</p>

<p>To emphasise, the grammar says that these the items are the only things it will accept at this point in the input stream, and that only if they are in the given order, and that they must literally consist of the three tokens (see <code>rhs</code>): <em>strict</em>, <em>digraph</em> and <em>graph_id</em>.</p>

<p>These latter three come from the <em>type</em> key in the array of hashrefs built by the lexer. The three corresponding <em>value</em> keys in those hashrefs are <code>yes</code> or <code>no</code> for <em>strict</em>, <code>yes</code> or <code>no</code> for <em>digraph</em>, and an id or the empty string for <em>graph_id</em>.</p>

<p>As with the lexer, when in incoming token (<em>type</em>) matches expectations, <code>Marpa::R2</code> triggers a call to an <em>action</em>, here called (for clarity) the same as the <code>rhs</code>.</p>

<p>Consider one of those functions:</p>

<pre><code>    sub graph_id
    {
        my($stash, $t1, undef, $t2)  = @_;

        $myself -&gt; new_item(&#39;graph_id&#39;, $t1);

        return $t1;

    } # End of graph_id.</code></pre>

<p>The parameter list is courtesy of how <code>Marpa::R2</code> manages callbacks. <code>$t1</code> is the incoming graph id. In <em>data/27.gv</em> (shown earlier), that is <code>graph_27</code>.</p>

<p>Marpa does not supply the string <code>graph_id</code> to this function, because there's no need. I designed the grammar such that this function is only called when the value of the incoming <em>type</em> is <code>graph_id</code>, so I know precisely under what circumstances this function was called. That's why I could hard-code the string <code>graph_id</code> in the body of the <code>graph_id()</code> function.</p>

<h2>The Grammar in Practice</h2>

<p>Now you might be thinking: Just a second! That code seems to be doing no more than copying the input token to the output stream. Well, you're right, sort of.</p>

<p>True understanding comes when you realize that Marpa calls that code only at the appropriate point precisely because the <em>type</em> <code>graph_id</code> and its <em>value</em> <code>graph_27</code> were at exactly the right place in the input stream. By that I mean that the location of the pair:</p>

<pre><code>    (type =&gt; value)
    (&#39;graph_id&#39; =&gt; &#39;graph_27&#39;)</code></pre>

<p>in the input stream was exactly where it had to be to satisfy the grammar initialized by <code>Marpa::R2::Grammar</code>. If it had not been there, Marpa would have thrown an exception, which we would recognize as a syntax error--a syntax error in the input stream fed into the <em>lexer</em>, but which Marpa picked up by testing that input stream against the grammar declared in the <em>parser</em>. The role of the lexer as an intermediary is to simplify the logic of the code as a whole with a divide-and-conquer strategy.</p>

<p>In other words, it's no accident that that function gets called at a particular point in time during the parser's processing of its input stream.</p>

<p>Consider another problem which arises as you build up the set of <em>rule descriptors</em> within the grammar.</p>

<h2>Trees Have Leaves</h2>

<p>The first article discussed chains and trees (see the <code>prolog_definition</code> mentioned earlier in this article). Briefly, each <em>rule descriptor</em> must be chained to other <em>rule descriptors</em>.</p>

<p>The astute reader will have already seen a problem: How do you define the meanings of the leaves of this tree when the chain of definitions must end at each leaf?</p>

<p>Here's part of the <em>data/27.lex</em> input file:</p>

<pre><code>    &quot;type&quot;,&quot;value&quot;
    strict          , &quot;no&quot;
    digraph         , &quot;yes&quot;
    graph_id        , &quot;graph_27&quot;
    start_scope     , &quot;1&quot;
    node_id         , &quot;node_27_1&quot;
    open_bracket    , &quot;[&quot;
    attribute_id    , &quot;color&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;red&quot;
    attribute_id    , &quot;fontcolor&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;green&quot;
    close_bracket   , &quot;]&quot;
    ...</code></pre>

<p>The corresponding rules descriptors look like:</p>

<pre><code>    [
    ...
    {
        lhs =&gt; &#39;attribute_statement&#39;,
        rhs =&gt; [qw/attribute_key has attribute_val/],
    },
    {
        lhs    =&gt; &#39;attribute_key&#39;,
        rhs    =&gt; [qw/attribute_id/], # &lt;=== This is a terminal.
        min    =&gt; 1,
        action =&gt; &#39;attribute_id&#39;,
    },
    {
        lhs    =&gt; &#39;has&#39;,
        rhs    =&gt; [qw/equals/],
        min    =&gt; 1,
    },
    {
        lhs    =&gt; &#39;attribute_val&#39;,
        rhs    =&gt; [qw/attribute_value/], # &lt;=== And so is this.
        min    =&gt; 1,
        action =&gt; &#39;attribute_value&#39;,
    },
    ...
    ]</code></pre>

<p>The items marked as terminals (standard parsing terminology) have no further definitions, so <code>attribute_key</code> and <code>attribute_val</code> are leaves in the tree of <em>rule descriptors</em>. What does that mean? The terminals <code>attribute_id</code> and <code>attribute_value</code> must appear literally in the input stream.</p>

<p>Switching between <code>attribute_key</code> and <code>attribute_id</code> is a requirement of Marpa to avoid ambiguity in the statement of the grammar. Likewise for <code>attribute_val</code> and <code>attribute_value</code>.</p>

<p>The <code>min</code> makes the attributes mandatory. Not in the sense that nodes and edges <em>must</em> have attributes, they don't, but in the sense that if the input stream has an <code>attribute_id</code> token, then it <em>must</em> have an <code>attribute_value</code> token and vice versa.</p>

<p>Remember the earlier section "Working With An Incomplete BNF"? If the original <em>*.gv</em> file used one of:</p>

<pre><code>    size = &quot;6,6&quot;
    [size = &quot;6,6&quot;]
    graph [size = &quot;6,6&quot;]</code></pre>

<p>... then the one chosen really represents the graph attribute:</p>

<pre><code>    graph [size = &quot;6,6&quot;]</code></pre>

<p>To make this work, the lexer must force the output to be:</p>

<pre><code>    &quot;type&quot;,&quot;value&quot;
    ...
    class_id        , &quot;graph&quot;
    open_bracket    , &quot;[&quot;
    attribute_id    , &quot;size&quot;
    equals          , &quot;=&quot;
    attribute_value , &quot;6,6&quot;
    close_bracket   , &quot;]&quot;</code></pre>

<p>This matches the requirements, in that both <code>attribute_id</code> and <code>attribute_value</code> are present, is their (so to speak) owner, the object itself, which is identified by the <em>type</em> <code>class_id</code>.</p>

<p>All of this should reinforce the point that the design of the lexer is intimately tied to the design of the parser. By taking decisions like this in the lexer you can standardize its output and simplify the work that the parser needs to don.</p>

<h2>Where to go from here</h2>

<p>The recently released Perl module <a
    href="http://search.cpan.org/perldoc?MarpaX::Simple::Rules">MarpaX::Simple::Rules</a>
takes a BNF and generates the corresponding grammar in the format expected by
<code>Marpa::R2</code>.</p>

<p>Jeffrey Kegler (author of Marpa) <a href="http://jeffreykegler.github.com/Ocean-of-Awareness-blog/individual/2012/06/the-useful-the-playful-the-easy-the-hard-and-the-beautiful.html>">has blogged about MarpaX::Simple::Rules</a>.</p>

<p>This is a very interesting development, because it automates the laborious process of converting a BNF into a set of Marpa's <em>rule descriptors</em>. Consequently, it makes sense for anyone contemplating using <code>Marpa::R2</code> to investigate how appropriate it would be to do so via <code>MarpaX::Simple::Rules</code>.</p>

<h2>Wrapping Up and Winding Down</h2>

<p>You've seen samples of lexer output and some parts of the grammar which both define the second sub-grammar of what to expect and what should match precisely the input from that lexer. If they don't match, it is in fact the parser which issues the dread syntax error message, because only it (not the lexer) knows which combinations of input tokens are acceptable.</p>

<p>Just like in the lexer, callback functions stockpile items which have passed Marpa::R2's attempt to match up input tokens with rule descriptors. This technique records exactly which rules fired in which order. After Marpa::R2 has run to completion, you have a stack of items whose elements are a (lexed and) parsed version of the original file. Your job is then to output that stack to a file, or await the caller of the parser to ask for the stack as an array reference. From there, the world.</p>

<p>For more details, consult <a href="http://savage.net.au/Ron/html/writing.graph.easy.marpa.html>">my July 2011 article on Marpa::R2</a>.</p>

<h2>The Lexer and the State Transition Table - Revisited</h2>

<p>The complexity of the STT in <code>GraphViz2::Marpa</code> justifies the
decision to split the lexer and the parser into separate modules. Clearly that
will not always be the case. Given a sufficiently simple grammar, the lexer
phase may be redundant. Consider this test data file,
<em>data/sample.1.ged</em>, from <a
    href="http://search.cpan.org/perldoc?Genealogy::Gedcom">Genealogy::Gedcom</a>:</p>

<pre><code>    0 HEAD
    1 SOUR Genealogy::Gedcom
    2 NAME Genealogy::Gedcom::Reader
    2 VERS V 1.00
    2 CORP Ron Savage
    3 ADDR Box 3055
    4 STAE Vic
    4 POST 3163
    4 CTRY Australia
    3 EMAIL ron@savage.net.au
    3 WWW http://savage.net.au
    2 DATA
    3 COPR Copyright 2011, Ron Savage
    1 NOTE
    2 CONT This file is based on test data in Paul Johnson&#39;s Gedcom.pm
    2 CONT Gedcom.pm is Copyright 1999-2009, Paul Johnson (paul@pjcj.net)
    2 CONT Version 1.16 - 24th April 2009
    2 CONT
    2 CONT Ron&#39;s modules under the Genealogy::Gedcom namespace are free
    2 CONT
    2 CONT The latest versions of these modules are available from
    2 CONT my homepage http://savage.net.au and http://metacpan.org
    1 GEDC
    2 VERS 5.5.1-5
    2 FORM LINEAGE-LINKED
    1 DATE 10-08-2011
    1 CHAR ANSEL
    1 SUBM @SUBM1@
    0 TRLR</code></pre>

<p>Each line matches <code>/^(\d+)\s([A-Z]{3,4})\s(.+)$/</code>: an integer, a
keyword, and a string. In this case I'd skip the lexer, and have the parser
tokenize the input. So, horses for courses. (GEDCOM defines genealogical data;
see <a href="http://wiki.webtrees.net/File:Ged551-5.pdf>">the GEDCOM
    definition</a> for more details).</p>

<h2>Sample Output</h2>

<p>I've provided several links of sample output for your perusal.</p>

<ul>

<li><a href="http://savage.net.au/Perl-modules/html/graphviz2/">GraphViz2 (non-Marpa)</a></li>

<li><a href="http://savage.net.au/Perl-modules/html/graphviz2.marpa/">GraphViz2::Marpa</a></li>

<li><a href="http://savage.net.au/Perl-modules/html/graphviz2.pathutils/">GraphViz2::Marpa::PathUtils</a></li>

<li><a href="http://savage.net.au/Perl-modules/html/graph.easy.marpa/">Graph::Easy::Marpa</a></li>

</ul>

<p>Happy lexing and parsing!</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/2012/12/">&laquo; December 2012</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/2013/10/">October 2013 &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2014/02/">February 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2014/01/">January 2014 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/10/">October 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2013/01/">January 2013 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/12/">December 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/11/">November 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2012/10/">October 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/08/">August 2012 (2)</a></li>
        
    
        
            <li><a href="/pub/2012/06/">June 2012 (11)</a></li>
        
    
        
            <li><a href="/pub/2012/05/">May 2012 (18)</a></li>
        
    
        
            <li><a href="/pub/2012/04/">April 2012 (17)</a></li>
        
    
        
            <li><a href="/pub/2012/02/">February 2012 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/12/">December 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/09/">September 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/08/">August 2011 (2)</a></li>
        
    
        
            <li><a href="/pub/2011/06/">June 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/05/">May 2011 (3)</a></li>
        
    
        
            <li><a href="/pub/2011/04/">April 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/03/">March 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/02/">February 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2011/01/">January 2011 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/11/">November 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/10/">October 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/09/">September 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2010/08/">August 2010 (3)</a></li>
        
    
        
            <li><a href="/pub/2010/07/">July 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/04/">April 2010 (2)</a></li>
        
    
        
            <li><a href="/pub/2010/03/">March 2010 (4)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.13-en" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

            <div class="widget-creative-commons widget">
                <div class="widget-content">
                    This blog is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons License</a>.
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
