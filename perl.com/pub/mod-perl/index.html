<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: mod_perl Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>mod_perl</em> Category</h1>






                            
                            <div id="entry-682" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/02/debug-mod-perl.html" rel="bookmark">Debugging and Profiling mod_perl Applications</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Frank Wiles</span> on <abbr class="published" title="2006-02-09T00:00:00-08:00">February  9, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>Because of the added complexity of being <em>inside</em> of the Apache web server, debugging <a href="http://perl.apache.org/"><code>mod_perl</code></a> applications is often not as straightforward as it is with regular Perl programs or CGIs. Is the problem with your code, Apache, a CPAN module you are using, or within <code>mod_perl</code> itself? How do you tell? Sometimes traditional debugging techniques will not give you enough information to find your problem.</p>

<p>Perhaps, instead, you're baffled as to why some code you just wrote is running so slow. You're probably asking yourself, "Isn't this <code>mod_perl</code> stuff supposed to improve my code's performance?" Don't worry, slow code happens even to the best of us. How do you profile your code to find the problem?</p>

<p>This article shows how to use the available CPAN modules to debug and profile your <code>mod_perl</code> applications.</p>

<h3>Traditional Debugging Methods</h3>

<p>The tried-and-true <code>print</code> statement is the debugger's best friend. Used wisely this, can be the easiest and fastest way of figuring out what is amiss in your program. Can't figure out why your sales tax subroutine is always off by 14 cents? Add several <code>print</code> statements just before, just after, and all around inside of that particular subroutine. Use them to show the value of key variables at each step in the process. You can direct the output straight onto the page in your browser, or if you prefer, into hidden HTML comments. Typically this is all that you need to spot your problems. It's flexible and easy to implement and understand.</p>

<p>Another common approach is to place <code>die()</code> and/or <code>warn()</code> statements as you trace through your code, isolating the problem. <code>die()</code> is especially useful if you do not want your program to continue executing, possibly because the errors will corrupt your otherwise valid testing data. The main benefit of using <code>warn</code> over a simple <code>print</code> statement is that the output goes instead to the appropriate Apache <em>error_log</em>. This keeps your debugging information out of the user interface and gives you the ability to log and spot errors long after they occurred for the user. Simply <code>tail</code> your <em>error_log</em> in another window and you can watch it all day long. If you're into that sort of thing.</p>

<p>For example, if you had some code like:</p>

<pre><code>sub handler {
    my $r   =   shift;

    # Set content type
    $r-&gt;content_type( 'text/html' );

    my $req = Apache2::Request-&gt;new($r);
   
    # Compute sales tax if we are told to do so
    my $tax = 0;
    if( $req-&gt;param('compute_sales_tax') ) {
        my $tax = compute_sales_tax($r, $req-&gt;param('total_amount');
    }

    # Code to display results to the browser....
}</code></pre>

<p>... you might find a problem during testing. Your initial search leads you to believe that either the code never calls the <code>compute_sales_tax()</code> function or the function always returns zero. You can add some simple debugging statements:</p>

<pre><code>sub handler {
    my $r   =   shift;
   
    # Set content type
    $r-&gt;content_type( 'text/html' );

    my $req = Apache2::Request-&gt;new($r);
   
    # Compute sales tax if we are told to do so
    my $tax = 0;

    # Debugging statements
    warn("Tax at start '$tax'");
    warn('compute_sales_tax ' . $req-&gt;param('compute_sales_tax') );

    if( $req-&gt;param('compute_sales_tax') ) {

        # Debugging
        warn("Tax before sub '$tax'");
        my $tax = compute_sales_tax($r, $req-&gt;param('total_amount');
        warn("Tax after sub '$tax'");
    }

    warn("Tax after if '$tax'");

    # Code to display results to the browser....
}</code></pre>

<p>Assuming that the page that directs the user to this code has set <code>compute_sales_tax</code> to a <code>true</code> value, you will see something similar to:</p>

<pre><code>Tax at start '0' at line 5
compute_sales_tax 1 at line 6
Tax before sub '0' at line 12
Tax after sub '1.36' at line 14
Tax after if '0' at line 17</code></pre>

<p>If you read through this, you see that <code>compute_sales_tax()</code> is indeed being called, otherwise you would not see the "Tax before/after" <code>warn</code> outputs. Directly after the subroutine call you can see that <code>$tax</code> holds a suitable value. However, after the <code>if</code> block, <code>$tax</code> reverts back to zero. Upon closer examination, you might find that the bug is the <code>my</code> before the call to <code>compute_sales_tax()</code>. This creates a locally scoped variable named <code>$tax</code> and does not assign it to the <code>$tax</code> variable in the outer block, which causes it to stay zero and makes it seem that <code>compute_sales_tax()</code> was never called.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/832" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3>When to Use <code>Apache::DB</code></h3>

<p>Using <code>print</code>, <code>die</code>, and <code>warn</code> statements in your code will help you find and fix 99 percent of the bugs you may run across when building <code>mod_perl</code> applications. Too bad there is still that pesky remaining 1 percent that will make you tear your hair out in clumps and wish you had gone into selling insurance instead of programming. Luckily there is <a href="http://search.cpan.org/perldoc?Apache::DB">Apache::DB</a> to help keep the glare off our collective heads at next year's Perl conference to a minimum.</p>

<p>Sometime, despite all of your attempts to see what is going wrong, you will find yourself in a situation where:</p>

<ul>
<li>Your code causes Apache to segfault and you can't for the life of you figure out why.</li>

<li>It appears that your code segfaults inside of a subroutine or method you are calling in a CPAN module you are using.</li>

<li>You have more debugging statements than actual code.</li>
</ul>

<p>You could spend time hacking up your other installed modules, such as those from CPAN, with debugging statements--but this only means you will have to return later and remove all of it. You could take an easier route and debug your <code>mod_perl</code> application with a real source debugger.</p>

<p>Using the Perl debugger allows you to see directly into what is happening to your code and data. You can step through your code line by line, as Perl executes it. Because you are following the same <em>flow</em>, there is no chance that you are making any bad assumptions. You might even consider it WYSIWYG, albeit without a GUI.</p>

<h3>Using <code>Apache::DB</code></h3>

<p>While <code>Apache::DB</code> works with both <code>mod_perl</code> 1.x and <code>mod_perl</code> 2.x, all of the examples in this article use <code>mod_perl</code> 2.0. Once you have installed <code>Apache::DB</code> from CPAN, using it is fairly simple. It does, however, require that you make a few Apache configuration changes. Assuming you have a <code>mod_perl</code> handler installed at <code>/modperl/</code> on your system, your configuration needs to resemble this:</p>

<pre><code>&lt;Location /modperl&gt;
  SetHandler perl-script
  PerlResponseHandler My::Modperl::Handler
  PerlFixupHandler +Apache::DB
&lt;/Location&gt;</code></pre>

<p>You also need to modify either the appropriate <code>&lt;Perl&gt;&lt;/Perl&gt;</code> section or your <em>startup.pl</em> file to include:</p>

<pre><code>use APR::Pool ();
use Apache::DB ();
Apache::DB-&gt;init();</code></pre>

<p>If you are working in a <code>mod_perl</code> 1.0 environment, the only change is that you should not include the <code>use APR::Pool ();</code> directive.</p>

<p>Note that you must call <code>Apache::DB-&gt;init();</code> prior to whatever code you are attempting to debug. To be safe, I always just put it as the very first thing in my <em>startup.pl</em>.</p>

<p>Once you have modified your configuration, the last step is to launch your Apache server with the <code>-X</code> command-line option. This option tells Apache to launch only one back-end process and to not fork into the background. If you don't use this option, you can't guarantee that your debugger has connected to same Apache child as your browser.</p>

<p>With this Apache daemon tying up your command prompt, simply browse to your application. As you will see, the shell running <code>httpd</code> has been replaced with a Perl debugging session. This debugging session is tied directly to your application and browser. If you look at your browser it will appear to hang waiting for a response; this is due to the fact your Apache server is waiting on you to work with the debugger.</p>

<p>Perl's debugger is very similar to other debuggers you may have used. You can step through your code line by line, skip entire subroutines, set break points, and display and/or change the value of variables with it.</p>

<p>It might be useful to read through <a
href="http://perldoc.perl.org/perldebtut.html"><code>man
perldebtut</code></a>, a introductory tutorial on using the debugger. For a
more complete reference to all of the available commands, see <a
href="http://perldoc.perl.org/perldebug.html"><code>man perldebug</code></a>.
This list should be just enough to get you started:</p>

<table>
<tr>
<th width="115">Command</th>
<th>Description</th>
</tr>

<tr valign="top">
<td><code>p&nbsp;<em>expression</em></code>
</td>
<td>This prints out the value of an expression or variable, just like the <code>print</code> directive in Perl.</td>
</tr>

<tr valign="top">
<td><code>x&nbsp;<em>expression</em></code>
</td>
<td>This evaluates an expression and prettily prints it for you. Use it to make complex data structures readable.</td>
</tr>

<tr valign="top">
<td><code>s</code>
</td>
<td>This tells the debugger to take a single <em>step</em>. A step is a single statement. If the next statement is a subroutine, the debugger will treat it as only one statement; you will not be able to step through each statement of that subroutine and the flow will continue without descending into it.</td>
</tr>

<tr valign="top">
<td><code>n</code>
</td>
<td>This tells the debugger to go to the next statement. If the next statement is a subroutine, you will descend into it and be able to step through each line of that subroutine.</td>
</tr>

<tr valign="top">
<td><code>l&nbsp;<em>line</em></code>
</td>
<td>Display a particular line of source code.</td>
</tr>

<tr valign="top">
<td><code>M</code>
</td>
<td>Display all loaded modules.</td>
</tr>
</table>

<h3>Code Profiling with <code>Apache::DProf</code></h3>

<p><a href="http://search.cpan.org/perldoc?Apache::DProf"><code>Apache::DProf</code></a> provides the necessary hooks for you to get some coarse profiling information about your code. By coarse, I mean only information on a subroutine level. It will show you the number of times a subroutine is called along with duration information.</p>

<p>Essentially, <code>Apache::DProf</code> wraps <a href="http://search.cpan.org/perldoc?Devel::DProf"><code>Devel::DProf</code></a> for you, making your life much easier. It is <em>possible</em> to use <code>Devel::DProf</code> by itself, but it assumes that you are running a normal Perl program from the command line and not in a persistent <code>mod_perl</code> environment. This isn't optimal, because while you can shoehorn <code>Devel::DProf</code> into working, you'll end up profiling all of the code used at server startup when you really only care about the runtime code.</p>

<p>Using <code>Apache::DProf</code> is relatively straightforward. All you need to do is include <code>PerlModule Apache::DProf</code> in your <em>httpd.conf</em> and restart your server.</p>













<p>As an example, here's a small application to profile. This code, while not all that useful, will help illustrate the major differences between these two profiling modules:</p>

<pre><code>package PerlTest;

sub handler {
    my $r = shift;
  
    $r-&gt;content_type( 'text/plain' );
  
    handle_request($r);

    return( Apache2::Const::OK );
}

sub handle_request {
    my $r = shift;

    $r-&gt;print( "Handling request....\n" );

    cleanup_request($r);

}

sub cleanup_request {
    my $r = shift;

    $r-&gt;print( "Cleaning up request....\n" );

    sleep(5);     # Take some time in this section
}

1;</code></pre>

<p>When you profile a module with <code>Apache::Dprof</code>, it will create a directory named <em>dprof/</em> in your server's <em>logs/</em> directory. Under this directory will be subdirectories named after the PID of each Apache child your server has. This allows you to profile code over a long period of time on a production system to see where your real bottlenecks are. Often, <em>faking</em> a typical user session does not truly represent how your users interact with your application and having the real data is beneficial.</p>

<p>After your server has run for a while, you need to stop it and revert your configuration, removing the <code>PerlModule Apache::DProf</code> you just inserted. This is due to the fact that <code>Apache::DProf</code> does not write its data to disk until the server child ends.</p>

<p>Viewing the profiling data is exactly the same as with <code>Devel::DProf</code>. Choose a particular Apache child directory in <em>$SERVER_ROOT/logs/dprof/</em> and run <code>dprofpp</code> on the corresponding <em>tmon.out</em> file.</p>

<p>After beating on the code sample above for awhile with <code>ab</code>, here are the results <code>Apache::DProf</code> gave me:</p>

<pre><code>Total Elapsed Time = 1082.402 Seconds
  User+System Time =        0 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 0.00   0.004  0.001    687   0.0000 0.0000  RevSys::PerlTest::cleanup_request
 0.00       - -0.000      1        -      -  warnings::import
 0.00       - -0.000      1        -      -  APR::Pool::DESTROY
 0.00       - -0.000      1        -      -  strict::import
 0.00       - -0.000      1        -      -  Apache2::XSLoader::load
 0.00       - -0.000      3        -      -  Apache2::RequestIO::BEGIN
 0.00       - -0.000      2        -      -  RevSys::PerlTest::BEGIN
 0.00       - -0.003    687        -      -  Apache2::RequestRec::content_type
 0.00       - -0.006   1374        -      -  Apache2::RequestRec::print
 0.00       - -0.012    687        -      -  RevSys::PerlTest::handle_request
 0.00       - -0.024    687        -      -  RevSys::PerlTest::handler</code></pre>

<p>As expected, <code>cleanup_request()</code> shows the most time used per call. The report also shows stats for the other function calls you would expect as well as the ones that happen <em>behind the scenes</em>.</p>

<h3>Code Profiling with <code>Apache::SmallProf</code></h3>

<p>While <code>Apache::DProf</code> will show you which subroutines use the most system resources, sometimes that is not enough information. <a href="http://search.cpan.org/perldoc?Apache::SmallProf"><code>Apache::SmallProf</code></a> gives you fine-grained details in a line-by-line profile of your code.</p>

<p>Setup is similar to both of two previous modules. Add into a <code>&lt;Perl&gt;</code> section or your <em>startup.pl</em> file the code:</p>

<pre><code>use APR::Pool ();
use Apache::DB ();
Apache::DB-&gt;init();</code></pre>

<p>You also need to add <code>PerlFixupHandler Apache::SmallProf</code> into the <code>&lt;Directory&gt;</code> or <code>&lt;Location&gt;</code> block that refers to your <code>mod_perl</code> code.</p>

<p>Like <code>Apache::DProf</code>, <code>Apache::SmallProf</code> writes all of the profiling data into <em>$SERVER_ROOT/logs/smallprof/</em>. One interesting difference between <code>Apache::DProf</code> and <code>Apache::SmallProf</code> is that the latter writes a profile for each module in use. This is helpful because you already know which subroutines are slow and which packages they are in, from your first round of profiling with <code>Apache::DProf</code>. By focusing on those modules you can find your troubled code much faster.</p>

<p>Viewing <code>Apache::SmallProf</code> data is, however, a little different from <code>Apache::DProf</code>. A module profile looks like this:</p>

<table>
<tr>
<td><code>&lt;number&gt;</code></td>
<td><code>&lt;wall time&gt;</code></td>
<td><code>&lt;cpu time&gt;</code></td>
<td><code>&lt;line number&gt;</code></td>
<td><code>&lt;source line&gt;</code></td>
</tr>
</table>

<p><code>&lt;number&gt;</code> is the number of times this particular line was executed, <code>&lt;wall time&gt;</code> is the actual time passed, and <code>&lt;cpu time&gt;</code> is the amount of time the CPU spent working on that line. The remaining two pieces of data are the line number in the file and the actual source on that line.</p>

<p>You can just open up the profiles generated by <code>Apache::SmallProf</code> and look at the results. However, this doesn't get to the heart of the matter very quickly. Sorting the profile by the amount of time spent on each line gets you where you want to go:</p>

<pre><code>$ <strong>sort -nrk 2 logs/smallprof/MyHandler.pm | more</strong></code></pre>

<p>This command sorts the profile for <code>MyHandler.pm</code> by the wall time of each line. If you use this same sort on the output from <code>Apache::SmallProf</code> on the example code, you will see something similar to this:</p>

<pre><code># <strong>sort -nrk 2 PerlTest.pm.prof | more</strong>
    1 5.000785 0.000000         29:    sleep( 5 );
    1 0.008177 0.000000         13:    return( Apache2::Const::OK );
    1 0.007431 0.010000         21:    cleanup_request( $r );
    3 0.001343 0.000000          4:use Apache2::RequestIO;
    1 0.000176 0.000000         33:1;
    3 0.000164 0.000000          3:use Apache2::RequestRec;
    1 0.000093 0.000000         19:    $r-&gt;print( "Handling request......\n" );
    1 0.000067 0.000000         11:    handle_request( $r );
    1 0.000058 0.000000          9:    $r-&gt;content_type( 'text/plain' );
    1 0.000058 0.000000         28:    $r-&gt;print( "Cleaning up request......\n" );</code></pre>

<p>As you can see, <code>Apache::SmallProf</code> has zeroed right in on our <code>sleep()</code> call as the source of our performance problems.</p>

<h3>Conclusion</h3>

<p>Hopefully, this article has given you enough of an introduction to these modules that you can begin using them in your development efforts. The next time you face a seemingly unsolvable bug or performance issue, you have a few more weapons in your arsenal.</p>

<p>If you have trouble getting any of these three modules to work, please don't hesitate to contact me directly. If you need <code>mod_perl</code> help in general, I strongly suggest you join the <code>mod_perl</code> mailing list. You can often get an answer to your <code>mod_perl</code> question in a few hours, if not minutes.</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1162" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2003/07/mod-perl.html" rel="bookmark">Integrating mod_perl with Apache 2.1 Authentication</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Geoffrey Young</span> on <abbr class="published" title="2003-07-08T00:00:00-08:00">July  8, 2003 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<h3>Scratching Your Own Itch</h3>

<p> Some time ago I became intrigued with <a href="ftp://ftp.isi.edu/in-notes/rfc2617.txt">Digest authentication</a>, which
uses the same general mechanism as the familiar Basic authentication scheme but
offers significantly more password security without requiring an SSL
connection. At the time it was really just an academic interest&mdash;while
some browsers supported Digest authentication, many of the more popular ones
did not.  Furthermore, even though the standard Apache distribution came with
modules to support both Basic and Digest authentication, Apache (and thus
mod_perl) only offered an API for interacting with Basic authentication. If you
wanted to use Digest authentication, flat files were the only password storage
medium available. With both of these restrictions, it seemed impractical to
deploy Digest authentication in all but the most limited circumstances.</p>

<p>Fast forward two years. Practically all mainstream browsers now support
Digest authentication, and my interest spawned what is now <a href="http://search.cpan.org/author/geoff/Apache-AuthDigest-0.022/">Apache::AuthDigest</a>,
a module that gives mod_perl 1.0 developers an API for Digest authentication
that is very similar to the Basic API that mod_perl natively supports. The one
lingering problem is probably not surprising&mdash;Microsoft Internet
Explorer. As it turns out, using the Digest scheme with MSIE requires a fully
RFC-compliant Digest implementation, and Apache::AuthDigest was patterned after
Apache 1.3's <code>mod_digest.c</code>, which is sufficient for most browsers
but not MSIE.</p>

<csperl file="grab" domain="on" record="b/832" template="b/article_sidebar.view">

<p>In my mind, opening up Digest authentication through mod_perl still needed
work to be truly useful, namely full RFC compliance to support MSIE. Wading
through RFCs is not how I like to spend my spare time, so I started searching
for a shortcut. Because Apache 2.0 did away with <code>mod_digest.c</code> and
replaced it with the fully compliant <code>mod_auth_digest.c</code>, I was
convinced that there was something in Apache 2.0 I could use to make my life
easier. In Apache 2.1, the development version of the next generation Apache
server, I found what I was looking for.</p>

<p>In this article, we're going to examine a mod_perl module that provides Perl
support for the new authentication provider hooks in Apache 2.1. These
authentication providers make writing Basic authentication handlers easier than
it has been in the past. At the same time, the new provider mechanism opens up
Digest authentication to the masses, making the Digest scheme a real
possibility for filling your dynamic authentication needs. While the material
is somewhat dense, the techniques we will be looking at are some of the most
interesting and powerful in the mod_perl arsenal. Buckle up.</p>

<p>To follow along with <a href="http://www.modperlcookbook.org/~geoff/perl.com/Apache-AuthenHook-2.00_01.tar.gz">the
code</a> in this article, you will need at least mod_perl version 1.99_10,
which is currently only available from CVS. You will also need <a href="http://httpd.apache.org/dev/">Apache 2.1</a>, which is also only
available from CVS. Instructions for obtaining the sources for both can be
found <a href="http://perl.apache.org/docs/2.0/user/install/install.html#Getting_Bleeding_Edge_CVS_Sources">here</a>.
When compiling Apache, keep in mind that the code presented here only works
under the <a href="http://httpd.apache.org/docs-2.0/mpm.html">prefork MPM</a>
&mdash; making it thread-safe is the next step in the adventure.</p>

<h3>Authentication Basics</h3>

<p>Because there is lots of material to cover, we'll skip over the requisite
introductory discussion of HTTP authentication, the Apache request cycle, and
other materials that probably already familiar and skip right to the mod_perl
authentication API. In both mod_perl 1.0 and mod_perl 2.0, the
<code>PerlAuthenHandler</code> represents Perl access to the Apache
authentication phase, where incoming user credentials are traditionally matched
to those stored within the application. A simple <code>PerlAuthenHandler</code>
in mod_perl 2.0 might look like the following.</p>

<pre><code>package My::BasicHandler;

use Apache::RequestRec ();
use Apache::Access ();

use Apache::Const -compile => qw(OK DECLINED HTTP_UNAUTHORIZED);

use strict;

sub handler {
  my $r = shift;

  # get the client-supplied credentials
  my ($status, $password) = $r->get_basic_auth_pw;

  # only continue if Apache says everything is OK
  return $status unless $status == Apache::OK;

  # user1/basic1 is ok
  if ($r->user eq 'user1' &amp;&amp; $password eq 'basic1') {
    return Apache::OK;
  }

  # user2 is denied outright
  if ($r->user eq 'user2') {
    $r->note_basic_auth_failure;
    return Apache::HTTP_UNAUTHORIZED;
  }

  # all others are passed along to the Apache default
  # handler, which reads from the AuthUserFile
  return Apache::DECLINED;
}

1;</code></pre>

<p>Although simple and impractical, this handler illustrates the API nicely.
The process begins with a call to <code>get_basic_auth_pw()</code>, which does
a few things behind the scenes. If a suitable Basic Authorization header is
found, <code>get_basic_auth_pw()</code> will parse and decode the header,
populate the user slot of the request record, and return <code>OK</code> along
with the user-supplied password in clear text. Any value other than
<code>OK</code> should be immediately propagated back to Apache, which
effectively terminates the current request.</p>

<p>The next step in the process is where the real authentication logic resides.
Our handler is responsible for digging out the username from
<code>$r->user()</code> and applying some criteria for determining whether the
user-supplied credentials are acceptable. If they are, the handler simply
returns <code>OK</code> and the request is allowed to proceed. If they are not,
the handler has a decision to make: either call
<code>note_basic_auth_failure()</code> and return
<code>HTTP_UNAUTHORIZED</code> (which is the same as the old
<code>AUTH_REQUIRED</code>) to indicate failure, or return
<code>DECLINED</code> to pass authentication control to the next authentication
handler.</p>

<p>For the most part, the mod_perl API is identical to the API Apache offers to
C module developers. The benefit that mod_perl adds is the ability to easily
extend authentication beyond Apache's default flat-file mechanism to the areas
where Perl support is strong, such as relational databases or LDAP.  However,
despite the versatility and strength programming the authentication phase
offered, I never liked the look and feel of the API.  While in some respects
the process is dictated by the nuances of <a href="ftp://ftp.isi.edu/in-notes/rfc2617.txt">RFC 2617</a> and the HTTP
protocol itself, the interface always struck me as somewhat inconsistent and
difficult for new users to grasp. Additionally, as already mentioned, the API
covers only Basic authentication, which is a real drawback as more and more
browsers support the Digest scheme.</p>

<p>Apparently I wasn't alone in some of these feelings. Apache 2.1 has taken
steps to improve the overall process for module developers. The result is a
new, streamlined API that focuses on a new concept: authentication
providers.</p>

<h3>Authentication Providers in Apache 2.1</h3>

<p>While in Apache 2.0 module writers were responsible for a large portion of
the authentication logic&mdash;calling routines to parse and set
authentication headers, digging out the user from the request record, and so on
&mdash; the new authentication mechanism in Apache 2.1 delegates all HTTP and
RFC logic out to two standard modules. <code>mod_auth_basic</code> handles
Basic authentication and is enabled in the default Apache build. The standard
<code>mod_auth_digest</code>, not enabled by default, handles the very complex
world of Digest authentication.  Regardless of the authentication scheme you
choose to support, these modules are responsible for the details of parsing and
interpreting the incoming request headers, as well as generating properly
formatted response headers.</p>

<p>Of course, managing authentication on an HTTP level is only part of the
story. What <code>mod_auth_basic</code> and <code>mod_auth_digest</code> leave
behind is the job of digging out the server-side credentials and matching them
to their incoming counterpart. Enter authentication providers.</p>

<p>Authentication providers are modules that supply server-side credential
services to <code>mod_auth_basic</code> or <code>mod_auth_digest</code>. For
instance, the default <code>mod_authn_file</code> digs the username and
password out of the flat file specified by the <code>AuthUserFile</code>
directive, similar to the default mechanism in Apache 1.3 and 2.0. An Apache
2.1 configuration that explicitly provides the same flat file behavior as
Apache 2.0 would look similar to the following.</p>

<pre><code>&lt;Location /protected>
  Require valid-user
  AuthType Basic
  AuthName realm1

  AuthBasicProvider file

  AuthUserFile realm1
&lt;/Location></code></pre>

<p>The new part of this configuration is the <code>AuthBasicProvider</code>
directive, which is implemented by <code>mod_auth_basic</code> and used to
specify the provider responsible for managing server-side credentials. There is
also a corresponding <code>AuthDigestProvider</code> directive if you have
<code>mod_auth_digest</code> installed.</p>

<p>While it could seem as though Apache 2.1 is merely adding another directive
to achieve essentially the same results, the shift to authentication providers
adds significant value for module developers: a new API that is far simpler
than before. Skipping ahead to the punch line, programming with new Perl API for
Basic authentication, which follows the Apache API almost exactly, would look
similar to the following.</p>

<pre><code>package My::BasicProvider;

use Apache::Const -compile => qw(OK DECLINED HTTP_UNAUTHORIZED);

use strict;

sub handler {
  my ($r, $user, $password) = @_;

  # user1/basic1 is ok
  if ($user eq 'user1' &amp;&amp; $password eq 'basic1') {
    return Apache::OK;
  }

  # user2 is denied outright
  if ($user eq 'user2') {
    return Apache::HTTP_UNAUTHORIZED;
  }

  # all others are passed along to the next provider
  return Apache::DECLINED;
}

1;</code></pre>

<p>As you can see, not only are the incoming username and password supplied in
the argument list, removing the need for <code>get_basic_auth_pw()</code> and
its associated checks, but gone is the need to call
<code>note_basic_auth_failure()</code> before returning
<code>HTTP_UNAUTHORIZED</code>. In essence, all that module writers need to be
concerned with is validating the user credentials against whatever back-end
datastore they choose. All in all, the API is a definite improvement. To add
even more excitement, the API for Digest authentication looks almost exactly
the same (but more on that later).</p>

<p>Because the new authentication provider approach represents a significant
change in the way Apache handles authentication internally, it is not part of
the stable Apache 2.0 tree and is instead being tested in the development tree.
Unfortunately, until the provider mechanism is backported to Apache 2.0, or an
official Apache 2.2 release, it is unlikely that authentication providers will
be supported by core mod_perl 2.0. However, this does not mean that mod_perl
developers are out of luck&mdash;by coupling mod_perl's native directive
handler API with a bit of XS, we can open up the new Apache provider API to
Perl with ease. The <a href="http://search.cpan.org/search?query=Apache::AuthenHook">Apache::AuthenHook</a>
module does exactly that.</p>

<h3>Introducing Apache::AuthenHook</h3>

<p>Over in the Apache C API, authentication providers have a few jobs to do:
they must register themselves by name as a provider while supplying a callback
interface for the schemes they wish to support (Basic, Digest, or both). In
order to open up the provider API to Perl modules our gateway module
Apache::AuthenHook will need to accomplish these tasks as well.  Both of these
are accomplished at the same time through a call to the official Apache API
function <code>ap_register_provider</code>.</p>

<p>Usually, mod_perl provides direct access to the Apache C API for us. For
instance, a Perl call to <code>$r->get_basic_auth_pw()</code> is proxied off to
<code>ap_get_basic_auth_pw</code>&mdash;but in this case
<code>ap_register_provider</code> only exists in Apache 2.1 and, thus, is not
supported by mod_perl 2.0.  Therefore, part of what Apache::AuthenHook needs to
do is open up this API to Perl. One of the great things about mod_perl is the
ease at which it allows itself to be extended even beyond its own core
functionality.  Opening up the Apache API past what mod_perl allows is
relatively easy with a dash of XS.</p>

<p>Our module opens with <code>AuthenHook.xs</code>, which is used to expose
<code>ap_register_provider</code> through the Perl function
<code>Apache::AuthenHook::register_provider()</code>.</p>

<pre><code>#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "mod_perl.h"
#include "ap_provider.h"
#include "mod_auth.h"

...

static const authn_provider authn_AAH_provider =
{
  &amp;check_password,
  &amp;get_realm_hash,
};

MODULE = Apache::AuthenHook    PACKAGE = Apache::AuthenHook

PROTOTYPES: DISABLE

void
register_provider(provider)
  SV *provider

  CODE:

    ap_register_provider(modperl_global_get_pconf(),
                         AUTHN_PROVIDER_GROUP,
                         SvPV_nolen(newSVsv(provider)), "0",
                         &amp;authn_AAH_provider);</code></pre>

<p>Let's start at the top. Any XS module you write will include the first three
header files, while any mod_perl XS extension will require at least
<code>#include "mod_perl.h"</code>. The remaining two included header files are
specific to what we are trying to accomplish&mdash;<code>ap_provider.h</code>
defines the <code>ap_register_provider</code> function, while
<code>mod_auth.h</code> defines the <code>AUTHN_PROVIDER_GROUP</code> constant
we will be using, as well as the <code>authn_provider</code> struct that holds
our callbacks.</p>

<p>Skipping down a bit, we can see our implementation of
<code>Apache::AuthenHook::register_provider()</code>. The <code>MODULE</code>
and <code>PACKAGE</code> declarations place <code>register_provider()</code>
into the <code>Apache::AuthenHook</code> package. Following that is the
definition of the <code>register_provider()</code> function itself.</p>

<p>As you can see, <code>register_provider()</code> accepts a single argument,
a Perl scalar representing the name of the provider to register, making its
usage something akin to the following.</p>

<pre><code>Apache::AuthenHook::register_provider('My::BasicProvider');</code></pre>

<p>The user-supplied name is then used in the call to
<code>ap_register_provider</code> from the Apache C API to register
<code>My::BasicProvider</code> as an authentication provider.</p>

<p>The twist in the process is that our implementation of
<code>ap_register_provider</code> registers Apache::AuthenHook's callbacks (the
<code>check_password</code> and <code>get_realm_hash</code> routines not shown
here) for each Perl provider. In essence, this means that Apache::AuthenHook
will be acting as go-between for Perl providers. Much in the same way that
mod_perl proper is called by Apache for each phase and dispatches to different
<code>Perl*Handlers</code>, Apache::AuthenHook will be called by Apache's
authentication modules and dispatch to the appropriate Perl provider at
runtime.</p>

<p>If this boggles your mind a bit, not to worry, it is only being presented to
give you a feel for the bigger picture and show how easy it is to open up
closed parts of the Apache C API with mod_perl and just a few lines of XS.
However, the fun part of Apache::AuthenHook (and the part that you are more
likely to use in your own mod_perl modules) is handled over in Perl space.</p>













<h4>Setting the Stage</h4>

<p>Now that we have the ability to call <code>ap_register_provider</code>, we
need to link that into the Apache configuration process somehow. What we do not
want to do is replace current <code>PerlAuthenHandler</code> functionality,
since that directive is for inserting authentication handler logic in place of
Apache's defaults.  In our case, we need the default modules to run so they can
call our Perl providers.  Instead, we want to make it possible for Perl modules
to register themselves as authentication providers. While we could have Perl
providers call our new <code>register_provider()</code> function directly,
Apache::AuthenHook chose to make the process transparent, using mod_perl's
directive handler API to call <code>register_provider()</code> silently as
<code>httpd.conf</code> is parsed.</p>

<p>Apache::AuthenHook makes sneaky use of directive handlers to extend the
default Apache <code>AuthBasicProvider</code> and
<code>AuthDigestProvider</code> directives so they register Perl providers
on-the-fly. The net result is that Perl providers will be fully registered and
configured via standard Apache directives, similar to the following.</p>

<pre><code>AuthBasicProvider My::BasicProvider file</code></pre>

<p>At configuration time, Apache::AuthenHook will intercept
<code>AuthBasicProvider</code> and register My::BasicProvider. At request time,
<code>mod_auth_basic</code> will attempt to authenticate the user, first using
My::BasicProvider, followed by the default file provider if My::BasicProvider
declines the request.</p>

<p>A nice side effect to this is that through our implementation we will be
giving mod_perl developers a feature they have never had before&mdash;the
ability to interlace Perl handlers and C handlers within the same phase.</p>

<pre><code>AuthDigestProvider My::DigestProvider file My::OtherDigestProvider</code></pre>

<p>Exciting, no? Let's take a look at <code>AuthenHook.pm</code> and see how
the directive handler API works in mod_perl 2.0.</p>

<h3>Directive Handlers with mod_perl</h3>

<p>Directive handlers are a very powerful but little used feature of mod_perl.
For the most part, their lack of use probably stems from the complex and
intimidating API in mod_perl 1.0. However, in mod_perl 2.0, the API is much
simpler and should lend itself to adoption by a larger audience.</p>

<p>The directive handler API allows mod_perl modules to define their own custom
configuration directives that are understood by Apache, For example, enabling
modules to make use of configuration variables like:</p>

<pre><code>Foo "bar"</code></pre>

<p>in <code>httpd.conf</code> requires only a few relatively simple settings
you can code directly in Perl.</p>

<p>While using directive handlers simply to replace <code>PerlSetVar</code>
behavior might seem a bit flashy, the techniques used by Apache::AuthenHook are
some of the most powerful mod_perl has to offer.</p>

<p>As previously mentioned, we will be extending the new
<code>AuthBasicProvider</code> and <code>AuthDigestProvider</code> directives
to apply to Perl providers as well, silently registering each provider as the
directive itself is parsed. To do this, we redefine these core directives,
manipulate their configuration data, then disappear and allow Apache to handle
the directives as if we were never there.</p>

<p>The code responsible for this is in <code>AuthenHook.pm</code>.</p>

<pre><code>package Apache::AuthenHook;

use 5.008;

use DynaLoader ();

use mod_perl 1.99_10;     # DECLINE_CMD and $parms->info support
use Apache::CmdParms ();  # $parms->info

use Apache::Const -compile => qw(OK DECLINE_CMD OR_AUTHCFG RAW_ARGS);

use strict;

our @ISA     = qw(DynaLoader);
our $VERSION = '2.00_01';

__PACKAGE__->bootstrap($VERSION);

our @APACHE_MODULE_COMMANDS = (
  { name         => 'AuthDigestProvider',
    errmsg       => 'specify the auth providers for a directory or location',
    args_how     => Apache::RAW_ARGS,
    req_override => Apache::OR_AUTHCFG,
    cmd_data     => 'digest' },

  { name         => 'AuthBasicProvider',
    errmsg       => 'specify the auth providers for a directory or location',
    args_how     => Apache::RAW_ARGS,
    req_override => Apache::OR_AUTHCFG,
    func         => 'AuthDigestProvider',
    cmd_data     => 'basic' },
);</code></pre>

<p>At the top of our module we import a few required items, some that are new
and some that should already be familiar. DynaLoader and the
<code>bootstrap()</code> method are required to pull in the
<code>register_provider()</code> function from our XS implementation and,
unlike with mod_perl 1.0, have nothing to do with the actual directive handler
implementation. The Apache::CmdParms class provides the <code>info()</code>
method we will be illustrating shortly, while Apache::Const gives us access to
the constants we will need throughout the process.</p>

<p>The <code>@APACHE_MODULE_COMMANDS</code> array is where the real interface
for directive handlers begins. <code>@APACHE_MODULE_COMMANDS</code> holds an
array of hashes, each of which defines the behavior of an Apache directive.
Let's focus on the first directive our handler implements,
<code>AuthDigestProvider</code>, forgetting for the moment that mod_auth_digest
also defines this directive.</p>

<p>While it should be obvious that the <code>name</code> key specifies the name
of the directive, it is not so obvious that it also specifies the default Perl
subroutine to call when Apache encounters <code>AuthDigestProvider</code> while
parsing <code>httpd.conf</code>.  Later on, we will need to implement the
<code>AuthDigestProvider()</code> subroutine, which will contain the logic for
all the activities we want to perform when Apache sees the
<code>AuthDigestProvider</code> directive.</p>

<p>The <code>args_how</code> and <code>req_override</code> are fields that tell
Apache specifically how the directive is supposed to behave in the
configuration. <code>req_override</code> defines how our directive will
interact with the core <a href="http://httpd.apache.org/docs-2.0/mod/core.html#allowoverride"><code>AllowOverride</code></a>
directive, in our case allowing <code>AuthDigestProvider</code> in
<code>.htaccess</code> files only on directories governed by
<code>AllowOverride AuthConfig</code>. Similarly, <code>args_how</code> defines
how Apache should interact with our <code>AuthDigestProvider()</code>
subroutine when it sees our directive in <code>httpd.conf</code>. In the case
of <code>RAW_ARGS</code>, it means that Apache will pass our callback whatever
follows the directive as a single string. Other possible values for both of
these keys can be found in the documentation pointed to at the end of this
article.</p>

<p>The final important key in our first hash is the <code>cmd_data</code> key,
in which we can store a string of our choosing.  This will become important in
a moment.</p>

<p>The second hash in <code>@APACHE_MODULE_COMMANDS</code> defines the behavior
of the <code>AuthBasicProvider</code> directive, which for the most part is
identical to <code>AuthDigestProvider</code>. The differences are important,
however, and begin with the addition of the <code>func</code> key. Although the
default Perl subroutine callback for handling directives is the same as the
name of the directive, the <code>func</code> key allows us to point to a
different subroutine instead.  Here we will be reusing
<code>AuthDigestProvider()</code> to process both directives. How will we know
which directive is actually being parsed?  The <code>cmd_data</code> slot will
contain <code>digest</code> when processing <code>AuthDigestProvider</code> and
<code>basic</code> when processing <code>AuthBasicProvider</code>.</p>

<p>At this point, we have defined what our directives will look like and how
they will interact with Apache in <code>httpd.conf</code>. What we have not
shown is the logic that sits behind our directives. As we mentioned, both of
our directives will be calling the Perl subroutine
<code>AuthDigestProvider</code>, defined in <code>AuthenHook.pm</code>.</p>

<pre><code>sub AuthDigestProvider {
  my ($cfg, $parms, $args) = @_;

  my @providers = split ' ', $args;

  foreach my $provider (@providers) {

    # if the provider looks like a Perl handler...
    if ($provider =~ m/::/) {

      # save the config for later
      push @{$cfg->{$parms->info}}, $provider;

      # and register the handler as an authentication provider
      register_provider($provider);
    }
  }

  # pass the directive back to Apache "unprocessed"
  return Apache::DECLINE_CMD;
}</code></pre>

<p>The first argument passed to our directive handler callback,
<code>$cfg</code>, represents the configuration object for our module, which we
can populate with whatever data we choose and access again at request time. The
second argument is an Apache::CmdParms object, which we will use to dig out the
string we specified in the <code>cmd_data</code> slot of our configuration hash
using the <code>info()</code> method.</p>

<p>While the first two arguments are standard and will be there for any
directive handler you write, the third argument can vary somewhat. Because we
specified <code>RAW_ARGS</code> as our <code>args_how</code> setting in the
configuration hash, <code>$args</code> contains everything on the
<code>httpd.conf</code> line following our directive. The standard
<code>Auth*Provider</code> directives we are overriding can take more than one
argument, so we split on whitespace and break apart the configuration into an
array of providers, each of which we then process separately.</p>

<p>Each provider is examined using a cursory check to see whether the specified
provider is a Perl provider. If the provider meets our criteria, we call the
<code>register_provider()</code> function defined in <code>AuthenHook.xs</code>
and keep track of the provider by storing it in our <code>$cfg</code>
configuration object.</p>

<p>The final part of our callback brings the entire process together.  The
constant <code>DECLINE_CMD</code> has special meaning to Apache. Just as you
might return <code>DECLINED</code> from a <code>PerlTransHandler</code> to
trick Apache into thinking no translation took place, returning
<code>DECLINE_CMD</code> from a directive handler tricks Apache into thinking
that the directive was unprocessed. So, after our
<code>AuthDigestProvider()</code> subroutine runs, Apache will continue along
until it finds <code>mod_auth_digest</code>, which will then process the
directive as though we were never there.</p>

<p>The one final piece of <code>AuthenHook.pm</code> that we need to discuss is
directive merging. In order to deal properly with situations when directives
meet, such as when <code>AuthBasicProvider</code> is specified in both an
<code>.htaccess</code> file as well as the <code>&lt;Location></code> that
governs the URI, we need to define <code>DIR_CREATE()</code> and
<code>DIR_MERGE()</code> subroutines.</p>

<p><code>DIR_CREATE()</code> is called at various times in the configuration
process, including when <code>&lt;Location></code> and related directives are
parsed at configuration time, as well as whenever an <code>.htaccess</code>
file enters the request cycle. This is where we create the <code>$cfg</code>
object our callback uses to store configuration data. While it is not required,
<code>DIR_CREATE()</code> is a good place to initialize fields in the object as
well, which prevents accidentally dereferencing nonexistent references.</p>

<pre><code>sub DIR_CREATE {
  return bless { digest => [],
                 basic  => [], }, shift;
}</code></pre>

<p><code>DIR_MERGE</code>, generally called at request time, defines how we
handle places where directives collide. The following code is standard for
allowing the current configuration (<code>%$base</code>) to inherit only
missing parameters from higher configurations (<code>%$add</code>), which is
the behavior you are most likely to want.</p>

<pre><code>sub DIR_MERGE {
  my ($base, $add) = @_;

  my %new = (%$add, %$base);

  return bless \%new, ref($base);
}

1;</code></pre>

<p>Thus ends <code>AuthenHook.pm</code>.</p>

<p>The final result is pretty amazing. By secretly intercepting the
<code>AuthDigestProvider</code> directive before <code>mod_auth_digest</code>
has the chance to process it, we have provided an interface that makes the
presence of Apache::AuthenHook all but undetectable. To enable the new provider
mechanism for mod_perl developers, all that is required is to load
Apache::AuthenHook using the new <code>PerlLoadModule</code> directive</p>

<pre><code>PerlLoadModule Apache::AuthenHook</code></pre>

<p>and their Perl providers will be magically inserted into the authentication
phase at the appropriate time.</p>













<h3>Taking a Step Back</h3>

<p>Let's recap what we have accomplished so far. <code>AuthenHook.pm</code>
redefines <code>AuthDigestProvider</code> and <code>AuthBasicProvider</code> so
that any Perl providers listed in the configuration are automagically
registered and inserted into the authentication process. At request time, one
of the default Apache authentication handlers will call on the configured
providers to supply server-side credentials. All registered Perl providers
really point to the callbacks in <code>AuthenHook.xs</code> which have the
arduous task of proxying the request for server-side credentials to the proper
Perl provider.  All in all, Apache::AuthenHook covers lots of ground, even if
the gory details of what happens over in XS land have been left out.</p>

<p>As we mentioned earlier, Apache::AuthenHook not only the ability to write
authentication providers in Perl, but it also follows the Apache API very
closely. While diving deep into the XS code that Apache::AuthenHook uses to
implement the <code>check_password</code> and <code>get_realm_hash</code>
callbacks is far beyond the scope of this article, you may find it interesting
that the callback signature for <code>check_password</code></p>

<pre><code>static authn_status check_password(request_rec *r, const char *user,
                                   const char *password)
{
  ...
}</code></pre>

<p>is practically identical to what Apache::AuthenHook passes on to Perl
providers supporting the Basic authentication scheme.</p>

<pre><code>sub handler {
  my ($r, $user, $password) = @_;

  ...
}</code></pre>

<p>If you recall, we started investigating the Apache 2.1 provider mechanism as
a way to combine the security of the Digest authentication scheme with the
strength of Perl. The signature for the Digest authentication callback,
<code>get_realm_hash</code>, is only slightly different than
<code>check_password</code>.</p>

<pre><code>static authn_status get_realm_hash(request_rec *r, const char *user,
                                   const char *realm, char **rethash)
{
  ...
}</code></pre>

<p>How does this translate into a Perl API? It is surprisingly simple.  As it
turns out, the name <code>check_password</code> is significant&mdash;for
Basic authentication, the provider is expected to take steps to see if the
incoming username and password match the username and password stored on the
server back-end. For Digest authentication, as the name
<code>get_realm_hash</code> might suggest, all a provider is responsible for is
retrieving the hash for a user at a given realm.  <code>mod_auth_digest</code>
does all the heavy lifting.</p>

<h3>Digest Authentication for the People</h3>

<p>While we didn't take the time to explain how Basic authentication over HTTP
actually works, briefly explaining Digest authentication is probably worth the
time, if only to allow you to appreciate the elegance of the new provider
mechanism.</p>

<p>When a request comes in for a resource protected by Digest authentication,
the server begins the process by returning a <code>WWW-Authenticate</code>
header that contains the authentication scheme, realm, a server generated
nonce, and various other bits of information. A fully RFC-compliant
<code>WWW-Authenticate</code> header might look like the following.</p>

<pre><code>WWW-Authenticate: Digest realm="realm1", 
nonce="Q9equ9C+AwA=195acc80cf91ce99828b8437707cafce78b11621", 
algorithm=MD5, qop="auth"</code></pre>

<p>On the client side, the username and password are entered by the end user
based on the authentication realm sent from the server. Unlike Basic
authentication, in which the client transmits the user's password practically
in the clear, Digest authentication never exposes the password over the wire.
Instead, both the client and server handle the user's credentials with care.
For the client, this means rolling up the user credentials, along with other
parts of the request such as the server-generated nonce and request URI, into a
single MD5 hash, which is then sent back to the server via the
<code>Authorization</code> header.</p>

<pre><code>Authorization: Digest username="user1", realm="realm1", 
qop="auth", algorithm="MD5", uri="/index.html",
nonce="Q9equ9C+AwA=195acc80cf91ce99828b8437707cafce78b11621", 
nc=00000001, cnonce="3e4b161902b931710ae04262c31d9307", 
response="49fac556a5b13f35a4c5f05c97723b32"</code></pre>

<p>The server, of course, needs to have its own copy of the user credentials
around for comparison. Now, because the client and server have had (at various
points in time) access to the same dataset&mdash;the user-supplied username
and password, as well as the request URI, authentication realm, and other
information shared in the HTTP headers&mdash;both ought to be able to
generate the same MD5 hash. If the hash generated by the server does not match
the one sent by the client in the <code>Authorization</code> header, the
difference can be attributed to the one piece of information not mutually
agreed upon through the HTTP request: the password.</p>

<p>As you can see from the headers involved, there is quite a lot of
information to process and interpret with the Digest authentication scheme.
However, if you recall, one of the benefits of the new provider mechanism is
that <code>mod_auth_digest</code> takes care of all the intimate details of the
scheme internally, relieving you from the burden of understanding it at
all.</p>

<p>All a Digest provider is required to do is match the incoming user and realm
to a suitable digest, stored in the medium of its choosing, and return it. With
the hash in hand, <code>mod_auth_digest</code> will do all the subsequent
manipulations and decide whether the hash the provider supplied is indeed
sufficient to allow the user to continue on its journey to the resource it is
after.</p>

<p>With that background behind us, we can proceed with a sample Perl Digest
provider.</p>

<pre><code>package My::DigestProvider;

use Apache::Log;

use Apache::Const -compile => qw(OK DECLINED HTTP_UNAUTHORIZED);

use strict;

sub handler {
  my ($r, $user, $realm, $hash) = @_;

  # user1 at realm1 is found - pass to mod_auth_digest
  if ($user eq 'user1' &amp;&amp; $realm eq 'realm1') {
    $$hash = 'eee52b97527306e9e8c4613b7fa800eb';
    return Apache::OK;
  }

  # user2 is denied outright
  if ($user eq 'user2' &amp;&amp; $realm eq 'realm1') {
    return Apache::HTTP_UNAUTHORIZED;
  }

  # all others are passed along to the next provider
  return Apache::DECLINED;
}

1;</code></pre>

<p>Note the only slight difference between the interface for Digest
authentication as compared to Basic authentication. Because the authentication
realm is an essential part of the Digest scheme, it is passed to our
<code>handler()</code> subroutine in addition to the request record,
<code>$r</code>, and username we received with the Basic scheme.</p>

<p>Knowing the username and authentication realm, our provider can choose
whatever method it desires to retrieve the MD5 hash associated with the user.
Returning the hash for comparison by <code>mod_auth_digest</code> is simply a
matter of populating the scalar referenced by <code>$hash</code> and returning
<code>OK</code>. While using references in this way may feel a bit strange, it
follows the same pattern as the official Apache C API, so I guess that makes it
ok.</p>

<p>If the user cannot be found, the provider can choose to return
<code>HTTP_UNAUTHORIZED</code> and deny access to the user, or return
<code>DECLINED</code> to pass authority for the user to the next provider.
Remember, unlike with the Perl handlers for all the other phases of the
request, you can intermix Perl providers with C providers, sandwiching the
default file provider with Perl providers of your own choosing.</p>

<p>The one question that remains is how to generate a suitable MD5 digest to
pass back to <code>mod_auth_digest</code>. For the default file provider, the
return digest is typically generated using the <code>htdigest</code> binary
that comes with the Apache installation. However, a Perl one-liner that can be
used to generate a suitable MD5 digest for Perl providers would look similar to
the following.</p>

<pre><code>$ perl -MDigest::MD5 -e'print Digest::MD5::md5_hex("user:realm:password")'</code></pre>

<p>That is all there is to it. No hash checking, no header manipulations, no
back flips or somersaults. Simply dig out the user credentials and pass them
along. At last, Digest authentication for the (Perl) people.</p>

<h3>Don't Forget the Tests!</h3>

<p>Of course, no module would be complete without a test suite, and the <a href="http://search.cpan.org/search?query=Apache-Test">Apache-Test</a>
framework introduced <a href="/pub/a/2003/05/22/testing.html">last time</a> gives us
all the tools we need to write a complete set of tests.</p>

<p>For the most part, the tests for Apache::AuthenHook are not that different
from those presented before. LWP supports Digest authentication natively, so
all our test scripts really need to do is make a request to a protected URI and
let LWP do all the work. Here is a snippet from one of the tests.</p>

<pre><code>plan tests => 10, (have_lwp &amp;&amp;
                   have_module('mod_auth_digest'));

my $url = '/digest/index.html';

$response = GET $url, username => 'user1', password => 'digest1';
ok $response->code == 200;</code></pre>

<p>When we plan the tests, we first check for the existence of
<code>mod_auth_digest</code>&mdash;both <code>mod_auth_basic</code> and
<code>mod_auth_digest</code> can be enabled or disabled for any given
installation, so we need to check for them where appropriate. Passing the
username and password credentials is pretty straightforward, using the
<code>username</code> and <code>password</code> keys after the URL when
formatting the request.</p>

<p>Actually, while the <code>username</code> and <code>password</code> keys
have special meaning, you can use the same technique to send any arbitrary
headers in the request.</p>

<pre><code># fetch the Last-Modified header from one response...
my $last_modified = $response->header('Last-Modified');

# and use it in the next request
$response = GET $uri, 'If-Modified-Since' => $last_modified;
ok ($response->code == HTTP_NOT_MODIFIED);</code></pre>

<p>That's something to note just in case you need that functionality sometime
later in your testing life.</p>

<p>One final note about our tests will apply to anyone writing a mod_perl XS
extension. Instead of using <code>extra.conf.in</code> to configure Apache, we
used <code>extra.last.conf.in</code>. The difference between the two is that
<code>extra.last.conf.in</code> is guaranteed to be loaded the last in the
configuration order&mdash;if our <code>PerlLoadModule</code> directive is
processed before mod_perl gets the chance to add the proper <code>blib</code>
entries, nothing will work, so ensuring our configuration is loaded after
everything else is in place is important.</p>

<h3>Whew</h3>

<p>mod_perl is truly exciting. With surprisingly little work, we have managed
to open an entire new world within Apache 2.1 to the Perl masses. I know of no
other blend of technologies that allow for such remarkable flexibility beyond
what each individually brings to the table. Hopefully, this article has not
only introduced you to new Apache and authentication concepts, but has also
brought to light ways in which you can leverage mod_perl that you never thought
of before.</p>

<h3>More Information</h3>

<p>I apologize if this article is a little on the heavy side, teasing you with
only cursory introductions to cool concepts while leaving out the finer
details. So, if you want to explore these concepts in more detail, I leave you
with the following required reading.</p>

<p>A nice overall introduction to the new provider mechanism can be found in <a href="http://www.serverwatch.com/tutorials/article.php/2202671">Safer Apache
Driving with AAA</a>. The mechanics of Basic authentication can be found in
lots of places, but decent explanations of Digest authentication are harder to
find. Both are covered to some level of detail in <a href="http://www.modperlcookbook.org/chapters/ch13.pdf">Chapter 13</a> of the
<a href="http://modperlcookbook.org/"><em>mod_perl Developer's
Cookbook</em></a>, which is freely available online. Recipe 13.8 in particular
includes the code that became the splinter in my mind and eventually this
article.</p>

<p>A more detailed explanation of directive handlers in mod_perl 2.0 can be
found in the <a href="http://perl.apache.org/docs/2.0/user/config/custom.html">mod_perl 2.0
documentation</a>. Although covering only mod_perl 1.0 directive handlers,
whose implementation is very different, <a href="http://modperl.com:9000/book/chapters/ch8.html">Chapter 8</a> in <a href="http://www.modperl.com/"><em>Writing Apache Modules with Perl and
C</em></a> and <a href="http://www.modperlcookbook.org/chapters/ch07.pdf">Recipes 7.8 through
7.11</a> in the <em>mod_perl Developer's Cookbook</em> provide excellent
explanations of concepts that are universal to both platforms, and are
essential reading if you plan on using directive handlers yourself. If you are
curious about the intricate details of directive merging, Chapter 21 in <a href="http://www.oreilly.com/catalog/apache3/">Apache: the Definitive Guide</a>
presents probably the most comprehensive explanation available.</p>

<p>Finally, if you are interested in the gory details of the XS that really
drives Apache::AuthenHook, there is no better single point of reference than <a href="http://www.manning.com/jenness/"><em>Extending and Embedding
Perl</em></a>, which was my best friend while writing this module and
absolutely deserves a place on your bookshelf.</p>

<h3>Thanks</h3>

<p>Many thanks to Stas Bekman and Philippe Chiasson for their feedback and
review of the several patches to mod_perl core that were required for the code
in this article, as well as to J&#246;rg Walter, who was kind enough to take
the time to review this article and give valuable feedback.</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1122" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2003/05/testing.html" rel="bookmark">Testing mod_perl 2.0</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Geoffrey Young</span> on <abbr class="published" title="2003-05-22T00:00:00-08:00">May 22, 2003 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->
<p></p>
<p><a href="/pub/a/2003/04/17/filters.html">Last time</a>, 
we looked at writing a simple Apache output filter -
<code>Apache::Clean</code> - 
using the mod_perl 2.0 API.  How did I know that the filter
I presented really worked?
I wrote a test suite for it, one that exercised
<a href="http://www.modperlcookbook.org/~geoff/perl.com/Apache-Clean-2.0.tar.gz">the code</a>
against a live Apache server
using the <code>Apache-Test</code> testing framework.
</p>

<p>
Writing a series of tests that executes against a live 
Apache server has become much simpler since the advent of
<code>Apache-Test</code>.  Although <code>Apache-Test</code>,
as part of the 
<a href="http://httpd.apache.org/test/">Apache HTTP Test Project</a>,
is generic enough to
be used with virtually any version of Apache (with or without 
mod_perl enabled), it comes bundled with mod_perl 2.0, making
it the tool of choice for writing tests for your
mod_perl 2.0 modules.
</p>

<csperl file="grab" domain="on" record="sc/1139" field="html">

<h3>Testing, Testing, 1, 2, 3</h3>

<p>
There are many advantages to writing tests.
For instance, maintaining the test suite as I coded <code>Apache::Clean</code>
allowed me to test each functional unit as I implemented it,
which made development easier.  The individual tests
also allowed me to be fairly certain that the module would
behave as expected once distributed.  As an added bonus,
tests offer additional end-user documentation in the form of 
test scripts, supporting libraries and configuration files,
available to anyone who wants to snoop around the distribution
a bit.  All in all, having a test suite increases the value of your
code exponentially, while at the same time making your life
easier.
</p>



<p>
Of course, these benefits come from having <i>any</i>
testing environment, and are not limited to just <code>Apache-Test</code>.
The particular advantage that <code>Apache-Test</code>
brings to the table is the ease at which it puts a whole,
pristine, and isolated Apache server at your disposal, 
allowing you to test and exercise
your code in a live environment with a minimum 
of effort.  No more <code>Apache::FakeRequest</code>, no
more <code>httpd.conf</code> configurations strewn across
development environments or corrupted with proof-of-concept
handlers that keep you busy following non-bugs for half a day. 
No more mess, no more tears.
</p>

<p>
If you have ever used tools like <code>Test.pm</code>
or <code>Test::More</code> as the basis for testing your modules, then
you already know most of what using <code>Apache-Test</code>
is going to look like.  In fact, <code>Apache-Test</code>
uses <code>Test.pm</code> under the hood, so the layout
and syntax are similar.  If you have never written
a test before, (and shame on you)then
<a href="/pub/a/2001/12/04/testing.html">An 
Introduction to Testing</a> provides a nice
overview of testing with Perl.  For the most part, though, 
<code>Apache-Test</code>
is really simple enough that you should be able to follow
along here without any trouble or previous knowledge.
</p>

<p>
Leveraging the <code>Apache-Test</code> framework requires
only a few steps - generating the test harness, configuring
Apache to your specific needs, and writing the tests - 
each of which is relatively straightforward.
</p>

<h3>Generating the Test Harness</h3>

<p>
The first step to using <code>Apache-Test</code>
is to tweak the <code>Makefile.PL</code> for your
module.  If you don't yet have a <code>Makefile.PL</code>,
or are not familiar with how to generate one, then don't worry - all that is required is a simple call to
<code>h2xs</code>, which provides us with a standard
platform both for distributing our module and
deploying the <code>Apache-Test</code> infrastructure.
</p>

<pre>
  <code>
$ <b>h2xs -AXPn Apache::Clean</b>
Defaulting to backward compatibility with perl 5.9.0
If you intend this module to be compatible with earlier perl versions, then please
specify a minimum perl version with the -b option.

Writing Apache/Clean/Clean.pm
Writing Apache/Clean/Makefile.PL
Writing Apache/Clean/README
Writing Apache/Clean/t/1.t
Writing Apache/Clean/Changes
Writing Apache/Clean/MANIFEST
  </code>
</pre>

<p>
<code>h2xs</code> generates the necessary structure
for our module, namely the <code>Clean.pm</code> template
and the <code>Makefile.PL</code>, as well as the 
<code>t/</code> subdirectory where our tests and supporting
files will eventually live.  You can take some extra
steps and shuffle the distribution around a bit (such
as removing <code>t/1.t</code> and putting everything
into <code>Apache-Clean/</code> instead of
<code>Apache/Clean/</code>) but it is not required.
Once you have the module layout sorted out and
have replaced the generated <code>Clean.pm</code> stub with
<a href="/pub/a/2003/04/17/filters.html">the
actual <code>Clean.pm</code> filter</a> from before,
it's time to start preparing the basic test harness.
</p>

<p>
To begin, we need to modify the <code>Makefile.PL</code> significantly.
The end result should look something like:</p>

<pre>
  <code>
#!perl

use 5.008;

use Apache2 ();
use ModPerl::MM ();
use Apache::TestMM qw(test clean);
use Apache::TestRunPerl ();

# configure tests based on incoming arguments
Apache::TestMM::filter_args();

# provide the test harness
Apache::TestRunPerl-&gt;generate_script();

# now, write out the Makefile
ModPerl::MM::WriteMakefile(
  NAME      =&gt; 'Apache::Clean',
  VERSION   =&gt; '2.0',
  PREREQ_PM =&gt; { HTML::Clean      =&gt; 0.8,
                 mod_perl         =&gt; 1.9909, },
);
  </code>
</pre>

<csperl file="grab" domain="on" record="b/832" template="b/article_sidebar.view">

<p>
Let's take a moment to analyze our nonstandard <code>Makefile.PL</code>.  We begin by importing
a few new mod_perl 2.0 libraries.  The first
is <code>Apache2.pm</code>.  In order to peacefully
co-exist with mod_perl 1.0 installations, mod_perl 2.0
gives you the option of installing mod_perl relative
to <code>Apache2/</code> in your <code>@INC</code>,
as to avoid collisions with 1.0 modules of the same name.
For instance,
the mod_perl 2.0 <code>Apache::Filter</code> we used
to write our output filter interface
would be installed as <code>Apache2/Apache/Filter.pm</code>.
Of course, ordinary calls that <code>require()</code> or
<code>use()</code> <code>Apache::Filter</code> in mod_perl 2.0 code
would fail to find
the correct version (if one was found at all), since
it was installed in a nonstandard place.
<code>Apache2.pm</code> extends <code>@INC</code> to
include any (existing) <code>Apache2/</code> directories
so that <code>use()</code> and related statements work as intended.
In our case, we need to <code>use() Apache2</code> in
order to ensure that, no matter how the end-user configured
his mod_perl 2.0 installation, we can find the rest of the 
libraries we need.
</p>

<p>
Secure in the knowledge that our <code>Makefile.PL</code>
will be able to find all our other mod_perl 2.0
packages (wherever they live), we can proceed.
<code>ModPerl::MM</code> provides the <code>WriteMakefile()</code>
function, which is similar to the <code>ExtUtils::MakeMaker</code>
function of the same name and takes the same options.
The reason that you will want to use the
<code>WriteMakefile()</code> from <code>ModPerl::MM</code> is that,
through means highly magical, all of your 
mod_perl-specific needs are satisfied.
For instance, your module will be installed relative to 
<code>Apache/</code> or <code>Apache2/</code>, depending
on how mod_perl itself is installed.  Other nice features
are automatic inclusion of mod_perl's <code>typemap</code>
and the header files required for XS-based modules, as well as magical
cross-platform compatibility for Win32 compilation, which has been 
troublesome in the past.  
</p>

<p>
Keep in mind that neither <code>Apache2.pm</code> nor
<code>ModPerl::MM</code> are required in order to use
<code>Apache-Test</code> -
both are packages specific to mod_perl 2.0 and any
handlers you may write for this version (as will be touched
on later, <code>Apache-Test</code> can be used for
mod_perl 1.0 based modules as well, or even
Apache 1.3 or 2.0 modules independent of mod_perl,
for that matter).  The next package, <code>Apache::TestMM</code>,
is where the real interface for <code>Apache-Test</code>
begins.
</p>

<p>
<code>Apache::TestMM</code>, contains
the functions we will need to configure the test harness.
The first thing we do is import the <code>test()</code>
and <code>clean()</code> functions, which generate their respective 
<code>Makefile</code> targets so that we can run 
(and re-run) our tests.
After that, we call the <code>filter_args()</code> function.  This allows
us to configure various parts of our tests on the command line
using different options, which will be discussed later.
</p>

<p>
The final part of our configuration uses the
<code>generate_script()</code> method 
from the <code>Apache::TestRunPerl</code> class, which writes
out the script responsible
for running our tests, <code>t/TEST</code>.  
It is <code>t/TEST</code> that will be invoked 
when a user issues <code>make test</code>, although
the script can be called directly as well.
While <code>t/TEST</code> can end up containing lots of
information, if you crack it open, then you would see that the
engine that really drives the test suite is rather simple.
</p>

<pre>
  <code>
use Apache::TestRunPerl ();
Apache::TestRunPerl-&gt;new-&gt;run(@ARGV);
  </code>
</pre>

<p>
Believe it or not, the single call to <code>run()</code> does all
intricate work of starting, configuring, and stopping Apache, 
as well as running the individual tests we (still) have
yet to define.
</p>

<p>
Despite the long explanations, the net result of our activity
thus far has been a few modifications to a typical
<code>Makefile.PL</code> so that
it reflects the needs of both our mod_perl 2.0 module and
our forthcoming use of the <code>Apache-Test</code> infrastructure.
Next, we need to configure Apache for the tests
specific to the functionality in our handler.
</p>

<h3>Configuring Apache</h3>

<p>
Ordinarily, there are many
things you need to stuff into <code>httpd.conf</code>
in order to get the server responding to requests, only
some of which are related to the content the
server will provide.
The <code>Apache-Test</code> framework provides a minimal
Apache configuration, such as default <code>DocumentRoot</code>,
<code>ErrorLog</code>, <code>Listen</code>, and other settings
required for normal operation of the server.  In fact, with no
intervention on your part, <code>Apache-Test</code>
provides a configuration that enables you to successfully request 
<code>/index.html</code> from the server.  Chances are,
though, that you will need something above a basic
configuration in order to test your module appropriately.
</p>

<p>
To add additional settings to the defaults, we create
the file <code>t/conf/extra.conf.in</code>, adding
any required directories along the way.  If 
<code>Apache-Test</code> sees <code>extra.conf.in</code>, then
it would pull the file into its default configuration
using an <code>Include</code> directive (after some
manipulations we will discuss shortly).  This provides
a nice way of adding only the configuration data you
require for your tests, and saves you from the need to
worry about the mundane aspects of running the server.
</p>

<p>
One of the first aspects of <code>Apache::Clean</code>
we should test is whether it can clean up a simple,
static HTML file.  So, we begin our <code>extra.conf.in</code>
with the following:
</p>

<pre>
  <code>
PerlSwitches -w

Alias /level @DocumentRoot@
&lt;Location /level&gt;
  PerlOutputFilterHandler Apache::Clean
  PerlSetVar CleanLevel 2
&lt;/Location&gt;
  </code>
</pre>

<p>
This activates our output filter for requests to
<code>/level</code>.  Note the introduction of a new
directive, <code>PerlSwitches</code>, which allows you to pass
command line switches to the embedded perl interpreter.
Here, we use it to enable warnings, similar to the
way that <code>PerlWarn</code> worked in mod_perl 1.0.
<code>PerlSwitches</code> can actually take
any perl command line switch, which makes it a fairly
useful and flexible tool.  For example, we could use the <code>-I</code>
switch to extend <code>@INC</code> in place of
adding <code>use lib</code> statements to a
<code>startup.pl</code>, or use <code>-T</code>
to enable taint mode in place of the former
<code>PerlTaintMode</code> directive, which
is not part of mod_perl 2.0.
</p>

<p>
Next, we come to the familiar <code>Alias</code>
directive, albeit with a twist.
As previously mentioned, <code>Apache-Test</code>
configures several defaults, including <code>DocumentRoot</code>
and <code>ServerRoot</code>.
One of the nice features of <code>Apache-Test</code>
is that it keeps track of its defaults for you and provides
some helpful variable expansions.  In my particular case,
the <code>@DocumentRoot@</code> variable in the
<code>Alias</code> directive is replaced
with the value of the default <code>DocumentRoot</code>
that <code>Apache-Test</code> calculated for my build.
The real configuration ends up looking like
</p>

<pre>
  <code>
Alias /level /src/perl.com/Apache-Clean-2.0/t/htdocs
  </code>
</pre>

<p>
when the tests are run.  This is handy, especially
when you take into consideration that your tests may
run on different platforms.
</p>

<p>
The rest of the configuration closely resembles our example
from last time - using the 
<code>PerlOutputFilterHandler</code> to specify 
<code>Apache::Clean</code> as our output filter, and
<code>PerlSetVar</code> to specify the specific 
<code>HTML::Clean</code> level.  The only thing missing 
before we have prepared our module enough to run our
first test is some testable content in <code>DocumentRoot</code>.
</p>

<p>
As you can see from the <code>@DocumentRoot@</code>
expansion in the previous example, <code>DocumentRoot</code>
resolves to <code><i>ServerRoot</i>/t/htdocs/</code>,
so that is one place where we can put any documents we are
interested in retrieving for our tests.  So, we create
<code>t/htdocs/index.html</code> and place some
useful content in it.
</p>

<pre>
  <code>
&lt;i    &gt;&lt;strong&gt;&amp;quot;This is a test&amp;quot;&lt;/strong&gt;&lt;/i   &gt;
  </code>
</pre>

<p>
Our <code>index.html</code> contains a number of
different elements that <code>HTML::Clean</code> can tidy,
making it useful for testing various configurations of <code>Apache::Clean</code>.
</p>

<p>
Now we have all the Apache configuration that is required:
some custom configuration directives in <code>t/conf/extra.conf.in</code>
and some useful content in <code>t/htdocs/index.html</code>.  All that
is left to do is write the tests.
</p>













<h3>Writing the Tests</h3>

<p>
The Apache configuration we have created thus far
provides a way to test 
<code>Apache::Clean</code> through 
<code>/level/index.html</code>.  The result of this
request should be that the default
Apache content handler serves up <code>index.html</code>,
applying our <code>PerlOutputFilterHandler</code> to
the file before it is sent over the wire.  Given the
configured <code>PerlSetVar CleanLevel 2</code> we would expect
the end results of the request to be
</p>

<pre>
  <code>
&lt;i&gt;&lt;b&gt;&amp;quot;This is a test&amp;quot;&lt;/b&gt;&lt;/i&gt;
  </code>
</pre>

<p>
where tags are shortened and whitespace removed but the
<code>&amp;quot;</code> entity is left untouched.  Well,
maybe this is not what <i>you</i> would have expected, but
cracking open the code for <code>HTML::Clean</code>
reveals that <code>level(2)</code> includes the
<code>whitespace</code> and <code>shortertags</code>
options, but not the <code>entities</code> option.  This
brings us to the larger issue of test design and the
possibility that flawed expectations can mask true bugs -
when a test fails, is the bug in the test or in the code? - 
but that is a discussion for another time.
</p>

<p>
Given our configuration and expected results, we can craft
a test that requests <code>/level/index.html</code>, 
isolates the content from the server response, then tests the content
against our expectations.  The file <code>t/01level.t</code>
shown here does exactly that.
</p>

<pre>
  <code>
use strict;
use warnings FATAL =&gt; 'all';

use Apache::Test qw(plan ok have_lwp);
use Apache::TestRequest qw(GET);
use Apache::TestUtil qw(t_cmp);

plan tests =&gt; 1, have_lwp;

my $response = GET '/level/index.html';
chomp(my $content = $response-&gt;content);

ok ($content eq q!&lt;i&gt;&lt;b&gt;&amp;quot;This is a test&amp;quot;&lt;/b&gt;&lt;/i&gt;!);
  </code>
</pre>

<p>
<code>t/01level.t</code> illustrates a few of the things 
that will be common to most of the tests you will write. 
First, we do some bookkeeping and plan the number of 
tests that will be attempted using the <code>plan()</code>
function from <code>Apache::Test</code> - in our case just one.
The final, optional argument to <code>plan()</code>
uses the <code>have_lwp()</code> function to check
for the availability of the modules from
the <code>libwww-perl</code> distribution.  If 
<code>have_lwp()</code> returns true, then we know we can 
take advantage of the <code>LWP</code> shortcuts <code>Apache::TestRequest</code>
provides.  If
<code>have_lwp()</code> returns false, then no tests are
planned and the entire test is skipped at runtime.
</p>

<p>
After planning our test, we use the shortcut function 
<code>GET()</code> from <code>Apache::TestRequest</code>
to issue a request to <code>/level/index.html</code>.
<code>GET()</code> returns an <code>HTTP::Response</code>
object, so if you are familiar with the <code>LWP</code> 
suite of modules you should feel right at home with 
what follows.  Using the object in <code>$response</code> we
isolate the server response using the <code>content()</code>
method and compare it against our expected string.  The 
comparison uses a call to <code>ok()</code>, which will
report success if the two strings are equivalent.
</p>

<p>
 Keep in mind that
even though this example explicitly imported 
the <code>plan()</code>, <code>ok()</code>,
<code>have_lwp()</code>, and <code>GET()</code>
functions into our test script, that was just to
illustrate the origins of the different parts of the
test - each of these functions, along with just about all
the others you may want, are exported by default.  So,
the typical test script will usually just call
</p>

<pre>
  <code>
use Apache::Test;
use Apache::TestRequest;
  </code>
</pre>

<p>
and go from there.
</p>

<p>
That is all there is to writing the test.  In its
simplest form, using <code>Apache-Test</code> involves
pretty much the same steps as when 
writing tests using other Perl testing tools: <code>plan()</code>
the number of tests in the script, do some stuff,
and call <code>ok()</code> for each test you <code>plan()</code>.
<code>Apache-Test</code> and its utility classes merely offer
shortcuts that make writing tests against a 
running Apache server idiomatic.
</p>

<h3>Running the Tests</h3>

<p>
With all the preparation behind us - generating and
customizing the <code>Makefile.PL</code>, configuring
Apache with <code>extra.conf.in</code>, writing
<code>index.html</code> and <code>01level.t</code> -
we have all the pieces in place and can (finally) run our test.
</p>

<p>
There are a few different ways we can run the
tests in a distribution, but all require that we go
through the standard build steps first.
</p>

<pre>
  <code>
$ <b>perl Makefile.PL -apxs /usr/local/apache2/bin/apxs</b>
Checking if your kit is complete ...
Looks good
Writing Makefile for Apache::Clean

$ <b>make</b>
cp Clean.pm blib/lib/Apache2/Apache/Clean.pm
Manifying blib/man3/Apache::Clean.3
  </code>
</pre>

<p>
<code>Makefile.PL</code> starts the process by generating the
<code>t/TEST</code> script via the call to
<code>Apache::TestRunPerl-&gt;generate_script()</code>.
The additional argument we pass, <code>-apxs</code>, is
trapped by <code>Apache::TestMM::filter_args()</code>
and is used to specify the Apache installation we want to 
test our code against.  Here, I use <code>-apxs</code> to
specify the location of the <code>apxs</code> binary
in my local Apache DSO installation - for
static builds you will want to use <code>-httpd</code> to
point to the <code>httpd</code> binary instead.  By the
time <code>Makefile.PL</code> exits,
we have our test harness and know where our server lives.
</p>

<p>
Running <code>make</code> creates our build directory,
<code>blib/</code>, and installs <code>Clean.pm</code>
locally so we can use it in our tests.  Note that 
<code>ModPerl::MM</code> installed <code>Clean.pm</code>
relative to <code>Apache2</code>, magically following
the path of my current mod_perl 2.0 installation.
</p>

<p>
At this point, we can run our tests.  Issuing
<code>make test</code> will run all the tests in 
<code>t/</code>, as you might expect.  However, 
we can run our tests individually as well, which is particularly
useful when debugging.  To run a specific test we call
<code>t/TEST</code> directly and give it the name of the
test we are interested in.
</p>

<pre>
  <code>
$ <b>t/TEST t/01level.t</b>
*** setting ulimit to allow core files
ulimit -c unlimited; t/TEST 't/01level.t'
/usr/local/apache2/bin/httpd  -d /src/perl.com/Apache-Clean-2.0/t 
    -f /src/perl.com/Apache-Clean-2.0/t/conf/httpd.conf 
	-DAPACHE2 -DPERL_USEITHREADS
using Apache/2.1.0-dev (prefork MPM)

waiting for server to start: ..
waiting for server to start: ok (waited 1 secs)
server localhost:8529 started
01level....ok                                                                
All tests successful.
Files=1, Tests=1,  4 wallclock secs ( 3.15 cusr +  0.13 csys =  3.28 CPU)
*** server localhost:8529 shutdown
  </code>
</pre>

<p>
As you can see, the server was started, our test was run,
the server was shutdown, and a report was generated - all with
what is really minimal work on our part.  Major kudos to the
<code>Apache-Test</code> developers for making the
development of live tests as easy as they are.
</p>

<h3>Beyond the Basics</h3>

<p>
What we have talked about so
far is just the basics, and the framework is full of a number
of different options designed to make writing and debugging tests
easier.  One of these is the <code>Apache::TestUtil</code> package,
which provides a number of utility functions you can use in your 
tests.  Probably the most helpful of these is <code>t_cmp()</code>,
a simple equality testing function that also provides 
additional information when you run tests in verbose mode.
For instance, after adding <code>use Apache::TestUtil;</code>
to our <code>01level.t</code> test, we can alter the call
to <code>ok()</code> to look like
</p>

<pre>
  <code>
ok t_cmp(q!&lt;i&gt;&lt;b&gt;&amp;quot;This is a test&amp;quot;&lt;/b&gt;&lt;/i&gt;!, $content);
  </code>
</pre>

<p>
and the result would include expected and received
notices (in addition to standard verbose output)
</p>

<pre>
  <code>
$ <b>t/TEST t/01level.t -v</b>
[lines snipped]
01level....1..1
# Running under perl version 5.009 for linux
# Current time local: Mon May  5 11:04:09 2003
# Current time GMT:   Mon May  5 15:04:09 2003
# Using Test.pm version 1.24
# expected: &lt;i&gt;&lt;b&gt;&amp;quot;This is a test&amp;quot;&lt;/b&gt;&lt;/i&gt;
# received: &lt;i&gt;&lt;b&gt;&amp;quot;This is a test&amp;quot;&lt;/b&gt;&lt;/i&gt;
ok 1
ok
All tests successful.
  </code>
</pre>

<p>
which is particularly helpful when debugging problems
reported by end users of your code.  See the 
<code>Apache::TestUtil</code> manpage for a long
list of helper functions, as well as the <code>README</code>
in the <code>Apache-Test</code> distribution for
additional command line options over and above
<code>-v</code>.
</p>

<p>
Of course, <code>01level.t</code> only tests one
aspect of our <code>Clean.pm</code> output filter, 
and there is much more functionality in the filter that
we might want verify.  So, let's take a quick look at some 
of the other tests that accompany the <code>Apache::Clean</code>
distribution.
</p>

<p> 
One of the features of <code>Apache::Clean</code> is that
it automatically declines processing non-HTML documents.
The logic for this was defined in just a few lines at
the start of our filter.
</p>

<pre>
  <code>
# we only process HTML documents
unless ($r-&gt;content_type =~ m!text/html!i) {
  $log-&gt;info('skipping request to ', $r-&gt;uri, ' (not an HTML document)');

  return Apache::DECLINED;
}
  </code>
</pre>

<p> 
A good test for this code would be verifying that content from a plain-text
document does indeed pass through our filter unaltered, even
if it has HTML tags that <code>HTML::Clean</code> would
ordinary manipulate. 
Our test suite includes a file <code>t/htdocs/index.txt</code>
whose content is identical to the <code>index.html</code> file
we created earlier.  Remembering that we already have an 
Apache configuration for <code>/level</code> that inserts
our filter into the request cycle, we can use a request for
<code>/level/index.txt</code> to test the decline logic.
</p>

<pre>
  <code>
use Apache::Test;
use Apache::TestRequest;

plan tests =&gt; 1, have_lwp;

my $response = GET '/level/index.txt';
chomp(my $content = $response-&gt;content);

ok ($content eq q!&lt;i&gt;&lt;strong&gt;&amp;quot;This is a test&amp;quot;&lt;/strong&gt;&lt;/i&gt;!);
  </code>
</pre>

<p>
It may be obvious, but if you think about what we are 
really testing here it is not that the content is
unaltered - that is just what we use to measure
the success of our test.  The real test is against the criterion
that determines whether the filter acts on the content.
If we wanted to be really thorough, then we could add
</p>

<pre>
  <code>
AddDefaultCharset On
  </code>
</pre>

<p>
to our <code>extra.conf.in</code> to test the <code>Content-Type</code>
logic against headers that look like <code>text/html; charset=iso-8859-1</code>
instead of just <code>text/html</code>.  I actually have had
more than one person comment that using a regular expression for testing the
<code>Content-Type</code> is excessive - adding the
<code>AddDefaultCharset On</code> directive shows that
the regex logic can handle more runtime environments than a simple
<code>$r-&gt;content_type eq 'text/html'</code> check.  Oh,
the bugs you will find, fix, and defend when 
you start writing tests.
</p>













<h3>More and More Tests</h3>

<p> 
What other aspects of the filter can we put to the test?
If you recall from our discussion of output filters last
time, one of the responsibilities of filters that alter
content is to remove the generated <code>Content-Length</code>
header from the server response.  The relevant code for this
in our filter was as follows.
</p>

<pre>
  <code>
# output filters that alter content are responsible for removing
# the Content-Length header, but we only need to do this once.
$r-&gt;headers_out-&gt;unset('Content-Length');
  </code>
</pre>

<p>
Here is the test for this bit of logic, which checks that the
<code>Content-Length</code> header is indeed present for plain documents,
but removed by our filter for HTML documents.  Again, we will
be using the existing <code>/level</code> URI to request
both <code>index.txt</code> and <code>index.html</code>.
</p>

<pre>
  <code>
use Apache::Test;
use Apache::TestRequest;

plan tests =&gt; 2, have_lwp;

my $response = GET '/level/index.txt';
ok ($response-&gt;content_length == 58);

$response = GET '/level/index.html';
ok (! $response-&gt;content_length);
  </code>
</pre>

<p>
Note the use of the <code>content_length()</code>
method on our <code>HTTP::Response</code> object to retrieve
the <code>Content-Length</code> of the server response.  Remember
that you have all the methods from that class to choose from
in your tests.
</p>

<p>
The final test we will take a look at is
the example we used previous time to illustrate our filter
does indeed co-exist with both mod_include and mod_cgi.
As it turns out, the example was taken right from the
test suite (always a good place from which to 
draw examples).  Here is the <code>extra.conf.in</code>
snippet.
</p>

<pre>
  <code>
Alias /cgi-bin @ServerRoot@/cgi-bin
&lt;Location /cgi-bin&gt;
  SetHandler cgi-script

  SetOutputFilter INCLUDES
  PerlOutputFilterHandler Apache::Clean

  PerlSetVar CleanOption shortertags
  PerlAddVar CleanOption whitespace
  Options +ExecCGI +Includes
&lt;/Location&gt;
  </code>
</pre>
 
<p>
The nature of our test requires that both mod_include
and a suitable CGI platform (either mod_cgi or mod_cgid)
be available to Apache -
without both of these, our tests are doomed to failure,
so we need a way to test whether these modules are available
to the server before planning the individual tests.
Also required are some CGI scripts, the location 
of which is specified by expanding <code>@ServerRoot@</code>.
To include these scripts, we could 
just create a <code>t/cgi-bin/</code> directory and
place the relevant files in it.  However, 
any CGI scripts we create would probably
include a platform-specific shebang line like
<code>#!/usr/bin/perl</code>.  A better solution is to
generate the scripts on-the-fly, specifying a shebang
line that matches the version of Perl we are using
to build and test the module.
</p>

<p>
Despite the extra work required,
the test script used for this test is only
a bit more complex than others we have seen so far.
</p>

<pre>
  <code>
use Apache::Test;
use Apache::TestRequest;
use Apache::TestUtil qw(t_write_perl_script);

use File::Spec::Functions qw(catfile);

plan tests =&gt; 4, (have_lwp &amp;&amp; 
                  have_cgi &amp;&amp;
                  have_module('include'));

my @lines = &lt;DATA&gt;;
t_write_perl_script(catfile(qw(cgi-bin plain.cgi)), @lines[0,2]);
t_write_perl_script(catfile(qw(cgi-bin include.cgi)), @lines[1,2]);

my $response = GET '/cgi-bin/plain.cgi';
chomp(my $content = $response-&gt;content);

ok ($content eq q!&lt;strong&gt;/cgi-bin/plain.cgi&lt;/strong&gt;!);
ok ($response-&gt;content_type =~ m!text/plain!);

$response = GET '/cgi-bin/include.cgi';
chomp($content = $response-&gt;content);

ok ($content eq q!&lt;b&gt;/cgi-bin/include.cgi&lt;/b&gt;!);
ok ($response-&gt;content_type =~ m!text/html!);

__END__
print &quot;Content-Type: text/plain\n\n&quot;;
print &quot;Content-Type: text/html\n\n&quot;;
print '&lt;strong&gt;&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt;&lt;/strong&gt;';
  </code>
</pre>

<p>
The first thing to note is that we have joined the familiar
call to <code>have_lwp()</code> with additional calls
to <code>have_cgi()</code> and <code>have_module()</code>.
The <code>Apache::Test</code> package comes with a number
of handy shortcuts for querying the server for
information.  <code>have_cgi()</code> returns true
if either mod_cgi or mod_cgid are installed.
<code>have_module()</code> is more generic and can
be used to test for either Apache C modules or Perl modules - 
for instance, <code>have_module('Template')</code> could
be used to check whether the 
<a href="http://template-toolkit.org/"><code>Template Toolkit</code></a>
is installed.
</p>

<p>
For generation of the CGI scripts, we use the <code>t_write_perl_script()</code>
function from the <code>Apache::TestUtil</code> package.
<code>t_write_perl_script()</code> takes two arguments, the
first of which is the name of the file to generate, relative to the
<code>t/</code> directory in the distribution.  If the
file includes a path, any necessary directories are automatically
created.  In the interests of portability, we use
<code>catfile()</code> from the <code>File::Spec::Functions</code>
package to join the file with the directory.  In general,
you will want to keep <code>File::Spec</code> and its
associated classes in mind when writing your tests - you never
know when somebody is going to try and run them on 
Win32 or VMS.  The second argument to <code>t_write_perl_script()</code>
is a list of lines to append to the file after the (calculated) 
shebang line. 
</p>

<p>
Although <code>t_write_perl_script()</code> cleans up any 
generated files and directories when the test completes, if we were to 
intercept <code>include.cgi</code> before removal
it would look similar to something we would have written
ourselves.
</p>

<pre>
  <code>
#!/src/bleedperl/bin/perl
# WARNING: this file is generated, do not edit
# 01: /src/bleedperl/lib/site_perl/5.9.0/i686-linux-thread-multi/
      Apache/TestUtil.pm:129
# 02: 06mod_cgi.t:18
print &quot;Content-Type: text/html\n\n&quot;;
print '&lt;strong&gt;&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt;&lt;/strong&gt;';
  </code>
</pre>

<p>
As you probably have guessed by now, just as we 
ran tests against scripts in the (generated) 
<code>t/cgi-bin/</code> directory, we can add other directories
to <code>t/</code> for other kinds of tests.
For instance, we can create <code>t/perl-bin/</code>
to hold standard <code>ModPerl::Registry</code> scripts
(remember, you don't need to generate a shebang
line for those).
We can even create <code>t/My/</code> to hold a custom
<code>My::ContentGenerator</code> handler, which can be used just
like any other Perl module during Apache's runtime.
All in all, you can simulate practically any
production environment imaginable.
</p>

<h3>But Wait, There's More!</h3>

<p>
The tests presented here should be enough to get
you started writing tests for your own modules, but
they are only part of the story.  If you are interested
in seeing some of the other tests written to support this article, the
<a href="http://www.modperlcookbook.org/~geoff/perl.com/Apache-Clean-2.0.tar.gz"><code>Apache::Clean</code>
distribution</a> is full
of all kinds of different tests and test approaches, including some
that integrate custom handlers as well as one that tests
the POD syntax for the module.  In fact, you will find 26 different
tests in 12 test files there, free for the taking.
</p>

<p>
Stuck using mod_perl 1.0?  One of the best things about <code>Apache-Test</code>
is that it is flexible and intelligent enough to be
used for mod_perl 1.0 handlers as well.
In fact, the <a href="http://search.cpan.org/~stas/Apache-Test-1.01/">recent
release</a> of <code>Apache-Test</code> as a CPAN module
outside of the mod_perl 2.0 distribution makes it even
easier for all mod_perl developers to take advantage of
the framework.  For the most part, the instructions in
this article should be enough to get you going writing
tests for 1.0-based modules - the only changes specific to
1.0 modules rest in the <code>Makefile.PL</code>.  I took
the time to whip up
a version of <code>Apache::Clean</code> for mod_perl 1.0 that
parallels the functionality in these articles,
which you can find
<a href="http://www.modperlcookbook.org/~geoff/perl.com/Apache-Clean-2.0.tar.gz">next to</a>
the 2.0 version.  The 1.0 distribution runs against
the exact same <code>*.t</code> files (where applicable)
and includes a sample 1.0 <code>Makefile.PL</code>.
</p>

<p>
Personally, I don't know how I ever got along without 
<code>Apache-Test</code>, and I'm sure that once you start using
it you will feel the same.  Secretly, I'm hoping that 
<code>Apache-Test</code> becomes so popular that end-users
start wrapping their bug reports up in little, self-contained,
<code>Apache-Test</code>-based tarballs so anyone
can reproduce the problem.
</p>

<h3>More Information</h3>

<p>
This article was derived from Recipe 7.7 in the 
<a href="http://www.modperlcookbook.org/"><i>mod_perl Developer's Cookbook</i></a>, 
adjusted to accommodate both mod_perl 2.0 and changes in the overall 
<code>Apache-Test</code> interface that have happened
since publication.  Despite these differences, the recipe 
is useful for its additional descriptions and coverage
of features not discussed here.  You can read Recipe 7.7, as well
as <a href="http://www.modperlcookbook.org/chapters/ch07.pdf">the rest
of Chapter 7</a> from the book's <a href="http://www.modperlcookbook.org/">website</a>.
Also, in addition to the
<a href="http://search.cpan.org/~stas/Apache-Test-1.01/lib/Apache/Test.pm"><code>Apache-Test</code></a>
manpage and 
<a href="http://search.cpan.org/src/STAS/Apache-Test-1.01/README"><code>README</code></a>
there is also the <code>Apache-Test</code> tutorial on
the <a href="http://perl.apache.org/docs/general/testing/testing.html">mod_perl
Project website</a>, all of which are valuable sources of information.
</p>

<h3>Thanks</h3>

<p>
The <code>Apache-Test</code> project is the result of the tireless efforts of many, many
developers - far too many to name individually here.  However, there has has been a recent 
surge of activity as <code>Apache-Test</code> made its way to CPAN, especially in making
it more platform aware and solving a few back compatibility problems with the old
<code>Apache::test</code> that ships with mod_perl 1.0.  Special thanks are due 
to Stas Bekman, David Wheeler, and Randy Kobes for helping to polish
<code>Apache-Test</code> on Win32 and Mac OS X without requiring
major changes to the API.
</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/modules/">&laquo; Modules</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/music/">Music &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
