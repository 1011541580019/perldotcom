<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: User Interfaces Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>User Interfaces</em> Category</h1>






                            
                            <div id="entry-696" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/07/lightning-articles.html" rel="bookmark">Still More Perl Lightning Articles</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">chromatic</span> on <abbr class="published" title="2006-07-13T00:00:00-08:00">July 13, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>It has been common practice within the Perl community for ages to ship distributions with a <em>Makefile.PL</em> so that the user will be able to install the packages when he retrieves them, either via the shell which the <code>CPAN/CPANPLUS</code> modules offer or via manual CPAN download.</p>

<p>The <em>Makefile.PL</em> consists of meta-information, which in the case of the distribution <a href="http://search.cpan.org/perldoc?HTML::Tagset"><code>HTML::Tagset</code></a> is:</p>

<pre><code> # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See "perldoc perlmodinstall" or "perldoc ExtUtils::MakeMaker" for
 # info on how to control how the installation goes.

 require 5.004;
 use strict;
 use ExtUtils::MakeMaker;

 WriteMakefile(
     NAME            =&gt; 'HTML::Tagset',
     AUTHOR          =&gt; 'Andy Lester &lt;andy@petdance.com&gt;',
     VERSION_FROM    =&gt; 'Tagset.pm', # finds $VERSION
     ABSTRACT_FROM   =&gt; 'Tagset.pm', # retrieve abstract from module
     PMLIBDIRS       =&gt; [qw(lib/)],
     dist            =&gt; { COMPRESS =&gt; 'gzip -9f', SUFFIX =&gt; 'gz', },
     clean           =&gt; { FILES =&gt; 'HTML-Tagset-*' },
 );</code></pre>

<p>Of interest are the arguments to <code>WriteMakefile()</code>, because they influence the <em>Makefile</em> written by <code>ExtUtils::MakeMaker</code> after the user has invoked the usual build and install procedure:</p>

<pre><code> % perl Makefile.PL
 % make
 % make test
 # make install</code></pre>

<h3><code>Module::Build</code>, Successor of <code>ExtUtils::MakeMaker</code>?</h3>

<p>As Ken Williams grew tired of <a href="http://search.cpan.org/perldoc?ExtUtils::MakeMaker"><code>ExtUtils::MakeMaker</code></a> and its portability issues, he invented <a href="http://search.cpan.org/perldoc?Module::Build"><code>Module::Build</code></a>, a successor of <code>ExtUtils::MakeMaker</code>. One goal of <code>Module::Build</code> is to run smoothly on most operating systems, because it takes advantage of creating Perl-valid syntax files only and does not rely upon crufty <em>Makefiles</em>, which are often subject to misinterpretation, because so many incompatible flavors of <code>make</code> exist in the wild.</p>

<p>The current maintainer of <code>ExtUtils::MakeMaker</code>, Michael G. Schwern, elaborated about this problem in his talk reachable via "<a href="http://mungus.schwern.org/~schwern/talks/MakeMaker_Is_DOOMED/slides/">MakeMaker is DOOMED</a>."</p>

<h3><code>Module::Build</code> Distribution "Skeleton"</h3>

<p>If you take in consideration the distribution <code>HTML::Tagset</code> again, the rough skeleton suitable for <code>Module::Build</code> having converted the <em>Makefile.PL</em> by <a href="http://search.cpan.org/perldoc?Module::Build::Convert"><code>Module::Build::Convert</code></a> into a <em>Build.PL</em>, the output would be:</p>

<pre><code> # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See "perldoc perlmodinstall" or "perldoc ExtUtils::MakeMaker" for
 # info on how to control how the installation goes.
 # Note: this file has been initially generated by Module::Build::Convert 0.24_01

 require 5.004;
 use strict;
 use warnings;

 use Module::Build;

 my $build = Module::Build-&gt;new
   (
    module_name =&gt; 'HTML::Tagset',
    dist_author =&gt; 'Andy Lester &lt;andy@petdance.com&gt;',
    dist_version_from =&gt; 'Tagset.pm',
    add_to_cleanup =&gt; [
                        'HTML-Tagset-*'
                      ],
    license =&gt; 'unknown',
    create_readme =&gt; 1,
    create_makefile_pl =&gt; 'traditional',
   );
  
 $build-&gt;create_build_script;</code></pre>

<p>As you can see, while <code>ExtUtils::MakeMaker</code> prefers uppercased arguments, <code>Module::Build</code> goes by entirely lowercased arguments, which obey the rule of least surprise by being as intuitive as a description can be.</p>

<p>The build and installation procedure for a <code>Module::Build</code> distribution is:</p>

<pre><code> % perl Build.PL
 % perl Build
 % perl Build test
 # perl Build install</code></pre>

<h3><code>Module::Build::Convert</code>'s State of Operation</h3>

<p><code>Module::Build::Convert</code> actually does all of the background work and can be safely considered the back end, whereas <code>make2build</code> is the practical front-end utility. <code>Module::Build::Convert</code> currently exposes two kinds of operation: static approach and dynamic execution. The static approach parses the arguments contained within the <em>Makefile.PL's</em> <code>WriteMakefile()</code> call, whereas dynamic execution runs the <em>Makefile.PL</em> and captures the arguments provided to <code>WriteMakefile()</code>.</p>

<p><code>Module::Build::Convert</code> parses statically by default, because the dynamic execution has the downside that code will be interpreted and the interpreted output will be written to the <em>Build.PL</em>, so you have to conclude that the user of the distribution will end up with predefined values computed on the author's system. This is something to avoid, whenever possible! If the parsing approach fails, perhaps looping endlessly on input, <code>Module::Build::Convert</code> will reinitialize to perform dynamic execution of the <em>Makefile.PL</em> instead.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1748" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3><a id="data_section" name="data_section">Data Section</a>
</h3>

<p><code>Module::Build::Convert</code> comes with a rather huge data section containing the argument conversion table, default arguments, sorting order, and begin and end code. If you wish to change this data, consider making a <em>~/.make2buildrc</em> file by launching <code>make2build</code> with the <code>-rc</code> switch. <em>Do not</em> edit the <code>Data</code> section within <code>Module::Build::Convert</code> directly, unless you are sure you want to submit a patch.</p>

<h4>Argument Conversion</h4>

<p>On the left-hand side is the <code>MakeMaker</code>'s argument name, and on the right-hand side the <code>Module::Build</code>'s equivalent.</p>

<pre><code> NAME                  module_name
 DISTNAME              dist_name
 ABSTRACT              dist_abstract
 AUTHOR                dist_author
 VERSION               dist_version
 VERSION_FROM          dist_version_from
 PREREQ_PM             requires
 PL_FILES              PL_files
 PM                    pm_files
 MAN1PODS              pod_files
 XS                    xs_files
 INC                   include_dirs
 INSTALLDIRS           installdirs
 DESTDIR               destdir
 CCFLAGS               extra_compiler_flags
 EXTRA_META            meta_add
 SIGN                  sign
 LICENSE               license
 clean.FILES           @add_to_cleanup</code></pre>

<h4>Default Arguments</h4>

<p>These are default <code>Module::Build</code> arguments to added. Arguments with a leading <code>#</code> are ignored.</p>

<pre><code> #build_requires       HASH
 #recommends           HASH
 #conflicts            HASH
 license               unknown
 create_readme         1
 create_makefile_pl    traditional</code></pre>

<h4>Sorting Order</h4>

<p>This is the sorting order for <code>Module::Build</code> arguments.</p>

<pre><code> module_name
 dist_name
 dist_abstract
 dist_author
 dist_version
 dist_version_from
 requires
 build_requires
 recommends
 conflicts
 PL_files
 pm_files
 pod_files
 xs_files
 include_dirs
 installdirs
 destdir
 add_to_cleanup
 extra_compiler_flags
 meta_add
 sign
 license
 create_readme
 create_makefile_pl</code></pre>

<h4>Begin Code</h4>

<p>Code that precedes converted <code>Module::Build</code> arguments. <code>$(UPPERCASE)</code> are stubs being substituted by <code>Module::Build</code> code.</p>

<pre><code> use strict;
 use warnings;

 use Module::Build;

 $MAKECODE

 my $b = Module::Build-&gt;new
 $INDENT(</code></pre>

<h4>End Code</h4>

<p>Code that follows converted <code>Module::Build</code> arguments. <code>$(UPPERCASE)</code> are stubs being substituted by <code>Module::Build</code> code.</p>

<pre><code> $INDENT);

 $b-&gt;create_build_script;

 $MAKECODE</code></pre>

<h3><code>make2build</code> Basic Usage</h3>

<p>Using <code>make2build</code> is as easy as launching it in the directory of the distribution of which <em>Makefile.PL</em> you wish to convert.</p>

<p>For example:</p>

<pre><code>% make2build</code></pre>

<p>You may also provide the full path to the distribution, assuming, for example, you didn't <code>cd</code> directly into the distribution directory.</p>

<pre><code>% make2build /path/to/HTML-Tagset*</code></pre>

<p>In both cases, the command will convert any found <em>Makefile.PL</em> files and will generate no output because <code>make2build</code> acts quiet by default.</p>

<h3><code>make2build</code> Switches</h3>

<p>As <code>make2build</code> aims to be a proper script, it of course, provides both the <code>-h</code> (help screen) and <code>-V</code> (version) switches.</p>

<pre><code> % make2build -h
 % make2build -V</code></pre>

<p>In case you end up with a mangled <em>Build.PL</em> written, you can examine the parsing process by launching <code>make2build</code> with the <code>-d</code> switch, enabling the pseudo-interactive debugging mode.</p>

<pre><code> % make2build -d</code></pre>

<p>Should you not like the indentation length or judge it to be too small, increase it via the <code>-l</code> switch followed by an integer.</p>

<pre><code> % make2build -l length</code></pre>

<p>If you don't agree with the sorting order predefined in <code>Module::Build::Convert</code>, you may enforce the native sorting order, which strives to arrange standard arguments with those seen available in the <code>Makefile.PL</code>.</p>

<pre><code> % make2build -n</code></pre>

<p>The argument conversion table, default arguments to add, the sorting order of the arguments, and the begin and end code aren't absolute, either. Change them by invoking <code>make2build</code> with the <code>-rc</code> switch to create a resource configuration file in the home directory of the current user; that is likely <em>~/.make2build.rc</em>.</p>

<pre><code> % make2build -rc</code></pre>

<p>While <code>make2build</code> is quiet by default, there are two verbosity levels. To enforce verbosity level 1, launch <code>make2build</code> with <code>-v</code>. To enforce verbosity level 2, use <code>-vv</code>.</p>

<p>With <code>-v</code>, the code will warn about <em>Makefile.PL</em> options it does not understand or skips. With <code>-vv</code>, it will accumulate <code>-v</code> output and the entire generated <em>Build.PL</em>.</p>

<pre><code> % make2build -v
 % make2build -vv</code></pre>

<p>You may execute the <em>Makefile.PL</em> in first place, but such usage is deprecated because <code>Module::Build::Convert</code> downgrades automatically when needed.</p>

<pre><code> % make2build -x (deprecated)</code></pre>













<h3>Swinging with Perl</h3>

<p>Phil Crow</p>

<p>Perl does not have a native graphical user interface (GUI) toolkit. So we use all manner of existing GUI tools in front of our Perl applications. Often we use a web browser. We have long had Perl/Tk and other libraries based on C/C++. Now we can also use Java's Swing toolkit with similar ease.</p>

<p>In my sample application, when the user presses a button, Perl evaluates an arithmetic expression from the input text box. The result appears in another text box. I'll show the code for this application a piece at a time with a discussion after each piece. To see the whole thing, look in the examples directory of the <a href="http://search.cpan.org/perldoc?Java::Swing"><code>Java::Swing</code></a> distribution.</p>

<pre><code>    #!/usr/bin/perl
    use strict; use warnings;

    BEGIN {
        $ENV{CLASSPATH} .= ':/path/to/Java/Swing/java'
    }</code></pre>

<p><code>Java::Swing</code> needs certain Java classes to be in the class path before it loads, so I've appended a path to those classes in a <code>BEGIN</code> block (this block must come before using <code>Java::Swing</code>).</p>

<pre><code>    use Java::Swing;</code></pre>

<p>This innocuous statement magically sets up namespaces for each Java Swing component, among other things.</p>

<pre><code>    my $expression  = JTextField-&gt;new();
    my $answer      = JTextField-&gt;new( { columns =&gt; 10 } );
    my $submit      = JButton   -&gt;new("Evaluate");
    my $frame       = JFrame    -&gt;new();
    my $root_pane   = $frame-&gt;getContentPane();
    my $south_panel = JPanel-&gt;new();</code></pre>

<p>After using <code>Java::Swing</code>, you can refer to Swing components as Perl classes. You can even pass named parameters to their constructors, as shown for the second <code>JTextField</code>.</p>

<pre><code>    $south_panel-&gt;add(JLabel-&gt;new("Answer:"), "West");
    $south_panel-&gt;add($answer,                "Center");
    $south_panel-&gt;add($submit,                "East");

    $root_pane-&gt;add($expression,  "North");
    $root_pane-&gt;add($south_panel, "South");

    $frame-&gt;setSize(300, 100);
    $frame-&gt;show();</code></pre>

<p>Most work with the components is the same as in any Java program. If you don't understand the above code, consult a good book on Swing (like the one from O'Reilly).</p>

<pre><code>    my $swinger = Java::Swing-&gt;new();</code></pre>

<p>This creates a <code>Java::Swing</code> instance to connect event listeners and to control the event loop.</p>

<pre><code>    $swinger-&gt;connect(
        "ActionListener", $submit, { actionPerformed =&gt; \&amp;evaluate }
    );

    $swinger-&gt;connect(
        "WindowListener", $frame, { windowClosing =&gt; \&amp;ending }
    );</code></pre>

<p>Connection is simple. Pass the listener type, the object to listen to, and a hash of code references to call back as events arrive.</p>

<pre><code>    $swinger-&gt;start();</code></pre>

<p>Start the event loop. After this, the program passively waits for event callbacks. It stops when one of the callbacks stops the event loop.</p>

<pre><code>    sub evaluate {
        my $sender_name = shift;
        my $event       = shift;

        $answer-&gt;setText(eval $expression-&gt;getText());
    }</code></pre>

<p>My evaluation is simple. I retrieve the text from the expression <code>JTextField</code>, <code>eval</code> it, and pass the result to <code>setText</code> on the answer <code>JTextField</code>. Using <code>eval</code> raises possible security concerns, so use it wisely.</p>

<pre><code>    sub ending {
        $swinger-&gt;stop();
    }</code></pre>

<p>When the user closes the window, I stop the event loop by calling <code>stop</code> on the <code>Java::Swing</code> instance gained earlier. This kills the program.</p>

<p>With <code>Java::Swing</code>, you can build Swing apps in Perl with some important bits of syntactic sugar. First, you don't need to have separate Java files or inline sections. Second, you can pass named arguments to constructors. Finally, you can easily connect event listeners to Perl callback code.</p>













<h3>Scriptify Your Module</h3>

<p>Josh McAdams</p>

<p>Recently during an MJD talk at Chicago.pm, I saw a little Perl trick that was so amazingly simple and yet so useful that it was hard to believe that more mongers in the crowd hadn't heard of it. The trick involved taking your module and adding a driver routine to it so the module could run as a script.</p>

<p>To illustrate, start with an example module that contains two utility subroutines that convert weights between pounds and kilograms. The subroutines accept some number and multiplies it by a conversion factor.</p>

<pre><code>  package WeightConverter;
  
  use strict;
  use warnings;
  use constant LB_PER_KG =&gt; 2.20462262;
  use constant KG_PER_LB =&gt; 1/LB_PER_KG;
  
  sub kilograms_to_pounds { $_[0] * LB_PER_KG; }
  
  sub pounds_to_kilograms { $_[0] * KG_PER_LB; }</code></pre>

<p>Assuming that the real module has a little error checking and POD, this module would serve you just fine. However, what if you decided that we needed to be able to easily do weight conversions from the command line? One option would be to write a Perl script that used <code>WeightConverter</code>. If that seems like too much effort, there is a one-liner that would do conversions.</p>

<pre><code>  perl -MWeightConverter -e 'print WeightConverter::kilograms_to_pounds(1),"\n"'</code></pre>

<p>This would do the trick, but it is a lot to remember and isn't very fun to type. There is a lot of benefit available from saving some form of script, and believe it or not, the module can hold that script. All that you have to do is write some driver subroutine and then call that subroutine if the module is not being used by another script. Here is an example driver for <code>WeightConverter</code>.</p>

<p>This example driver script just loops through the command-line arguments and tries to find instances where the argument contains either a <code>k</code> or <code>p</code> equal to some value. Based on whether or not you are starting with pounds or kilograms, it calls the appropriate subroutine and prints the results.</p>

<pre><code>  sub run {
    for (@ARGV) {
      if(/^[-]{0,2}(k|p)\w*=(.+)$/) {
        $1 eq 'k' ?
          print "$2 kilograms is ", kilograms_to_pounds($2), " pounds\n" :
          print "$2 pounds is ", pounds_to_kilograms($2), " kilograms\n" ;
      }
    }
  }</code></pre>

<p>Now all that is left is to tell the module to run the <code>run</code> subroutine if someone has run the module on its own. This is as easy as adding one line somewhere in the main body of the module.</p>

<pre><code>  run unless caller;</code></pre>

<p>All this statement does is execute the <code>run</code> subroutine unless the <code>caller</code> function returns a value. <code>caller</code> will only return true if <code>WeightConverter</code> is being used in another script. Now, this module is usable in other scripts as well as on the command line.</p>

<pre><code>  $&gt; perl WeightConverter.pm -kilos=2 -pounds=145 -k=.345
  2 kilograms is 4.40924524 pounds
  145 pounds is 65.7708937051548 kilograms
  .345 kilograms is 0.7605948039 pounds</code></pre>

<h3>Mocks in Your Test Fixtures</h3>

<p>by chromatic</p>

<p>Since writing <code><a
href="http://search.cpan.org/perldoc?Test::MockObject">Test::MockObject</a></code>,
I've used it in nearly every complex test file I've written. It makes my life
much easier to be able to control only what I need for the current group of
tests.</p>

<p>I wish I'd written <code><a
href="http://search.cpan.org/perldoc?Test::MockObject::Extends">Test::MockObject::Extends</a></code>
earlier than I did; that module allows you to decorate an existing object with
a mockable wrapper. It works just as the wrapped object does, but if you add
any mocked methods, it will work like a regular mock object.</p>

<p>This is very useful when you don't want to go through all of the overhead of
setting up your own mock object but do want to override one or two methods.
(It's almost always the right thing to do instead of using
<code>Test::MockObject.</code>.)</p>

<p>Another very useful test module is <code><a
href="http://search.cpan.org/perldoc?Test::Class">Test::Class</a></code>. It
takes more work to understand and to use than <code><a
href="http://search.cpan.org/perldoc?Test::More">Test::More</a></code>, but
it pays back that investment by allowing you to group, reuse, and organize
tests in the same way you would group, reuse, and organize objects in your
code. Instead of writing your tests procedurally, from the start to the end of
a test file, you organize them into classes.</p>

<p>This is most useful when you've organized your code along similar lines.
If you have a base class with a lot of behavior and a handful of subclasses
that add and override a little bit of behavior, write a
<code>Test::Class</code>-based test for the base class and smaller tests
that inherit from the base test for the subclasses.</p>

<p>Goodbye, duplicate code.</p>

<h4>Fixtures</h4>

<p><code>Test::Class</code> encourages you to group related tests into test
methods. This allows you to override and extend those groups of tests in
test subclasses. (Good OO design principles apply here; tests are still
just code, after all.) One of the benefits of grouping tests in this way is
that you can use test fixtures.</p>

<p>A test fixture is another method that runs before every test method. You
can use them to set up the test environment--creating a new object to
test, resetting test data, and generally making sure that tests don't
interfere with each other.</p>

<p>A standard test fixture might resemble:</p>

<pre><code>  sub make_fixture :Test( setup )
  {
      my $self        = shift;
      $self-&gt;{object} = $self-&gt;test_class()-&gt;new();
  }</code></pre>

<p>Assuming that there's a <code>test_class()</code> method that returns
the name of the class being tested, this fixture creates a new instance
before every test method and stores it as the <code>object</code>
attribute. The test methods can then fetch this as normal.</p>

<h4>Putting Them Together</h4>

<p>I recently built some tests for a large system using
<code>Test::Class</code>. Some of the tests had mockable features--they
dealt with file or database errors, for example. I found myself creating a
lot of little <code>Test::MockObject::Extends</code> instances within most
of the tests.</p>

<p>Then inspiration struck. Duplication is bad. Repetition is bad. Factor
it out into one place.</p>

<p>The insight was quick and sudden. If
<code>Test::MockObject::Extends</code> is transparent (and if it isn't,
please file a bug--I'll fix it), I can use it in the test fixture all the
time and then be able to mock whenever I want without doing any setup. I
changed my fixture to:</p>

<pre><code>  sub make_fixture :Test( setup )
  {
      my $self        = shift;
          my $object      = $self-&gt;test_class()-&gt;new();
      $self-&gt;{object} = Test::MockObject::Extends-&gt;new( $object );
  }</code></pre>

<p>The rest of my code remained unchanged, except that now I could delete
several identical lines from several test methods.</p>

<p>Do note that, for this to work, you must adhere to good OO design
principles in the code being tested. Don't assume that <code>ref</code> is
always what you think it should be (and use the <code>isa()</code> method
instead).</p>

<p>Sure, this is a one-line trick, but it removed a lot of busy work from
my life and it illustrates two interesting techniques for managing tests.
If you need simpler, more precise mocks, use
<code>Test::MockObject::Extends</code>. If you need better organization and
less duplication in your test files, use <code>Test::Class</code>. Like all
good test modules, they work together almost flawlessly.</p>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-680" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2006/02/x11-gui-testing.html" rel="bookmark">Test-Driving X11 GUIs</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">George Nistorica</span> on <abbr class="published" title="2006-02-02T00:00:00-08:00">February  2, 2006 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<h3>Driving X11 GUIs using X11::GUITest</h3>

<h3>Introduction</h3>

<p>Interfaces to GUI applications like <a href="http://developer.kde.org/documentation/library/kdeqt/kde3arch/dcop.html">DCOP</a> or <a href="http://www.freedesktop.org/Software/dbus">D-BUS</a> allow you to interact with GUI applications in order to get at their internal states or set some arbitrary states.</p>

<p>Sometimes GUIs don't allow for such interaction and you need to "click" them. If you're writing such an application, you need some sort of regression tests for it to make sure your widget/windows are as accessible as they should be. If this is the case, there is a Perl module to help you: <a href="http://search.cpan.org/perldoc?X11::GUITest">X11::GUITest</a>.</p>

<p>Be aware that <code>X11::GUITest</code> allows you to drive a GUI, but you can't "read" data written in a widget, such as a button or an edit box. More on this in the Limitations section below.</p>

<p>To install <code>X11::GUITest</code>, run:</p>

<pre><code>$ <strong>perl -MCPAN -e 'shell'</strong>
<strong>install X11::GUITest</strong>
<strong>quit</strong></code></pre>

<h3>A Simple Example</h3>

<p>I've included two example programs. One is <a href="/2006/02/02/examples/tested.pl"><em>tested.pl</em></a> and it serves as an example GUI. The other is <a href="/2006/02/02/examples/tester.pl"><em>tester.pl</em></a> that starts and drives the tested program.</p>

<p>You need Tk installed for the tested GUI. Tk comes as a package in most GNU/Linux distributions or other *NIX OSes. Download both files in the same folder, run <em>./tester.pl</em>, and watch.</p>

<p>What are they doing and how do they work?</p>

<h3>Starting a GUI</h3>

<p>First thing to do prior to driving a GUI is to start the driven program. While you can use <code>fork</code> and <code>exec</code> or any other means, <code>X11::GUITest</code> comes with a routine of its own.</p>

<p>Use <code>StartApp( $tested_application );</code> to start a GUI, which results in starting the desired application in an asynchronous manner.</p>

<p>If you want to start an application and wait for it to finish before going on, use <code>RunApp</code>.</p>

<h3>Finding a Window</h3>

<p>After having the GUI started, you need to search for it among the other open windows on your desktop. For this, use <code>FindWindowLike()</code>, <code>WaitWindowLike()</code>, or <code>WaitWindowViewable()</code>, depending on what you need. Their names are pretty much self-explanatory.</p>

<p>Usually you need to have only one instance of the tested application started:</p>

<pre><code>@windows = FindWindowLike( $tested_app_title );
print "* Number of $tested_app_title windows found: ", scalar @windows, "\n";

if ( @windows == 1 ) {
     print "* Only one instance found, going on ...\n";
} else {
    print "* The number of $tested_app_title instances is different than 1\n";
    print "exiting ...\n";
    exit;
}</code></pre>

<p><code>FindWindowLike()</code> returns a list of windows that match the search criteria, which is a regular expression to match against the window title. In case there is more than one window that matches the criteria, either you have the same window started multiple times, or the regular expression isn't specific enough.</p>

<h3>Sending Keyboard Events to an Application</h3>

<p>Having found the window, (when you know that there is only one, you can access it as the first element of <code>@windows</code>, namely <code>$windows[0]</code>), you probably want to send it some keystrokes. Use <code>SendKeys()</code> to do this.</p>

<p>If you are having a busy X server, or just want your testing to be easy for the human eye to watch, set the delay between the keystrokes (in milliseconds) with <code>SetKeySendDelay()</code>:</p>

<pre><code>SetKeySendDelay( $delay );</code></pre>

<p>To send <code>Alt</code>+<code>O</code>, followed by a delay of <code>$delay</code> milliseconds, then <code>e</code>:</p>

<pre><code>SendKeys( '%(o)e' );</code></pre>

<p>Besides sending plain text to an application, like sending the infamous "Hello World" to an editor window, you may have noticed that the previous example sent a combination of keys. Do so by using modifiers. The modifier keys are:</p>

<ul>
<li><code>^</code>, <code>Ctrl</code></li>

<li><code>%</code>, <code>Alt</code></li>

<li><code>+</code>, <code>Shift</code></li>
</ul>

<p>The <code>X11::GUITest</code> documentation has a complete list of special keys and their "encodings."</p>

<p>You may also find it useful to use <code>QuoteStringForSendKeys()</code> in the case of complicated strings.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1796" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3>Sending Mouse Events to an Application</h3>

<p>Sending keys may be not enough in some situations. Having an application that has keyboard shortcuts is nice, but not all of them support it. Sometimes you may need to send mouse events.</p>

<p>To get the absolute position of the appropriate window on your desktop:</p>

<pre><code>my ($x, $y, $width, $height) = GetWindowPos($edit_windows[0]);</code></pre>

<p>Suppose that you want to click right in the middle of it. First, compute the position of the middle of the window:</p>

<pre><code>$x += $width  / 2;
$y += $height / 2;</code></pre>

<p>Now move the mouse:</p>

<pre><code>MoveMouseAbs( $x, $y );</code></pre>

<p>Then press the right mouse button:</p>

<pre><code>PressMouseButton M_RIGHT;</code></pre>

<p>Do something useful, and then release the mouse button. (Don't forget to do that when you're using <code>PressMouseButton</code>; otherwise, you may experience "strange" desktop behavior when your testing application exits.)</p>

<pre><code>ReleaseMouseButton M_RIGHT</code></pre>

<p>You could replace <code>PressMouseButton()</code> and <code>ReleaseMouseButton()</code> with <code>ClickMouseButton()</code> if you don't have anything to do between pressing and releasing the mouse button.</p>

<p>In the example programs, there's something to do--navigating the context menu with keystrokes.</p>

<h3>Moving a Window</h3>

<p>This is a neat and interesting feature: the ability to move windows. While it is useful to impress your friends with having their favorite mail program moving up and down, its utility lies in the fact that you can arrange the tested windows on the desktop so they are all visible.</p>

<pre><code>MoveWindow( $window_id, $x, $y );</code></pre>

<h3>Limitations</h3>

<p>As you may have noticed reading the example code, there is almost no way of validating the fact that you are indeed interacting with the right widget or window. The functions you can use for this are <code>FindWindow*</code> or <code>WaitWindow*</code>, which return a list of windows whose titles match an arbitrary regexp, and the functions that deal with child windows, such as <code>IsChild()</code> and <code>GetChildWindows()</code>.</p>

<p>While you may pass the window ID to a testing program, using external means to validate the tested application (such as indicating the coordinates on the screen), the problem is that you can't grab a widget's contents.</p>

<p>Also, while you might be tempted to parse the child tree of an application to get from the main window to one of its children, this doesn't work every time. Plenty of GUIs spawn other windows at the top level, and the spawned windows have as root window the topmost window (which is the desktop).</p>

<p>Here's an example of the problem that uses Mozilla Firefox. Before running the test, you must meet some prerequisites:</p>

<ul>
<li>Back up your preferences before running the tests.</li>

<li>Go to Edit -&gt; Preferences -&gt; General -&gt; Connection Settings and set it to "Direct connection to the Internet."</li>

<li>Click OK, and then OK, and close the browser.</li>
</ul>

<p>Now run the <em><a href="/2006/02/02/examples/Firefox.pl">Firefox.pl</a></em> example code.</p>

<p>The test program assumes that when the Preferences window pops up, the General menu is selected.</p>

<p>Open Mozilla Firefox again, go to Preferences, select the Web Features menu, click OK, and exit the browser.</p>

<p>Rerun the <em>Firefox.pl</em> program, and watch it.</p>

<p>It has no idea which menu is selected, because every menu component belongs to the same window, having the same title.</p>













<h3>Writing GUIs for Testability</h3>

<p>Having in mind the strengths and weaknesses of <code>X11::GUITest</code>, it's critical to design graphical user interfaces that are easy to test. This way, you shorten your maintenance time, as you can have a tester program that can help check that the GUI hasn't lost some of its windows in the development/maintenance process.</p>

<p>Of course, when displaying a license text when your GUI starts, you don't have the means to check that the contents are unchanged using <code>X11::GUITest</code>.</p>

<p>What you can do is to ensure that all child windows are "in place" and that a user can access them in the same way as he/she could in previous versions.</p>

<p>If you define ways of navigating the GUI using keyboard shortcuts so that you can reach any "leaf" window starting from the top-level window, then it's trivial for a test program to navigate the same way you do and ensure that all windows are reachable as they were in previous versions.</p>

<p>Consider the following code based on the tested Tk program:</p>

<pre><code>$menu{'OTHER'} = $menu_bar-&gt;cascade(
    -label   =&gt; 'Other',
    -tearoff =&gt; 0,
);

$menu{'OTHER'}-&gt;command(
    -label   =&gt; 'Editor',
    -command =&gt; sub {
        edit_window();
    }
);</code></pre>

<p>It defines a piece of menu from the overall menu of the application. As you may notice, there are no keyboard shortcuts that you can use to access the Editor window.</p>

<p>Thinking of testability, you could go to some lengths to test this piece of code to ensure that the Editor window is reachable and that it indeed pops up. You could record the application's position on the screen and then click the Other button, then move the mouse over the Editor button and click it. I'm sure you can spot some caveats here, among them:</p>

<ul>
<li>You need to make sure that the application is always on the screen at some known coordinates (use <code>GetWindowPos()</code>) or maybe that the test always moves the window to the same place (use <code>MoveWindow()</code>).</li>

<li>You have to take into consideration font size changes, localization, and resolution changes so that you are sure you are clicking in the right place.</li>
</ul>

<p>This kind of testing is fragile and error-prone. You can make things simpler and more robust: add keyboard shortcuts for each action. You gain two main benefits: you make some users (like me) happier and ease the testing process. You just need to define all the "paths" that you need to "walk" and define the child window titles so you know you've reached them.</p>

<p>Here's a slight adjustment to the tested application so that it provides keyboard shortcuts:</p>

<pre><code>$menu{'OTHER'} = $menu_bar-&gt;cascade(
    -label   =&gt; '~Other',
    -tearoff =&gt; 0,
);

$menu{'OTHER'}-&gt;command(
    -label   =&gt; '~Editor',
    -command =&gt; sub {
        edit_window();
    }
);

sub edit_window {
    # some initialization code here ...

    $edit_window = $main_window-&gt;Toplevel();

    # Set the title of the Editor window
    $edit_window-&gt;title("This is an edit window");

    # the rest of the code here ....

}</code></pre>

<p>This piece of code is easier to test. Navigate the application until you reach the Editor window:</p>

<pre><code>SendKeys('%(o)e');</code></pre>

<p>Now you should have the Editor window spawned. Grab a list of windows having the title matching the Editor window's title:</p>

<pre><code>@edit_windows = FindWindowLike( $edit_title );</code></pre>

<p>Check to see whether the Editor window is present. Also, there should be only one Editor window started:</p>

<pre><code>if ( @edit_windows == 1 ) {
    # code here
} else {
    # we have zero or more than one Editor window, so something is not quite
    # right
}</code></pre>

<p>This kind of code is easy to extend, as you can store the application window hierarchy in some external file outside of the program source (in some sort of markup language file, or anything that suits your needs). Having this external definition of the windows' hierarchy and their properties, the tester program can read the same file the tested application uses; thus, both know the same keyboard shortcuts and window titles.</p>

<p>Program logic errors and/or bugs in underlying libraries used are easier to catch before you release the software.</p>

<h3>Conclusion</h3>

<p>As you can see, there is no easy way to test an entire GUI application with <code>X11::GUITest</code>, but you can test the important parts. Also, for some actions you can use a mixed approach, such as initiating an event using the application interface (connecting to a remote server protected with a user/password auth scheme) and picking the results from a log file.</p>

<p>While the testing done in the previous paragraph is necessary, it is not sufficient. It would be great if there were someone willing to pick up the module and research whether it could be possible for <code>X11::GUITest</code> to be able to fetch data from the widgets, making it possible to "read" the contents of a window (from a text widget, for example).</p>

<p>This kind of testing is more complete than simply driving the GUI.</p>

<p>Of course, you could also use <code>X11::GUITest</code> to write a "record and playback" application. You might only need <code>GetMousePos()</code>, <code>IsMouseButtonPressed()</code>, and the other mouse functions. As I said earlier, in my opinion this kind of testing is too fragile.</p>

<p>The problem is that you can't validate the contents of the windows.</p>
        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-838" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/10/wxperl-menus.html" rel="bookmark">Making Menus with wxPerl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Roberto Alamos</span> on <abbr class="published" title="2005-10-06T00:00:00-08:00">October  6, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<br clear="all" />
<p>In a previous article about wxPerl published on Perl.com, Jouke Visser taught <a href="/pub/a/2001/09/12/wxtutorial1.html">the very basics of wxPerl programming</a>. In this article, I will continue with Jouke's work, explaining how to add menus in our wxPerl applications. I will cover the creation, editing, and erasure of menus with the <a href="http://search.cpan.org/perldoc?Wx::Menu">Wx::Menu</a> and Wx::MenuBar modules, and also will show examples of their use.</p>

<h3>Conventions</h3>

<p>I assume that you understand the wxPerl approach to GUI programming, so I won't explain it here. The following code is the base for the examples in this article:</p>

<pre><code>use strict;
use Wx;

package WxPerlComExample;

use base qw(Wx::App);

sub OnInit {
    my $self  = shift;
    my $frame = WxPerlComExampleFrame-&gt;new(undef, -1, "WxPerl Example");

    $frame-&gt;Show(1);
    $self-&gt;SetTopWindow($frame);

    return 1;
}

package WxPerlComExampleFrame;

use base qw(Wx::Frame);

use Wx qw( 
    wxDefaultPosition wxDefaultSize wxDefaultPosition wxDefaultSize wxID_EXIT
);

use Wx::Event qw(EVT_MENU);

our @id = (0 .. 100); # IDs array

sub new {
    my $class = shift;
    my $self  = $class-&gt;SUPER::new( @_ );

    ### CODE GOES HERE ###

    return $self;
}

### PUT SUBROUTINES HERE ###

package main;

my($app) = WxPerlComExample-&gt;new();

$app-&gt;MainLoop();</code></pre>

<p><code>@id</code> is an array of integer numbers to use as unique identifier numbers. In addition, the following definitions are important:</p>

<ul>
<li><b>Menu bar</b>: The bar located at the top of the window where menus will appear. This is a particular instance of Wx::MenuBar.</li>

<li><b>Menu</b>: A particular instance of Wx::Menu.</li>

<li><b>Item</b>: An option inside of a (sub)menu.</li>
</ul>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1714" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3>A Quick Example</h3>

<p>Instead of wading through several pages of explanation before the first example, here is a short example that serves as a summary of this article. Note that I have divided it in two parts. Add this code to the base code in the <code>WxPerlComExampleFrame</code> constructor:</p>

<pre><code># Create menus
my $firstmenu = Wx::Menu-&gt;new();
$firstmenu-&gt;Append($id[0], "Normal Item");
$firstmenu-&gt;AppendCheckItem($id[1], "Check Item");
$firstmenu-&gt;AppendSeparator();
$firstmenu-&gt;AppendRadioItem($id[2], "Radio Item");

my $secmenu   = Wx::Menu-&gt;new();
$secmenu-&gt;Append(wxID_EXIT, "Exit\tCtrl+X");

# Create menu bar
my $menubar   = Wx::MenuBar-&gt;new();
$menubar-&gt;Append($firstmenu, "First Menu");
$menubar-&gt;Append($secmenu, "Exit Menu");

# Attach menubar to the window
$self-&gt;SetMenuBar($menubar);
$self-&gt;SetAutoLayout(1);

# Handle events only for Exit and Normal item
EVT_MENU( $self, $id[0], \&amp;ShowDialog );
EVT_MENU( $self, wxID_EXIT, sub {$_[0]-&gt;Close(1)} );</code></pre>

<p>Insert the following code into the base code at the line <code>### PUT SUBROUTINES HERE ###</code>.</p>

<pre><code>use Wx qw(wxOK wxCENTRE);

# The following subroutine will be called when you click in the normal item

sub ShowDialog {
  my($self, $event) = @_;
  Wx::MessageBox( "This is a dialog", 
                  "Wx::MessageBox example", 
                   wxOK|wxCENTRE, 
                   $self
               );
}</code></pre>

<p>Run this example to see something like Figures 1 and 2.</p>

<p><img src="/pub/2005/10/06/graphics/qexample1.jpg" width="290" height="224" alt="a menu with complex sub-items" /><br />
<em>Figure 1. A menu with complex sub-items</em>
</p>

<p><img src="/pub/2005/10/06/graphics/qexample2.jpg" width="290" height="224" alt="a menu with a single sub-item" /><br />
<em>Figure 2. A menu with a single sub-item</em>
</p>

<h3>Programming Menus</h3>

<p>To add a menu to your wxPerl application, you must know how to use two Perl modules that come with WxPerl: Wx::MenuBar and Wx::Menu. Wx::MenuBar creates and manages the bar that contains menus created with Wx::Menu. There is also a third module involved: Wx::MenuItem. This module, as its name implies, creates and manages menu items. You usually don't need to use it, because almost all of the operations you need for a menu item are available through Wx::Menu methods.</p>













<h4>Using Wx::Menu</h4>

<p>Creating a menu with Wx::Menu is as easy as:</p>

<pre><code>my $menu = Wx::Menu-&gt;new();</code></pre>

<p>Now <code>$menu</code> is a Wx::Menu object. WxPerl has five types of items. The first is the normal item, upon which you can click to get a response (a dialog or something else). The second is the check item, which has the Boolean property of being checked or not (independent of another check items). The third item is the radio item, which is an "exclusive check item;" if you check a particular radio item, other radio items in its radio group get unchecked instantly. The fourth type of item is the separator, which is just a straight line that acts as a barrier that separates groups of similar items inside of a menu. The fifth type is the submenu, an item that expands another menu when the mouse cursor is over it.</p>

<h5>Setting Up Menu Items</h5>

<p>To create a normal item for your menu, write:</p>

<pre><code>$menu-&gt;Append($id, $label, $helpstr);</code></pre>

<p>where <code>$id</code> is an unique integer that identifies this item, <code>$label</code> is the text to display on the menu, and <code>$helpstr</code> is a string to display in the status bar. (This last argument is optional.) Note that every menu item must have an unique identifier number in order to be able to operate with this item during the rest of the program. (From now on, <code>$id</code> will denote the unique identifier number of a menu item.)</p>

<p>To create a check or radio item, the methods are analogous to <code>Append</code>--<code>AppendCheckItem</code> and <code>AppendRadioItem</code>, respectively. Add a separator with the <code>AppendSeparator</code> method; it does not expect arguments. Create a submenu with the <code>AppendSubMenu</code> method:</p>

<pre><code>$menu-&gt;AppendSubMenu($id, $label, $submenu, $helpstr);</code></pre>

<p>where <code>$submenu</code> is an instance to another Wx::Menu object. (Don't try to make that a submenu be a submenu of itself, because the Universe will crash or, in the best case, your program won't execute at all.)</p>

<p>While append methods add menu items in the last position of your menus, Wx::Menu gives you methods to add menu items at any position you want. For instance, to add a normal item at some position in a menu:</p>

<pre><code>$menu-&gt;Insert($pos, $id, $label, $helpstr);</code></pre>

<p>where <code>$pos</code> is the position of the item, starting at 0. To add a radio item, check item, or separator, use the <code>InsertRadioItem</code>, <code>InsertCheckItem</code>, or <code>InsertSeparator</code> methods. As usual, the latter takes no arguments. To insert a submenu, use the <code>InsertSubMenu</code> method:</p>

<pre><code>$menu-&gt;InsertSubMenu($pos, $id, $label, $submenu, $helpstr);</code></pre>

<p>You can also insert an item at the first position by using the <code>Prepend</code> method:</p>

<p>$menu-&gt;Prepend($id, $label, $helpstr);</p>

<p><code>PrependRadioItem</code>, <code>PrependCheckItem</code>, and <code>PrependSeparator</code> methods are also available. As you might expect, there's a <code>PrependSubMenu</code> method that works like this:</p>

<p><code>$menu-&gt;PrependSubMenu($id, $label, $submenu, $helpstr);</code>
</p>

<p>Sometimes, a menu grows to include too many menu items, and then it's impractical to show them all. For this problem, Wx::Menu has the <code>Break</code> method. When called, it causes Wx to place subsequently appended items into another column. Call this method like so:</p>

<pre><code>$menu-&gt;Break();</code></pre>

<h5>Menu Item Methods</h5>

<p>Once you have created your items, you need some way to operate on them, such as finding information about them through their identifier numbers, getting or setting their labels or help strings, enabling or disabling them, checking or unchecking them, or removing them. For example, you may want to retrieve some specific menu item in some point of your program. To do this, use the <code>FindItem</code> method in either of two ways:</p>

<pre><code>my $menuitem_with_the_given_id = $menu-&gt;FindItem($id);
my ($menuitem, $submenu)        = $menu-&gt;FindItem($id);</code></pre>

<p>where <code>$menuitem</code> is the corresponding Wx::MenuItem object with the identifier <code>$id</code>, and <code>$submenu</code> is the (sub)menu to which <code>$menuitem</code> belongs. You can also retrieve a menu item through the <code>FindItemByPosition</code> method (but remember that positions start at 0):</p>

<pre><code>my $menuitem = $menu-&gt;FindItemByPosition($pos);</code></pre>

<p>Wx::Menu provides methods to get or set properties of menu items. To set a property, there are two methods: <code>SetLabel</code> and <code>SetHelpString</code>. A <code>SetLabel</code> call might be:</p>

<pre><code>$menu-&gt;SetLabel($id, $newlabel);</code></pre>

<p><code>SetHelpString</code> works similarly:</p>

<pre><code>$menu-&gt;SetHelpString($id, $newhelpstr);</code></pre>













<p>To retrieve the label or help string of a particular item, use the <code>GetLabel</code> and <code>GetHelpString</code> methods. Both methods expect the menu item identifier number as the sole argument.</p>

<p>Every menu item has an <em>enabled</em> property that makes an item available or unavailable. By default, all items are enabled. To enable or disable a particular menu item, use the <code>Enable</code> method:</p>

<pre><code>$menu-&gt;Enable($id, $boolean);</code></pre>

<p>where <code>$boolean</code> is 0 or 1, depending if you want to disable or enable it, respectively. Maybe your next question is how to check if a menu item is enabled; use the <code>IsEnabled</code> method:</p>

<pre><code>$menu-&gt;IsEnabled($id);</code></pre>

<p>This returns <code>TRUE</code> or <code>FALSE</code>, depending on the status of the menu item.</p>

<p>Radio items and check items have the <em>checked</em> property that indicates the selection status of the item. By default, no check item is checked at the start of the execution of your program. For radio items, the first one created is checked at the start of execution. Use the <code>Check</code> method to check or uncheck a radio or check item:</p>

<pre><code>$menu-&gt;Check($id, $boolean);</code></pre>

<p>To determine if a menu item is checked, use <code>IsChecked</code>:</p>

<pre><code>$menu-&gt;IsChecked($id);</code></pre>

<p>This method, as does <code>IsEnabled</code>, returns <code>TRUE</code> or <code>FALSE</code>.</p>

<p>It's also possible to get the number of menu items your menu has. For this, use the <code>GetMenuItemCount</code> method:</p>

<pre><code>$menu-&gt;GetMenuItemCount();</code></pre>

<p>note that if <code>@args</code> is the argument's array, then <code>$menu-&gt;Append(@args)</code> and <code>$menu-&gt;Insert($menu-&gt;GetMenuItemCount(), @args)</code> are the same.</p>

<p>Finally, it's important to know that there are three ways to remove an item from a menu (honoring Larry Wall's phrase: "There's more than one way to do it"). The first is the <code>Delete</code> method, which just kills the menu item without compassion:</p>

<pre><code>$menu-&gt;Delete($id);</code></pre>

<p>This method returns nothing. Be careful--WxWidgets documentation says that the <code>Delete</code> method doesn't delete a menu item that's a submenu. Instead, the documentation recommends that you use the <code>Destroy</code> method to delete a submenu. In wxPerl, this isn't true. <code>Delete</code> is certainly capable of deleting a submenu, and is here equivalent to the <code>Destroy</code> method. I don't know the reason for this strange behavior.</p>

<p>The <code>Destroy</code> method looks like this:</p>

<pre>$menu-&gt;Destroy($id);</pre>

<p>If you want to remove an item but not destroy it, then the <code>Remove</code> method is for you. It allows you to store the menu item that you want to delete in a variable for later use, and at the same time delete it from its original menu. Use it like so:</p>

<pre><code>my $removed_item = $menu-&gt;Remove($id);</code></pre>

<p>Now you have your menu item with the identifier <code>$id</code> in the <code>$removed_item</code> variable (it now contains a Wx::MenuItem object). You can now use this variable to relocate the removed item into another menu with the append methods. For example:</p>

<pre><code>$other_menu-&gt;Append($removed_item);</code></pre>

<p>does the same thing as:</p>

<pre><code>$other_menu-&gt;Append($id_removed_item, $title_removed_item, 
    $helpstr_removed_item);</code></pre>

<p>but in a shorter way.</p>

<p>Finally, it's useful to be able to remove a submenu's menu item. You can't use the <code>Destroy</code>, <code>Delete</code>, or <code>Remove</code> methods, because they don't work. Instead, you need to do something like this:</p>

<pre><code>my ($mitem, $submenu) = $menu-&gt;FindItem($mitem_id);</code></pre>

<p>where <code>$mitem_id</code> is the identifier number of the submenu's menu item you're looking for. <code>$submenu</code> is a Wx::Menu object, just as <code>$menu</code> is, and hence you can use all the methods mentioned here, so the only thing you have to do to remove <code>$mitem</code> from <code>$submenu</code> is:</p>

<pre><code>$submenu-&gt;Delete($mitem_id);</code></pre>

<p>As the good reader that I am sure you are, you already have realized that this isn't the only thing you can do with the <code>$submenu</code> object. In fact, you can now add new menu items to your submenu, delete another menu item, and in general do everything mentioned already.</p>













<h4>Using Wx::MenuBar</h4>

<p>You have created your menus and obviously want to use them. The last step to get the job done is to create the menu bar that will handle your menus. When you want to create a menu bar, the first step is to enable your code to handle menu events. This is the job of the Wx::Event module:</p>

<pre><code>use Wx::Event qw(EVT_MENU)</code></pre>

<p>Now create a Wx::MenuBar object:</p>

<pre><code>my $menubar = Wx::MenuBar-&gt;new();</code></pre>

<p>This object will contain all of the menus that you want to show on your window. To associate a menu bar with a frame, call the <code>SetMenuBar</code> method from Wx::Frame:</p>

<pre><code>$self-&gt;SetMenuBar($menubar);</code></pre>

<p>where <code>$self</code> is the Wx::Frame object inherited in <code>WxPerlComExampleFrame</code>'s constructor. Note that if your application has MDI characteristics, or has many windows, then you have to take in account that Wx first sends menu events to the focused window. (I won't cover this issue in this article, so for more information, review the WxWidgets documentation.) Finally, be sure to call the <code>EVT_MENU</code> subroutine as many times as you have menu items that execute some action when clicked:</p>

<pre><code>EVT_MENU($self, $menu_item_id, \&amp;subroutine);</code></pre>

<p>where <code>$self</code> is the object of your package's <code>new</code> method, <code>$menu_item_id</code> is the unique identifier of the menu item involved, and <code>subroutine</code> is the name of the subroutine that will handle the click event you want to catch.</p>

<h5>Setting Up Menus</h5>

<p>The first thing to do once you have created your menu bar is to attach your menus to the menu bar. There are two methods for this: <code>Append</code> and <code>Insert</code>. <code>Append</code>, as you might expect, attaches a menu in the last position:</p>

<pre><code>$menubar-&gt;Append($menu, $label);</code></pre>

<p>where <code>$menu</code> is the menu created in the previous section and <code>$label</code> is the name to display for this menu in the menu bar. To insert a menu in an arbitrary position, use the <code>Insert</code> method:</p>

<pre><code>$menubar-&gt;Insert($pos, $menu, $label);</code></pre>

<p>where <code>$pos</code> is the position of your menu, starting at 0.</p>

<h5>Menu Methods</h5>

<p>Wx::MenuBar provides some methods that are also present in Wx::Menu and work in the same way. This methods are <code>Check</code>, <code>Enable</code>, <code>FindItem</code>, <code>GetLabel</code>, <code>GetHelpString</code>, <code>SetLabel</code>, <code>SetHelpString</code>, <code>IsChecked</code>, and <code>IsEnabled</code>. Besides these methods, Wx::MenuBar has its own set of methods to manage the properties of the menu bar. For example, as a menu item, a menu has its own <em>enabled</em> property, which you toggle with the <code>EnableTop</code> method:</p>

<pre><code>$menubar-&gt;EnableTop($pos, $boolean);</code></pre>

<p>where <code>$pos</code> is the position of your menu (starting at 0) and <code>$boolean</code> is <code>TRUE</code> or <code>FALSE</code>, depending on whether you want that menu enabled. Note that you can use this method only after you attach your menu bar to the window through the <code>SetMenuBar</code> method.</p>

<p>Wx::MenuBar has methods to retrieve an entire menu or menu item given its title or (menu title, menu item label) pair, respectively. In the first case, use the code:</p>

<pre><code>$menu_with_the_given_title = $menubar-&gt;FindMenu($title);</code></pre>

<p>In the second case:</p>

<pre><code>$menu_item = $menubar-&gt;FindMenuItem($menu_title, $menu_item_label);</code></pre>

<p>In both cases, the returned variables are Wx::Menu objects. You can also retrieve a menu if you provide its position (starting at 0):</p>

<pre><code>$menu_with_the_given_pos = $menubar-&gt;GetMenu($pos);</code></pre>

<p>As in the Wx::Menu case, Wx::MenuBar provides methods to set or get the label of a specific menu and to retrieve the number of menus in a menu bar. Those methods are <code>SetLabelTop</code>, <code>GetLabelTop</code>, and <code>GetMenuCount</code> respectively. Use them like this:</p>

<pre><code>$menu-&gt;SetLabelTop($pos, $label);
my $menu_label = $menu-&gt;GetLabelTop($pos);
my $num_menu   = $menu-&gt;GetMenuCount();</code></pre>

<p>where <code>$pos</code> is the position of the menu and <code>$label</code> is the new label that you want to put on your menu. Note that <code>GetLabelTop</code>'s result doesn't include accelerator characters inside the returned string.</p>

<p>Finally, Wx::MenuBar gives two more choices to remove a menu. The first method is <code>Replace</code>, which replaces it with another menu:</p>

<pre><code>$menubar-&gt;Replace($pos, $new_menu, $label);</code></pre>

<p>where <code>$pos</code> is the position of the menu to remove, <code>$new_menu</code> is the new menu that will be in the <code>$pos</code> position, and <code>$label</code> is the label to display on the menu bar for <code>$new_menu</code>. The second choice is to remove a menu, just by removing it with the <code>Remove</code> method:</p>

<pre><code>my $removed_menu = $menubar-&gt;Remove($pos);</code></pre>

<p><code>Remove</code> returns the <code>$removed_menu</code> object, so if you need it in the future, it'll be still there waiting for you.</p>













<h3>Example</h3>

<p>With all of that explained, I can show a full, working example. As before, add this code to the base code in the blank spot in the <code>WxPerlComExampleFrame</code> constructor.</p>

<pre><code># Create menus
# Action's sub menu
my $submenu = Wx::Menu-&gt;new();
$submenu-&gt;Append($id[2], "New normal item");
$submenu-&gt;Append($id[3], "Delete normal item");
$submenu-&gt;AppendSeparator();
$submenu-&gt;Append($id[4], "New check item");
$submenu-&gt;Append($id[5], "Delete check item");
$submenu-&gt;AppendSeparator();
$submenu-&gt;Append($id[6], "New radio item");
$submenu-&gt;Append($id[7], "Delete radio item");

# Disable items for this submenu
for(2..7) {
    $submenu-&gt;Enable($id[$_], 0);
}

# Actions menu
my $actionmenu = Wx::Menu-&gt;new();
$actionmenu-&gt;Append($id[0], "Create Menu"); # Create new menu
$actionmenu-&gt;Append($id[1], "Delete Menu"); # Delete New Menu
$actionmenu-&gt;AppendSeparator();
$actionmenu-&gt;AppendSubMenu($id[100], "New Item", $submenu); # Create item submenu
$actionmenu-&gt;AppendSeparator();
$actionmenu-&gt;Append(wxID_EXIT, "Exit\tCtrl+X"); # Exit

# At first, disable the Delete Menu option
$actionmenu-&gt;Enable($id[1], 0);

# Create menu bar
$self-&gt;{MENU} = Wx::MenuBar-&gt;new();
$self-&gt;{MENU}-&gt;Append($actionmenu, "Actions");

# Attach menubar to the window
$self-&gt;SetMenuBar($self-&gt;{MENU});
$self-&gt;SetAutoLayout(1);

# Handle events
EVT_MENU($self, $id[0], \&amp;MakeActionMenu);
EVT_MENU($self, $id[1], \&amp;MakeActionMenu);
EVT_MENU($self, $id[2], \&amp;MakeActionNormal);
EVT_MENU($self, $id[3], \&amp;MakeActionNormal);
EVT_MENU($self, $id[4], \&amp;MakeActionCheck);
EVT_MENU($self, $id[5], \&amp;MakeActionCheck);
EVT_MENU($self, $id[6], \&amp;MakeActionRadio);
EVT_MENU($self, $id[7], \&amp;MakeActionRadio);

EVT_MENU($self, wxID_EXIT, sub {$_[0]-&gt;Close(1)});</code></pre>

<p>This code creates a menu called <em>Actions</em> with the following options inside:</p>

<ul>
<li><b>Create Menu</b>: When a user clicks this option, the program creates a new menu called <em>New Menu</em> at the right side of the <em>Actions</em> menu. The <em>Create Menu</em> option is enabled by default, but creating the menu disables this option.</li>

<li><b>Delete Menu</b>: Deletes the menu created with <em>Create Menu</em>. This option is disabled by default and is enabled when <em>New Menu</em> exists.</li>

<li><b>New normal item</b>: This option creates the <em>Normal item</em> option on <em>New Menu</em> when it exists. It is disabled by default.</li>

<li><b>Delete normal item</b>: Deletes <em>Normal item</em> when it exists. It is disabled by default.</li>

<li><b>New check item</b>: Creates the <em>Check item</em> option on <em>New Menu</em> when it exists. It is disabled by default. <em>Check item</em> is unchecked by default.</li>

<li><b>Delete check item</b>: Deletes <em>Check item</em> when it exists. It is disabled by default.</li>

<li><b>New radio item</b>: Creates the <em>Radio item</em> option on <em>New Menu</em> when it exists. It is disabled by default. <em>Radio item</em> is checked by default.</li>

<li><b>Delete radio item</b>: Deletes <em>Radio item</em> when it exists. It is disabled by default.</li>

<li><b>Exit</b>: Exits the program.</li>
</ul>

<p>Once the code has created the menu, it attaches the menu to the menu bar saved on <code>$self-&gt;{MENU}</code>, then calls the <code>EVT_MENU</code> subroutine eight times to handle all of the menu events from <em>Action</em>'s menu items. Add the following code to the base code where it says <code>### PUT SUBROUTINES HERE ###</code>:</p>

<pre><code># Subroutine that handles menu creation/erasure
sub MakeActionMenu {
    my($self, $event) = @_;

    # Get Actions menu
    my $actionmenu    = $self-&gt;{MENU}-&gt;GetMenu(0);

    # Now check if we have to create or delete the New Menu
    if ($self-&gt;{MENU}-&gt;GetMenuCount() == 1) {
        # New Menu doesn't exist

        # Create menu
        my $newmenu = Wx::Menu-&gt;new();
        $self-&gt;{MENU}-&gt;Append($newmenu, "New Menu");       

        # Disable and Enable options
        $actionmenu-&gt;Enable($id[0], 0); # New menu
        $actionmenu-&gt;Enable($id[1], 1); # Delete menu
        $actionmenu-&gt;Enable($id[2], 1); # New normal item
        $actionmenu-&gt;Enable($id[3], 0); # Delete normal item
        $actionmenu-&gt;Enable($id[4], 1); # New check item
        $actionmenu-&gt;Enable($id[5], 0); # Delete check item
        $actionmenu-&gt;Enable($id[6], 1); # New radio item
        $actionmenu-&gt;Enable($id[7], 0); # Delete radio item
    } else {
        # New Menu exists

        # Remove menu
       $self-&gt;{MENU}-&gt;Remove(1);

        # Enable and disable options
        $actionmenu-&gt;Enable($id[0], 1);

        for(1..7) {
               $actionmenu-&gt;Enable($id[$_], 0);
        }
    }

    return 1;
}

# Subroutine that handles normal item creation/erasure
sub MakeActionNormal {
    my($self, $event) = @_;
    # Check if New Menu exists
    if($self-&gt;{MENU}-&gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&gt;{MENU}-&gt;GetMenu(0);
        my $newmenu    = $self-&gt;{MENU}-&gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if($actionmenu-&gt;IsEnabled($id[2])) {
            # Create normal menu item
            $newmenu-&gt;Append($id[50], "Normal item");           

            # Disable and Enable options
            $actionmenu-&gt;Enable($id[2], 0);
            $actionmenu-&gt;Enable($id[3], 1);
        } else {
            # Delete menu item
               $newmenu-&gt;Delete($id[50]);

            # Enable and disable options
            $actionmenu-&gt;Enable($id[2], 1);
            $actionmenu-&gt;Enable($id[3], 0);
        }
    }

    return 1;
}

# Subroutine that handles check item creation/erasure
sub MakeActionCheck {
    my($self, $event) = @_;

    # Check if New Menu exists
    if($self-&gt;{MENU}-&gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&gt;{MENU}-&gt;GetMenu(0);
        my $newmenu    = $self-&gt;{MENU}-&gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if($actionmenu-&gt;IsEnabled($id[4])) {
            # Create check item
               $newmenu-&gt;AppendCheckItem($id[51], "Check item");

           # Disable and Enable options
           $actionmenu-&gt;Enable($id[4], 0);
           $actionmenu-&gt;Enable($id[5], 1);
        } else {
           # Delete menu item
           $newmenu-&gt;Delete($id[51]);

              # Enable and disable options
              $actionmenu-&gt;Enable($id[4], 1);
              $actionmenu-&gt;Enable($id[5], 0);
        }
    }

    return 1;
}

# Subroutine that handles radio item creation/erasure

sub MakeActionRadio {
    my($self, $event) = @_;

    # Check if New Menu exists
    if($self-&gt;{MENU}-&gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&gt;{MENU}-&gt;GetMenu(0);
        my $newmenu    = $self-&gt;{MENU}-&gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if ($actionmenu-&gt;IsEnabled($id[6])) {
               # Create radio item
              $newmenu-&gt;AppendRadioItem($id[52], "Radio item");

              # Disable and Enable options
              $actionmenu-&gt;Enable($id[6], 0);
              $actionmenu-&gt;Enable($id[7], 1);
        } else {
              # Delete menu item
              $newmenu-&gt;Delete($id[52]);

              # Enable and disable options
              $actionmenu-&gt;Enable($id[6], 1);
              $actionmenu-&gt;Enable($id[7], 0);
        }
    }

    return 1;
}</code></pre>

<p>The <code>MakeActionMenu</code> subroutine handles events for the <em>New Menu</em> and <em>Delete Menu</em> items. It first gets the <em>Actions</em> menu and checks whether the <em>New Menu</em> exists by retrieving the number of menus attached to the <code>$self-&gt;{MENU}</code> menu bar. If the new menu doesn't exist, the number of menus in the menu bar is equal to 1, and the subroutine then creates <em>New Menu</em>. If it exists, the subroutine deletes <em>New Menu</em>.</p>

<p>The <code>MakeActionNormal</code>, <code>MakeActionCheck</code>, and <code>MakeActionRadio</code> subroutines are almost identical. They differ only in the involved identifier numbers. These subroutines handle events for <em>New normal item</em>, <em>Delete normal item</em>, <em>New check item</em>, <em>Delete check item</em>, <em>New radio item</em>, and <em>Delete radio item</em>, respectively. They first check if <em>New Menu</em> exists (the number of menus attached to the menu bar is equal to 2). If so, they check if the options to create normal, check, or radio items are enabled, respectively. If the corresponding option is enabled, then the corresponding item doesn't exist on <em>New Menu</em>, and the subroutine creates it. If the option to create an item is disabled, then that item exists on <em>New Menu</em> and hence it must be deleted. If <em>New Menu</em> doesn't exist, the subroutines do nothing. Figure 3 shows how there are no options available if <em>New Menu</em> does not exist, and Figure 4 shows <em>New Menu</em> with two options added.</p>

<p><img src="/pub/2005/10/06/graphics/example1.jpg" width="289" height="268" alt="no available options without New Menu" /><br />
<em>Figure 3. No available options without New Menu</em>
</p>

<p><img src="/pub/2005/10/06/graphics/example2.jpg" width="289" height="268" alt="New Menu has menu options" /><br />
<em>Figure 4. New Menu has menu options</em>
</p>

<h3>Conclusion</h3>

<p>As this article has shown, menu programming with wxPerl is an extremely simple task. Wx::MenuBar and Wx::Menu's methods are very easy to use and remember. If you understood this article, you can do anything possible with menus in your wxPerl programs.</p>

<p>I have covered almost all of the available methods in Wx::Menu and Wx::MenuBar. I left out some methods related to pop-up menus, but I hope to cover these topics in future articles. WxPerl is a really great module, but its lack of adoption is due to its severe lack of documentation. This situation must be reversed, and this article is a small contribution to that cause.</p>

<h3>See Also</h3>

<ul>
<li><a href="http://www.wxwidgets.org/manuals/2.4.2/wx262.htm">WxMenu tutorial</a> and <a href="http://www.wxwidgets.org/manuals/2.4.2/wx263.htm">WxMenuBar tutorial</a> by Julian Smart, Robert Roebling, Vadim Zeitlin, Robin Dunn, et al.</li>

<li>"<a href="http://www.bzzt.net/~wxwidgets/icpp_wx2.html#menubar">Adding a Menu Bar</a>," by David Beech.</li>

<li>"<a href="/pub/a/2001/09/12/wxtutorial1.html">wxPerl: Another GUI for Perl</a>," by Jouke Visser.</li>
</ul>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/tutorials/">&laquo; Tutorials</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/version-control-systems/">Version Control Systems &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
