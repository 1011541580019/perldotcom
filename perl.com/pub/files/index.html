<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    <title>Perl.com: Files Archives</title>


</head>
<body id="perl-com" class="mt-archive-listing mt-category-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">

                            
                            <h1 id="page-title" class="archive-title">Recently in <em>Files</em> Category</h1>






                            
                            <div id="entry-852" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2005/12/test-files.html" rel="bookmark">Testing Files and Test Modules</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Phil Crow</span> on <abbr class="published" title="2005-12-08T00:00:00-08:00">December  8, 2005 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars-->
<!-- sidebar ends -->
<p>For the last several years, there has been more and more emphasis on automated testing. No self-respecting CPAN author can post a distribution without tests. Yet some things are hard to test. This article explains how writing <code>Test::Files</code> gave me a useful tool for validating one module's output and taught me a few things about the current state of Perl testing.</p>

<h3>Introduction</h3>

<p>My boss put me to work writing a moderately large suite in Perl. Among many other things, it needed to perform check out and commit operations on CVS repositories. In a quest to build quality tests for that module, I wrote <a href="http://search.cpan.org/perldoc/Test::Files"><code>Test::Files</code></a>, which is now on CPAN. This article explains how to use that module and, perhaps more importantly, how it tests itself.</p>

<h3>Using <code>Test::Files</code></h3>

<p>To use <code>Test::Files</code>, first use <a href="http://search.cpan.org/perldoc/Test::More"><code>Test::More</code></a> and tell it how many tests you want to run.</p>

<pre><code>use strict;
use warnings;
use Test::More tests =&gt; 5;
use Test::Files;</code></pre>

<p>After you use the module, there are four things it can help you do:</p>

<ul>
<li>Compare one file to a string or to another file.</li>

<li>Make sure that directories have the files you expect them to have.</li>

<li>Compare all the files in one directory to all the files in another directory.</li>

<li>Exclude some things from consideration.</li>
</ul>

<h3>Single Files</h3>

<p>In the simplest case, you have written a file. Now it is time to validate it. That could look like this:</p>

<pre><code>file_ok($file_name, "This is the\ntext\n",
    "file one contents");</code></pre>

<p>The <code>file_ok</code> function takes two (or optionally, and preferably, three) arguments. The first is the name of the file you want to validate. The second is a text string containing the text that should be in the file. The third is the name of the test. In the rush of writing, I'm likely to fail to mention the test names at some point, so let me say up front that all of the tests shown here take a name argument. Including a name makes finding the test easier.</p>

<p>If the file agrees with the string, the test passes with only an OK message. Otherwise, the test will fail and diagnostic messages will show where the two differed. The diagnostic output is really the reason to use <code>Test::Files</code>.</p>

<p>Some, including myself, prefer to check one file against another. I put one version in the distribution. The other one, my tests write. To compare two files, use:</p>

<pre><code>compare_ok($file1, $file2, $name);</code></pre>

<p>As with <code>file_ok</code>, if the files are the same, <code>Test::Files</code> only reports an OK message. Failure shows where the files differ.</p>

<h3>Directory Structures</h3>

<p>Sometimes, you need to validate that certain files are present in a directory. Other times, you need to make that check exclusive so that only known files are present. Finally, you might want to know that not only is the directory structure is the same, but that the files contain the same data.</p>

<p>To look for some files in a directory by name, write:</p>

<pre><code>dir_contains_ok($dir, [qw(list files here)], $name);</code></pre>

<p>This will succeed, even if the directory has some other files you weren't looking for.</p>

<p>To ensure that your list is exclusive, add only to the function name:</p>

<pre><code>dir_only_contains_ok($dir, [qw(list all files here)], $name);</code></pre>

<p>Both of these report a list of absent files if they fail due to them. The exclusive form also reports a list of unexpected files, if it sees any.</p>

<!-- sidebar begins -->
 <csperl file="grab" domain="on" record="b/1796" template="b/article_sidebar2.view">
<!-- sidebar ends -->













<h3>Directory Contents</h3>

<p>If knowing that certain file names are present is not enough, use the <code>compare_dirs_ok</code> function to check the contents of all files in one directory against files in another directory. A typical module might build one directory during <code>make test</code>, with the other built ahead of time and shipped with the distribution.</p>

<pre><code>compare_dirs_ok($test_built, $shipped, $name);</code></pre>

<p>This will generate a separate diagnostic <code>diff</code> output for each pair of files that differs, in addition to listing files that are missing from either distribution. (If you need to know which files are missing from the built directory, either reverse the order of the directories or use <code>dir_only_contains_ok</code> in addition to <code>compare_dirs_ok</code>. This is a bug and might eventually be fixed.) Even though this could yield many diagnostic reports, all of those separate failures only count as one failed test.</p>

<p>There are many times when testing <em>all</em> files in the directories is just wrong. In these cases, it is best to use <a href="http://search.cpan.org/perldoc/File::Find"><code>File::Find</code></a> or an equivalent, putting an exclusion criterion at the top of your wanted function and a call to <code>compare_ok</code> at the bottom. This probably requires you to use <code>no_plan</code> with <code>Test::More</code>:</p>

<pre><code>use Test::More qw(no_plan);</code></pre>

<p><code>Test::More</code> wants to know the exact number of tests you are about to run. If you tell it the wrong number, the test harness will think something is wrong with your test script, causing it to report failures. To avoid this confusion, use <code>no_plan</code>--but keep in mind that plans are there for a reason. If your test dies, the plan lets the harness know how many tests it missed. If you have <code>no_plan</code>, the harness doesn't always have enough information to keep score. Thus, you should put such tests in separate scripts, so that the harness can count your other tests properly.</p>

<h3>Filtering</h3>

<p>While the above list of functions seemed sufficient during planning, reality set in as soon as I tried it out on my CVS module. I wanted to compare two CVS repositories: one ready for shipment with the distribution, the other built during testing. As soon as I tried the test it failed, not because the operative parts of the module were not working, but because the CVS timestamps differed between the two versions.</p>

<p>To deal with cosmetic differences that should not count as failures, I added two functions to the above list: one for single files and the other for directories. These new functions accept a code reference that receives each line prior to comparison. It performs any needed alterations, and then returns a line suitable for comparison. My example function below redacts the offending timestamps. With the filtered versions in place, the tests pass and fail when they should.</p>

<p>My final tests for the CVS repository directories look like this:</p>

<pre><code>compare_dirs_filter_ok(
    't/cvsroot/CVSROOT',
    't/sampleroot/CVSROOT',
    \&amp;chop_dates,
    "make repo"
);</code></pre>

<p>The code reference argument comes between the directory names and the test name. The <code>chop_dates</code> function is not particularly complex. It removes two kinds of dates favored by CVS, as shown in its comments.</p>

<pre><code>sub chop_dates {
    my $line =  shift;

    #  2003.10.15.13.45.57 (year month day hour minute sec)
    $line    =~ s/\d{4}(.\d\d){5}//;

    #  Thu Oct 16 18:00:28 2003
    $line    =~ s/\w{3} \w{3} \d\d? \d\d:\d\d:\d\d \d{4}//;

    return $line;
}</code></pre>

<p>This shows the general behavior of filters. They receive a line of input which they must not directly change. Instead, they must return a new, corrected line.</p>

<p>In addition to <code>compare_dirs_filter_ok</code> for whole directory structures, there is also <code>compare_filter_ok</code>, which works similarly for single file comparisons. (There is no <code>file_filter_ok</code>, but maybe there should be.)</p>













<h3>Testing a Test Module</h3>

<p>The most interesting part of writing <code>Test::Files</code> was learning how to test it. Thanks to Schwern, I learned about <a href="http://search.cpan.org/perldoc/Test::Builder::Tester"><code>Test::Builder::Tester</code></a>, which eases the problems inherent in testing a Perl test module.</p>

<p>The difficulty with testing Perl tests has to do with how they normally run. The venerable test harness scheme expects test scripts to produce pass and fail data on standard out and diagnostic help on standard error. This is a great design. The simplicity is exactly what you would expect from a Unix-inspired tool. Yet, it poses a problem for testing test modules.</p>

<p>When eventual users use the test module, their harness expects it to write quite specific things to standard out and standard error. Among the things that must go to standard out are a sequence of lines such as <code>ok 1</code>. When you write a test of the test module, its harness also expects to see this sort of data on standard out and standard error. Having two different sources of <code>ok 1</code> is highly confusing, not least to the harness, which chokes on such duplications.</p>

<p>Test module writers need a scheme to trap the output from the module being tested, check it for correct content, and report that result onto the actual standard channels for the harness to see. This is tricky, requiring care in diversion of file handles at the right moments without the knowledge of the module whose output is diverted. Doing this by hand is inelegant and prone to error. Further, multiple test scripts might have to recreate home-rolled solutions (introducing the oldest of known coding sins: duplication of code). Finally, the diagnostic output, in the event of failure, from homemade diverters is unlikely to be helpful when tests of the test module fail.</p>

<p><em>Enter <code>Test::Builder::Tester</code>.</em>
</p>

<p>To help us test testers, Mark Fowler collected some code from Schwern, and used it to make <code>Test::Builder::Tester</code>. With it, tests of test modules are relatively painless and their failure diagnostics are highly informative. Here are two examples from the <code>Test::Files</code> test suite. The first shows a file comparison that should pass:</p>

<pre><code>test_out("ok 1 - passing file");
compare_ok("t/ok_pass.dat", "t/ok_pass.same.dat",
    "passing file");
test_test("passing file");</code></pre>

<p>This test should work, generating <code>ok 1 - passing file</code> on standard output. To tell <code>Test::Builder::Tester</code> what the standard output should be, I called <code>test_out</code>. After the test, I called <code>test_test</code> with only the name of my test. (To avoid confusion, I made the test names the same.)</p>

<p>Between the call to <code>test_out</code> and the one to <code>test_test</code>, <code>Test::Builder::Tester</code> diverted the regular output channels so the harness won't see them.</p>

<p>The second example shows a failed test and how to check both standard out and standard error. The later contains the diagnostic data the module should generate.</p>

<pre><code>test_out("not ok 1 - failing file");
$line = line_num(+9);
test_diag("    Failed test (t/03compare_ok.t at line $line)",
'+---+--------------------+-------------------+',
'|   |Got                 |Expected           |',
'| Ln|                    |                   |',
'+---+--------------------+-------------------+',
'|  1|This file           |This file          |',
'*  2|is for 03ok_pass.t  |is for many tests  *',
'+---+--------------------+-------------------+'  );
compare_ok("t/ok_pass.dat", "t/ok_pass.diff.dat",
    "failing file");
test_test("failing file");</code></pre>

<p>Two new functions appear here. First, <code>line_num</code> returns the current line number plus or minus an offset. Because failing tests report the line number of the failure, checking standard error for an exact match requires matching that number. Yet, no one wants his tests to break because he inserted a new line at the top of the script. With <code>line_num</code>, you can obtain the line number of the test relative to where you are. Here, there are nine lines between the call to <code>line_num</code> and the actual test.</p>

<p>The other new function is <code>test_diag</code>. It allows you to check the standard error output, where diagnostic messages appear. The easiest way to use it is to provide each line of output as a separate parameter.</p>

<h3>Summary</h3>

<p>Now you know how to use <code>Test::Files</code> and how to test modules that implement tests. There is one final way I use <code>Test::Files</code>. I use it outside of module testing any time I want to know how the contents of text files in two directory hierarchies compare. With this, I can quickly locate differences in archives, for example, enabling me to debug builders of those archives. In one example, I used it compare more than 400 text files in two WebSphere .ear archives. My program had only about 30 operative lines (there were also comments and blank lines) and performed the comparison in under five seconds. This is testament to the leverage of Perl and CPAN.</p>

<p>(Since doing that comparison, I have moved to a new company. In the process I exchanged WebSphere for <code>mod_perl</code> and am generally happier with the latter.)</p>

        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-1004" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/10/file-editing.html" rel="bookmark">FMTYEWTK About Mass Edits In Perl</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                By <span class="vcard author">Geoff Broadwell</span> on <abbr class="published" title="2004-10-14T00:00:00-08:00">October 14, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            <p>For those not used to the terminology, FMTYEWTK stands for <em>F</em>ar
<em>M</em>ore <em>T</em>han <em>Y</em>ou <em>E</em>ver <em>W</em>anted
<em>T</em>o <em>K</em>now. This one is fairly light as FMTYEWTKs usually go. In
any case, the question before us is, "How do you apply an edit against a list
of files using Perl?" Well, that depends on what you want to do....</p>

<h3><a id="beginning">The Beginning</a></h3>

<p>If you only want to read in one or more files, apply a regex to the
contents, and spit out the altered text as one big stream -- the best approach is
probably a one-liner such as the following:</p>

<pre><code>perl -p -e "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<p>This command calls <code>perl</code> with the options <code>-p</code> and
<code>-e "s/Foo/Bar/g"</code> against the files listed in
<code><em>FileList</em></code>. The first argument, <code>-p</code>, tells Perl
to <em>p</em>rint each line it reads after applying the alteration. The second
option, <code>-e</code>, tells Perl to <em>e</em>valuate the provided
substitution regex rather than reading a script from a file. The Perl interpreter
then evaluates this regex against every line of all (space separated) files
listed on the command line and spits out one huge stream of the concatenated
fixed lines.</p>

<p>In standard fashion, Perl allows you to concatenate options without
arguments with following options for brevity and convenience.  Therefore,
you'll more often see the previous example written as:</p>

<pre><code>perl -pe "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<h3><a id="inplace">In-place Editing</a></h3>

<p>If you want to edit the files in place, editing each file before going on to
the next, that's pretty easy, too:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" <em>&lt;FileList&gt;</em></code></pre>

<p>The only change from the last command is the new option <code>-i.bak</code>,
which tells Perl to operate on files <em>i</em>n-place, rather than
concatenating them together into one big output stream. Like the
<code>-e</code> option, <code>-i</code> takes one argument, an extension to add
to the original file names when making backup copies; for this example I chose
<code>.bak</code>.  <strong>Warning:</strong> If you execute the command twice,
you've most likely just overwritten your backups with the changed versions from
the first run. You probably didn't want to do that.</p>

<p>Because <code>-i</code> takes an argument, I had to separate out the
<code>-e</code> option, which Perl otherwise would interpret as the argument to
<code>-i</code>, leaving us with a backup extension of <code>.bake</code>,
unlikely to be correct unless you happen to be a pastry chef. In addition, Perl
would have thought that <code>"s/Foo/Bar/"</code> was the filename of the
script to run, and would complain when it could not find a script by that
name.</p>

<h3><a id="multiple">Running Multiple Regexes</a></h3>

<p>Of course, you may want to make more extensive changes than just one regex.
To make several changes all at once, add more code to the evaluated script.
Remember to separate each additional line of code with a semicolon
(technically, you should place a semicolon at the end of each line of code, but
the very last one in any code block is optional). For example, you could make a
series of changes:</p>

<pre><code>perl -pi.bak -e "s/Bill Gates/Microsoft CEO/g;
 	s/CEO/Overlord/g" <em>&lt;FileList&gt;</em></code></pre>

<p>"Bill Gates" would then become "Microsoft Overlord" throughout the files.
(Here, as in all examples, we ignore such finicky things as making sure we
don't change "HERBACEOUS" to "HERBAOverlordUS"; for that kind of information,
refer to a good treatise on regular expressions, such as Jeffrey Friedl's
impressive book <a href="http://www.oreilly.com/catalog/regex2/">Mastering
Regular Expressions, 2nd Edition</a>. Also, I've wrapped the command to
fit, but you should type it in as just one line.)</p>

<h3><a id="printing">Doing Your Own Printing</a></h3>

<p>You may wish to override the behavior created by <code>-p</code>, which
prints every line read in, after any changes made by your script. In this case,
change to the <code>-n</code> option. <code>-p -e "s/Foo/Bar/"</code> is
roughly equivalent to <code>-n -e "s/Foo/Bar/; print"</code>. This allows you
to write interesting commands, such as removing lines beginning with hash marks
(Perl comments, C-style preprocessor directives, etc.):</p>

<pre><code>perl -ni.bak -e "print unless /^\s*#/;" <em>&lt;FileList&gt;</em></code></pre>

<h3><a id="fields">Fields and Scripts</a></h3>

<p>Of course, there are far more powerful things you can do with this. For
example, imagine a flat-file database, with one row per line of the file, and
fields separated by colons, like so:</p>

<pre><code>Bill:Hennig:Male:43:62000
Mary:Myrtle:Female:28:56000
Jim:Smith:Male:24:50700
Mike:Jones:Male:29:35200
...</code></pre>

<p>Suppose you want to find everyone who was over 25, but paid less than
$40,000. At the same time, you'd like to document the number and percentage of
women and men found. This time, instead of providing a mini-script on the
command line, we'll create a file, <code>glass.pl</code>, which contains the
script.  Here's how to run the query:</p>

<pre><code>perl -naF':' glass.pl <em>&lt;FileList&gt;</em></code></pre>

<p><em><code>glass.pl</code> contains the following</em>:</p>

<pre><code>BEGIN { $men = $women = $lowmen = $lowwomen = 0; }

next unless /:/;
/Female/ ? $women++ : $men++;
if ($F[3] &gt; 25 and $F[4] &lt; 40000)
    { print; /Female/ ? $lowwomen++ : $lowmen++; }

END {
print "\n\n$lowwomen of $women women (",
      int($lowwomen / $women * 100),
      "%) and $lowmen of $men men (",
      int($lowmen / $men * 100),
      "%) seem to be underpaid.\n";
}</code></pre>

<p>Don't worry too much about the syntax, other than to note some of the awk
and C similarities. The important thing here and in later sections is to see
how Perl makes these problems easily solvable.</p>

<p>Several new features appear in this example; first, if there is no
<code>-e</code> option to evaluate, Perl assumes the first filename listed, in
this case <code>glass.pl</code>, refers to a Perl script for it to execute. Secondly, two new options make it easy to deal with field-based data. <code>-a</code> (<em>a</em>utosplit mode) takes each line and splits its fields
into the array <code>@F</code>, based on the field delimiter given by the
<code>-F</code> (<em>F</em>ield delimiter) option, which can be a string or a
regex. If no <code>-F</code> option exists, the field delimiter defaults to
<code>' '</code> (one single-quoted space). By default, arrays in Perl are
zero-based, so <code>$F[3]</code> and <code>$F[4]</code> refer to the age and
pay fields, respectively.  Finally, the <code>BEGIN</code> and <code>END</code>
blocks allow the programmer to perform actions before file reading begins and
after it finishes, respectively.</p>

<h3><a id="files">File Handling</a></h3>

<p>All of these little tidbits have made use only of data from within the files
being operated on. What if you want to be able to read in data from elsewhere?
For example, imagine that you had some sort of file that allows includes; in
this case, we'll assume that you somehow specify these files by relative
pathname, rather than looking them up in an include path.  Perhaps the includes
look like the following:</p>

<pre><code>...
#include foo.bar, baz.bar, boo.bar
...</code></pre>

<p>If you want to see what the file looks like with the includes placed into
the master file, you might try something like this:</p>

<pre><code>perl -ni.bak -e "if (s/#include\s+//) {foreach $file
 (split /,\s*/) {open FILE, '&lt;', $file; print &lt;FILE&gt;}}
 else {print}" <em>&lt;FileList&gt;</em></code></pre>

<p>To make it easier to see what's going on here, this is what it looks like
with a full set of line breaks added for clarity:</p>

<pre><code>perl -ni.bak -e "
        if (s/#include\s+//) {
            foreach $file (split /,\s*/) {
                open FILE, '&lt;', $file;
                print &lt;FILE&gt;
            }
        } else {
            print
        }
    " <em>&lt;FileList&gt;</em></code></pre>


<p>Of course, this only expands one level of include, but then we haven't
provided any way for the script to know when to stop if there's an include
loop. In this little example, we take advantage of the fact that the
substitution operator returns the number of changes made, so if it manages to
chop off the <code>#include</code> at the beginning of the line, it returns a
non-zero (true) value, and the rest of the code splits apart the list of
includes, opens each one in turn, and prints its entire contents.</p>

<p>There are some handy shortcuts as well: if you open a new file using the
name of an old file handle (<code>FILE</code> in this case), Perl automatically
closes the old file first.  In addition, if you read from a file using the
<code>&lt;&gt;</code> operator into a list (which the <code>print</code>
function expects), it happily reads in the entire file at once, one line per
list entry.  The <code>print</code> call then prints the entire list, inserting
it into the current file, as expected. Finally, the <code>else</code> clause
handles printing non-include lines from the source, because we are using
<code>-n</code> rather than <code>-p</code>.</p>

<h3><a id="filelists">Better File Lists</a></h3>

<p>The fact that it is relatively easy to handle filenames listed within other
files indicates that it ought to be fairly easy to deal entirely with files
read from some other source than a list on the end of the command line. The
simplest case is to read all of the file contents from standard input as a
single stream, which is common when building up pipes. As a matter of fact,
this is so common that Perl automatically switches to this mode if there are no
files listed on the command line:</p>

<pre><code><em>&lt;Source&gt;</em> | perl -pe "s/Foo/Bar/g" | <em>&lt;Sink&gt;</em></code></pre>

<p>Here <em>Source</em> and <em>Sink</em> are the commands that generate the
raw data and handle the altered output from Perl, respectively. Incidentally, the
filename consisting of a single hyphen (<code>-</code>) is an explicit alias
for standard input; this allows the Perl programmer to merge input from files
and pipes, like so:</p>

<pre><code><em>&lt;Source&gt;</em> | perl -pe "s/Foo/Bar/g" header.bar - footer.bar
 | <em>&lt;Sink&gt;</em></code></pre>

<p>This example first reads a header file, then the input from the pipe source,
and then a footer file &mdash; the whole mess.  The program modifies this text
and sends it through to the out pipe.</p>

<p>As I mentioned earlier, when dealing with multiple files it is usually
better to keep the files separate, by using in-place editing or by explicitly
handling each file separately. On the other hand, it can be a pain to list all
of the files on the command line, especially if there are a lot of files, or
when dealing with files generated programmatically.</p>

<p>The simplest method is to read the files from standard input, pushing them
onto <code>@ARGV</code> in a <code>BEGIN</code> block; this has the effect of
tricking Perl into thinking it received all of the filenames on the command
line!  Assuming the common case of one filename per input line, the following
will do the trick:</p>

<pre><code><em>&lt;FilenamesSource&gt;</em> | perl -pi.bak -e "BEGIN {push @ARGV,
 &lt;STDIN&gt;; chomp @ARGV} s/Foo/Bar/g"</code></pre>

<p>Here we once again use the shortcut that reading in a file in a list context
(which <code>push</code> provides) will read in the entire file.  This adds the
entire contents, one filename per entry, to the <code>@ARGV</code> array, which
normally contains the list of arguments to the script. To complete the trick,
we <code>chomp</code> the line endings from the filenames, because Perl
normally returns the line ending characters (a carriage return and/or a line
feed) when reading lines from a file.  We don't want to consider these to be
part of the filenames. (On some platforms, you <em>could</em> actually have
filenames containing line ending characters, but then you'd have to make the
Perl code a little more complex, and you deserve to figure that out for
yourself for trying it in the first place.)</p>

<h3><a id="response">Response Files</a></h3>

<p>Another common design is to provide filenames on the command line as usual,
treating filenames starting with an <code>@</code> specially.  The program
should consider their contents to be lists of filenames to insert directly into
the command line. For example, if the contents of the file
<code>names.baz</code> (often called a <em>response file</em>) are:</p>

<pre><code>two
three
four</code></pre>

<p>then this command:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" one @names.baz five</code></pre>

<p>should work equivalently to:</p>

<pre><code>perl -pi.bak -e "s/Foo/Bar/g" one two three four five</code></pre>

<p>To make this work, we once again need to do a little magic in a
<code>BEGIN</code> block. Essentially, we want to parse through the
<code>@ARGV</code> array, looking for filenames that begin with <code>@</code>.
We pass through any unmarked filenames, but for each response file found, we
read in the contents of the response file and insert the new list of filenames
into <code>@ARGV</code>.  Finally, we chomp the line endings, just as in the <a
href="#filelists">previous section</a>.  This produces a canonical file list in
<code>@ARGV</code>, just as if we'd specified all of the files on the command
line. Here's what it looks like in action:</p>

<pre><code>perl -pi.bak -e "BEGIN {@ARGV = map {s/^@// ? @{open RESP,
 '&lt;', $_; [&lt;RESP&gt;]} : $_} @ARGV; chomp @ARGV} s/Foo/Bar/g"
 <em>&lt;ResponseFileList&gt;</em></code></pre>

<p>Here's the same code with line breaks added so you can see what's going
on:</p>

<pre><code>perl -pi.bak -e "
        BEGIN {
            @ARGV = map {
                        s/^@// ? @{open RESP, '&lt;', $_;
                                   [&lt;RESP&gt;]}
                               : $_
                    } @ARGV;
            chomp @ARGV
        }
        
        s/Foo/Bar/g
    " <em>&lt;ResponseFileList&gt;</em></code></pre>

<p>The only tricky part is the <code>map</code> block.  <code>map</code>
applies a piece of code to every element of a list, returning a list of the
return values of the code; the current element is in the <code>$_</code>
special variable. The block here checks to see if it could remove a
<code>@</code> from the beginning of each filename. If so, it opens the file,
reads the whole thing into an anonymous temporary array (that's what the square
brackets are there for), and then inserts that array instead of the response
file's name (that's the odd <code>@{...}</code> construct). If there is no
<code>@</code> at the beginning of the filename to remove, the filename goes
directly into the map results. Once we've performed this expansion and chomped
any line endings, we can then proceed with the main work, in this case our
usual substitution, <code>s/Foo/Bar/g</code>.</p>

<h3><a id="recursing">Recursing Directories</a></h3>

<p>For our final example, let's deal with a major weakness in the way we've
been doing things so far &mdash; we're not recursing into directories, instead
expecting all of the files we need to read to appear explicitly on the command
line. To perform the recursion, we need to pull out the big guns:
<code>File::Find</code>. This Perl module provides very powerful recursion
methods.  It also comes standard with any recent version of the Perl
interpreter. The command line is deceptively simple, because all of the brains
are in the script:</p>

<pre><code>perl cleanup.pl <em>&lt;DirectoryList&gt;</em></code></pre>

<p>This script will perform some basic housecleaning, marking all files
readable and writeable, removing those with the extensions <code>.bak</code>,
<code>.$$$</code>, and <code>.tmp</code>, and cleaning up <code>.log</code>
files. For the log files, we will create a master log file (for archiving or
perusal) containing the contents of all of the other logs, and then delete the
logs so that they remain short over time. Here's the script:</p>

<pre><code>use File::Find;

die "All arguments must be directories!"
    if grep {!-d} @ARGV;
open MASTER, '&gt;', 'master.lgm';
finddepth(\&amp;filehandler, @ARGV);
close MASTER;
rename 'master.lgm', 'master.log';

sub filehandler
{
    chmod stat(_) | 0666, $_ unless (-r and -w);
    unlink if (/\.bak$/ or /\.tmp$/ or /\.\$\$\$$/);
    if (/\.log$/) {
        open LOG, '&lt;', $_;
        print MASTER "\n\n****\n$File::Find::name\n****\n";
        print MASTER &lt;LOG&gt;;
        close LOG;
        unlink;
    }
}</code></pre>

<p>This example shows just how powerful Perl and Perl modules can be, and at
the same time just how obtuse Perl can appear to the inexperienced.  In this
case, the short explanation is that the <code>finddepth()</code> function
iterates through all of the program arguments (<code>@ARGV</code>), recursing
into each directory and calling the <code>filehandler()</code> subroutine for
each file. That subroutine then can examine the file and decide what to do with
it. The example checks for readability and writability with <code>-r</code> and
<code>-w</code>, fixing the file's security settings if needed with
<code>chmod</code>. It then <code>unlink</code>s (deletes) any file with a name
ending in any of the three unwanted extensions. Finally, if the extension is
<code>.log</code>, it opens the file, writes a few header lines to the master
log, copies the file into the master log, closes it, and deletes it.</p>

<p>Instead of using <code>finddepth()</code>, which does a depth-first search
of the directories and visits them from the bottom up, we could have used
<code>find()</code>, which does the same depth-first search from the top down.
As a side note, the program writes the master log file with the extension
<code>.lgm</code>, then renames it at the end to have the extension
<code>.log</code>, so as to avoid the possibility of writing the master log
into itself if the program is searching the current directory.</p>

<h3><a id="end"></a>Conclusion</h3>

<p>That's it. Sure, there's a lot more that you could do with these examples,
including adding error checking, generating additional statistics, producing
help text, etc. To learn how to do this, find a copy of <em><a
href="http://www.oreilly.com/catalog/pperl3/">Programming Perl, 3rd
Edition</a></em>, by Larry Wall, Tom Christiansen, and Jon Orwant. This is the
bible (or the Camel, rather) of the Perl community, and well worth the read.
Good luck!</p>



        </div>



    </div>
    <div class="asset-footer"></div>
</div>


                            
                            <div id="entry-944" class="entry-asset asset hentry">
    <div class="asset-header">
        <h2 class="asset-name entry-title"><a href="/pub/2004/06/variables.html" rel="bookmark">Perl's Special Variables</a></h2>
        <div class="asset-meta">
            <span class="byline">
    
                <abbr class="published" title="2004-06-18T00:00:00-08:00">June 18, 2004 12:00 AM</abbr>
    
            </span>

            
            

        </div>
    </div>
    <div class="asset-content entry-content">

        <div class="asset-body">
            
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->


<p>One of the best ways to make your Perl code look more like ... well, like Perl code -- and not like C or BASIC or whatever you used before you were introduced to Perl -- is to get to know the internal variables that Perl uses to control various aspects of your program's execution.</p>

<p>In this article we'll take a look at a number of variables that give you finer control over your file input and output.</p>

<h3><a name="Counting_Lines">Counting Lines</a></h3>

<p>I decided to write this article because I am constantly amazed by the number of people who don't know about the existence of <code>$.</code>.
I still see people producing code that looks like this:</p>

<pre><code>  my $line_no = 0;

  while (&lt;FILE&gt;) {
    ++$line_no;
    unless (/some regex/) {
      warn &quot;Error in line $line_no\n&quot;;
      next;
    }

    # process the record in some way
  }</code></pre>

<p>For some reason, many people seem to completely miss the existence of <code>$.</code>, which is Perl's internal variable that keeps track of your current record number. The code above can be rewritten as:</p>

<pre><code>  while (&lt;FILE&gt;) {
    unless (/some regex/) {
      warn &quot;Error in line $.\n&quot;;
      next;
    }

    # process the record in some way
  }</code></pre>

<p>I know that it doesn't actually save you very much typing, but why create a new variable if you don't have to?</p>

<p>One other nice way to use <code>$.</code> is in conjunction with Perl's &quot;flip-flop&quot; operator (<code>..</code>). When used in list context, <code>..</code> is the list construction operator. It builds a list of elements by calculating all of the items between given start and end values like this:</p>

<pre><code>  my @numbers = (1 .. 1000);</code></pre>

<p>But when you use this operator in a scalar context (like, for example, as the condition of an <code>if</code> statement), its behavior changes completely. The first operand (the left-hand expression) is evaluated to see if it is true or false. If it is false then the operator returns false and nothing happens. If it is true, however, the operator returns true and <i>continues</i> to return true on subsequent calls until the second operand (the right-hand expression) returns true.</p>

<p>An example will hopefully make this clearer. Suppose you have a file and you only want to process certain sections of it. The sections that you want to print are clearly marked with the string &quot;!! START !!&quot; at the start and &quot;!! END !!&quot; at the end. Using the flip-flop operator you can write code like this:</p>

<pre><code>  while (&lt;FILE&gt;) {
    if (/!! START !!/ .. /!! END !!/) {
      # process line
    }
  }</code></pre>

<p>Each time around the loop, the current line is checked by the flip-flop operator. If the line doesn't match <code>/!! START !!/</code> then the operator returns false and the loop continues. When we reach the first line that matches <code>/!! START !!/</code> then the flip-flop operator returns true and the code in the <code>if</code> block is executed. On subsequent iterations of the <code>while</code> loop, the flip-flop operator checks for matches again <code>/!! END !!/</code>, but it continues to return true until it finds a match. This means that all of the lines between the &quot;!! START !!&quot; and &quot;!! END !!&quot; markers are processed. When a line matches <code>/!! END !!/</code> then the flip-flop operator returns false and starts checking against the first regex again.</p>

<p>So what does all this have to do with <code>$.</code>? Well, there's another piece of magic coded into the flip-flop operator. If either of its operands are constant values then they are converted to integers and matched against <code>$.</code>. So to print out just the first 10 lines of a file you can write code like this:</p>

<pre><code>  while (&lt;FILE&gt;) {
    print if 1 .. 10;
  }</code></pre>

<p>One final point on <code>$.</code>, there is only one <code>$.</code> variable. If you are reading from multiple filehandles then <code>$.</code> contains the current record number from the most recently read filehandle. If you want anything more complex then you can use something like IO::File objects for your filehandle. These objects all have an <code>input_line_number</code> method.</p>

<h3><a name="The_Field_Record_Separators">The Field Record Separators</a></h3>

<p>Next, we'll look at <code>$/</code> and <code>$\</code> which are the input and output record separators respectively. They control what defines a &quot;record&quot; when you are reading or writing data.</p>

<p>Let me explain that in a bit more detail. Remember when you were first learning Perl and you were introduced to the file input operator. Almost certainly you were told that <code>&lt;FILE&gt;</code> read data from the file up to and including the next newline character. Well that's not true. Well, it is, but it's only a specialized case. Actually it reads data up to and including the next occurrence of whatever is currently in <code>$/</code> - the file input separator. Let's look at an example.</p>

<p>Imagine you have a text file which contains amusing quotes. Or lyrics from songs. Or whatever it is that you like to put in your randomly generated signature. The file might look something like this.</p>

<pre><code>    This is the definition of my life
  %%
    We are far too young and clever
  %%
    Stab a sorry heart
    With your favorite finger</code></pre>

<p>Here we have three quotes separated by a line containing just the string <code>%%</code>. How would you go about reading in that file a quote at a time?</p>

<p>One solution would be to read the file a line at a time, checking to see if the new line is just the string <code>%%</code>. You'd need to keep a variable that contains current quote that you are building up and process a completed quote when you find the termination string. Oh, and you'd need to remember to process the last quote in the file as that doesn't have a termination string (although, it might!)</p>

<p>A simpler solution would be to change Perl's idea of what constitutes a record. We do that by changing the value of <code>$/</code>. The default value is a newline character - which is why <code>&lt;...&gt;</code> usually reads in a line at a time. But we can set it to any value we like. We can do something like this</p>

<pre><code>  $/ = &quot;%%\n&quot;;

  while (&lt;QUOTE&gt;) {
    chomp;
    print;
  }</code></pre>

<p>Now each time we call the file input operator, Perl reads data from
the filehandle until it finds <code>%%\n</code> (or the end of file
marker). A newline is no longer seen as a special character. Notice,
however, that the file input operator always returns the next record
with the file input separator still attached. When <code>$/</code> has
its default value of a newline character, you know that you can remove
the newline character by calling <code>chomp</code>. Well it works
exactly the same way when <code>$/</code> has other values. It turns out
that <code>chomp</code> doesn't just remove a newline character (that's
another &quot;simplification&quot; that you find in beginners books) it
actually removes whatever is the current value of <code>$/</code>. So in our sample code above, the call to <code>chomp</code> is removing the whole string <code>%%\n</code>.</p>

<h3><a name="Changing_Perl's_Special_Variables">Changing Perl's Special Variables</a></h3>

<p>Before we go on I just need to alert you to one possible repercussion of changing these variables whenever you want. The problem is that most of these variables are forced into the <code>main</code> package. This means that when you change one of these variables, you are altering the value everywhere in your program. This includes any modules that you use in your program. The reverse is also true. If you're writing a module that other people will use in their programs and you change the value of <code>$/</code> inside it, then you have changed the value for all of the remaining program execution. I hope you can seen why changing variables like <code>$/</code> in one part of your program can potentially lead to hard to find bugs in another part.</p>

<p>So we need to do what we can to avoid this. Your first approach might be to reset the value of <code>$/</code> after you have finished with it. So you'd write code like this.</p>

<pre><code>  $/ = &quot;%%\n&quot;;

  while (&lt;QUOTE&gt;) {
    chomp;
    print;
  }

  $/ = &quot;\n&quot;;</code></pre>

<p>The problem with this is you can't be sure that <code>$/</code> contained <code>\n</code> before you started fiddling with it. Someone else might have changed it before your code was reached. So the next attempt might look like this.</p>

<pre><code>  $old_input_rec_sep = $/;
  $/ = &quot;%%\n&quot;;

  while (&lt;QUOTE&gt;) {
    chomp;
    print;
  }

  $/ = $old_input_rec_sep;</code></pre>

<p>This code works and doesn't have the bug that we're trying to avoid but there's another way that looks cleaner. Remember the <code>local</code> function that you used to declare local variables until someone told you that you should use <code>my</code> instead? Well this is one of the few places where you can use <code>local</code> to great effect.</p>

<p>It's generally acknowledged that <code>local</code> is badly named. The name doesn't describe what the function does. In Perl 6 the function is likely to be renamed to <code>temp</code> as that's a far better description of what it does - it creates a temporary variable with the same name as an existing variable and restores the original variable when the program leaves the innermost enclosing block. This means that we can write our code like this.</p>

<pre><code>  {
    local $/ = &quot;%%\n&quot;;

    while (&lt;QUOTE&gt;) {
      chomp;
      print;
    }
  }</code></pre>

<p>We've enclosed all of the code in another pair of braces to create a <i>naked block</i>. Code blocks are usually associated with loops, conditionals or subroutines, but in Perl they don't need to be. You can introduce a new block whenever you want. Here, we've introduced a block purely to delimit the area where we want <code>$/</code> to have a new value. We then use <code>local</code> to store the old <code>$/</code> variable somewhere where it can't be disturbed and set our new version of the variable to <code>%%\n</code>. We can then do whatever we want in the code block and when we exit from the block, Perl automatically restores the original copy of <code>$/</code> and we never needed to know what it was set to.</p>

<p>For all this reason, it's good practice to never change one of Perl's internal variables unless it is localized in a block.</p>

<h4><a name="Other_Values_For_$/">Other Values For $/</a></h4>

<p>There are a few special values that you can give <code>$/</code> which turn on interesting behaviours. The first of these is setting it to <code>undef</code>. This turns on &quot;slurp mode&quot; and the next time you read from a filehandle you will get all of the remaining data right up to the end of file marker. This means that you can read a whole file in using code like this.</p>

<pre><code>  my $file = do { local $/; &lt;FILE&gt; };</code></pre>

<p>A <code>do</code> block returns the value of the last expression evaluated within it, which in this case is the file input operator. And as <code>$/</code> has been set to <code>undef</code> it returns the whole file. Notice that we don't even need to explicitly set <code>$/</code> to <code>undef</code> as all Perl variables are initialized to <code>undef</code> when they are created.</p>

<p>There is a big difference between setting <code>$/</code> to <code>undef</code> and setting it to an empty string. Setting it to an empty string turns on &quot;paragraph&quot; mode. In this mode each record is a paragraph of text terminated by one or more empty lines. You might think that this effect can be mimicked by setting <code>$/</code> to <code>\n\n</code>, but the subtle difference is that paragraph mode acts as thought <code>$/</code> had been set to <code>\n\n+</code> (although you can't actually set <code>$/</code> equal to a regular expression.)</p>

<p>The final special value is to set <code>$/</code> to either a reference to a scalar variable that holds an integer, or to a reference to an integer constant. In these cases the next read from a filehandle will read up to that number of bytes (I say &quot;up to&quot; because at the end of the file there might not be enough data left to give you). So you read a file 2Kb at a time and you can do this.</p>

<pre><code>  {
    local $/ = \2048;

    while (&lt;FILE&gt;) {
      # $_ contains the next 2048 bytes from FILE
    }
  }</code></pre>

<h4><a name="$/_and_$.">$/ and $.</a></h4>

<p>Note that changing <code>$/</code> alters Perl's definition of a record and therefore it alters the behavior of <code>$.</code>. <code>$.</code> doesn't actually contain the current line number, it contains the current <i>record</i> number. So in our quotes example above, <code>$.</code> will be incremented for each quote that you read from the filehandle.</p>

<h4><a name="What_About_$\?">What About $\?</a></h4>

<p>Many paragraphs back I mentioned both <code>$/</code> and <code>$\</code> as being the input and output record separators. But since then I've just gone on about <code>$/</code>. What happened to <code>$\</code>?</p>

<p>Well, to be honest, <code>$\</code> isn't anywhere near as useful as <code>$/</code>. It contains a string that is printed at the end of every call to <code>print</code>. Its default value is the empty string, so nothing gets added to data that you display with <code>print</code>. But if, for example, you longed for the days of Pascal you could write a <code>println</code> function like this.</p>

<pre><code>  sub println {
    local $\ = &quot;\n&quot;;
    print @_;
  }</code></pre>

<p>Then every time you called <code>println</code>, all of the arguments would be printed followed by a newline.</p>

<h3><a name="Other_Print_Variables">Other Print Variables</a></h3>

<p>The next two variables that I want to discuss are very easily confused although they do completely different things. To illustrate them, consider the following code.</p>

<pre><code>  my @arr = (1, 2, 3);

  print @arr;
  print &quot;@arr&quot;;</code></pre>

<p>Now, without looking it up do you know what the difference is between the output from the two calls to <code>print</code>?</p>

<p>The answer is that the first one prints the three elements of the array with nothing separating them (like this - <code>123</code>) whereas the second one prints the elements separated by spaces (like this - <code>1 2 3</code>). Why is there a difference?</p>

<p>The key to understanding it is to look at exactly what is being passed to <code>print</code> in each case. In the first case <code>print</code> is passed an array. Perl unrolls that array into a list and <code>print</code> actually sees the three elements of the array as separate arguments. In the second case, the array is interpolated into a double quoted string before <code>print</code> sees it. That interpolation has nothing at all to do with the call to <code>print</code>. Exactly the same process would take place if, for example, we did something like this.</p>

<pre><code>  my $string = &quot;@arr&quot;;
  print $string;</code></pre>

<p>So in the second case, the <code>print</code> function only sees one argument. The fact that it is the results of interpolating an array in double quotes has no effect on how <code>print</code> treats the string.</p>

<p>We therefore have two cases. When <code>print</code> receives a number of arguments it prints them out with no spaces between them. And when an array is interpolated in double quotes it is expanded with spaces between the individual elements. These two cases are completely unrelated, but from our first example above it's easy to see how people can get them confused.</p>

<p>Of course, Perl allows us to change these behaviors if we want to. The string that is printed between the arguments passed to <code>print</code> is stored in a variable called <code>$,</code> (because you use a comma to separate arguments). As we've seen, the default value for that is an empty string but it can, of course, be changed.</p>

<pre><code>  my @arr = (1, 2, 3);
  {
    local $, = ',';

    print @arr;
  }</code></pre>

<p>This code prints the string <code>1,2,3</code>.</p>

<p>The string that separates the elements of an array when expanded in a double quoted string is stored in <code>$&quot;</code>. Once again, it's simple to change it to a different value.</p>

<pre><code>  my @arr = (1, 2, 3);
  {
    local $&quot; = '+';

    print &quot;@arr&quot;;
  }</code></pre>

<p>This code prints <code>1+2+3&quot;</code>.</p>

<p>Of course, <code>$&quot;</code> doesn't necessarily have to used in conjunction with a print statement. You can use it anywhere that you have an array in a doubled quoted string. And it doesn't just work for arrays. Array and hash slices work just as well.</p>

<pre><code>  my %hash = (one =&gt; 1, two =&gt; 2, three =&gt; 3);

  {
    local $&quot; = ' &lt; ';

    print &quot;@hash{qw(one two three)}&quot;;
  }</code></pre>

<p>This displays <code>1 &lt; 2 &lt; 3</code>.</p>

<h3><a name="Conclusion">Conclusion</a></h3>

<p>In this article we've just scratched the surface of what you can do by changing the values in Perl's internal variables. If this makes you want to look at this subject in more detail, then you should read the <code>perlvar</code> manual page.</p>


        </div>



    </div>
    <div class="asset-footer"></div>
</div>




                            <div class="content-nav">
                                <a href="/pub/email/">&laquo; Email</a> |
                                <a href="/pub/">Main Index</a> |
                                <a href="/pub/archives.html">Archives</a>
                                | <a href="/pub/finance/">Finance &raquo;</a>
                            </div>


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
